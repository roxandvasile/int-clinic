"use strict"; (self.webpackChunkclinic_internship_app = self.webpackChunkclinic_internship_app || []).push([[179], { 7247: (nn, Qe, C) => { C.d(Qe, { nm: () => Ai }); var a = C(1966), he = (C(5879), C(8726), C(3182), C(5861)), Se = C(6122), ke = C(4537), re = C(9058), Ie = C(7879); const Q = new Map, _e = { activated: !1, tokenObservers: [] }, xe = { initialized: !1, enabled: !1 }; function ze(wt) { return Q.get(wt) || Object.assign({}, _e) } function We() { return xe } const Pe = "https://content-firebaseappcheck.googleapis.com/v1", Ye = "exchangeDebugToken", ut = { OFFSET_DURATION: 3e5, RETRIAL_MIN_WAIT: 3e4, RETRIAL_MAX_WAIT: 96e4 }; class Le { constructor(bt, Rt, sn, wn, dt) { if (this.operation = bt, this.retryPolicy = Rt, this.getWaitDuration = sn, this.lowerBound = wn, this.upperBound = dt, this.pending = null, this.nextErrorWaitInterval = wn, wn > dt) throw new Error("Proactive refresh lower bound greater than upper bound!") } start() { this.nextErrorWaitInterval = this.lowerBound, this.process(!0).catch(() => { }) } stop() { this.pending && (this.pending.reject("cancelled"), this.pending = null) } isRunning() { return !!this.pending } process(bt) { var Rt = this; return (0, he.Z)(function* () { Rt.stop(); try { Rt.pending = new re.BH, yield function le(wt) { return new Promise(bt => { setTimeout(bt, wt) }) }(Rt.getNextRun(bt)), Rt.pending.resolve(), yield Rt.pending.promise, Rt.pending = new re.BH, yield Rt.operation(), Rt.pending.resolve(), yield Rt.pending.promise, Rt.process(!0).catch(() => { }) } catch (sn) { Rt.retryPolicy(sn) ? Rt.process(!1).catch(() => { }) : Rt.stop() } })() } getNextRun(bt) { if (bt) return this.nextErrorWaitInterval = this.lowerBound, this.getWaitDuration(); { const Rt = this.nextErrorWaitInterval; return this.nextErrorWaitInterval *= 2, this.nextErrorWaitInterval > this.upperBound && (this.nextErrorWaitInterval = this.upperBound), Rt } } } const ue = new re.LL("appCheck", "AppCheck", { "already-initialized": "You have already called initializeAppCheck() for FirebaseApp {$appName} with different options. To avoid this error, call initializeAppCheck() with the same options as when it was originally called. This will return the already initialized instance.", "use-before-activation": "App Check is being used before initializeAppCheck() is called for FirebaseApp {$appName}. Call initializeAppCheck() before instantiating other Firebase services.", "fetch-network-error": "Fetch failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.", "fetch-parse-error": "Fetch client could not parse response. Original error: {$originalErrorMessage}.", "fetch-status-error": "Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.", "storage-open": "Error thrown when opening storage. Original error: {$originalErrorMessage}.", "storage-get": "Error thrown when reading from storage. Original error: {$originalErrorMessage}.", "storage-set": "Error thrown when writing to storage. Original error: {$originalErrorMessage}.", "recaptcha-error": "ReCAPTCHA error.", throttled: "Requests throttled due to {$httpStatus} error. Attempts allowed again after {$time}" }); function $e(wt) { if (!ze(wt).activated) throw ue.create("use-before-activation", { appName: wt.name }) } function bn(wt, bt) { return Dn.apply(this, arguments) } function Dn() { return (Dn = (0, he.Z)(function* ({ url: wt, body: bt }, Rt) { const sn = { "Content-Type": "application/json" }, wn = Rt.getImmediate({ optional: !0 }); if (wn) { const cn = yield wn.getHeartbeatsHeader(); cn && (sn["X-Firebase-Client"] = cn) } const dt = { method: "POST", body: JSON.stringify(bt), headers: sn }; let Be, ye; try { Be = yield fetch(wt, dt) } catch (cn) { throw ue.create("fetch-network-error", { originalErrorMessage: cn?.message }) } if (200 !== Be.status) throw ue.create("fetch-status-error", { httpStatus: Be.status }); try { ye = yield Be.json() } catch (cn) { throw ue.create("fetch-parse-error", { originalErrorMessage: cn?.message }) } const et = ye.ttl.match(/^([\d.]+)(s)$/); if (!et || !et[2] || isNaN(Number(et[1]))) throw ue.create("fetch-parse-error", { originalErrorMessage: `ttl field (timeToLive) is not in standard Protobuf Duration format: ${ye.ttl}` }); const Vt = 1e3 * Number(et[1]), At = Date.now(); return { token: ye.token, expireTimeMillis: At + Vt, issuedAtTimeMillis: At } })).apply(this, arguments) } function Wn(wt, bt) { const { projectId: Rt, appId: sn, apiKey: wn } = wt.options; return { url: `${Pe}/projects/${Rt}/apps/${sn}:${Ye}?key=${wn}`, body: { debug_token: bt } } } const Hn = "firebase-app-check-database", at = 1, vt = "firebase-app-check-store"; let it = null; function ht() { return (ht = (0, he.Z)(function* (wt, bt) { const sn = (yield function Ft() { return it || (it = new Promise((wt, bt) => { try { const Rt = indexedDB.open(Hn, at); Rt.onsuccess = sn => { wt(sn.target.result) }, Rt.onerror = sn => { var wn; bt(ue.create("storage-open", { originalErrorMessage: null === (wn = sn.target.error) || void 0 === wn ? void 0 : wn.message })) }, Rt.onupgradeneeded = sn => { 0 === sn.oldVersion && sn.target.result.createObjectStore(vt, { keyPath: "compositeKey" }) } } catch (Rt) { bt(ue.create("storage-open", { originalErrorMessage: Rt?.message })) } }), it) }()).transaction(vt, "readwrite"), dt = sn.objectStore(vt).put({ compositeKey: wt, value: bt }); return new Promise((Be, ye) => { dt.onsuccess = et => { Be() }, sn.onerror = et => { var Vt; ye(ue.create("storage-set", { originalErrorMessage: null === (Vt = et.target.error) || void 0 === Vt ? void 0 : Vt.message })) } }) })).apply(this, arguments) } const jt = new Ie.Yd("@firebase/app-check"); function Nt(wt, bt) { return (0, re.hl)() ? function rn(wt, bt) { return function St(wt, bt) { return ht.apply(this, arguments) }(function qt(wt) { return `${wt.options.appId}-${wt.name}` }(wt), bt) }(wt, bt).catch(Rt => { jt.warn(`Failed to write token to IndexedDB. Error: ${Rt}`) }) : Promise.resolve() } function gn() { return We().enabled } function $n() { return Fn.apply(this, arguments) } function Fn() { return (Fn = (0, he.Z)(function* () { const wt = We(); if (wt.enabled && wt.token) return wt.token.promise; throw Error("\n            Can't get debug token in production mode.\n        ") })).apply(this, arguments) } const se = { error: "UNKNOWN_ERROR" }; function Me(wt) { return re.US.encodeString(JSON.stringify(wt), !1) } function Xe(wt) { return Ot.apply(this, arguments) } function Ot() { return (Ot = (0, he.Z)(function* (wt, bt = !1) { const Rt = wt.app; $e(Rt); const sn = ze(Rt); let dt, wn = sn.token; if (wn && !fn(wn) && (sn.token = void 0, wn = void 0), !wn) { const et = yield sn.cachedTokenPromise; et && (fn(et) ? wn = et : yield Nt(Rt, void 0)) } if (!bt && wn && fn(wn)) return { token: wn.token }; let ye, Be = !1; if (gn()) { sn.exchangeTokenPromise || (sn.exchangeTokenPromise = bn(Wn(Rt, yield $n()), wt.heartbeatServiceProvider).finally(() => { sn.exchangeTokenPromise = void 0 }), Be = !0); const et = yield sn.exchangeTokenPromise; return yield Nt(Rt, et), sn.token = et, { token: et.token } } try { sn.exchangeTokenPromise || (sn.exchangeTokenPromise = sn.provider.getToken().finally(() => { sn.exchangeTokenPromise = void 0 }), Be = !0), wn = yield ze(Rt).exchangeTokenPromise } catch (et) { "appCheck/throttled" === et.code ? jt.warn(et.message) : jt.error(et), dt = et } return wn ? dt ? ye = fn(wn) ? { token: wn.token, internalError: dt } : En(dt) : (ye = { token: wn.token }, sn.token = wn, yield Nt(Rt, wn)) : ye = En(dt), Be && function Qt(wt, bt) { const Rt = ze(wt).tokenObservers; for (const sn of Rt) try { "EXTERNAL" === sn.type && null != bt.error ? sn.error(bt.error) : sn.next(bt) } catch { } }(Rt, ye), ye })).apply(this, arguments) } function ve(wt) { return Ue.apply(this, arguments) } function Ue() { return (Ue = (0, he.Z)(function* (wt) { const bt = wt.app; $e(bt); const { provider: Rt } = ze(bt); if (gn()) { const sn = yield $n(), { token: wn } = yield bn(Wn(bt, sn), wt.heartbeatServiceProvider); return { token: wn } } { const { token: sn } = yield Rt.getToken(); return { token: sn } } })).apply(this, arguments) } function Fe(wt, bt) { const Rt = ze(wt), sn = Rt.tokenObservers.filter(wn => wn.next !== bt); 0 === sn.length && Rt.tokenRefresher && Rt.tokenRefresher.isRunning() && Rt.tokenRefresher.stop(), Rt.tokenObservers = sn } function ct(wt) { const { app: bt } = wt, Rt = ze(bt); let sn = Rt.tokenRefresher; sn || (sn = function Mt(wt) { const { app: bt } = wt; return new Le((0, he.Z)(function* () { let sn; if (sn = ze(bt).token ? yield Xe(wt, !0) : yield Xe(wt), sn.error) throw sn.error; if (sn.internalError) throw sn.internalError }), () => !0, () => { const Rt = ze(bt); if (Rt.token) { let sn = Rt.token.issuedAtTimeMillis + .5 * (Rt.token.expireTimeMillis - Rt.token.issuedAtTimeMillis) + 3e5; return sn = Math.min(sn, Rt.token.expireTimeMillis - 3e5), Math.max(0, sn - Date.now()) } return 0 }, ut.RETRIAL_MIN_WAIT, ut.RETRIAL_MAX_WAIT) }(wt), Rt.tokenRefresher = sn), !sn.isRunning() && Rt.isTokenAutoRefreshEnabled && sn.start() } function fn(wt) { return wt.expireTimeMillis - Date.now() > 0 } function En(wt) { return { token: Me(se), error: wt } } class Ln { constructor(bt, Rt) { this.app = bt, this.heartbeatServiceProvider = Rt } _delete() { const { tokenObservers: bt } = ze(this.app); for (const Rt of bt) Fe(this.app, Rt.next); return Promise.resolve() } } const Pn = "app-check-internal"; !function qn() { (0, Se._registerComponent)(new ke.wA("app-check", wt => function In(wt, bt) { return new Ln(wt, bt) }(wt.getProvider("app").getImmediate(), wt.getProvider("heartbeat")), "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((wt, bt, Rt) => { wt.getProvider(Pn).initialize() })), (0, Se._registerComponent)(new ke.wA(Pn, wt => function Et(wt) { return { getToken: bt => Xe(wt, bt), getLimitedUseToken: () => ve(wt), addTokenListener: bt => function Z(wt, bt, Rt, sn) { const { app: wn } = wt, dt = ze(wn); if (dt.tokenObservers = [...dt.tokenObservers, { next: Rt, error: sn, type: bt }], dt.token && fn(dt.token)) { const ye = dt.token; Promise.resolve().then(() => { Rt({ token: ye.token }), ct(wt) }).catch(() => { }) } dt.cachedTokenPromise.then(() => ct(wt)) }(wt, "INTERNAL", bt), removeTokenListener: bt => Fe(wt.app, bt) } }(wt.getProvider("app-check").getImmediate()), "PUBLIC").setInstantiationMode("EXPLICIT")), (0, Se.registerVersion)("@firebase/app-check", "0.8.0") }(); class Ai { constructor() { return (0, a.vb)("app-check") } } typeof window < "u" && window }, 8726: (nn, Qe, C) => { C.d(Qe, { Ot: () => Y, ZF: () => Ve, hX: () => ze, z6: () => he }); var a = C(3182), y = C(5879), v = C(1966); class Y { constructor(Le) { return Le } } class he { constructor() { return (0, a.C6)() } } const re = new y.OlP("angularfire2._apps"), Ie = { provide: Y, useFactory: function ke(ie) { return ie && 1 === ie.length ? ie[0] : new Y((0, a.Mq)()) }, deps: [[new y.FiY, re]] }, Q = { provide: he, deps: [[new y.FiY, re]] }; function _e(ie) { return (Le, le) => { const ge = Le.runOutsideAngular(() => ie(le)); return new Y(ge) } } let xe = (() => { class ie { constructor(le) { (0, a.KN)("angularfire", v.q4.full, "core"), (0, a.KN)("angularfire", v.q4.full, "app"), (0, a.KN)("angular", y.q4F.full, le.toString()) } } return ie.\u0275fac = function (le) { return new (le || ie)(y.LFG(y.Lbi)) }, ie.\u0275mod = y.oAB({ type: ie }), ie.\u0275inj = y.cJS({ providers: [Ie, Q] }), ie })(); function ze(ie, ...Le) { return { ngModule: xe, providers: [{ provide: re, useFactory: _e(ie), multi: !0, deps: [y.R0b, y.zs3, v.HU, ...Le] }] } } const Ve = (0, v.u3)(a.ZF, !0) }, 8429: (nn, Qe, C) => { C.d(Qe, { AR: () => Ve, Xb: () => ee, dh: () => Ie, v0: () => bn }); var a = C(1966), y = C(5879), v = C(8726), Y = C(3182), he = C(7247), Se = C(752); class re { constructor(Ln) { return Ln } } class Ie { constructor() { return (0, a.vb)("auth") } } const _e = new y.OlP("angularfire2.auth-instances"); function ze(En) { return (Ln, In) => { const Et = Ln.runOutsideAngular(() => En(In)); return new re(Et) } } const Oe = { provide: Ie, deps: [[new y.FiY, _e]] }, We = { provide: re, useFactory: function xe(En, Ln) { const In = (0, a.JM)("auth", En, Ln); return In && new re(In) }, deps: [[new y.FiY, _e], v.Ot] }; let Pe = (() => { class En { constructor() { (0, Y.KN)("angularfire", a.q4.full, "auth") } } return En.\u0275fac = function (In) { return new (In || En) }, En.\u0275mod = y.oAB({ type: En }), En.\u0275inj = y.cJS({ providers: [We, Oe] }), En })(); function Ve(En, ...Ln) { return { ngModule: Pe, providers: [{ provide: _e, useFactory: ze(En), multi: !0, deps: [y.R0b, y.zs3, a.HU, v.z6, [new y.FiY, he.nm], ...Ln] }] } } const ee = (0, a.u3)(Se.Xb, !0), bn = (0, a.u3)(Se.v0, !0) }, 7046: (nn, Qe, C) => { C.d(Qe, { zQ: () => Kt, ww: () => bn, rT: () => ue, f7: () => $e, L6: () => le, _Q: () => ge, lh: () => ee, Qv: () => Le, nw: () => rt }); var a = C(5879), y = C(8645), v = C(2096), Y = C(5592), he = C(2459), Se = C(3019), ke = C(3093), re = C(4664), Ie = C(7398), Q = C(7081), _e = C(1374), xe = C(4674); function ze(Dn, Mn) { return (0, xe.m)(Mn) ? (0, re.w)(() => Dn, Mn) : (0, re.w)(() => Dn) } var Oe = C(5137), We = C(2181), Pe = C(1966), Ve = C(6304), tt = C(6814), Ye = C(7247), ut = C(7142); const Le = new a.OlP("angularfire2.auth.use-emulator"), le = new a.OlP("angularfire2.auth.settings"), ge = new a.OlP("angularfire2.auth.tenant-id"), ue = new a.OlP("angularfire2.auth.langugage-code"), ee = new a.OlP("angularfire2.auth.use-device-language"), $e = new a.OlP("angularfire.auth.persistence"), rt = (Dn, Mn, On, Wn, Hn, at, vt, xt) => (0, Ve.cc)(`${Dn.name}.auth`, "AngularFireAuth", Dn.name, () => { const it = Mn.runOutsideAngular(() => Dn.auth()); if (On && it.useEmulator(...On), Wn && (it.tenantId = Wn), it.languageCode = Hn, at && it.useDeviceLanguage(), vt) for (const [Ft, Wt] of Object.entries(vt)) it.settings[Ft] = Wt; return xt && it.setPersistence(xt), it }, [On, Wn, Hn, at, vt, xt]); let Kt = (() => { class Dn { constructor(On, Wn, Hn, at, vt, xt, it, Ft, Wt, rn, Jt, tn) { const St = new y.x, ht = (0, v.of)(void 0).pipe((0, ke.Q)(vt.outsideAngular), (0, re.w)(() => at.runOutsideAngular(() => Promise.resolve().then(C.bind(C, 6365)))), (0, Ie.U)(() => (0, Ve.on)(On, at, Wn)), (0, Ie.U)(Ae => rt(Ae, at, xt, Ft, Wt, rn, it, Jt)), (0, Q.d)({ bufferSize: 1, refCount: !1 })); if ((0, tt.PM)(Hn)) this.authState = this.user = this.idToken = this.idTokenResult = this.credential = (0, v.of)(null); else { ht.pipe((0, _e.P)()).subscribe(); const nt = ht.pipe((0, re.w)(Pt => Pt.getRedirectResult().then(qe => qe, () => null)), Pe.iC, (0, Q.d)({ bufferSize: 1, refCount: !1 })), qt = ht.pipe((0, re.w)(Pt => new Y.y(qe => ({ unsubscribe: at.runOutsideAngular(() => Pt.onAuthStateChanged(Nt => qe.next(Nt), Nt => qe.error(Nt), () => qe.complete())) })))), jt = ht.pipe((0, re.w)(Pt => new Y.y(qe => ({ unsubscribe: at.runOutsideAngular(() => Pt.onIdTokenChanged(Nt => qe.next(Nt), Nt => qe.error(Nt), () => qe.complete())) })))); this.authState = nt.pipe(ze(qt), (0, Oe.R)(vt.outsideAngular), (0, ke.Q)(vt.insideAngular)), this.user = nt.pipe(ze(jt), (0, Oe.R)(vt.outsideAngular), (0, ke.Q)(vt.insideAngular)), this.idToken = this.user.pipe((0, re.w)(Pt => Pt ? (0, he.D)(Pt.getIdToken()) : (0, v.of)(null))), this.idTokenResult = this.user.pipe((0, re.w)(Pt => Pt ? (0, he.D)(Pt.getIdTokenResult()) : (0, v.of)(null))), this.credential = (0, Se.T)(nt, St, this.authState.pipe((0, We.h)(Pt => !Pt))).pipe((0, Ie.U)(Pt => Pt?.user ? Pt : null), (0, Oe.R)(vt.outsideAngular), (0, ke.Q)(vt.insideAngular)) } return (0, Ve.pX)(this, ht, at, { spy: { apply: (Ae, nt, qt) => { (Ae.startsWith("signIn") || Ae.startsWith("createUser")) && qt.then(jt => St.next(jt)) } } }) } } return Dn.\u0275fac = function (On) { return new (On || Dn)(a.LFG(Ve.Dh), a.LFG(Ve.xv, 8), a.LFG(a.Lbi), a.LFG(a.R0b), a.LFG(Pe.HU), a.LFG(Le, 8), a.LFG(le, 8), a.LFG(ge, 8), a.LFG(ue, 8), a.LFG(ee, 8), a.LFG($e, 8), a.LFG(Ye.nm, 8)) }, Dn.\u0275prov = a.Yz7({ token: Dn, factory: Dn.\u0275fac, providedIn: "any" }), Dn })(), bn = (() => { class Dn { constructor() { ut.Z.registerVersion("angularfire", Pe.q4.full, "auth-compat") } } return Dn.\u0275fac = function (On) { return new (On || Dn) }, Dn.\u0275mod = a.oAB({ type: Dn }), Dn.\u0275inj = a.cJS({ providers: [Kt] }), Dn })() }, 1457: (nn, Qe, C) => { C.d(Qe, { ST: () => In }); var a = C(5879), y = C(6321), v = C(5592), Y = C(2459), he = C(2096), Se = C(1966), ke = C(7921), re = C(9360), Ie = C(8251); function Q() { return (0, re.e)((_t, G) => { let W, me = !1; _t.subscribe((0, Ie.x)(G, de => { const st = W; W = de, me && G.next([st, de]), me = !0 })) }) } var _e = C(7398), xe = C(6699), ze = C(3997), Oe = C(2181), We = C(6304), Pe = C(6814), tt = (C(6365), C(3106)), Ye = C(5776), ut = C(9058), ie = C(4537); function ge(_t, G) { if (void 0 === G) return { merge: !1 }; if (void 0 !== G.mergeFields && void 0 !== G.merge) throw new Ye.WA("invalid-argument", `Invalid options passed to function ${_t}(): You cannot specify both "merge" and "mergeFields".`); return G } function ue() { if (typeof Uint8Array > "u") throw new Ye.WA("unimplemented", "Uint8Arrays are not available in this environment.") } function ee() { if (!(0, Ye.Me)()) throw new Ye.WA("unimplemented", "Blobs are unavailable in Firestore in this environment.") } class $e { constructor(G) { this._delegate = G } static fromBase64String(G) { return ee(), new $e(Ye.Jj.fromBase64String(G)) } static fromUint8Array(G) { return ue(), new $e(Ye.Jj.fromUint8Array(G)) } toBase64() { return ee(), this._delegate.toBase64() } toUint8Array() { return ue(), this._delegate.toUint8Array() } isEqual(G) { return this._delegate.isEqual(G._delegate) } toString() { return "Blob(base64: " + this.toBase64() + ")" } } function rt(_t) { return function Kt(_t, G) { if ("object" != typeof _t || null === _t) return !1; const W = _t; for (const me of G) if (me in W && "function" == typeof W[me]) return !0; return !1 }(_t, ["next", "error", "complete"]) } class bn { enableIndexedDbPersistence(G, W) { return (0, Ye.ST)(G._delegate, { forceOwnership: W }) } enableMultiTabIndexedDbPersistence(G) { return (0, Ye.fH)(G._delegate) } clearIndexedDbPersistence(G) { return (0, Ye.Fc)(G._delegate) } } class Dn { constructor(G, W, me) { this._delegate = W, this._persistenceProvider = me, this.INTERNAL = { delete: () => this.terminate() }, G instanceof Ye.l7 || (this._appCompat = G) } get _databaseId() { return this._delegate._databaseId } settings(G) { const W = this._delegate._getSettings(); !G.merge && W.host !== G.host && (0, Ye.yq)("You are overriding the original host. If you did not intend to override your settings, use {merge: true}."), G.merge && delete (G = Object.assign(Object.assign({}, W), G)).merge, this._delegate._setSettings(G) } useEmulator(G, W, me = {}) { (0, Ye.at)(this._delegate, G, W, me) } enableNetwork() { return (0, Ye.Ix)(this._delegate) } disableNetwork() { return (0, Ye.TF)(this._delegate) } enablePersistence(G) { let W = !1, me = !1; return G && (W = !!G.synchronizeTabs, me = !!G.experimentalForceOwningTab, (0, Ye.Wi)("synchronizeTabs", W, "experimentalForceOwningTab", me)), W ? this._persistenceProvider.enableMultiTabIndexedDbPersistence(this) : this._persistenceProvider.enableIndexedDbPersistence(this, me) } clearPersistence() { return this._persistenceProvider.clearIndexedDbPersistence(this) } terminate() { return this._appCompat && (this._appCompat._removeServiceInstance("firestore-compat"), this._appCompat._removeServiceInstance("firestore")), this._delegate._delete() } waitForPendingWrites() { return (0, Ye.Mx)(this._delegate) } onSnapshotsInSync(G) { return (0, Ye.sc)(this._delegate, G) } get app() { if (!this._appCompat) throw new Ye.WA("failed-precondition", "Firestore was not initialized using the Firebase SDK. 'app' is not available"); return this._appCompat } collection(G) { try { return new ht(this, (0, Ye.hJ)(this._delegate, G)) } catch (W) { throw xt(W, "collection()", "Firestore.collection()") } } doc(G) { try { return new vt(this, (0, Ye.JU)(this._delegate, G)) } catch (W) { throw xt(W, "doc()", "Firestore.doc()") } } collectionGroup(G) { try { return new Jt(this, (0, Ye.B$)(this._delegate, G)) } catch (W) { throw xt(W, "collectionGroup()", "Firestore.collectionGroup()") } } runTransaction(G) { return (0, Ye.i3)(this._delegate, W => G(new Wn(this, W))) } batch() { return (0, Ye.qY)(this._delegate), new Hn(new Ye.PU(this._delegate, G => (0, Ye.GL)(this._delegate, G))) } loadBundle(G) { return (0, Ye.Pb)(this._delegate, G) } namedQuery(G) { return (0, Ye.L$)(this._delegate, G).then(W => W ? new Jt(this, W) : null) } } class Mn extends Ye.u7 { constructor(G) { super(), this.firestore = G } convertBytes(G) { return new $e(new Ye.Jj(G)) } convertReference(G) { const W = this.convertDocumentKey(G, this.firestore._databaseId); return vt.forKey(W, this.firestore, null) } } class Wn { constructor(G, W) { this._firestore = G, this._delegate = W, this._userDataWriter = new Mn(G) } get(G) { const W = Ae(G); return this._delegate.get(W).then(me => new Wt(this._firestore, new Ye.xU(this._firestore._delegate, this._userDataWriter, me._key, me._document, me.metadata, W.converter))) } set(G, W, me) { const de = Ae(G); return me ? (ge("Transaction.set", me), this._delegate.set(de, W, me)) : this._delegate.set(de, W), this } update(G, W, me, ...de) { const st = Ae(G); return 2 === arguments.length ? this._delegate.update(st, W) : this._delegate.update(st, W, me, ...de), this } delete(G) { const W = Ae(G); return this._delegate.delete(W), this } } class Hn { constructor(G) { this._delegate = G } set(G, W, me) { const de = Ae(G); return me ? (ge("WriteBatch.set", me), this._delegate.set(de, W, me)) : this._delegate.set(de, W), this } update(G, W, me, ...de) { const st = Ae(G); return 2 === arguments.length ? this._delegate.update(st, W) : this._delegate.update(st, W, me, ...de), this } delete(G) { const W = Ae(G); return this._delegate.delete(W), this } commit() { return this._delegate.commit() } } class at { constructor(G, W, me) { this._firestore = G, this._userDataWriter = W, this._delegate = me } fromFirestore(G, W) { const me = new Ye.$q(this._firestore._delegate, this._userDataWriter, G._key, G._document, G.metadata, null); return this._delegate.fromFirestore(new rn(this._firestore, me), W ?? {}) } toFirestore(G, W) { return W ? this._delegate.toFirestore(G, W) : this._delegate.toFirestore(G) } static getInstance(G, W) { const me = at.INSTANCES; let de = me.get(G); de || (de = new WeakMap, me.set(G, de)); let st = de.get(W); return st || (st = new at(G, new Mn(G), W), de.set(W, st)), st } } at.INSTANCES = new WeakMap; class vt { constructor(G, W) { this.firestore = G, this._delegate = W, this._userDataWriter = new Mn(G) } static forPath(G, W, me) { if (G.length % 2 != 0) throw new Ye.WA("invalid-argument", `Invalid document reference. Document references must have an even number of segments, but ${G.canonicalString()} has ${G.length}`); return new vt(W, new Ye.my(W._delegate, me, new Ye.Ky(G))) } static forKey(G, W, me) { return new vt(W, new Ye.my(W._delegate, me, G)) } get id() { return this._delegate.id } get parent() { return new ht(this.firestore, this._delegate.parent) } get path() { return this._delegate.path } collection(G) { try { return new ht(this.firestore, (0, Ye.hJ)(this._delegate, G)) } catch (W) { throw xt(W, "collection()", "DocumentReference.collection()") } } isEqual(G) { return (G = (0, ut.m9)(G)) instanceof Ye.my && (0, Ye.Eo)(this._delegate, G) } set(G, W) { W = ge("DocumentReference.set", W); try { return W ? (0, Ye.pl)(this._delegate, G, W) : (0, Ye.pl)(this._delegate, G) } catch (me) { throw xt(me, "setDoc()", "DocumentReference.set()") } } update(G, W, ...me) { try { return 1 === arguments.length ? (0, Ye.r7)(this._delegate, G) : (0, Ye.r7)(this._delegate, G, W, ...me) } catch (de) { throw xt(de, "updateDoc()", "DocumentReference.update()") } } delete() { return (0, Ye.oe)(this._delegate) } onSnapshot(...G) { const W = it(G), me = Ft(G, de => new Wt(this.firestore, new Ye.xU(this.firestore._delegate, this._userDataWriter, de._key, de._document, de.metadata, this._delegate.converter))); return (0, Ye.cf)(this._delegate, W, me) } get(G) { let W; return W = "cache" === G?.source ? (0, Ye.kl)(this._delegate) : "server" === G?.source ? (0, Ye.Xk)(this._delegate) : (0, Ye.QT)(this._delegate), W.then(me => new Wt(this.firestore, new Ye.xU(this.firestore._delegate, this._userDataWriter, me._key, me._document, me.metadata, this._delegate.converter))) } withConverter(G) { return new vt(this.firestore, this._delegate.withConverter(G ? at.getInstance(this.firestore, G) : null)) } } function xt(_t, G, W) { return _t.message = _t.message.replace(G, W), _t } function it(_t) { for (const G of _t) if ("object" == typeof G && !rt(G)) return G; return {} } function Ft(_t, G) { var W, me; let de; return de = rt(_t[0]) ? _t[0] : rt(_t[1]) ? _t[1] : "function" == typeof _t[0] ? { next: _t[0], error: _t[1], complete: _t[2] } : { next: _t[1], error: _t[2], complete: _t[3] }, { next: st => { de.next && de.next(G(st)) }, error: null === (W = de.error) || void 0 === W ? void 0 : W.bind(de), complete: null === (me = de.complete) || void 0 === me ? void 0 : me.bind(de) } } class Wt { constructor(G, W) { this._firestore = G, this._delegate = W } get ref() { return new vt(this._firestore, this._delegate.ref) } get id() { return this._delegate.id } get metadata() { return this._delegate.metadata } get exists() { return this._delegate.exists() } data(G) { return this._delegate.data(G) } get(G, W) { return this._delegate.get(G, W) } isEqual(G) { return (0, Ye.qK)(this._delegate, G._delegate) } } class rn extends Wt { data(G) { const W = this._delegate.data(G); return (0, Ye.K9)(void 0 !== W, "Document in a QueryDocumentSnapshot should exist"), W } } class Jt { constructor(G, W) { this.firestore = G, this._delegate = W, this._userDataWriter = new Mn(G) } where(G, W, me) { try { return new Jt(this.firestore, (0, Ye.IO)(this._delegate, (0, Ye.ar)(G, W, me))) } catch (de) { throw xt(de, /(orderBy|where)\(\)/, "Query.$1()") } } orderBy(G, W) { try { return new Jt(this.firestore, (0, Ye.IO)(this._delegate, (0, Ye.Xo)(G, W))) } catch (me) { throw xt(me, /(orderBy|where)\(\)/, "Query.$1()") } } limit(G) { try { return new Jt(this.firestore, (0, Ye.IO)(this._delegate, (0, Ye.b9)(G))) } catch (W) { throw xt(W, "limit()", "Query.limit()") } } limitToLast(G) { try { return new Jt(this.firestore, (0, Ye.IO)(this._delegate, (0, Ye.vh)(G))) } catch (W) { throw xt(W, "limitToLast()", "Query.limitToLast()") } } startAt(...G) { try { return new Jt(this.firestore, (0, Ye.IO)(this._delegate, (0, Ye.e0)(...G))) } catch (W) { throw xt(W, "startAt()", "Query.startAt()") } } startAfter(...G) { try { return new Jt(this.firestore, (0, Ye.IO)(this._delegate, (0, Ye.TQ)(...G))) } catch (W) { throw xt(W, "startAfter()", "Query.startAfter()") } } endBefore(...G) { try { return new Jt(this.firestore, (0, Ye.IO)(this._delegate, (0, Ye.Lx)(...G))) } catch (W) { throw xt(W, "endBefore()", "Query.endBefore()") } } endAt(...G) { try { return new Jt(this.firestore, (0, Ye.IO)(this._delegate, (0, Ye.Wu)(...G))) } catch (W) { throw xt(W, "endAt()", "Query.endAt()") } } isEqual(G) { return (0, Ye.iE)(this._delegate, G._delegate) } get(G) { let W; return W = "cache" === G?.source ? (0, Ye.UQ)(this._delegate) : "server" === G?.source ? (0, Ye.zN)(this._delegate) : (0, Ye.PL)(this._delegate), W.then(me => new St(this.firestore, new Ye.W(this.firestore._delegate, this._userDataWriter, this._delegate, me._snapshot))) } onSnapshot(...G) { const W = it(G), me = Ft(G, de => new St(this.firestore, new Ye.W(this.firestore._delegate, this._userDataWriter, this._delegate, de._snapshot))); return (0, Ye.cf)(this._delegate, W, me) } withConverter(G) { return new Jt(this.firestore, this._delegate.withConverter(G ? at.getInstance(this.firestore, G) : null)) } } class tn { constructor(G, W) { this._firestore = G, this._delegate = W } get type() { return this._delegate.type } get doc() { return new rn(this._firestore, this._delegate.doc) } get oldIndex() { return this._delegate.oldIndex } get newIndex() { return this._delegate.newIndex } } class St { constructor(G, W) { this._firestore = G, this._delegate = W } get query() { return new Jt(this._firestore, this._delegate.query) } get metadata() { return this._delegate.metadata } get size() { return this._delegate.size } get empty() { return this._delegate.empty } get docs() { return this._delegate.docs.map(G => new rn(this._firestore, G)) } docChanges(G) { return this._delegate.docChanges(G).map(W => new tn(this._firestore, W)) } forEach(G, W) { this._delegate.forEach(me => { G.call(W, new rn(this._firestore, me)) }) } isEqual(G) { return (0, Ye.qK)(this._delegate, G._delegate) } } class ht extends Jt { constructor(G, W) { super(G, W), this.firestore = G, this._delegate = W } get id() { return this._delegate.id } get path() { return this._delegate.path } get parent() { const G = this._delegate.parent; return G ? new vt(this.firestore, G) : null } doc(G) { try { return new vt(this.firestore, void 0 === G ? (0, Ye.JU)(this._delegate) : (0, Ye.JU)(this._delegate, G)) } catch (W) { throw xt(W, "doc()", "CollectionReference.doc()") } } add(G) { return (0, Ye.ET)(this._delegate, G).then(W => new vt(this.firestore, W)) } isEqual(G) { return (0, Ye.Eo)(this._delegate, G._delegate) } withConverter(G) { return new ht(this.firestore, this._delegate.withConverter(G ? at.getInstance(this.firestore, G) : null)) } } function Ae(_t) { return (0, Ye.Cf)(_t, Ye.my) } class nt { constructor(...G) { this._delegate = new Ye.Lz(...G) } static documentId() { return new nt(Ye.Xb.keyField().canonicalString()) } isEqual(G) { return (G = (0, ut.m9)(G)) instanceof Ye.Lz && this._delegate._internalPath.isEqual(G._internalPath) } } class qt { constructor(G) { this._delegate = G } static serverTimestamp() { const G = (0, Ye.Bt)(); return G._methodName = "FieldValue.serverTimestamp", new qt(G) } static delete() { const G = (0, Ye.AK)(); return G._methodName = "FieldValue.delete", new qt(G) } static arrayUnion(...G) { const W = (0, Ye.vr)(...G); return W._methodName = "FieldValue.arrayUnion", new qt(W) } static arrayRemove(...G) { const W = (0, Ye.Ab)(...G); return W._methodName = "FieldValue.arrayRemove", new qt(W) } static increment(G) { const W = (0, Ye.nP)(G); return W._methodName = "FieldValue.increment", new qt(W) } isEqual(G) { return this._delegate.isEqual(G._delegate) } } const jt = { Firestore: Dn, GeoPoint: Ye.F8, Timestamp: Ye.EK, Blob: $e, Transaction: Wn, WriteBatch: Hn, DocumentReference: vt, DocumentSnapshot: Wt, Query: Jt, QueryDocumentSnapshot: rn, QuerySnapshot: St, CollectionReference: ht, FieldPath: nt, FieldValue: qt, setLogLevel: function On(_t) { (0, Ye.Ub)(_t) }, CACHE_SIZE_UNLIMITED: Ye.IX }; !function qe(_t) { (function Pt(_t, G) { _t.INTERNAL.registerComponent(new ie.wA("firestore-compat", W => { const me = W.getProvider("app-compat").getImmediate(), de = W.getProvider("firestore").getImmediate(); return G(me, de) }, "PUBLIC").setServiceProps(Object.assign({}, jt))) })(_t, (G, W) => new Dn(G, W, new bn)), _t.registerVersion("@firebase/firestore-compat", "0.3.12") }(tt.Z); var Nt = C(7046), on = C(7247); function $n(_t, G) { return function gn(_t, G = y.z) { return new v.y(W => { let me; return null != G ? G.schedule(() => { me = _t.onSnapshot({ includeMetadataChanges: !0 }, W) }) : me = _t.onSnapshot({ includeMetadataChanges: !0 }, W), () => { me?.() } }) }(_t, G) } function Ke(_t, G) { return $n(_t, G).pipe((0, _e.U)(W => ({ payload: W, type: "query" }))) } function se(_t, G) { return Ke(_t, G).pipe((0, ke.O)(void 0), Q(), (0, _e.U)(([W, me]) => { const de = me.payload.docChanges(), st = de.map(Lt => ({ type: Lt.type, payload: Lt })); return W && JSON.stringify(W.payload.metadata) !== JSON.stringify(me.payload.metadata) && me.payload.docs.forEach((Lt, He) => { const ae = de.find(L => L.doc.ref.isEqual(Lt.ref)), z = W?.payload.docs.find(L => L.ref.isEqual(Lt.ref)); ae && JSON.stringify(ae.doc.metadata) === JSON.stringify(Lt.metadata) || !ae && z && JSON.stringify(z.metadata) === JSON.stringify(Lt.metadata) || st.push({ type: "modified", payload: { oldIndex: He, newIndex: He, type: "modified", doc: Lt } }) }), st })) } function Me(_t, G, W) { return se(_t, W).pipe((0, xe.R)((me, de) => function Xe(_t, G, W) { return G.forEach(me => { W.indexOf(me.type) > -1 && (_t = function ve(_t, G) { switch (G.type) { case "added": if (!_t[G.newIndex] || !_t[G.newIndex].doc.ref.isEqual(G.doc.ref)) return Ot(_t, G.newIndex, 0, G); break; case "modified": if (null == _t[G.oldIndex] || _t[G.oldIndex].doc.ref.isEqual(G.doc.ref)) { if (G.oldIndex !== G.newIndex) { const W = _t.slice(); return W.splice(G.oldIndex, 1), W.splice(G.newIndex, 0, G), W } return Ot(_t, G.newIndex, 1, G) } break; case "removed": if (_t[G.oldIndex] && _t[G.oldIndex].doc.ref.isEqual(G.doc.ref)) return Ot(_t, G.oldIndex, 1) }return _t }(_t, me)) }), _t }(me, de.map(st => st.payload), G), []), (0, ze.x)(), (0, _e.U)(me => me.map(de => ({ type: de.type, payload: de })))) } function Ot(_t, G, W, ...me) { const de = _t.slice(); return de.splice(G, W, ...me), de } function Ue(_t) { return (!_t || 0 === _t.length) && (_t = ["added", "removed", "modified"]), _t } C(7142); class Z { constructor(G, W, me) { this.ref = G, this.query = W, this.afs = me } stateChanges(G) { let W = se(this.query, this.afs.schedulers.outsideAngular); return G && G.length > 0 && (W = W.pipe((0, _e.U)(me => me.filter(de => G.indexOf(de.type) > -1)))), W.pipe((0, ke.O)(void 0), Q(), (0, Oe.h)(([me, de]) => de.length > 0 || !me), (0, _e.U)(([me, de]) => de), Se.iC) } auditTrail(G) { return this.stateChanges(G).pipe((0, xe.R)((W, me) => [...W, ...me], [])) } snapshotChanges(G) { const W = Ue(G); return Me(this.query, W, this.afs.schedulers.outsideAngular).pipe(Se.iC) } valueChanges(G = {}) { return Ke(this.query, this.afs.schedulers.outsideAngular).pipe((0, _e.U)(W => W.payload.docs.map(me => G.idField ? Object.assign(Object.assign({}, me.data()), { [G.idField]: me.id }) : me.data())), Se.iC) } get(G) { return (0, Y.D)(this.query.get(G)).pipe(Se.iC) } add(G) { return this.ref.add(G) } doc(G) { return new Fe(this.ref.doc(G), this.afs) } } class Fe { constructor(G, W) { this.ref = G, this.afs = W } set(G, W) { return this.ref.set(G, W) } update(G) { return this.ref.update(G) } delete() { return this.ref.delete() } collection(G, W) { const me = this.ref.collection(G), { ref: de, query: st } = Ln(me, W); return new Z(de, st, this.afs) } snapshotChanges() { return function Fn(_t, G) { return $n(_t, G).pipe((0, ke.O)(void 0), Q(), (0, _e.U)(([W, me]) => me.exists ? W?.exists ? { payload: me, type: "modified" } : { payload: me, type: "added" } : { payload: me, type: "removed" })) }(this.ref, this.afs.schedulers.outsideAngular).pipe(Se.iC) } valueChanges(G = {}) { return this.snapshotChanges().pipe((0, _e.U)(({ payload: W }) => G.idField ? Object.assign(Object.assign({}, W.data()), { [G.idField]: W.id }) : W.data())) } get(G) { return (0, Y.D)(this.ref.get(G)).pipe(Se.iC) } } class ct { constructor(G, W) { this.query = G, this.afs = W } stateChanges(G) { return G && 0 !== G.length ? se(this.query, this.afs.schedulers.outsideAngular).pipe((0, _e.U)(W => W.filter(me => G.indexOf(me.type) > -1)), (0, Oe.h)(W => W.length > 0), Se.iC) : se(this.query, this.afs.schedulers.outsideAngular).pipe(Se.iC) } auditTrail(G) { return this.stateChanges(G).pipe((0, xe.R)((W, me) => [...W, ...me], [])) } snapshotChanges(G) { const W = Ue(G); return Me(this.query, W, this.afs.schedulers.outsideAngular).pipe(Se.iC) } valueChanges(G = {}) { return Ke(this.query, this.afs.schedulers.outsideAngular).pipe((0, _e.U)(me => me.payload.docs.map(de => G.idField ? Object.assign({ [G.idField]: de.id }, de.data()) : de.data())), Se.iC) } get(G) { return (0, Y.D)(this.query.get(G)).pipe(Se.iC) } } const Mt = new a.OlP("angularfire2.enableFirestorePersistence"), Qt = new a.OlP("angularfire2.firestore.persistenceSettings"), fn = new a.OlP("angularfire2.firestore.settings"), En = new a.OlP("angularfire2.firestore.use-emulator"); function Ln(_t, G = (W => W)) { return { query: G(_t), ref: _t } } let In = (() => { class _t { constructor(W, me, de, st, Lt, He, ae, z, L, H, Ne, pt, pe, fe, F, J, Te) { this.schedulers = ae; const lt = (0, We.on)(W, He, me), gt = L; H && (0, Nt.nw)(lt, He, Ne, pe, fe, F, pt, J), [this.firestore, this.persistenceEnabled$] = (0, We.cc)(`${lt.name}.firestore`, "AngularFirestore", lt.name, () => { const Ht = He.runOutsideAngular(() => lt.firestore()); if (st && Ht.settings(st), gt && Ht.useEmulator(...gt), de && !(0, Pe.PM)(Lt)) { const un = () => { try { return (0, Y.D)(Ht.enablePersistence(z || void 0).then(() => !0, () => !1)) } catch (yt) { return typeof console < "u" && console.warn(yt), (0, he.of)(!1) } }; return [Ht, He.runOutsideAngular(un)] } return [Ht, (0, he.of)(!1)] }, [st, gt, de]) } collection(W, me) { let de; de = "string" == typeof W ? this.firestore.collection(W) : W; const { ref: st, query: Lt } = Ln(de, me), He = this.schedulers.ngZone.run(() => st); return new Z(He, Lt, this) } collectionGroup(W, me) { const de = me || (Lt => Lt), st = this.firestore.collectionGroup(W); return new ct(de(st), this) } doc(W) { let me; me = "string" == typeof W ? this.firestore.doc(W) : W; const de = this.schedulers.ngZone.run(() => me); return new Fe(de, this) } createId() { return this.firestore.collection("_").doc().id } } return _t.\u0275fac = function (W) { return new (W || _t)(a.LFG(We.Dh), a.LFG(We.xv, 8), a.LFG(Mt, 8), a.LFG(fn, 8), a.LFG(a.Lbi), a.LFG(a.R0b), a.LFG(Se.HU), a.LFG(Qt, 8), a.LFG(En, 8), a.LFG(Nt.zQ, 8), a.LFG(Nt.Qv, 8), a.LFG(Nt.L6, 8), a.LFG(Nt._Q, 8), a.LFG(Nt.rT, 8), a.LFG(Nt.lh, 8), a.LFG(Nt.f7, 8), a.LFG(on.nm, 8)) }, _t.\u0275prov = a.Yz7({ token: _t, factory: _t.\u0275fac, providedIn: "any" }), _t })() }, 7793: (nn, Qe, C) => { C.d(Qe, { Q1: () => Ks }); var a = C(5592), y = C(2096), v = C(2459), Y = C(3620), he = C(7398), Se = C(4664), ke = C(1966), re = C(5879), Ie = C(6304), Q = C(3106), _e = C(5861), xe = C(6122), ze = C(9058), Oe = C(4537); const We = "firebasestorage.googleapis.com", Pe = "storageBucket"; class ut extends ze.ZR { constructor(D, ne, Re = 0) { super(Le(D), `Firebase Storage: ${ne} (${Le(D)})`), this.status_ = Re, this.customData = { serverResponse: null }, this._baseMessage = this.message, Object.setPrototypeOf(this, ut.prototype) } get status() { return this.status_ } set status(D) { this.status_ = D } _codeEquals(D) { return Le(D) === this.code } get serverResponse() { return this.customData.serverResponse } set serverResponse(D) { this.customData.serverResponse = D, this.message = this.customData.serverResponse ? `${this._baseMessage}\n${this.customData.serverResponse}` : this._baseMessage } } var ie = (() => ((ie = ie || {}).UNKNOWN = "unknown", ie.OBJECT_NOT_FOUND = "object-not-found", ie.BUCKET_NOT_FOUND = "bucket-not-found", ie.PROJECT_NOT_FOUND = "project-not-found", ie.QUOTA_EXCEEDED = "quota-exceeded", ie.UNAUTHENTICATED = "unauthenticated", ie.UNAUTHORIZED = "unauthorized", ie.UNAUTHORIZED_APP = "unauthorized-app", ie.RETRY_LIMIT_EXCEEDED = "retry-limit-exceeded", ie.INVALID_CHECKSUM = "invalid-checksum", ie.CANCELED = "canceled", ie.INVALID_EVENT_NAME = "invalid-event-name", ie.INVALID_URL = "invalid-url", ie.INVALID_DEFAULT_BUCKET = "invalid-default-bucket", ie.NO_DEFAULT_BUCKET = "no-default-bucket", ie.CANNOT_SLICE_BLOB = "cannot-slice-blob", ie.SERVER_FILE_WRONG_SIZE = "server-file-wrong-size", ie.NO_DOWNLOAD_URL = "no-download-url", ie.INVALID_ARGUMENT = "invalid-argument", ie.INVALID_ARGUMENT_COUNT = "invalid-argument-count", ie.APP_DELETED = "app-deleted", ie.INVALID_ROOT_OPERATION = "invalid-root-operation", ie.INVALID_FORMAT = "invalid-format", ie.INTERNAL_ERROR = "internal-error", ie.UNSUPPORTED_ENVIRONMENT = "unsupported-environment", ie))(); function Le(w) { return "storage/" + w } function le() { return new ut(ie.UNKNOWN, "An unknown error occurred, please check the error payload for server response.") } function Kt() { return new ut(ie.RETRY_LIMIT_EXCEEDED, "Max retry time for operation exceeded, please try again.") } function bn() { return new ut(ie.CANCELED, "User canceled the upload/download.") } function Wn() { return new ut(ie.CANNOT_SLICE_BLOB, "Cannot slice blob for upload. Please retry the upload.") } function xt(w) { return new ut(ie.INVALID_ARGUMENT, w) } function it() { return new ut(ie.APP_DELETED, "The Firebase app was deleted.") } function Ft(w) { return new ut(ie.INVALID_ROOT_OPERATION, "The operation '" + w + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').") } function Wt(w, D) { return new ut(ie.INVALID_FORMAT, "String does not match format '" + w + "': " + D) } function rn(w) { throw new ut(ie.INTERNAL_ERROR, "Internal error: " + w) } class Jt { constructor(D, ne) { this.bucket = D, this.path_ = ne } get path() { return this.path_ } get isRoot() { return 0 === this.path.length } fullServerUrl() { const D = encodeURIComponent; return "/b/" + D(this.bucket) + "/o/" + D(this.path) } bucketOnlyServerUrl() { return "/b/" + encodeURIComponent(this.bucket) + "/o" } static makeFromBucketSpec(D, ne) { let Re; try { Re = Jt.makeFromUrl(D, ne) } catch { return new Jt(D, "") } if ("" === Re.path) return Re; throw function Mn(w) { return new ut(ie.INVALID_DEFAULT_BUCKET, "Invalid default bucket '" + w + "'.") }(D) } static makeFromUrl(D, ne) { let Re = null; const mt = "([A-Za-z0-9.\\-_]+)", Gn = new RegExp("^gs://" + mt + "(/(.*))?$", "i"); function gi(Sr) { Sr.path_ = decodeURIComponent(Sr.path) } const Zi = ne.replace(/[.]/g, "\\."), Mr = [{ regex: Gn, indices: { bucket: 1, path: 3 }, postModify: function kt(Sr) { "/" === Sr.path.charAt(Sr.path.length - 1) && (Sr.path_ = Sr.path_.slice(0, -1)) } }, { regex: new RegExp(`^https?://${Zi}/v[A-Za-z0-9_]+/b/${mt}/o(/([^?#]*).*)?$`, "i"), indices: { bucket: 1, path: 3 }, postModify: gi }, { regex: new RegExp(`^https?://${ne === We ? "(?:storage.googleapis.com|storage.cloud.google.com)" : ne}/${mt}/([^?#]*)`, "i"), indices: { bucket: 1, path: 2 }, postModify: gi }]; for (let Sr = 0; Sr < Mr.length; Sr++) { const Do = Mr[Sr], $o = Do.regex.exec(D); if ($o) { let rs = $o[Do.indices.path]; rs || (rs = ""), Re = new Jt($o[Do.indices.bucket], rs), Do.postModify(Re); break } } if (null == Re) throw function Dn(w) { return new ut(ie.INVALID_URL, "Invalid URL '" + w + "'.") }(D); return Re } } class tn { constructor(D) { this.promise_ = Promise.reject(D) } getPromise() { return this.promise_ } cancel(D = !1) { } } function jt(w) { return "string" == typeof w || w instanceof String } function Pt(w) { return qe() && w instanceof Blob } function qe() { return typeof Blob < "u" && !(0, ze.UG)() } function Nt(w, D, ne, Re) { if (Re < D) throw xt(`Invalid value for '${w}'. Expected ${D} or greater.`); if (Re > ne) throw xt(`Invalid value for '${w}'. Expected ${ne} or less.`) } function on(w, D, ne) { let Re = D; return null == ne && (Re = `https://${D}`), `${ne}://${Re}/v0${w}` } function Zt(w) { const D = encodeURIComponent; let ne = "?"; for (const Re in w) w.hasOwnProperty(Re) && (ne = ne + (D(Re) + "=") + D(w[Re]) + "&"); return ne = ne.slice(0, -1), ne } var gn = (() => ((gn = gn || {})[gn.NO_ERROR = 0] = "NO_ERROR", gn[gn.NETWORK_ERROR = 1] = "NETWORK_ERROR", gn[gn.ABORT = 2] = "ABORT", gn))(); function $n(w, D) { const ne = w >= 500 && w < 600, mt = -1 !== [408, 429].indexOf(w), kt = -1 !== D.indexOf(w); return ne || mt || kt } class Fn { constructor(D, ne, Re, mt, kt, mn, Gn, jn, gi, Ii, Zi, ji = !0) { this.url_ = D, this.method_ = ne, this.headers_ = Re, this.body_ = mt, this.successCodes_ = kt, this.additionalRetryCodes_ = mn, this.callback_ = Gn, this.errorCallback_ = jn, this.timeout_ = gi, this.progressCallback_ = Ii, this.connectionFactory_ = Zi, this.retry = ji, this.pendingConnection_ = null, this.backoffId_ = null, this.canceled_ = !1, this.appDelete_ = !1, this.promise_ = new Promise((Bi, ir) => { this.resolve_ = Bi, this.reject_ = ir, this.start_() }) } start_() { const ne = (Re, mt) => { const kt = this.resolve_, mn = this.reject_, Gn = mt.connection; if (mt.wasSuccessCode) try { const jn = this.callback_(Gn, Gn.getResponse()); !function Ae(w) { return void 0 !== w }(jn) ? kt() : kt(jn) } catch (jn) { mn(jn) } else if (null !== Gn) { const jn = le(); jn.serverResponse = Gn.getErrorText(), mn(this.errorCallback_ ? this.errorCallback_(Gn, jn) : jn) } else mn(mt.canceled ? this.appDelete_ ? it() : bn() : Kt()) }; this.canceled_ ? ne(0, new Ke(!1, null, !0)) : this.backoffId_ = function St(w, D, ne) { let Re = 1, mt = null, kt = null, mn = !1, Gn = 0; function jn() { return 2 === Gn } let gi = !1; function Ii(...gr) { gi || (gi = !0, D.apply(null, gr)) } function Zi(gr) { mt = setTimeout(() => { mt = null, w(Bi, jn()) }, gr) } function ji() { kt && clearTimeout(kt) } function Bi(gr, ...Yi) { if (gi) return void ji(); if (gr) return ji(), void Ii.call(null, gr, ...Yi); if (jn() || mn) return ji(), void Ii.call(null, gr, ...Yi); let Mr; Re < 64 && (Re *= 2), 1 === Gn ? (Gn = 2, Mr = 0) : Mr = 1e3 * (Re + Math.random()), Zi(Mr) } let ir = !1; function ar(gr) { ir || (ir = !0, ji(), !gi && (null !== mt ? (gr || (Gn = 2), clearTimeout(mt), Zi(0)) : gr || (Gn = 1))) } return Zi(0), kt = setTimeout(() => { mn = !0, ar(!0) }, ne), ar }((Re, mt) => { if (mt) return void Re(!1, new Ke(!1, null, !0)); const kt = this.connectionFactory_(); this.pendingConnection_ = kt; const mn = Gn => { null !== this.progressCallback_ && this.progressCallback_(Gn.loaded, Gn.lengthComputable ? Gn.total : -1) }; null !== this.progressCallback_ && kt.addUploadProgressListener(mn), kt.send(this.url_, this.method_, this.body_, this.headers_).then(() => { null !== this.progressCallback_ && kt.removeUploadProgressListener(mn), this.pendingConnection_ = null; const Gn = kt.getErrorCode() === gn.NO_ERROR, jn = kt.getStatus(); if (!Gn || $n(jn, this.additionalRetryCodes_) && this.retry) { const Ii = kt.getErrorCode() === gn.ABORT; return void Re(!1, new Ke(!1, null, Ii)) } const gi = -1 !== this.successCodes_.indexOf(jn); Re(!0, new Ke(gi, kt)) }) }, ne, this.timeout_) } getPromise() { return this.promise_ } cancel(D) { this.canceled_ = !0, this.appDelete_ = D || !1, null !== this.backoffId_ && function ht(w) { w(!1) }(this.backoffId_), null !== this.pendingConnection_ && this.pendingConnection_.abort() } } class Ke { constructor(D, ne, Re) { this.wasSuccessCode = D, this.connection = ne, this.canceled = !!Re } } function Z(...w) { const D = function Ue() { return typeof BlobBuilder < "u" ? BlobBuilder : typeof WebKitBlobBuilder < "u" ? WebKitBlobBuilder : void 0 }(); if (void 0 !== D) { const ne = new D; for (let Re = 0; Re < w.length; Re++)ne.append(w[Re]); return ne.getBlob() } if (qe()) return new Blob(w); throw new ut(ie.UNSUPPORTED_ENVIRONMENT, "This browser doesn't seem to support creating Blobs") } const Mt = { RAW: "raw", BASE64: "base64", BASE64URL: "base64url", DATA_URL: "data_url" }; class Qt { constructor(D, ne) { this.data = D, this.contentType = ne || null } } function fn(w, D) { switch (w) { case Mt.RAW: return new Qt(En(D)); case Mt.BASE64: case Mt.BASE64URL: return new Qt(In(w, D)); case Mt.DATA_URL: return new Qt(function _t(w) { const D = new Et(w); return D.base64 ? In(Mt.BASE64, D.rest) : function Ln(w) { let D; try { D = decodeURIComponent(w) } catch { throw Wt(Mt.DATA_URL, "Malformed data URL.") } return En(D) }(D.rest) }(D), function G(w) { return new Et(w).contentType }(D)) }throw le() } function En(w) { const D = []; for (let ne = 0; ne < w.length; ne++) { let Re = w.charCodeAt(ne); Re <= 127 ? D.push(Re) : Re <= 2047 ? D.push(192 | Re >> 6, 128 | 63 & Re) : 55296 == (64512 & Re) ? ne < w.length - 1 && 56320 == (64512 & w.charCodeAt(ne + 1)) ? (Re = 65536 | (1023 & Re) << 10 | 1023 & w.charCodeAt(++ne), D.push(240 | Re >> 18, 128 | Re >> 12 & 63, 128 | Re >> 6 & 63, 128 | 63 & Re)) : D.push(239, 191, 189) : 56320 == (64512 & Re) ? D.push(239, 191, 189) : D.push(224 | Re >> 12, 128 | Re >> 6 & 63, 128 | 63 & Re) } return new Uint8Array(D) } function In(w, D) { switch (w) { case Mt.BASE64: { const mt = -1 !== D.indexOf("-"), kt = -1 !== D.indexOf("_"); if (mt || kt) throw Wt(w, "Invalid character '" + (mt ? "-" : "_") + "' found: is it base64url encoded?"); break } case Mt.BASE64URL: { const mt = -1 !== D.indexOf("+"), kt = -1 !== D.indexOf("/"); if (mt || kt) throw Wt(w, "Invalid character '" + (mt ? "+" : "/") + "' found: is it base64 encoded?"); D = D.replace(/-/g, "+").replace(/_/g, "/"); break } }let ne; try { ne = function ct(w) { if (typeof atob > "u") throw function vt(w) { return new ut(ie.UNSUPPORTED_ENVIRONMENT, `${w} is missing. Make sure to install the required polyfills. See https://firebase.google.com/docs/web/environments-js-sdk#polyfills for more information.`) }("base-64"); return atob(w) }(D) } catch (mt) { throw mt.message.includes("polyfill") ? mt : Wt(w, "Invalid character found") } const Re = new Uint8Array(ne.length); for (let mt = 0; mt < ne.length; mt++)Re[mt] = ne.charCodeAt(mt); return Re } class Et { constructor(D) { this.base64 = !1, this.contentType = null; const ne = D.match(/^data:([^,]+)?,/); if (null === ne) throw Wt(Mt.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>"); const Re = ne[1] || null; null != Re && (this.base64 = function W(w, D) { return w.length >= D.length && w.substring(w.length - D.length) === D }(Re, ";base64"), this.contentType = this.base64 ? Re.substring(0, Re.length - 7) : Re), this.rest = D.substring(D.indexOf(",") + 1) } } class me { constructor(D, ne) { let Re = 0, mt = ""; Pt(D) ? (this.data_ = D, Re = D.size, mt = D.type) : D instanceof ArrayBuffer ? (ne ? this.data_ = new Uint8Array(D) : (this.data_ = new Uint8Array(D.byteLength), this.data_.set(new Uint8Array(D))), Re = this.data_.length) : D instanceof Uint8Array && (ne ? this.data_ = D : (this.data_ = new Uint8Array(D.length), this.data_.set(D)), Re = D.length), this.size_ = Re, this.type_ = mt } size() { return this.size_ } type() { return this.type_ } slice(D, ne) { if (Pt(this.data_)) { const mt = function Fe(w, D, ne) { return w.webkitSlice ? w.webkitSlice(D, ne) : w.mozSlice ? w.mozSlice(D, ne) : w.slice ? w.slice(D, ne) : null }(this.data_, D, ne); return null === mt ? null : new me(mt) } { const Re = new Uint8Array(this.data_.buffer, D, ne - D); return new me(Re, !0) } } static getBlob(...D) { if (qe()) { const ne = D.map(Re => Re instanceof me ? Re.data_ : Re); return new me(Z.apply(null, ne)) } { const ne = D.map(mn => jt(mn) ? fn(Mt.RAW, mn).data : mn.data_); let Re = 0; ne.forEach(mn => { Re += mn.byteLength }); const mt = new Uint8Array(Re); let kt = 0; return ne.forEach(mn => { for (let Gn = 0; Gn < mn.length; Gn++)mt[kt++] = mn[Gn] }), new me(mt, !0) } } uploadData() { return this.data_ } } function de(w) { let D; try { D = JSON.parse(w) } catch { return null } return function qt(w) { return "object" == typeof w && !Array.isArray(w) }(D) ? D : null } function He(w) { const D = w.lastIndexOf("/", w.length - 2); return -1 === D ? w : w.slice(D + 1) } function ae(w, D) { return D } class z { constructor(D, ne, Re, mt) { this.server = D, this.local = ne || D, this.writable = !!Re, this.xform = mt || ae } } let L = null; function Ne() { if (L) return L; const w = []; w.push(new z("bucket")), w.push(new z("generation")), w.push(new z("metageneration")), w.push(new z("name", "fullPath", !0)); const ne = new z("name"); ne.xform = function D(kt, mn) { return function H(w) { return !jt(w) || w.length < 2 ? w : He(w) }(mn) }, w.push(ne); const mt = new z("size"); return mt.xform = function Re(kt, mn) { return void 0 !== mn ? Number(mn) : mn }, w.push(mt), w.push(new z("timeCreated")), w.push(new z("updated")), w.push(new z("md5Hash", null, !0)), w.push(new z("cacheControl", null, !0)), w.push(new z("contentDisposition", null, !0)), w.push(new z("contentEncoding", null, !0)), w.push(new z("contentLanguage", null, !0)), w.push(new z("contentType", null, !0)), w.push(new z("metadata", "customMetadata", !0)), L = w, L } function fe(w, D, ne) { const Re = de(D); return null === Re ? null : function pe(w, D, ne) { const Re = { type: "file" }, mt = ne.length; for (let kt = 0; kt < mt; kt++) { const mn = ne[kt]; Re[mn.local] = mn.xform(Re, D[mn.server]) } return function pt(w, D) { Object.defineProperty(w, "ref", { get: function ne() { const kt = new Jt(w.bucket, w.fullPath); return D._makeStorageReference(kt) } }) }(Re, w), Re }(w, Re, ne) } function J(w, D) { const ne = {}, Re = D.length; for (let mt = 0; mt < Re; mt++) { const kt = D[mt]; kt.writable && (ne[kt.server] = w[kt.local]) } return JSON.stringify(ne) } const Te = "prefixes", lt = "items"; class un { constructor(D, ne, Re, mt) { this.url = D, this.method = ne, this.handler = Re, this.timeout = mt, this.urlParams = {}, this.headers = {}, this.body = null, this.errorHandler = null, this.progressCallback = null, this.successCodes = [200], this.additionalRetryCodes = [] } } function yt(w) { if (!w) throw le() } function It(w, D) { return function ne(Re, mt) { const kt = fe(w, mt, D); return yt(null !== kt), kt } } function qn(w) { return function D(ne, Re) { let mt; return mt = 401 === ne.getStatus() ? ne.getErrorText().includes("Firebase App Check token is invalid") ? function $e() { return new ut(ie.UNAUTHORIZED_APP, "This app does not have permission to access Firebase Storage on this project.") }() : function ee() { return new ut(ie.UNAUTHENTICATED, "User is not authenticated, please authenticate using Firebase Authentication and try again.") }() : 402 === ne.getStatus() ? function ue(w) { return new ut(ie.QUOTA_EXCEEDED, "Quota for bucket '" + w + "' exceeded, please view quota on https://firebase.google.com/pricing/.") }(w.bucket) : 403 === ne.getStatus() ? function rt(w) { return new ut(ie.UNAUTHORIZED, "User does not have permission to access '" + w + "'.") }(w.path) : Re, mt.status = ne.getStatus(), mt.serverResponse = Re.serverResponse, mt } } function ni(w) { const D = qn(w); return function ne(Re, mt) { let kt = D(Re, mt); return 404 === Re.getStatus() && (kt = function ge(w) { return new ut(ie.OBJECT_NOT_FOUND, "Object '" + w + "' does not exist.") }(w.path)), kt.serverResponse = mt.serverResponse, kt } } function si(w, D, ne) { const mt = on(D.fullServerUrl(), w.host, w._protocol), mn = w.maxOperationRetryTime, Gn = new un(mt, "GET", It(w, ne), mn); return Gn.errorHandler = ni(D), Gn } function Ai(w, D, ne, Re, mt) { const kt = {}; kt.prefix = D.isRoot ? "" : D.path + "/", ne && ne.length > 0 && (kt.delimiter = ne), Re && (kt.pageToken = Re), mt && (kt.maxResults = mt); const Gn = on(D.bucketOnlyServerUrl(), w.host, w._protocol), gi = w.maxOperationRetryTime, Ii = new un(Gn, "GET", function dn(w, D) { return function ne(Re, mt) { const kt = function Ht(w, D, ne) { const Re = de(ne); return null === Re ? null : function gt(w, D, ne) { const Re = { prefixes: [], items: [], nextPageToken: ne.nextPageToken }; if (ne[Te]) for (const mt of ne[Te]) { const kt = mt.replace(/\/$/, ""), mn = w._makeStorageReference(new Jt(D, kt)); Re.prefixes.push(mn) } if (ne[lt]) for (const mt of ne[lt]) { const kt = w._makeStorageReference(new Jt(D, mt.name)); Re.items.push(kt) } return Re }(w, D, Re) }(w, D, mt); return yt(null !== kt), kt } }(w, D.bucket), gi); return Ii.urlParams = kt, Ii.errorHandler = qn(D), Ii } function Ti(w, D, ne) { const Re = Object.assign({}, ne); return Re.fullPath = w.path, Re.size = D.size(), Re.contentType || (Re.contentType = function zi(w, D) { return w && w.contentType || D && D.type() || "application/octet-stream" }(null, D)), Re } class Ir { constructor(D, ne, Re, mt) { this.current = D, this.total = ne, this.finalized = !!Re, this.metadata = mt || null } } function bo(w, D) { let ne = null; try { ne = w.getResponseHeader("X-Goog-Upload-Status") } catch { yt(!1) } return yt(!!ne && -1 !== (D || ["active"]).indexOf(ne)), ne } const Jo = { STATE_CHANGED: "state_changed" }, sr = { RUNNING: "running", PAUSED: "paused", SUCCESS: "success", CANCELED: "canceled", ERROR: "error" }; function wt(w) { switch (w) { case "running": case "pausing": case "canceling": return sr.RUNNING; case "paused": return sr.PAUSED; case "success": return sr.SUCCESS; case "canceled": return sr.CANCELED; default: return sr.ERROR } } class bt { constructor(D, ne, Re) { if (function nt(w) { return "function" == typeof w }(D) || null != ne || null != Re) this.next = D, this.error = ne ?? void 0, this.complete = Re ?? void 0; else { const kt = D; this.next = kt.next, this.error = kt.error, this.complete = kt.complete } } } function Rt(w) { return (...D) => { Promise.resolve().then(() => w(...D)) } } let sn = null; class wn { constructor() { this.sent_ = !1, this.xhr_ = new XMLHttpRequest, this.initXhr(), this.errorCode_ = gn.NO_ERROR, this.sendPromise_ = new Promise(D => { this.xhr_.addEventListener("abort", () => { this.errorCode_ = gn.ABORT, D() }), this.xhr_.addEventListener("error", () => { this.errorCode_ = gn.NETWORK_ERROR, D() }), this.xhr_.addEventListener("load", () => { D() }) }) } send(D, ne, Re, mt) { if (this.sent_) throw rn("cannot .send() more than once"); if (this.sent_ = !0, this.xhr_.open(ne, D, !0), void 0 !== mt) for (const kt in mt) mt.hasOwnProperty(kt) && this.xhr_.setRequestHeader(kt, mt[kt].toString()); return void 0 !== Re ? this.xhr_.send(Re) : this.xhr_.send(), this.sendPromise_ } getErrorCode() { if (!this.sent_) throw rn("cannot .getErrorCode() before sending"); return this.errorCode_ } getStatus() { if (!this.sent_) throw rn("cannot .getStatus() before sending"); try { return this.xhr_.status } catch { return -1 } } getResponse() { if (!this.sent_) throw rn("cannot .getResponse() before sending"); return this.xhr_.response } getErrorText() { if (!this.sent_) throw rn("cannot .getErrorText() before sending"); return this.xhr_.statusText } abort() { this.xhr_.abort() } getResponseHeader(D) { return this.xhr_.getResponseHeader(D) } addUploadProgressListener(D) { null != this.xhr_.upload && this.xhr_.upload.addEventListener("progress", D) } removeUploadProgressListener(D) { null != this.xhr_.upload && this.xhr_.upload.removeEventListener("progress", D) } } class dt extends wn { initXhr() { this.xhr_.responseType = "text" } } function Be() { return sn ? sn() : new dt } class cn { constructor(D, ne, Re = null) { this._transferred = 0, this._needToFetchStatus = !1, this._needToFetchMetadata = !1, this._observers = [], this._error = void 0, this._uploadUrl = void 0, this._request = void 0, this._chunkMultiplier = 1, this._resolve = void 0, this._reject = void 0, this._ref = D, this._blob = ne, this._metadata = Re, this._mappings = Ne(), this._resumable = this._shouldDoResumable(this._blob), this._state = "running", this._errorHandler = mt => { if (this._request = void 0, this._chunkMultiplier = 1, mt._codeEquals(ie.CANCELED)) this._needToFetchStatus = !0, this.completeTransitions_(); else { const kt = this.isExponentialBackoffExpired(); if ($n(mt.status, [])) { if (!kt) return this.sleepTime = Math.max(2 * this.sleepTime, 1e3), this._needToFetchStatus = !0, void this.completeTransitions_(); mt = Kt() } this._error = mt, this._transition("error") } }, this._metadataErrorHandler = mt => { this._request = void 0, mt._codeEquals(ie.CANCELED) ? this.completeTransitions_() : (this._error = mt, this._transition("error")) }, this.sleepTime = 0, this.maxSleepTime = this._ref.storage.maxUploadRetryTime, this._promise = new Promise((mt, kt) => { this._resolve = mt, this._reject = kt, this._start() }), this._promise.then(null, () => { }) } isExponentialBackoffExpired() { return this.sleepTime > this.maxSleepTime } _makeProgressCallback() { const D = this._transferred; return ne => this._updateProgress(D + ne) } _shouldDoResumable(D) { return D.size() > 262144 } _start() { "running" === this._state && void 0 === this._request && (this._resumable ? void 0 === this._uploadUrl ? this._createResumable() : this._needToFetchStatus ? this._fetchStatus() : this._needToFetchMetadata ? this._fetchMetadata() : this.pendingTimeout = setTimeout(() => { this.pendingTimeout = void 0, this._continueUpload() }, this.sleepTime) : this._oneShotUpload()) } _resolveToken(D) { Promise.all([this._ref.storage._getAuthToken(), this._ref.storage._getAppCheckToken()]).then(([ne, Re]) => { switch (this._state) { case "running": D(ne, Re); break; case "canceling": this._transition("canceled"); break; case "pausing": this._transition("paused") } }) } _createResumable() { this._resolveToken((D, ne) => { const Re = function Nr(w, D, ne, Re, mt) { const kt = D.bucketOnlyServerUrl(), mn = Ti(D, Re, mt), Gn = { name: mn.fullPath }, jn = on(kt, w.host, w._protocol), Ii = { "X-Goog-Upload-Protocol": "resumable", "X-Goog-Upload-Command": "start", "X-Goog-Upload-Header-Content-Length": `${Re.size()}`, "X-Goog-Upload-Header-Content-Type": mn.contentType, "Content-Type": "application/json; charset=utf-8" }, Zi = J(mn, ne), ir = new un(jn, "POST", function Bi(ar) { let gr; bo(ar); try { gr = ar.getResponseHeader("X-Goog-Upload-URL") } catch { yt(!1) } return yt(jt(gr)), gr }, w.maxUploadRetryTime); return ir.urlParams = Gn, ir.headers = Ii, ir.body = Zi, ir.errorHandler = qn(D), ir }(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata), mt = this._ref.storage._makeRequest(Re, Be, D, ne); this._request = mt, mt.getPromise().then(kt => { this._request = void 0, this._uploadUrl = kt, this._needToFetchStatus = !1, this.completeTransitions_() }, this._errorHandler) }) } _fetchStatus() { const D = this._uploadUrl; this._resolveToken((ne, Re) => { const mt = function Vi(w, D, ne, Re) { const jn = new un(ne, "POST", function kt(gi) { const Ii = bo(gi, ["active", "final"]); let Zi = null; try { Zi = gi.getResponseHeader("X-Goog-Upload-Size-Received") } catch { yt(!1) } Zi || yt(!1); const ji = Number(Zi); return yt(!isNaN(ji)), new Ir(ji, Re.size(), "final" === Ii) }, w.maxUploadRetryTime); return jn.headers = { "X-Goog-Upload-Command": "query" }, jn.errorHandler = qn(D), jn }(this._ref.storage, this._ref._location, D, this._blob), kt = this._ref.storage._makeRequest(mt, Be, ne, Re); this._request = kt, kt.getPromise().then(mn => { this._request = void 0, this._updateProgress(mn.current), this._needToFetchStatus = !1, mn.finalized && (this._needToFetchMetadata = !0), this.completeTransitions_() }, this._errorHandler) }) } _continueUpload() { const D = 262144 * this._chunkMultiplier, ne = new Ir(this._transferred, this._blob.size()), Re = this._uploadUrl; this._resolveToken((mt, kt) => { let mn; try { mn = function fo(w, D, ne, Re, mt, kt, mn, Gn) { const jn = new Ir(0, 0); if (mn ? (jn.current = mn.current, jn.total = mn.total) : (jn.current = 0, jn.total = Re.size()), Re.size() !== jn.total) throw function Hn() { return new ut(ie.SERVER_FILE_WRONG_SIZE, "Server recorded incorrect upload file size, please retry the upload.") }(); const gi = jn.total - jn.current; let Ii = gi; mt > 0 && (Ii = Math.min(Ii, mt)); const Zi = jn.current; let Bi = ""; Bi = 0 === Ii ? "finalize" : gi === Ii ? "upload, finalize" : "upload"; const ir = { "X-Goog-Upload-Command": Bi, "X-Goog-Upload-Offset": `${jn.current}` }, ar = Re.slice(Zi, Zi + Ii); if (null === ar) throw Wn(); const Mr = new un(ne, "POST", function gr(Sr, Do) { const $o = bo(Sr, ["active", "final"]), hs = jn.current + Ii, rs = Re.size(); let Jr; return Jr = "final" === $o ? It(D, kt)(Sr, Do) : null, new Ir(hs, rs, "final" === $o, Jr) }, D.maxUploadRetryTime); return Mr.headers = ir, Mr.body = ar.uploadData(), Mr.progressCallback = Gn || null, Mr.errorHandler = qn(w), Mr }(this._ref._location, this._ref.storage, Re, this._blob, D, this._mappings, ne, this._makeProgressCallback()) } catch (jn) { return this._error = jn, void this._transition("error") } const Gn = this._ref.storage._makeRequest(mn, Be, mt, kt, !1); this._request = Gn, Gn.getPromise().then(jn => { this._increaseMultiplier(), this._request = void 0, this._updateProgress(jn.current), jn.finalized ? (this._metadata = jn.metadata, this._transition("success")) : this.completeTransitions_() }, this._errorHandler) }) } _increaseMultiplier() { 262144 * this._chunkMultiplier * 2 < 33554432 && (this._chunkMultiplier *= 2) } _fetchMetadata() { this._resolveToken((D, ne) => { const Re = si(this._ref.storage, this._ref._location, this._mappings), mt = this._ref.storage._makeRequest(Re, Be, D, ne); this._request = mt, mt.getPromise().then(kt => { this._request = void 0, this._metadata = kt, this._transition("success") }, this._metadataErrorHandler) }) } _oneShotUpload() { this._resolveToken((D, ne) => { const Re = function Pr(w, D, ne, Re, mt) { const kt = D.bucketOnlyServerUrl(), mn = { "X-Goog-Upload-Protocol": "multipart" }, jn = function Gn() { let Mr = ""; for (let Sr = 0; Sr < 2; Sr++)Mr += Math.random().toString().slice(2); return Mr }(); mn["Content-Type"] = "multipart/related; boundary=" + jn; const gi = Ti(D, Re, mt), Ii = J(gi, ne), Bi = me.getBlob("--" + jn + "\r\nContent-Type: application/json; charset=utf-8\r\n\r\n" + Ii + "\r\n--" + jn + "\r\nContent-Type: " + gi.contentType + "\r\n\r\n", Re, "\r\n--" + jn + "--"); if (null === Bi) throw Wn(); const ir = { name: gi.fullPath }, ar = on(kt, w.host, w._protocol), Yi = w.maxUploadRetryTime, Kr = new un(ar, "POST", It(w, ne), Yi); return Kr.urlParams = ir, Kr.headers = mn, Kr.body = Bi.uploadData(), Kr.errorHandler = qn(D), Kr }(this._ref.storage, this._ref._location, this._mappings, this._blob, this._metadata), mt = this._ref.storage._makeRequest(Re, Be, D, ne); this._request = mt, mt.getPromise().then(kt => { this._request = void 0, this._metadata = kt, this._updateProgress(this._blob.size()), this._transition("success") }, this._errorHandler) }) } _updateProgress(D) { const ne = this._transferred; this._transferred = D, this._transferred !== ne && this._notifyObservers() } _transition(D) { if (this._state !== D) switch (D) { case "canceling": case "pausing": this._state = D, void 0 !== this._request ? this._request.cancel() : this.pendingTimeout && (clearTimeout(this.pendingTimeout), this.pendingTimeout = void 0, this.completeTransitions_()); break; case "running": const ne = "paused" === this._state; this._state = D, ne && (this._notifyObservers(), this._start()); break; case "paused": case "error": case "success": this._state = D, this._notifyObservers(); break; case "canceled": this._error = bn(), this._state = D, this._notifyObservers() } } completeTransitions_() { switch (this._state) { case "pausing": this._transition("paused"); break; case "canceling": this._transition("canceled"); break; case "running": this._start() } } get snapshot() { const D = wt(this._state); return { bytesTransferred: this._transferred, totalBytes: this._blob.size(), state: D, metadata: this._metadata, task: this, ref: this._ref } } on(D, ne, Re, mt) { const kt = new bt(ne || void 0, Re || void 0, mt || void 0); return this._addObserver(kt), () => { this._removeObserver(kt) } } then(D, ne) { return this._promise.then(D, ne) } catch(D) { return this.then(null, D) } _addObserver(D) { this._observers.push(D), this._notifyObserver(D) } _removeObserver(D) { const ne = this._observers.indexOf(D); -1 !== ne && this._observers.splice(ne, 1) } _notifyObservers() { this._finishPromise(), this._observers.slice().forEach(ne => { this._notifyObserver(ne) }) } _finishPromise() { if (void 0 !== this._resolve) { let D = !0; switch (wt(this._state)) { case sr.SUCCESS: Rt(this._resolve.bind(null, this.snapshot))(); break; case sr.CANCELED: case sr.ERROR: Rt(this._reject.bind(null, this._error))(); break; default: D = !1 }D && (this._resolve = void 0, this._reject = void 0) } } _notifyObserver(D) { switch (wt(this._state)) { case sr.RUNNING: case sr.PAUSED: D.next && Rt(D.next.bind(D, this.snapshot))(); break; case sr.SUCCESS: D.complete && Rt(D.complete.bind(D))(); break; default: D.error && Rt(D.error.bind(D, this._error))() } } resume() { const D = "paused" === this._state || "pausing" === this._state; return D && this._transition("running"), D } pause() { const D = "running" === this._state; return D && this._transition("pausing"), D } cancel() { const D = "running" === this._state || "pausing" === this._state; return D && this._transition("canceling"), D } } class Tn { constructor(D, ne) { this._service = D, this._location = ne instanceof Jt ? ne : Jt.makeFromUrl(ne, D.host) } toString() { return "gs://" + this._location.bucket + "/" + this._location.path } _newRef(D, ne) { return new Tn(D, ne) } get root() { const D = new Jt(this._location.bucket, ""); return this._newRef(this._service, D) } get bucket() { return this._location.bucket } get fullPath() { return this._location.path } get name() { return He(this._location.path) } get storage() { return this._service } get parent() { const D = function st(w) { if (0 === w.length) return null; const D = w.lastIndexOf("/"); return -1 === D ? "" : w.slice(0, D) }(this._location.path); if (null === D) return null; const ne = new Jt(this._location.bucket, D); return new Tn(this._service, ne) } _throwIfRoot(D) { if ("" === this._location.path) throw Ft(D) } } function mo(w, D, ne) { return _i.apply(this, arguments) } function _i() { return (_i = (0, _e.Z)(function* (w, D, ne) { const mt = yield Sn(w, { pageToken: ne }); D.prefixes.push(...mt.prefixes), D.items.push(...mt.items), null != mt.nextPageToken && (yield mo(w, D, mt.nextPageToken)) })).apply(this, arguments) } function Sn(w, D) { null != D && "number" == typeof D.maxResults && Nt("options.maxResults", 1, 1e3, D.maxResults); const ne = D || {}, Re = Ai(w.storage, w._location, "/", ne.pageToken, ne.maxResults); return w.storage.makeRequestWithTokens(Re, Be) } function tr(w) { w._throwIfRoot("getDownloadURL"); const D = function ho(w, D, ne) { const mt = on(D.fullServerUrl(), w.host, w._protocol), mn = w.maxOperationRetryTime, Gn = new un(mt, "GET", function Pn(w, D) { return function ne(Re, mt) { const kt = fe(w, mt, D); return yt(null !== kt), function F(w, D, ne, Re) { const mt = de(D); if (null === mt || !jt(mt.downloadTokens)) return null; const kt = mt.downloadTokens; if (0 === kt.length) return null; const mn = encodeURIComponent; return kt.split(",").map(gi => { const Zi = w.fullPath; return on("/b/" + mn(w.bucket) + "/o/" + mn(Zi), ne, Re) + Zt({ alt: "media", token: gi }) })[0] }(kt, mt, w.host, w._protocol) } }(w, ne), mn); return Gn.errorHandler = ni(D), Gn }(w.storage, w._location, Ne()); return w.storage.makeRequestWithTokens(D, Be).then(ne => { if (null === ne) throw function at() { return new ut(ie.NO_DOWNLOAD_URL, "The given file does not have any download URLs.") }(); return ne }) } function nr(w, D) { const ne = function Lt(w, D) { const ne = D.split("/").filter(Re => Re.length > 0).join("/"); return 0 === w.length ? ne : w + "/" + ne }(w._location.path, D), Re = new Jt(w._location.bucket, ne); return new Tn(w.storage, Re) } function qr(w, D) { if (w instanceof Ao) { const ne = w; if (null == ne._bucket) throw function On() { return new ut(ie.NO_DEFAULT_BUCKET, "No default bucket found. Did you set the '" + Pe + "' property when initializing the app?") }(); const Re = new Tn(ne, ne._bucket); return null != D ? qr(Re, D) : Re } return void 0 !== D ? nr(w, D) : w } function ro(w, D) { if (D && function io(w) { return /^[A-Za-z]+:\/\//.test(w) }(D)) { if (w instanceof Ao) return function di(w, D) { return new Tn(w, D) }(w, D); throw xt("To use ref(service, url), the first argument must be a Storage instance.") } return qr(w, D) } function Xn(w, D) { const ne = D?.[Pe]; return null == ne ? null : Jt.makeFromBucketSpec(ne, w) } class Ao { constructor(D, ne, Re, mt, kt) { this.app = D, this._authProvider = ne, this._appCheckProvider = Re, this._url = mt, this._firebaseVersion = kt, this._bucket = null, this._host = We, this._protocol = "https", this._appId = null, this._deleted = !1, this._maxOperationRetryTime = 12e4, this._maxUploadRetryTime = 6e5, this._requests = new Set, this._bucket = null != mt ? Jt.makeFromBucketSpec(mt, this._host) : Xn(this._host, this.app.options) } get host() { return this._host } set host(D) { this._host = D, this._bucket = null != this._url ? Jt.makeFromBucketSpec(this._url, D) : Xn(D, this.app.options) } get maxUploadRetryTime() { return this._maxUploadRetryTime } set maxUploadRetryTime(D) { Nt("time", 0, Number.POSITIVE_INFINITY, D), this._maxUploadRetryTime = D } get maxOperationRetryTime() { return this._maxOperationRetryTime } set maxOperationRetryTime(D) { Nt("time", 0, Number.POSITIVE_INFINITY, D), this._maxOperationRetryTime = D } _getAuthToken() { var D = this; return (0, _e.Z)(function* () { if (D._overrideAuthToken) return D._overrideAuthToken; const ne = D._authProvider.getImmediate({ optional: !0 }); if (ne) { const Re = yield ne.getToken(); if (null !== Re) return Re.accessToken } return null })() } _getAppCheckToken() { var D = this; return (0, _e.Z)(function* () { const ne = D._appCheckProvider.getImmediate({ optional: !0 }); return ne ? (yield ne.getToken()).token : null })() } _delete() { return this._deleted || (this._deleted = !0, this._requests.forEach(D => D.cancel()), this._requests.clear()), Promise.resolve() } _makeStorageReference(D) { return new Tn(this, D) } _makeRequest(D, ne, Re, mt, kt = !0) { if (this._deleted) return new tn(it()); { const mn = function ve(w, D, ne, Re, mt, kt, mn = !0) { const Gn = Zt(w.urlParams), jn = w.url + Gn, gi = Object.assign({}, w.headers); return function Xe(w, D) { D && (w["X-Firebase-GMPID"] = D) }(gi, D), function se(w, D) { null !== D && D.length > 0 && (w.Authorization = "Firebase " + D) }(gi, ne), function Me(w, D) { w["X-Firebase-Storage-Version"] = "webjs/" + (D ?? "AppManager") }(gi, kt), function Ot(w, D) { null !== D && (w["X-Firebase-AppCheck"] = D) }(gi, Re), new Fn(jn, w.method, gi, w.body, w.successCodes, w.additionalRetryCodes, w.handler, w.errorHandler, w.timeout, w.progressCallback, mt, mn) }(D, this._appId, Re, mt, ne, this._firebaseVersion, kt); return this._requests.add(mn), mn.getPromise().then(() => this._requests.delete(mn), () => this._requests.delete(mn)), mn } } makeRequestWithTokens(D, ne) { var Re = this; return (0, _e.Z)(function* () { const [mt, kt] = yield Promise.all([Re._getAuthToken(), Re._getAppCheckToken()]); return Re._makeRequest(D, ne, mt, kt).getPromise() })() } } const ko = "@firebase/storage"; function Ho(w, D) { return ro(w = (0, ze.m9)(w), D) } function Ki(w, { instanceIdentifier: D }) { const ne = w.getProvider("app").getImmediate(), Re = w.getProvider("auth-internal"), mt = w.getProvider("app-check-internal"); return new Ao(ne, Re, mt, D, xe.SDK_VERSION) } !function po() { (0, xe._registerComponent)(new Oe.wA("storage", Ki, "PUBLIC").setMultipleInstances(!0)), (0, xe.registerVersion)(ko, "0.11.2", ""), (0, xe.registerVersion)(ko, "0.11.2", "esm2017") }(); class Er { constructor(D, ne, Re) { this._delegate = D, this.task = ne, this.ref = Re } get bytesTransferred() { return this._delegate.bytesTransferred } get metadata() { return this._delegate.metadata } get state() { return this._delegate.state } get totalBytes() { return this._delegate.totalBytes } } class Gr { constructor(D, ne) { this._delegate = D, this._ref = ne, this.cancel = this._delegate.cancel.bind(this._delegate), this.catch = this._delegate.catch.bind(this._delegate), this.pause = this._delegate.pause.bind(this._delegate), this.resume = this._delegate.resume.bind(this._delegate) } get snapshot() { return new Er(this._delegate.snapshot, this, this._ref) } then(D, ne) { return this._delegate.then(Re => { if (D) return D(new Er(Re, this, this._ref)) }, ne) } on(D, ne, Re, mt) { let kt; return ne && (kt = "function" == typeof ne ? mn => ne(new Er(mn, this, this._ref)) : { next: ne.next ? mn => ne.next(new Er(mn, this, this._ref)) : void 0, complete: ne.complete || void 0, error: ne.error || void 0 }), this._delegate.on(D, kt, Re || void 0, mt || void 0) } } class us { constructor(D, ne) { this._delegate = D, this._service = ne } get prefixes() { return this._delegate.prefixes.map(D => new dr(D, this._service)) } get items() { return this._delegate.items.map(D => new dr(D, this._service)) } get nextPageToken() { return this._delegate.nextPageToken || null } } class dr { constructor(D, ne) { this._delegate = D, this.storage = ne } get name() { return this._delegate.name } get bucket() { return this._delegate.bucket } get fullPath() { return this._delegate.fullPath } toString() { return this._delegate.toString() } child(D) { const ne = function Ro(w, D) { return nr(w, D) }(this._delegate, D); return new dr(ne, this.storage) } get root() { return new dr(this._delegate.root, this.storage) } get parent() { const D = this._delegate.parent; return null == D ? null : new dr(D, this.storage) } put(D, ne) { return this._throwIfRoot("put"), new Gr(function es(w, D, ne) { return function Dr(w, D, ne) { return w._throwIfRoot("uploadBytesResumable"), new cn(w, new me(D), ne) }(w = (0, ze.m9)(w), D, ne) }(this._delegate, D, ne), this) } putString(D, ne = Mt.RAW, Re) { this._throwIfRoot("putString"); const mt = fn(ne, D), kt = Object.assign({}, Re); return null == kt.contentType && null != mt.contentType && (kt.contentType = mt.contentType), new Gr(new cn(this._delegate, new me(mt.data, !0), kt), this) } listAll() { return function so(w) { return function Ko(w) { const D = { prefixes: [], items: [] }; return mo(w, D).then(() => D) }(w = (0, ze.m9)(w)) }(this._delegate).then(D => new us(D, this.storage)) } list(D) { return function Yo(w, D) { return Sn(w = (0, ze.m9)(w), D) }(this._delegate, D || void 0).then(ne => new us(ne, this.storage)) } getMetadata() { return function Tr(w) { return function ci(w) { w._throwIfRoot("getMetadata"); const D = si(w.storage, w._location, Ne()); return w.storage.makeRequestWithTokens(D, Be) }(w = (0, ze.m9)(w)) }(this._delegate) } updateMetadata(D) { return function Br(w, D) { return function ki(w, D) { w._throwIfRoot("updateMetadata"); const ne = function $r(w, D, ne, Re) { const kt = on(D.fullServerUrl(), w.host, w._protocol), Gn = J(ne, Re), gi = w.maxOperationRetryTime, Ii = new un(kt, "PATCH", It(w, Re), gi); return Ii.headers = { "Content-Type": "application/json; charset=utf-8" }, Ii.body = Gn, Ii.errorHandler = ni(D), Ii }(w.storage, w._location, D, Ne()); return w.storage.makeRequestWithTokens(ne, Be) }(w = (0, ze.m9)(w), D) }(this._delegate, D) } getDownloadURL() { return function Mi(w) { return tr(w = (0, ze.m9)(w)) }(this._delegate) } delete() { return this._throwIfRoot("delete"), function qo(w) { return function Lr(w) { w._throwIfRoot("deleteObject"); const D = function Io(w, D) { const Re = on(D.fullServerUrl(), w.host, w._protocol), Gn = new un(Re, "DELETE", function mn(jn, gi) { }, w.maxOperationRetryTime); return Gn.successCodes = [200, 204], Gn.errorHandler = ni(D), Gn }(w.storage, w._location); return w.storage.makeRequestWithTokens(D, Be) }(w = (0, ze.m9)(w)) }(this._delegate) } _throwIfRoot(D) { if ("" === this._delegate._location.path) throw Ft(D) } } class Wr { constructor(D, ne) { this.app = D, this._delegate = ne } get maxOperationRetryTime() { return this._delegate.maxOperationRetryTime } get maxUploadRetryTime() { return this._delegate.maxUploadRetryTime } ref(D) { if (Ni(D)) throw xt("ref() expected a child path but got a URL, use refFromURL instead."); return new dr(Ho(this._delegate, D), this) } refFromURL(D) { if (!Ni(D)) throw xt("refFromURL() expected a full URL but got a child path, use ref() instead."); try { Jt.makeFromUrl(D, this._delegate.host) } catch { throw xt("refFromUrl() expected a valid full URL but got an invalid one.") } return new dr(Ho(this._delegate, D), this) } setMaxUploadRetryTime(D) { this._delegate.maxUploadRetryTime = D } setMaxOperationRetryTime(D) { this._delegate.maxOperationRetryTime = D } useEmulator(D, ne, Re = {}) { !function zo(w, D, ne, Re = {}) { !function vs(w, D, ne, Re = {}) { w.host = `${D}:${ne}`, w._protocol = "http"; const { mockUserToken: mt } = Re; mt && (w._overrideAuthToken = "string" == typeof mt ? mt : (0, ze.Sg)(mt, w.app.options.projectId)) }(w, D, ne, Re) }(this._delegate, D, ne, Re) } } function Ni(w) { return /^[A-Za-z]+:\/\//.test(w) } function bs(w, { instanceIdentifier: D }) { const ne = w.getProvider("app-compat").getImmediate(), Re = w.getProvider("storage").getImmediate({ identifier: D }); return new Wr(ne, Re) } !function ta(w) { const D = { TaskState: sr, TaskEvent: Jo, StringFormat: Mt, Storage: Wr, Reference: dr }; w.INTERNAL.registerComponent(new Oe.wA("storage-compat", bs, "PUBLIC").setServiceProps(D).setMultipleInstances(!0)), w.registerVersion("@firebase/storage-compat", "0.3.2") }(Q.Z); var Ci = C(7247); function Ws(w) { const D = function Da(w) { return new a.y(D => { const ne = mn => D.next(mn); ne(w.snapshot); const kt = w.on("state_changed", ne); return w.then(mn => { ne(mn), D.complete() }, mn => { ne(w.snapshot), (mn => { D.error(mn) })(mn) }), function () { kt() } }).pipe((0, Y.b)(0)) }(w); return { task: w, then: w.then.bind(w), catch: w.catch.bind(w), pause: w.pause.bind(w), cancel: w.cancel.bind(w), resume: w.resume.bind(w), snapshotChanges: () => D, percentageChanges: () => D.pipe((0, he.U)(ne => ne.bytesTransferred / ne.totalBytes * 100)) } } function na(w) { return { getDownloadURL: () => (0, y.of)(void 0).pipe(ke.fc, (0, Se.w)(() => w.getDownloadURL()), ke.iC), getMetadata: () => (0, y.of)(void 0).pipe(ke.fc, (0, Se.w)(() => w.getMetadata()), ke.iC), delete: () => (0, v.D)(w.delete()), child: D => na(w.child(D)), updateMetadata: D => (0, v.D)(w.updateMetadata(D)), put: (D, ne) => Ws(w.put(D, ne)), putString: (D, ne, Re) => Ws(w.putString(D, ne, Re)), list: D => (0, v.D)(w.list(D)), listAll: () => (0, v.D)(w.listAll()) } } C(7142); const ha = new re.OlP("angularfire2.storageBucket"), fa = new re.OlP("angularfire2.storage.maxUploadRetryTime"), ws = new re.OlP("angularfire2.storage.maxOperationRetryTime"), is = new re.OlP("angularfire2.storage.use-emulator"); let Ks = (() => { class w { constructor(ne, Re, mt, kt, mn, Gn, jn, gi, Ii, Zi) { const ji = (0, Ie.on)(ne, mn, Re); this.storage = (0, Ie.cc)(`${ji.name}.storage.${mt}`, "AngularFireStorage", ji.name, () => { const Bi = mn.runOutsideAngular(() => ji.storage(mt || void 0)), ir = Ii; return ir && Bi.useEmulator(...ir), jn && Bi.setMaxUploadRetryTime(jn), gi && Bi.setMaxOperationRetryTime(gi), Bi }, [jn, gi]) } ref(ne) { return na(this.storage.ref(ne)) } refFromURL(ne) { return na(this.storage.refFromURL(ne)) } upload(ne, Re, mt) { return na(this.storage.ref(ne)).put(Re, mt) } } return w.\u0275fac = function (ne) { return new (ne || w)(re.LFG(Ie.Dh), re.LFG(Ie.xv, 8), re.LFG(ha, 8), re.LFG(re.Lbi), re.LFG(re.R0b), re.LFG(ke.HU), re.LFG(fa, 8), re.LFG(ws, 8), re.LFG(is, 8), re.LFG(Ci.nm, 8)) }, w.\u0275prov = re.Yz7({ token: w, factory: w.\u0275fac, providedIn: "any" }), w })() }, 6304: (nn, Qe, C) => { C.d(Qe, { Dh: () => ke, GT: () => he, cc: () => ze, on: () => Ie, pX: () => Y, xv: () => re }); var a = C(5879), y = C(7142); nn = C.hmd(nn); const v = ["ngOnDestroy"], Y = (Ve, tt, Ye, ut = {}) => new Proxy(Ve, { get: (ie, Le) => Ye.runOutsideAngular(() => { var le; if (Ve[Le]) return !(null === (le = ut?.spy) || void 0 === le) && le.get && ut.spy.get(Le, Ve[Le]), Ve[Le]; if (v.indexOf(Le) > -1) return () => { }; const ge = tt.toPromise().then(ue => { const ee = ue && ue[Le]; return "function" == typeof ee ? ee.bind(ue) : ee && ee.then ? ee.then($e => Ye.run(() => $e)) : Ye.run(() => ee) }); return new Proxy(() => { }, { get: (ue, ee) => ge[ee], apply: (ue, ee, $e) => ge.then(rt => { var Kt; const bn = rt && rt(...$e); return !(null === (Kt = ut?.spy) || void 0 === Kt) && Kt.apply && ut.spy.apply(Le, $e, bn), bn }) }) }) }), he = (Ve, tt) => { tt.forEach(Ye => { Object.getOwnPropertyNames(Ye.prototype || Ye).forEach(ut => { Object.defineProperty(Ve.prototype, ut, Object.getOwnPropertyDescriptor(Ye.prototype || Ye, ut)) }) }) }; class Se { constructor(tt) { return tt } } const ke = new a.OlP("angularfire2.app.options"), re = new a.OlP("angularfire2.app.name"); function Ie(Ve, tt, Ye) { const ie = "object" == typeof Ye && Ye || {}; ie.name = ie.name || "string" == typeof Ye && Ye || "[DEFAULT]"; const le = y.Z.apps.filter(ge => ge && ge.name === ie.name)[0] || tt.runOutsideAngular(() => y.Z.initializeApp(Ve, ie)); try { JSON.stringify(Ve) !== JSON.stringify(le.options) && Q("error", `${le.name} Firebase App already initialized with different options${nn.hot ? ", you may need to reload as Firebase is not HMR aware." : "."}`) } catch { } return new Se(le) } const Q = (Ve, ...tt) => { (0, a.X6Q)() && typeof console < "u" && console[Ve](...tt) }; function ze(Ve, tt, Ye, ut, ie) { const [, Le, le] = globalThis.\u0275AngularfireInstanceCache.find(ge => ge[0] === Ve) || []; if (Le) return function Oe(Ve, tt) { try { return Ve.toString() === tt.toString() } catch { return Ve === tt } }(ie, le) || (Pe("error", `${tt} was already initialized on the ${Ye} Firebase App with different settings.${We ? " You may need to reload as Firebase is not HMR aware." : ""}`), Pe("warn", { is: ie, was: le })), Le; { const ge = ut(); return globalThis.\u0275AngularfireInstanceCache.push([Ve, ge, ie]), ge } } const We = !!nn.hot, Pe = (Ve, ...tt) => { (0, a.X6Q)() && typeof console < "u" && console[Ve](...tt) }; globalThis.\u0275AngularfireInstanceCache || (globalThis.\u0275AngularfireInstanceCache = []) }, 3828: (nn, Qe, C) => { C.d(Qe, { gg: () => rt, ET: () => nt, hJ: () => qe, BS: () => Jt, oe: () => Zt, JU: () => Fn, QT: () => Ue, ad: () => fn, Cm: () => xt, IO: () => st, r7: () => F, ar: () => Te }); var a = C(1966), y = C(5879), v = C(8429), Y = C(8726), he = C(3182), Se = C(7247), ke = C(5776), re = C(5592), Ie = C(7398), Q = { includeMetadataChanges: !1 }; function $e(gt, Ht) { return void 0 === Ht && (Ht = {}), function ge(gt) { return function _e(gt, Ht) { return void 0 === Ht && (Ht = Q), new re.y(function (un) { return { unsubscribe: (0, ke.cf)(gt, Ht, { next: un.next.bind(un), error: un.error.bind(un), complete: un.complete.bind(un) }) } }) }(gt, { includeMetadataChanges: !0 }).pipe((0, Ie.U)(function (Ht) { return Ht.docs })) }(gt).pipe((0, Ie.U)(function (un) { return un.map(function (yt) { return function Oe(gt, Ht) { void 0 === Ht && (Ht = {}); var un = gt.data(); return !gt.exists() || "object" != typeof un || null === un || Ht.idField && (un[Ht.idField] = gt.id), un }(yt, Ht) }) })) } class rt { constructor(Ht) { return Ht } } const Kt = "firestore", Mn = new y.OlP("angularfire2.firestore-instances"); function Wn(gt) { return (Ht, un) => { const yt = Ht.runOutsideAngular(() => gt(un)); return new rt(yt) } } const Hn = { provide: class bn { constructor() { return (0, a.vb)(Kt) } }, deps: [[new y.FiY, Mn]] }, at = { provide: rt, useFactory: function On(gt, Ht) { const un = (0, a.JM)(Kt, gt, Ht); return un && new rt(un) }, deps: [[new y.FiY, Mn], Y.Ot] }; let vt = (() => { class gt { constructor() { (0, he.KN)("angularfire", a.q4.full, "fst") } } return gt.\u0275fac = function (un) { return new (un || gt) }, gt.\u0275mod = y.oAB({ type: gt }), gt.\u0275inj = y.cJS({ providers: [at, Hn] }), gt })(); function xt(gt, ...Ht) { return { ngModule: vt, providers: [{ provide: Mn, useFactory: Wn(gt), multi: !0, deps: [y.R0b, y.zs3, a.HU, Y.z6, [new y.FiY, v.dh], [new y.FiY, Se.nm], ...Ht] }] } } const Jt = (0, a.u3)($e, !0), nt = (0, a.u3)(ke.ET, !0), qe = (0, a.u3)(ke.hJ, !0), Zt = (0, a.u3)(ke.oe, !0), Fn = (0, a.u3)(ke.JU, !0), Ue = (0, a.u3)(ke.QT, !0), fn = (0, a.u3)(ke.ad, !0), st = (0, a.u3)(ke.IO, !0), F = (0, a.u3)(ke.r7, !0), Te = (0, a.u3)(ke.ar, !0) }, 1966: (nn, Qe, C) => { C.d(Qe, { q4: () => Is, iC: () => Ds, fc: () => tl, HU: () => Ea, vb: () => Lo, JM: () => ud, u3: () => Ns }); var a = C(5879), y = C(3182), v = C(5861), Y = C(6122), he = C(9058), Se = C(4537), ke = C(7879); const re = (O, U) => U.some(ce => O instanceof ce); let Ie, Q; const ze = new WeakMap, Oe = new WeakMap, We = new WeakMap, Pe = new WeakMap, Ve = new WeakMap; let ut = { get(O, U, ce) { if (O instanceof IDBTransaction) { if ("done" === U) return Oe.get(O); if ("objectStoreNames" === U) return O.objectStoreNames || We.get(O); if ("store" === U) return ce.objectStoreNames[1] ? void 0 : ce.objectStore(ce.objectStoreNames[0]) } return ge(O[U]) }, set: (O, U, ce) => (O[U] = ce, !0), has: (O, U) => O instanceof IDBTransaction && ("done" === U || "store" === U) || U in O }; function le(O) { return "function" == typeof O ? function Le(O) { return O !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? function xe() { return Q || (Q = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]) }().includes(O) ? function (...U) { return O.apply(ue(this), U), ge(ze.get(this)) } : function (...U) { return ge(O.apply(ue(this), U)) } : function (U, ...ce) { const Ze = O.call(ue(this), U, ...ce); return We.set(Ze, U.sort ? U.sort() : [U]), ge(Ze) } }(O) : (O instanceof IDBTransaction && function Ye(O) { if (Oe.has(O)) return; const U = new Promise((ce, Ze) => { const Ct = () => { O.removeEventListener("complete", Ut), O.removeEventListener("error", ln), O.removeEventListener("abort", ln) }, Ut = () => { ce(), Ct() }, ln = () => { Ze(O.error || new DOMException("AbortError", "AbortError")), Ct() }; O.addEventListener("complete", Ut), O.addEventListener("error", ln), O.addEventListener("abort", ln) }); Oe.set(O, U) }(O), re(O, function _e() { return Ie || (Ie = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]) }()) ? new Proxy(O, ut) : O) } function ge(O) { if (O instanceof IDBRequest) return function tt(O) { const U = new Promise((ce, Ze) => { const Ct = () => { O.removeEventListener("success", Ut), O.removeEventListener("error", ln) }, Ut = () => { ce(ge(O.result)), Ct() }, ln = () => { Ze(O.error), Ct() }; O.addEventListener("success", Ut), O.addEventListener("error", ln) }); return U.then(ce => { ce instanceof IDBCursor && ze.set(ce, O) }).catch(() => { }), Ve.set(U, O), U }(O); if (Pe.has(O)) return Pe.get(O); const U = le(O); return U !== O && (Pe.set(O, U), Ve.set(U, O)), U } const ue = O => Ve.get(O); function ee(O, U, { blocked: ce, upgrade: Ze, blocking: Ct, terminated: Ut } = {}) { const ln = indexedDB.open(O, U), Kn = ge(ln); return Ze && ln.addEventListener("upgradeneeded", Vn => { Ze(ge(ln.result), Vn.oldVersion, Vn.newVersion, ge(ln.transaction)) }), ce && ln.addEventListener("blocked", () => ce()), Kn.then(Vn => { Ut && Vn.addEventListener("close", () => Ut()), Ct && Vn.addEventListener("versionchange", () => Ct()) }).catch(() => { }), Kn } function $e(O, { blocked: U } = {}) { const ce = indexedDB.deleteDatabase(O); return U && ce.addEventListener("blocked", () => U()), ge(ce).then(() => { }) } const rt = ["get", "getKey", "getAll", "getAllKeys", "count"], Kt = ["put", "add", "delete", "clear"], bn = new Map; function Dn(O, U) { if (!(O instanceof IDBDatabase) || U in O || "string" != typeof U) return; if (bn.get(U)) return bn.get(U); const ce = U.replace(/FromIndex$/, ""), Ze = U !== ce, Ct = Kt.includes(ce); if (!(ce in (Ze ? IDBIndex : IDBObjectStore).prototype) || !Ct && !rt.includes(ce)) return; const Ut = function () { var ln = (0, v.Z)(function* (Kn, ...Vn) { const mi = this.transaction(Kn, Ct ? "readwrite" : "readonly"); let Ui = mi.store; return Ze && (Ui = Ui.index(Vn.shift())), (yield Promise.all([Ui[ce](...Vn), Ct && mi.done]))[0] }); return function (Vn) { return ln.apply(this, arguments) } }(); return bn.set(U, Ut), Ut } !function ie(O) { ut = O(ut) }(O => ({ ...O, get: (U, ce, Ze) => Dn(U, ce) || O.get(U, ce, Ze), has: (U, ce) => !!Dn(U, ce) || O.has(U, ce) })); const Mn = "@firebase/installations", On = "0.6.4", Wn = 1e4, Hn = `w:${On}`, at = "FIS_v2", vt = "https://firebaseinstallations.googleapis.com/v1", xt = 36e5, rn = new he.LL("installations", "Installations", { "missing-app-config-values": 'Missing App configuration value: "{$valueName}"', "not-registered": "Firebase Installation is not registered.", "installation-not-found": "Firebase Installation not found.", "request-failed": '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"', "app-offline": "Could not process request. Application offline.", "delete-pending-registration": "Can't delete installation while there is a pending registration request." }); function Jt(O) { return O instanceof he.ZR && O.code.includes("request-failed") } function tn({ projectId: O }) { return `${vt}/projects/${O}/installations` } function St(O) { return { token: O.token, requestStatus: 2, expiresIn: qe(O.expiresIn), creationTime: Date.now() } } function ht(O, U) { return Ae.apply(this, arguments) } function Ae() { return (Ae = (0, v.Z)(function* (O, U) { const Ze = (yield U.json()).error; return rn.create("request-failed", { requestName: O, serverCode: Ze.code, serverMessage: Ze.message, serverStatus: Ze.status }) })).apply(this, arguments) } function nt({ apiKey: O }) { return new Headers({ "Content-Type": "application/json", Accept: "application/json", "x-goog-api-key": O }) } function jt(O) { return Pt.apply(this, arguments) } function Pt() { return (Pt = (0, v.Z)(function* (O) { const U = yield O(); return U.status >= 500 && U.status < 600 ? O() : U })).apply(this, arguments) } function qe(O) { return Number(O.replace("s", "000")) } function Zt() { return (Zt = (0, v.Z)(function* ({ appConfig: O, heartbeatServiceProvider: U }, { fid: ce }) { const Ze = tn(O), Ct = nt(O), Ut = U.getImmediate({ optional: !0 }); if (Ut) { const mi = yield Ut.getHeartbeatsHeader(); mi && Ct.append("x-firebase-client", mi) } const Kn = { method: "POST", headers: Ct, body: JSON.stringify({ fid: ce, authVersion: at, appId: O.appId, sdkVersion: Hn }) }, Vn = yield jt(() => fetch(Ze, Kn)); if (Vn.ok) { const mi = yield Vn.json(); return { fid: mi.fid || ce, registrationStatus: 2, refreshToken: mi.refreshToken, authToken: St(mi.authToken) } } throw yield ht("Create Installation", Vn) })).apply(this, arguments) } function gn(O) { return new Promise(U => { setTimeout(U, O) }) } const Fn = /^[cdef][\w-]{21}$/, Ke = ""; function se() { try { const O = new Uint8Array(17); (self.crypto || self.msCrypto).getRandomValues(O), O[0] = 112 + O[0] % 16; const ce = function Me(O) { return function $n(O) { return btoa(String.fromCharCode(...O)).replace(/\+/g, "-").replace(/\//g, "_") }(O).substr(0, 22) }(O); return Fn.test(ce) ? ce : Ke } catch { return Ke } } function Xe(O) { return `${O.appName}!${O.appId}` } const Ot = new Map; function ve(O, U) { const ce = Xe(O); Fe(ce, U), function ct(O, U) { const ce = function Qt() { return !Mt && "BroadcastChannel" in self && (Mt = new BroadcastChannel("[Firebase] FID Change"), Mt.onmessage = O => { Fe(O.data.key, O.data.fid) }), Mt }(); ce && ce.postMessage({ key: O, fid: U }), function fn() { 0 === Ot.size && Mt && (Mt.close(), Mt = null) }() }(ce, U) } function Fe(O, U) { const ce = Ot.get(O); if (ce) for (const Ze of ce) Ze(U) } let Mt = null; const En = "firebase-installations-database", Ln = 1, In = "firebase-installations-store"; let Et = null; function _t() { return Et || (Et = ee(En, Ln, { upgrade: (O, U) => { 0 === U && O.createObjectStore(In) } })), Et } function G(O, U) { return W.apply(this, arguments) } function W() { return (W = (0, v.Z)(function* (O, U) { const ce = Xe(O), Ct = (yield _t()).transaction(In, "readwrite"), Ut = Ct.objectStore(In), ln = yield Ut.get(ce); return yield Ut.put(U, ce), yield Ct.done, (!ln || ln.fid !== U.fid) && ve(O, U.fid), U })).apply(this, arguments) } function me(O) { return de.apply(this, arguments) } function de() { return (de = (0, v.Z)(function* (O) { const U = Xe(O), Ze = (yield _t()).transaction(In, "readwrite"); yield Ze.objectStore(In).delete(U), yield Ze.done })).apply(this, arguments) } function st(O, U) { return Lt.apply(this, arguments) } function Lt() { return (Lt = (0, v.Z)(function* (O, U) { const ce = Xe(O), Ct = (yield _t()).transaction(In, "readwrite"), Ut = Ct.objectStore(In), ln = yield Ut.get(ce), Kn = U(ln); return void 0 === Kn ? yield Ut.delete(ce) : yield Ut.put(Kn, ce), yield Ct.done, Kn && (!ln || ln.fid !== Kn.fid) && ve(O, Kn.fid), Kn })).apply(this, arguments) } function He(O) { return ae.apply(this, arguments) } function ae() { return ae = (0, v.Z)(function* (O) { let U; const ce = yield st(O.appConfig, Ze => { const Ct = function z(O) { return F(O || { fid: se(), registrationStatus: 0 }) }(Ze), Ut = function L(O, U) { if (0 === U.registrationStatus) { if (!navigator.onLine) return { installationEntry: U, registrationPromise: Promise.reject(rn.create("app-offline")) }; const ce = { fid: U.fid, registrationStatus: 1, registrationTime: Date.now() }, Ze = function H(O, U) { return Ne.apply(this, arguments) }(O, ce); return { installationEntry: ce, registrationPromise: Ze } } return 1 === U.registrationStatus ? { installationEntry: U, registrationPromise: pt(O) } : { installationEntry: U } }(O, Ct); return U = Ut.registrationPromise, Ut.installationEntry }); return ce.fid === Ke ? { installationEntry: yield U } : { installationEntry: ce, registrationPromise: U } }), ae.apply(this, arguments) } function Ne() { return Ne = (0, v.Z)(function* (O, U) { try { const ce = yield function on(O, U) { return Zt.apply(this, arguments) }(O, U); return G(O.appConfig, ce) } catch (ce) { throw Jt(ce) && 409 === ce.customData.serverCode ? yield me(O.appConfig) : yield G(O.appConfig, { fid: U.fid, registrationStatus: 0 }), ce } }), Ne.apply(this, arguments) } function pt(O) { return pe.apply(this, arguments) } function pe() { return (pe = (0, v.Z)(function* (O) { let U = yield fe(O.appConfig); for (; 1 === U.registrationStatus;)yield gn(100), U = yield fe(O.appConfig); if (0 === U.registrationStatus) { const { installationEntry: ce, registrationPromise: Ze } = yield He(O); return Ze || ce } return U })).apply(this, arguments) } function fe(O) { return st(O, U => { if (!U) throw rn.create("installation-not-found"); return F(U) }) } function F(O) { return function J(O) { return 1 === O.registrationStatus && O.registrationTime + Wn < Date.now() }(O) ? { fid: O.fid, registrationStatus: 0 } : O } function lt() { return (lt = (0, v.Z)(function* ({ appConfig: O, heartbeatServiceProvider: U }, ce) { const Ze = function gt(O, { fid: U }) { return `${tn(O)}/${U}/authTokens:generate` }(O, ce), Ct = function qt(O, { refreshToken: U }) { const ce = nt(O); return ce.append("Authorization", function Nt(O) { return `${at} ${O}` }(U)), ce }(O, ce), Ut = U.getImmediate({ optional: !0 }); if (Ut) { const mi = yield Ut.getHeartbeatsHeader(); mi && Ct.append("x-firebase-client", mi) } const Kn = { method: "POST", headers: Ct, body: JSON.stringify({ installation: { sdkVersion: Hn, appId: O.appId } }) }, Vn = yield jt(() => fetch(Ze, Kn)); if (Vn.ok) return St(yield Vn.json()); throw yield ht("Generate Auth Token", Vn) })).apply(this, arguments) } function Ht(O) { return un.apply(this, arguments) } function un() { return un = (0, v.Z)(function* (O, U = !1) { let ce; const Ze = yield st(O.appConfig, Ut => { if (!ni(Ut)) throw rn.create("not-registered"); const ln = Ut.authToken; if (!U && function si(O) { return 2 === O.requestStatus && !function Ai(O) { const U = Date.now(); return U < O.creationTime || O.creationTime + O.expiresIn < U + xt }(O) }(ln)) return Ut; if (1 === ln.requestStatus) return ce = function yt(O, U) { return It.apply(this, arguments) }(O, U), Ut; { if (!navigator.onLine) throw rn.create("app-offline"); const Kn = function Li(O) { const U = { requestStatus: 1, requestTime: Date.now() }; return Object.assign(Object.assign({}, O), { authToken: U }) }(Ut); return ce = function Pn(O, U) { return qn.apply(this, arguments) }(O, Kn), Kn } }); return ce ? yield ce : Ze.authToken }), un.apply(this, arguments) } function It() { return (It = (0, v.Z)(function* (O, U) { let ce = yield dn(O.appConfig); for (; 1 === ce.authToken.requestStatus;)yield gn(100), ce = yield dn(O.appConfig); const Ze = ce.authToken; return 0 === Ze.requestStatus ? Ht(O, U) : Ze })).apply(this, arguments) } function dn(O) { return st(O, U => { if (!ni(U)) throw rn.create("not-registered"); return function ho(O) { return 1 === O.requestStatus && O.requestTime + Wn < Date.now() }(U.authToken) ? Object.assign(Object.assign({}, U), { authToken: { requestStatus: 0 } }) : U }) } function qn() { return qn = (0, v.Z)(function* (O, U) { try { const ce = yield function Te(O, U) { return lt.apply(this, arguments) }(O, U), Ze = Object.assign(Object.assign({}, U), { authToken: ce }); return yield G(O.appConfig, Ze), ce } catch (ce) { if (!Jt(ce) || 401 !== ce.customData.serverCode && 404 !== ce.customData.serverCode) { const Ze = Object.assign(Object.assign({}, U), { authToken: { requestStatus: 0 } }); yield G(O.appConfig, Ze) } else yield me(O.appConfig); throw ce } }), qn.apply(this, arguments) } function ni(O) { return void 0 !== O && 2 === O.registrationStatus } function Io() { return (Io = (0, v.Z)(function* (O) { const U = O, { installationEntry: ce, registrationPromise: Ze } = yield He(U); return Ze ? Ze.catch(console.error) : Ht(U).catch(console.error), ce.fid })).apply(this, arguments) } function Ti() { return Ti = (0, v.Z)(function* (O, U = !1) { const ce = O; return yield function Pr(O) { return Ir.apply(this, arguments) }(ce), (yield Ht(ce, U)).token }), Ti.apply(this, arguments) } function Ir() { return (Ir = (0, v.Z)(function* (O) { const { registrationPromise: U } = yield He(O); U && (yield U) })).apply(this, arguments) } function bt(O) { return rn.create("missing-app-config-values", { valueName: O }) } const Rt = "installations", wn = O => { const U = O.getProvider("app").getImmediate(), ce = function wt(O) { if (!O || !O.options) throw bt("App Configuration"); if (!O.name) throw bt("App Name"); const U = ["projectId", "apiKey", "appId"]; for (const ce of U) if (!O.options[ce]) throw bt(ce); return { appName: O.name, projectId: O.options.projectId, apiKey: O.options.apiKey, appId: O.options.appId } }(U); return { app: U, appConfig: ce, heartbeatServiceProvider: (0, Y._getProvider)(U, "heartbeat"), _delete: () => Promise.resolve() } }, dt = O => { const U = O.getProvider("app").getImmediate(), ce = (0, Y._getProvider)(U, Rt).getImmediate(); return { getId: () => function $r(O) { return Io.apply(this, arguments) }(ce), getToken: Ct => function zi(O) { return Ti.apply(this, arguments) }(ce, Ct) } }; (function Be() { (0, Y._registerComponent)(new Se.wA(Rt, wn, "PUBLIC")), (0, Y._registerComponent)(new Se.wA("installations-internal", dt, "PRIVATE")) })(), (0, Y.registerVersion)(Mn, On), (0, Y.registerVersion)(Mn, On, "esm2017"); const ye = "@firebase/remote-config", Tn = new he.LL("remoteconfig", "Remote Config", { "registration-window": "Undefined window object. This SDK only supports usage in a browser environment.", "registration-project-id": "Undefined project identifier. Check Firebase app initialization.", "registration-api-key": "Undefined API key. Check Firebase app initialization.", "registration-app-id": "Undefined app identifier. Check Firebase app initialization.", "storage-open": "Error thrown when opening storage. Original error: {$originalErrorMessage}.", "storage-get": "Error thrown when reading from storage. Original error: {$originalErrorMessage}.", "storage-set": "Error thrown when writing to storage. Original error: {$originalErrorMessage}.", "storage-delete": "Error thrown when deleting from storage. Original error: {$originalErrorMessage}.", "fetch-client-network": "Fetch client failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.", "fetch-timeout": 'The config fetch request timed out.  Configure timeout using "fetchTimeoutMillis" SDK setting.', "fetch-throttle": 'The config fetch request timed out while in an exponential backoff state. Configure timeout using "fetchTimeoutMillis" SDK setting. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.', "fetch-client-parse": "Fetch client could not parse response. Original error: {$originalErrorMessage}.", "fetch-status": "Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.", "indexed-db-unavailable": "Indexed DB is not supported by current browser" }); class vs { constructor(U, ce, Ze, Ct) { this.client = U, this.storage = ce, this.storageCache = Ze, this.logger = Ct } isCachedDataFresh(U, ce) { if (!ce) return this.logger.debug("Config fetch cache check. Cache unpopulated."), !1; const Ze = Date.now() - ce, Ct = Ze <= U; return this.logger.debug(`Config fetch cache check. Cache age millis: ${Ze}. Cache max age millis (minimumFetchIntervalMillis setting): ${U}. Is cache hit: ${Ct}.`), Ct } fetch(U) { var ce = this; return (0, v.Z)(function* () { const [Ze, Ct] = yield Promise.all([ce.storage.getLastSuccessfulFetchTimestampMillis(), ce.storage.getLastSuccessfulFetchResponse()]); if (Ct && ce.isCachedDataFresh(U.cacheMaxAgeMillis, Ze)) return Ct; U.eTag = Ct && Ct.eTag; const Ut = yield ce.client.fetch(U), ln = [ce.storageCache.setLastSuccessfulFetchTimestampMillis(Date.now())]; return 200 === Ut.status && ln.push(ce.storage.setLastSuccessfulFetchResponse(Ut)), yield Promise.all(ln), Ut })() } } function Ao(O = navigator) { return O.languages && O.languages[0] || O.language } class ko { constructor(U, ce, Ze, Ct, Ut, ln) { this.firebaseInstallations = U, this.sdkVersion = ce, this.namespace = Ze, this.projectId = Ct, this.apiKey = Ut, this.appId = ln } fetch(U) { var ce = this; return (0, v.Z)(function* () { const [Ze, Ct] = yield Promise.all([ce.firebaseInstallations.getId(), ce.firebaseInstallations.getToken()]), ln = `${window.FIREBASE_REMOTE_CONFIG_URL_BASE || "https://firebaseremoteconfig.googleapis.com"}/v1/projects/${ce.projectId}/namespaces/${ce.namespace}:fetch?key=${ce.apiKey}`, Kn = { "Content-Type": "application/json", "Content-Encoding": "gzip", "If-None-Match": U.eTag || "*" }, Vn = { sdk_version: ce.sdkVersion, app_instance_id: Ze, app_instance_id_token: Ct, app_id: ce.appId, language_code: Ao() }, mi = { method: "POST", headers: Kn, body: JSON.stringify(Vn) }, Ui = fetch(ln, mi), li = new Promise((Qs, no) => { U.signal.addEventListener(() => { const ml = new Error("The operation was aborted."); ml.name = "AbortError", no(ml) }) }); let gs; try { yield Promise.race([Ui, li]), gs = yield Ui } catch (Qs) { let no = "fetch-client-network"; throw "AbortError" === Qs?.name && (no = "fetch-timeout"), Tn.create(no, { originalErrorMessage: Qs?.message }) } let Bo = gs.status; const fl = gs.headers.get("ETag") || void 0; let js, Pa; if (200 === gs.status) { let Qs; try { Qs = yield gs.json() } catch (no) { throw Tn.create("fetch-client-parse", { originalErrorMessage: no?.message }) } js = Qs.entries, Pa = Qs.state } if ("INSTANCE_STATE_UNSPECIFIED" === Pa ? Bo = 500 : "NO_CHANGE" === Pa ? Bo = 304 : ("NO_TEMPLATE" === Pa || "EMPTY_CONFIG" === Pa) && (js = {}), 304 !== Bo && 200 !== Bo) throw Tn.create("fetch-status", { httpStatus: Bo }); return { status: Bo, eTag: fl, config: js } })() } } class ds { constructor(U, ce) { this.client = U, this.storage = ce } fetch(U) { var ce = this; return (0, v.Z)(function* () { const Ze = (yield ce.storage.getThrottleMetadata()) || { backoffCount: 0, throttleEndTimeMillis: Date.now() }; return ce.attemptFetch(U, Ze) })() } attemptFetch(U, { throttleEndTimeMillis: ce, backoffCount: Ze }) { var Ct = this; return (0, v.Z)(function* () { yield function cr(O, U) { return new Promise((ce, Ze) => { const Ct = Math.max(U - Date.now(), 0), Ut = setTimeout(ce, Ct); O.addEventListener(() => { clearTimeout(Ut), Ze(Tn.create("fetch-throttle", { throttleEndTimeMillis: U })) }) }) }(U.signal, ce); try { const Ut = yield Ct.client.fetch(U); return yield Ct.storage.deleteThrottleMetadata(), Ut } catch (Ut) { if (!function Zo(O) { if (!(O instanceof he.ZR && O.customData)) return !1; const U = Number(O.customData.httpStatus); return 429 === U || 500 === U || 503 === U || 504 === U }(Ut)) throw Ut; const ln = { throttleEndTimeMillis: Date.now() + (0, he.$s)(Ze), backoffCount: Ze + 1 }; return yield Ct.storage.setThrottleMetadata(ln), Ct.attemptFetch(U, ln) } })() } } class es { constructor(U, ce, Ze, Ct, Ut) { this.app = U, this._client = ce, this._storageCache = Ze, this._storage = Ct, this._logger = Ut, this._isInitializationComplete = !1, this.settings = { fetchTimeoutMillis: 6e4, minimumFetchIntervalMillis: 432e5 }, this.defaultConfig = {} } get fetchTimeMillis() { return this._storageCache.getLastSuccessfulFetchTimestampMillis() || -1 } get lastFetchStatus() { return this._storageCache.getLastFetchStatus() || "no-fetch-yet" } } function Tr(O, U) { const ce = O.target.error || void 0; return Tn.create(U, { originalErrorMessage: ce && ce?.message }) } const Br = "app_namespace_store"; class qo { constructor(U, ce, Ze, Ct = function Mi() { return new Promise((O, U) => { try { const ce = indexedDB.open("firebase_remote_config", 1); ce.onerror = Ze => { U(Tr(Ze, "storage-open")) }, ce.onsuccess = Ze => { O(Ze.target.result) }, ce.onupgradeneeded = Ze => { 0 === Ze.oldVersion && Ze.target.result.createObjectStore(Br, { keyPath: "compositeKey" }) } } catch (ce) { U(Tn.create("storage-open", { originalErrorMessage: ce?.message })) } }) }()) { this.appId = U, this.appName = ce, this.namespace = Ze, this.openDbPromise = Ct } getLastFetchStatus() { return this.get("last_fetch_status") } setLastFetchStatus(U) { return this.set("last_fetch_status", U) } getLastSuccessfulFetchTimestampMillis() { return this.get("last_successful_fetch_timestamp_millis") } setLastSuccessfulFetchTimestampMillis(U) { return this.set("last_successful_fetch_timestamp_millis", U) } getLastSuccessfulFetchResponse() { return this.get("last_successful_fetch_response") } setLastSuccessfulFetchResponse(U) { return this.set("last_successful_fetch_response", U) } getActiveConfig() { return this.get("active_config") } setActiveConfig(U) { return this.set("active_config", U) } getActiveConfigEtag() { return this.get("active_config_etag") } setActiveConfigEtag(U) { return this.set("active_config_etag", U) } getThrottleMetadata() { return this.get("throttle_metadata") } setThrottleMetadata(U) { return this.set("throttle_metadata", U) } deleteThrottleMetadata() { return this.delete("throttle_metadata") } get(U) { var ce = this; return (0, v.Z)(function* () { const Ze = yield ce.openDbPromise; return new Promise((Ct, Ut) => { const Kn = Ze.transaction([Br], "readonly").objectStore(Br), Vn = ce.createCompositeKey(U); try { const mi = Kn.get(Vn); mi.onerror = Ui => { Ut(Tr(Ui, "storage-get")) }, mi.onsuccess = Ui => { const li = Ui.target.result; Ct(li ? li.value : void 0) } } catch (mi) { Ut(Tn.create("storage-get", { originalErrorMessage: mi?.message })) } }) })() } set(U, ce) { var Ze = this; return (0, v.Z)(function* () { const Ct = yield Ze.openDbPromise; return new Promise((Ut, ln) => { const Vn = Ct.transaction([Br], "readwrite").objectStore(Br), mi = Ze.createCompositeKey(U); try { const Ui = Vn.put({ compositeKey: mi, value: ce }); Ui.onerror = li => { ln(Tr(li, "storage-set")) }, Ui.onsuccess = () => { Ut() } } catch (Ui) { ln(Tn.create("storage-set", { originalErrorMessage: Ui?.message })) } }) })() } delete(U) { var ce = this; return (0, v.Z)(function* () { const Ze = yield ce.openDbPromise; return new Promise((Ct, Ut) => { const Kn = Ze.transaction([Br], "readwrite").objectStore(Br), Vn = ce.createCompositeKey(U); try { const mi = Kn.delete(Vn); mi.onerror = Ui => { Ut(Tr(Ui, "storage-delete")) }, mi.onsuccess = () => { Ct() } } catch (mi) { Ut(Tn.create("storage-delete", { originalErrorMessage: mi?.message })) } }) })() } createCompositeKey(U) { return [this.appId, this.appName, this.namespace, U].join() } } class Ho { constructor(U) { this.storage = U } getLastFetchStatus() { return this.lastFetchStatus } getLastSuccessfulFetchTimestampMillis() { return this.lastSuccessfulFetchTimestampMillis } getActiveConfig() { return this.activeConfig } loadFromStorage() { var U = this; return (0, v.Z)(function* () { const ce = U.storage.getLastFetchStatus(), Ze = U.storage.getLastSuccessfulFetchTimestampMillis(), Ct = U.storage.getActiveConfig(), Ut = yield ce; Ut && (U.lastFetchStatus = Ut); const ln = yield Ze; ln && (U.lastSuccessfulFetchTimestampMillis = ln); const Kn = yield Ct; Kn && (U.activeConfig = Kn) })() } setLastFetchStatus(U) { return this.lastFetchStatus = U, this.storage.setLastFetchStatus(U) } setLastSuccessfulFetchTimestampMillis(U) { return this.lastSuccessfulFetchTimestampMillis = U, this.storage.setLastSuccessfulFetchTimestampMillis(U) } setActiveConfig(U) { return this.activeConfig = U, this.storage.setActiveConfig(U) } } function Qo() { return br.apply(this, arguments) } function br() { return (br = (0, v.Z)(function* () { if (!(0, he.hl)()) return !1; try { return yield (0, he.eu)() } catch { return !1 } })).apply(this, arguments) } !function Ro() { (0, Y._registerComponent)(new Se.wA("remote-config", function O(U, { instanceIdentifier: ce }) { const Ze = U.getProvider("app").getImmediate(), Ct = U.getProvider("installations-internal").getImmediate(); if (typeof window > "u") throw Tn.create("registration-window"); if (!(0, he.hl)()) throw Tn.create("indexed-db-unavailable"); const { projectId: Ut, apiKey: ln, appId: Kn } = Ze.options; if (!Ut) throw Tn.create("registration-project-id"); if (!ln) throw Tn.create("registration-api-key"); if (!Kn) throw Tn.create("registration-app-id"); const Vn = new qo(Kn, Ze.name, ce = ce || "firebase"), mi = new Ho(Vn), Ui = new ke.Yd(ye); Ui.logLevel = ke.in.ERROR; const li = new ko(Ct, Y.SDK_VERSION, ce, Ut, ln, Kn), gs = new ds(li, Vn), Bo = new vs(gs, Vn, mi, Ui), fl = new es(Ze, Bo, mi, Vn, Ui); return function ci(O) { const U = (0, he.m9)(O); U._initializePromise || (U._initializePromise = U._storageCache.loadFromStorage().then(() => { U._isInitializationComplete = !0 })) }(fl), fl }, "PUBLIC").setMultipleInstances(!0)), (0, Y.registerVersion)(ye, "0.4.4"), (0, Y.registerVersion)(ye, "0.4.4", "esm2017") }(); const Ki = "/firebase-messaging-sw.js", po = "/firebase-cloud-messaging-push-scope", Er = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4", Gr = "https://fcmregistrations.googleapis.com/v1", us = "google.c.a.c_id", dr = "google.c.a.c_l", Wr = "google.c.a.ts"; var ao = (() => ((ao = ao || {}).PUSH_RECEIVED = "push-received", ao.NOTIFICATION_CLICKED = "notification-clicked", ao))(); function Xr(O) { const U = new Uint8Array(O); return btoa(String.fromCharCode(...U)).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_") } function bs(O) { const ce = (O + "=".repeat((4 - O.length % 4) % 4)).replace(/\-/g, "+").replace(/_/g, "/"), Ze = atob(ce), Ct = new Uint8Array(Ze.length); for (let Ut = 0; Ut < Ze.length; ++Ut)Ct[Ut] = Ze.charCodeAt(Ut); return Ct } const ta = "fcm_token_details_db", Ci = 5, ys = "fcm_token_object_Store"; function Ws() { return Ws = (0, v.Z)(function* (O) { if ("databases" in indexedDB && !(yield indexedDB.databases()).map(Ut => Ut.name).includes(ta)) return null; let U = null; return (yield ee(ta, Ci, { upgrade: (Ze = (0, v.Z)(function* (Ct, Ut, ln, Kn) { var Vn; if (Ut < 2 || !Ct.objectStoreNames.contains(ys)) return; const mi = Kn.objectStore(ys), Ui = yield mi.index("fcmSenderId").get(O); if (yield mi.clear(), Ui) if (2 === Ut) { const li = Ui; if (!li.auth || !li.p256dh || !li.endpoint) return; U = { token: li.fcmToken, createTime: null !== (Vn = li.createTime) && void 0 !== Vn ? Vn : Date.now(), subscriptionOptions: { auth: li.auth, p256dh: li.p256dh, endpoint: li.endpoint, swScope: li.swScope, vapidKey: "string" == typeof li.vapidKey ? li.vapidKey : Xr(li.vapidKey) } } } else if (3 === Ut) { const li = Ui; U = { token: li.fcmToken, createTime: li.createTime, subscriptionOptions: { auth: Xr(li.auth), p256dh: Xr(li.p256dh), endpoint: li.endpoint, swScope: li.swScope, vapidKey: Xr(li.vapidKey) } } } else if (4 === Ut) { const li = Ui; U = { token: li.fcmToken, createTime: li.createTime, subscriptionOptions: { auth: Xr(li.auth), p256dh: Xr(li.p256dh), endpoint: li.endpoint, swScope: li.swScope, vapidKey: Xr(li.vapidKey) } } } }), function (Ut, ln, Kn, Vn) { return Ze.apply(this, arguments) }) })).close(), yield $e(ta), yield $e("fcm_vapid_details_db"), yield $e("undefined"), function na(O) { if (!O || !O.subscriptionOptions) return !1; const { subscriptionOptions: U } = O; return "number" == typeof O.createTime && O.createTime > 0 && "string" == typeof O.token && O.token.length > 0 && "string" == typeof U.auth && U.auth.length > 0 && "string" == typeof U.p256dh && U.p256dh.length > 0 && "string" == typeof U.endpoint && U.endpoint.length > 0 && "string" == typeof U.swScope && U.swScope.length > 0 && "string" == typeof U.vapidKey && U.vapidKey.length > 0 }(U) ? U : null; var Ze }), Ws.apply(this, arguments) } const ha = "firebase-messaging-database", fa = 1, ws = "firebase-messaging-store"; let is = null; function Ks() { return is || (is = ee(ha, fa, { upgrade: (O, U) => { 0 === U && O.createObjectStore(ws) } })), is } function jo(O) { return K.apply(this, arguments) } function K() { return K = (0, v.Z)(function* (O) { const U = Re(O), Ze = yield (yield Ks()).transaction(ws).objectStore(ws).get(U); if (Ze) return Ze; { const Ct = yield function Da(O) { return Ws.apply(this, arguments) }(O.appConfig.senderId); if (Ct) return yield V(O, Ct), Ct } }), K.apply(this, arguments) } function V(O, U) { return w.apply(this, arguments) } function w() { return (w = (0, v.Z)(function* (O, U) { const ce = Re(O), Ct = (yield Ks()).transaction(ws, "readwrite"); return yield Ct.objectStore(ws).put(U, ce), yield Ct.done, U })).apply(this, arguments) } function ne() { return (ne = (0, v.Z)(function* (O) { const U = Re(O), Ze = (yield Ks()).transaction(ws, "readwrite"); yield Ze.objectStore(ws).delete(U), yield Ze.done })).apply(this, arguments) } function Re({ appConfig: O }) { return O.appId } const kt = new he.LL("messaging", "Messaging", { "missing-app-config-values": 'Missing App configuration value: "{$valueName}"', "only-available-in-window": "This method is available in a Window context.", "only-available-in-sw": "This method is available in a service worker context.", "permission-default": "The notification permission was not granted and dismissed instead.", "permission-blocked": "The notification permission was not granted and blocked instead.", "unsupported-browser": "This browser doesn't support the API's required to use the Firebase SDK.", "indexed-db-unsupported": "This browser doesn't support indexedDb.open() (ex. Safari iFrame, Firefox Private Browsing, etc)", "failed-service-worker-registration": "We are unable to register the default service worker. {$browserErrorMessage}", "token-subscribe-failed": "A problem occurred while subscribing the user to FCM: {$errorInfo}", "token-subscribe-no-token": "FCM returned no token when subscribing the user to push.", "token-unsubscribe-failed": "A problem occurred while unsubscribing the user from FCM: {$errorInfo}", "token-update-failed": "A problem occurred while updating the user from FCM: {$errorInfo}", "token-update-no-token": "FCM returned no token when updating the user to push.", "use-sw-after-get-token": "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.", "invalid-sw-registration": "The input to useServiceWorker() must be a ServiceWorkerRegistration.", "invalid-bg-handler": "The input to setBackgroundMessageHandler() must be a function.", "invalid-vapid-key": "The public VAPID key must be a string.", "use-vapid-key-after-get-token": "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used." }); function mn(O, U) { return Gn.apply(this, arguments) } function Gn() { return (Gn = (0, v.Z)(function* (O, U) { const ce = yield Bi(O), Ze = ar(U), Ct = { method: "POST", headers: ce, body: JSON.stringify(Ze) }; let Ut; try { Ut = yield (yield fetch(ji(O.appConfig), Ct)).json() } catch (ln) { throw kt.create("token-subscribe-failed", { errorInfo: ln?.toString() }) } if (Ut.error) throw kt.create("token-subscribe-failed", { errorInfo: Ut.error.message }); if (!Ut.token) throw kt.create("token-subscribe-no-token"); return Ut.token })).apply(this, arguments) } function gi() { return (gi = (0, v.Z)(function* (O, U) { const ce = yield Bi(O), Ze = ar(U.subscriptionOptions), Ct = { method: "PATCH", headers: ce, body: JSON.stringify(Ze) }; let Ut; try { Ut = yield (yield fetch(`${ji(O.appConfig)}/${U.token}`, Ct)).json() } catch (ln) { throw kt.create("token-update-failed", { errorInfo: ln?.toString() }) } if (Ut.error) throw kt.create("token-update-failed", { errorInfo: Ut.error.message }); if (!Ut.token) throw kt.create("token-update-no-token"); return Ut.token })).apply(this, arguments) } function Ii(O, U) { return Zi.apply(this, arguments) } function Zi() { return (Zi = (0, v.Z)(function* (O, U) { const Ze = { method: "DELETE", headers: yield Bi(O) }; try { const Ut = yield (yield fetch(`${ji(O.appConfig)}/${U}`, Ze)).json(); if (Ut.error) throw kt.create("token-unsubscribe-failed", { errorInfo: Ut.error.message }) } catch (Ct) { throw kt.create("token-unsubscribe-failed", { errorInfo: Ct?.toString() }) } })).apply(this, arguments) } function ji({ projectId: O }) { return `${Gr}/projects/${O}/registrations` } function Bi(O) { return ir.apply(this, arguments) } function ir() { return (ir = (0, v.Z)(function* ({ appConfig: O, installations: U }) { const ce = yield U.getToken(); return new Headers({ "Content-Type": "application/json", Accept: "application/json", "x-goog-api-key": O.apiKey, "x-goog-firebase-installations-auth": `FIS ${ce}` }) })).apply(this, arguments) } function ar({ p256dh: O, auth: U, endpoint: ce, vapidKey: Ze }) { const Ct = { web: { endpoint: ce, auth: U, p256dh: O } }; return Ze !== Er && (Ct.web.applicationPubKey = Ze), Ct } const gr = 6048e5; function Kr() { return Kr = (0, v.Z)(function* (O) { const U = yield function Jr(O, U) { return os.apply(this, arguments) }(O.swRegistration, O.vapidKey), ce = { vapidKey: O.vapidKey, swScope: O.swRegistration.scope, endpoint: U.endpoint, auth: Xr(U.getKey("auth")), p256dh: Xr(U.getKey("p256dh")) }, Ze = yield jo(O.firebaseDependencies); if (Ze) { if (function Ka(O, U) { return U.vapidKey === O.vapidKey && U.endpoint === O.endpoint && U.auth === O.auth && U.p256dh === O.p256dh }(Ze.subscriptionOptions, ce)) return Date.now() >= Ze.createTime + gr ? function Do(O, U) { return $o.apply(this, arguments) }(O, { token: Ze.token, createTime: Date.now(), subscriptionOptions: ce }) : Ze.token; try { yield Ii(O.firebaseDependencies, Ze.token) } catch (Ct) { console.warn(Ct) } return hs(O.firebaseDependencies, ce) } return hs(O.firebaseDependencies, ce) }), Kr.apply(this, arguments) } function Sr() { return Sr = (0, v.Z)(function* (O) { const U = yield jo(O.firebaseDependencies); U && (yield Ii(O.firebaseDependencies, U.token), yield function D(O) { return ne.apply(this, arguments) }(O.firebaseDependencies)); const ce = yield O.swRegistration.pushManager.getSubscription(); return !ce || ce.unsubscribe() }), Sr.apply(this, arguments) } function $o() { return $o = (0, v.Z)(function* (O, U) { try { const ce = yield function jn(O, U) { return gi.apply(this, arguments) }(O.firebaseDependencies, U), Ze = Object.assign(Object.assign({}, U), { token: ce, createTime: Date.now() }); return yield V(O.firebaseDependencies, Ze), ce } catch (ce) { throw yield function Mr(O) { return Sr.apply(this, arguments) }(O), ce } }), $o.apply(this, arguments) } function hs(O, U) { return rs.apply(this, arguments) } function rs() { return (rs = (0, v.Z)(function* (O, U) { const Ze = { token: yield mn(O, U), createTime: Date.now(), subscriptionOptions: U }; return yield V(O, Ze), Ze.token })).apply(this, arguments) } function os() { return (os = (0, v.Z)(function* (O, U) { return (yield O.pushManager.getSubscription()) || O.pushManager.subscribe({ userVisibleOnly: !0, applicationServerKey: bs(U) }) })).apply(this, arguments) } function ks(O) { const U = { from: O.from, collapseKey: O.collapse_key, messageId: O.fcmMessageId }; return function sl(O, U) { if (!U.notification) return; O.notification = {}; const ce = U.notification.title; ce && (O.notification.title = ce); const Ze = U.notification.body; Ze && (O.notification.body = Ze); const Ct = U.notification.image; Ct && (O.notification.image = Ct); const Ut = U.notification.icon; Ut && (O.notification.icon = Ut) }(U, O), function fs(O, U) { U.data && (O.data = U.data) }(U, O), function Za(O, U) { var ce, Ze, Ct, Ut, ln; if (!(U.fcmOptions || null !== (ce = U.notification) && void 0 !== ce && ce.click_action)) return; O.fcmOptions = {}; const Kn = null !== (Ct = null === (Ze = U.fcmOptions) || void 0 === Ze ? void 0 : Ze.link) && void 0 !== Ct ? Ct : null === (Ut = U.notification) || void 0 === Ut ? void 0 : Ut.click_action; Kn && (O.fcmOptions.link = Kn); const Vn = null === (ln = U.fcmOptions) || void 0 === ln ? void 0 : ln.analytics_label; Vn && (O.fcmOptions.analyticsLabel = Vn) }(U, O), U } function ma(O, U) { const ce = []; for (let Ze = 0; Ze < O.length; Ze++)ce.push(O.charAt(Ze)), Ze < U.length && ce.push(U.charAt(Ze)); return ce.join("") } function To(O) { return kt.create("missing-app-config-values", { valueName: O }) } ma("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o"), ma("AzSCbw63g1R0nCw85jG8", "Iaya3yLKwmgvh7cF0q4"); class pa { constructor(U, ce, Ze) { this.deliveryMetricsExportedToBigQueryEnabled = !1, this.onBackgroundMessageHandler = null, this.onMessageHandler = null, this.logEvents = [], this.isLogServiceStarted = !1; const Ct = function Ya(O) { if (!O || !O.options) throw To("App Configuration Object"); if (!O.name) throw To("App Name"); const U = ["projectId", "apiKey", "appId", "messagingSenderId"], { options: ce } = O; for (const Ze of U) if (!ce[Ze]) throw To(Ze); return { appName: O.name, projectId: ce.projectId, apiKey: ce.apiKey, appId: ce.appId, senderId: ce.messagingSenderId } }(U); this.firebaseDependencies = { app: U, appConfig: Ct, installations: ce, analyticsProvider: Ze } } _delete() { return Promise.resolve() } } function Bs() { return (Bs = (0, v.Z)(function* (O) { try { O.swRegistration = yield navigator.serviceWorker.register(Ki, { scope: po }), O.swRegistration.update().catch(() => { }) } catch (U) { throw kt.create("failed-service-worker-registration", { browserErrorMessage: U?.message }) } })).apply(this, arguments) } function Ma() { return (Ma = (0, v.Z)(function* (O, U) { if (!U && !O.swRegistration && (yield function ia(O) { return Bs.apply(this, arguments) }(O)), U || !O.swRegistration) { if (!(U instanceof ServiceWorkerRegistration)) throw kt.create("invalid-sw-registration"); O.swRegistration = U } })).apply(this, arguments) } function ts() { return (ts = (0, v.Z)(function* (O, U) { U ? O.vapidKey = U : O.vapidKey || (O.vapidKey = Er) })).apply(this, arguments) } function Rs() { return Rs = (0, v.Z)(function* (O, U) { if (!navigator) throw kt.create("only-available-in-window"); if ("default" === Notification.permission && (yield Notification.requestPermission()), "granted" !== Notification.permission) throw kt.create("permission-blocked"); return yield function ms(O, U) { return ts.apply(this, arguments) }(O, U?.vapidKey), yield function Ta(O, U) { return Ma.apply(this, arguments) }(O, U?.serviceWorkerRegistration), function Yi(O) { return Kr.apply(this, arguments) }(O) }), Rs.apply(this, arguments) } function Os() { return (Os = (0, v.Z)(function* (O, U, ce) { const Ze = function xs(O) { switch (O) { case ao.NOTIFICATION_CLICKED: return "notification_open"; case ao.PUSH_RECEIVED: return "notification_foreground"; default: throw new Error } }(U); (yield O.firebaseDependencies.analyticsProvider.get()).logEvent(Ze, { message_id: ce[us], message_name: ce[dr], message_time: ce[Wr], message_device_time: Math.floor(Date.now() / 1e3) }) })).apply(this, arguments) } function Oo() { return Oo = (0, v.Z)(function* (O, U) { const ce = U.data; if (!ce.isFirebaseMessaging) return; O.onMessageHandler && ce.messageType === ao.PUSH_RECEIVED && ("function" == typeof O.onMessageHandler ? O.onMessageHandler(ks(ce)) : O.onMessageHandler.next(ks(ce))); const Ze = ce.data; (function _r(O) { return "object" == typeof O && !!O && us in O })(Ze) && "1" === Ze["google.c.a.e"] && (yield function go(O, U, ce) { return Os.apply(this, arguments) }(O, ce.messageType, Ze)) }), Oo.apply(this, arguments) } const P = "@firebase/messaging", X = "0.12.4", B = O => { const U = new pa(O.getProvider("app").getImmediate(), O.getProvider("installations-internal").getImmediate(), O.getProvider("analytics-internal")); return navigator.serviceWorker.addEventListener("message", ce => function yr(O, U) { return Oo.apply(this, arguments) }(U, ce)), U }, be = O => { const U = O.getProvider("messaging").getImmediate(); return { getToken: Ze => function lo(O, U) { return Rs.apply(this, arguments) }(U, Ze) } }; function $t() { return en.apply(this, arguments) } function en() { return (en = (0, v.Z)(function* () { try { yield (0, he.eu)() } catch { return !1 } return typeof window < "u" && (0, he.hl)() && (0, he.zI)() && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey") })).apply(this, arguments) } !function Je() { (0, Y._registerComponent)(new Se.wA("messaging", B, "PUBLIC")), (0, Y._registerComponent)(new Se.wA("messaging-internal", be, "PRIVATE")), (0, Y.registerVersion)(P, X), (0, Y.registerVersion)(P, X, "esm2017") }(); const lr = "analytics", ui = "firebase_id", pn = "origin", er = 6e4, wo = "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig", Ur = "https://www.googletagmanager.com/gtag/js", Cn = new ke.Yd("@firebase/analytics"), co = new he.LL("analytics", "Analytics", { "already-exists": "A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.", "already-initialized": "initializeAnalytics() cannot be called again with different options than those it was initially called with. It can be called again with the same options to return the existing instance, or getAnalytics() can be used to get a reference to the already-intialized instance.", "already-initialized-settings": "Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.", "interop-component-reg-failed": "Firebase Analytics Interop Component failed to instantiate: {$reason}", "invalid-analytics-context": "Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}", "indexeddb-unavailable": "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}", "fetch-throttle": "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.", "config-fetch-failed": "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}", "no-api-key": 'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.', "no-app-id": 'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.', "no-client-id": 'The "client_id" field is empty.', "invalid-gtag-resource": "Trusted Types detected an invalid gtag resource: {$gtagURL}." }); function Un(O) { if (!O.startsWith(Ur)) { const U = co.create("invalid-gtag-resource", { gtagURL: O }); return Cn.warn(U.message), "" } return O } function Yt(O) { return Promise.all(O.map(U => U.catch(ce => ce))) } function $i() { return ($i = (0, v.Z)(function* (O, U, ce, Ze, Ct, Ut) { const ln = Ze[Ct]; try { if (ln) yield U[ln]; else { const Vn = (yield Yt(ce)).find(mi => mi.measurementId === Ct); Vn && (yield U[Vn.appId]) } } catch (Kn) { Cn.error(Kn) } O("config", Ct, Ut) })).apply(this, arguments) } function al() { return (al = (0, v.Z)(function* (O, U, ce, Ze, Ct) { try { let Ut = []; if (Ct && Ct.send_to) { let ln = Ct.send_to; Array.isArray(ln) || (ln = [ln]); const Kn = yield Yt(ce); for (const Vn of ln) { const mi = Kn.find(li => li.measurementId === Vn), Ui = mi && U[mi.appId]; if (!Ui) { Ut = []; break } Ut.push(Ui) } } 0 === Ut.length && (Ut = Object.values(U)), yield Promise.all(Ut), O("event", Ze, Ct || {}) } catch (Ut) { Cn.error(Ut) } })).apply(this, arguments) } const ps = 30, Ei = new class Vr { constructor(U = {}, ce = 1e3) { this.throttleMetadata = U, this.intervalMillis = ce } getThrottleMetadata(U) { return this.throttleMetadata[U] } setThrottleMetadata(U, ce) { this.throttleMetadata[U] = ce } deleteThrottleMetadata(U) { delete this.throttleMetadata[U] } }; function _a(O) { return new Headers({ Accept: "application/json", "x-goog-api-key": O }) } function Ri() { return (Ri = (0, v.Z)(function* (O) { var U; const { appId: ce, apiKey: Ze } = O, Ct = { method: "GET", headers: _a(Ze) }, Ut = wo.replace("{app-id}", ce), ln = yield fetch(Ut, Ct); if (200 !== ln.status && 304 !== ln.status) { let Kn = ""; try { const Vn = yield ln.json(); null !== (U = Vn.error) && void 0 !== U && U.message && (Kn = Vn.error.message) } catch { } throw co.create("config-fetch-failed", { httpStatus: ln.status, responseMessage: Kn }) } return ln.json() })).apply(this, arguments) } function ra() { return (ra = (0, v.Z)(function* (O, U = Ei, ce) { const { appId: Ze, apiKey: Ct, measurementId: Ut } = O.options; if (!Ze) throw co.create("no-app-id"); if (!Ct) { if (Ut) return { measurementId: Ut, appId: Ze }; throw co.create("no-api-key") } const ln = U.getThrottleMetadata(Ze) || { backoffCount: 0, throttleEndTimeMillis: Date.now() }, Kn = new Vs; return setTimeout((0, v.Z)(function* () { Kn.abort() }), void 0 !== ce ? ce : er), Pi({ appId: Ze, apiKey: Ct, measurementId: Ut }, ln, Kn, U) })).apply(this, arguments) } function Pi(O, U, ce) { return Es.apply(this, arguments) } function Es() { return Es = (0, v.Z)(function* (O, { throttleEndTimeMillis: U, backoffCount: ce }, Ze, Ct = Ei) { var Ut; const { appId: ln, measurementId: Kn } = O; try { yield function Hr(O, U) { return new Promise((ce, Ze) => { const Ct = Math.max(U - Date.now(), 0), Ut = setTimeout(ce, Ct); O.addEventListener(() => { clearTimeout(Ut), Ze(co.create("fetch-throttle", { throttleEndTimeMillis: U })) }) }) }(Ze, U) } catch (Vn) { if (Kn) return Cn.warn(`Timed out fetching this Firebase app's measurement ID from the server. Falling back to the measurement ID ${Kn} provided in the "measurementId" field in the local Firebase config. [${Vn?.message}]`), { appId: ln, measurementId: Kn }; throw Vn } try { const Vn = yield function ll(O) { return Ri.apply(this, arguments) }(O); return Ct.deleteThrottleMetadata(ln), Vn } catch (Vn) { const mi = Vn; if (!function Bn(O) { if (!(O instanceof he.ZR && O.customData)) return !1; const U = Number(O.customData.httpStatus); return 429 === U || 500 === U || 503 === U || 504 === U }(mi)) { if (Ct.deleteThrottleMetadata(ln), Kn) return Cn.warn(`Failed to fetch this Firebase app's measurement ID from the server. Falling back to the measurement ID ${Kn} provided in the "measurementId" field in the local Firebase config. [${mi?.message}]`), { appId: ln, measurementId: Kn }; throw Vn } const Ui = 503 === Number(null === (Ut = mi?.customData) || void 0 === Ut ? void 0 : Ut.httpStatus) ? (0, he.$s)(ce, Ct.intervalMillis, ps) : (0, he.$s)(ce, Ct.intervalMillis), li = { throttleEndTimeMillis: Date.now() + Ui, backoffCount: ce + 1 }; return Ct.setThrottleMetadata(ln, li), Cn.debug(`Calling attemptFetch again in ${Ui} millis`), Pi(O, li, Ze, Ct) } }), Es.apply(this, arguments) } class Vs { constructor() { this.listeners = [] } addEventListener(U) { this.listeners.push(U) } abort() { this.listeners.forEach(U => U()) } } let Zs, S; function Sa() { return (Sa = (0, v.Z)(function* (O, U, ce, Ze, Ct) { if (Ct && Ct.global) O("event", ce, Ze); else { const Ut = yield U; O("event", ce, Object.assign(Object.assign({}, Ze), { send_to: Ut })) } })).apply(this, arguments) } function h() { return (h = (0, v.Z)(function* () { if (!(0, he.hl)()) return Cn.warn(co.create("indexeddb-unavailable", { errorInfo: "IndexedDB is not available in this environment." }).message), !1; try { yield (0, he.eu)() } catch (O) { return Cn.warn(co.create("indexeddb-unavailable", { errorInfo: O?.toString() }).message), !1 } return !0 })).apply(this, arguments) } function M() { return M = (0, v.Z)(function* (O, U, ce, Ze, Ct, Ut, ln) { var Kn; const Vn = function Jn(O) { return ra.apply(this, arguments) }(O); Vn.then(Bo => { ce[Bo.measurementId] = Bo.appId, O.options.measurementId && Bo.measurementId !== O.options.measurementId && Cn.warn(`The measurement ID in the local Firebase config (${O.options.measurementId}) does not match the measurement ID fetched from the server (${Bo.measurementId}). To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.`) }).catch(Bo => Cn.error(Bo)), U.push(Vn); const mi = function u() { return h.apply(this, arguments) }().then(Bo => { if (Bo) return Ze.getId() }), [Ui, li] = yield Promise.all([Vn, mi]); (function ga(O) { const U = window.document.getElementsByTagName("script"); for (const ce of Object.values(U)) if (ce.src && ce.src.includes(Ur) && ce.src.includes(O)) return ce; return null })(Ut) || function eo(O, U) { const ce = function _n(O, U) { let ce; return window.trustedTypes && (ce = window.trustedTypes.createPolicy(O, U)), ce }("firebase-js-sdk-policy", { createScriptURL: Un }), Ze = document.createElement("script"), Ct = `${Ur}?l=${O}&id=${U}`; Ze.src = ce ? ce?.createScriptURL(Ct) : Ct, Ze.async = !0, document.head.appendChild(Ze) }(Ut, Ui.measurementId), S && (Ct("consent", "default", S), function I(O) { S = O }(void 0)), Ct("js", new Date); const gs = null !== (Kn = ln?.config) && void 0 !== Kn ? Kn : {}; return gs[pn] = "firebase", gs.update = !0, null != li && (gs[ui] = li), Ct("config", Ui.measurementId, gs), Zs && (Ct("set", Zs), function m(O) { Zs = O }(void 0)), Ui.measurementId }), M.apply(this, arguments) } class $ { constructor(U) { this.app = U } _delete() { return delete Ee[this.app.options.appId], Promise.resolve() } } let Ee = {}, je = []; const ft = {}; let An, ri, zt = "dataLayer", hi = !1; function zr(O, U, ce) { !function ei() { const O = []; if ((0, he.ru)() && O.push("This is a browser extension environment."), (0, he.zI)() || O.push("Cookies are not available."), O.length > 0) { const U = O.map((Ze, Ct) => `(${Ct + 1}) ${Ze}`).join(" "), ce = co.create("invalid-analytics-context", { errorInfo: U }); Cn.warn(ce.message) } }(); const Ze = O.options.appId; if (!Ze) throw co.create("no-app-id"); if (!O.options.apiKey) { if (!O.options.measurementId) throw co.create("no-api-key"); Cn.warn(`The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest measurement ID for this Firebase app. Falling back to the measurement ID ${O.options.measurementId} provided in the "measurementId" field in the local Firebase config.`) } if (null != Ee[Ze]) throw co.create("already-exists", { id: Ze }); if (!hi) { !function Us(O) { let U = []; Array.isArray(window[O]) ? U = window[O] : window[O] = U }(zt); const { wrappedGtag: Ut, gtagCore: ln } = function qa(O, U, ce, Ze, Ct) { let Ut = function (...ln) { window[Ze].push(arguments) }; return window[Ct] && "function" == typeof window[Ct] && (Ut = window[Ct]), window[Ct] = function xo(O, U, ce, Ze) { function Ut() { return Ut = (0, v.Z)(function* (ln, ...Kn) { try { if ("event" === ln) { const [Vn, mi] = Kn; yield function Cl(O, U, ce, Ze, Ct) { return al.apply(this, arguments) }(O, U, ce, Vn, mi) } else if ("config" === ln) { const [Vn, mi] = Kn; yield function vn(O, U, ce, Ze, Ct, Ut) { return $i.apply(this, arguments) }(O, U, ce, Ze, Vn, mi) } else if ("consent" === ln) { const [Vn] = Kn; O("consent", "update", Vn) } else if ("get" === ln) { const [Vn, mi, Ui] = Kn; O("get", Vn, mi, Ui) } else if ("set" === ln) { const [Vn] = Kn; O("set", Vn) } else O(ln, ...Kn) } catch (Vn) { Cn.error(Vn) } }), Ut.apply(this, arguments) } return function Ct(ln) { return Ut.apply(this, arguments) } }(Ut, O, U, ce), { gtagCore: Ut, wrappedGtag: window[Ct] } }(Ee, je, ft, zt, "gtag"); ri = Ut, An = ln, hi = !0 } return Ee[Ze] = function x(O, U, ce, Ze, Ct, Ut, ln) { return M.apply(this, arguments) }(O, je, ft, U, An, zt, ce), new $(O) } function Mo() { return Fr.apply(this, arguments) } function Fr() { return (Fr = (0, v.Z)(function* () { if ((0, he.ru)() || !(0, he.zI)() || !(0, he.hl)()) return !1; try { return yield (0, he.eu)() } catch { return !1 } })).apply(this, arguments) } const el = "@firebase/analytics"; !function oi() { (0, Y._registerComponent)(new Se.wA(lr, (U, { options: ce }) => zr(U.getProvider("app").getImmediate(), U.getProvider("installations-internal").getImmediate(), ce), "PUBLIC")), (0, Y._registerComponent)(new Se.wA("analytics-internal", function O(U) { try { const ce = U.getProvider(lr).getImmediate(); return { logEvent: (Ze, Ct, Ut) => function aa(O, U, ce, Ze) { O = (0, he.m9)(O), function Ys(O, U, ce, Ze, Ct) { return Sa.apply(this, arguments) }(ri, Ee[O.app.options.appId], U, ce, Ze).catch(Ct => Cn.error(Ct)) }(ce, Ze, Ct, Ut) } } catch (ce) { throw co.create("interop-component-reg-failed", { reason: ce }) } }, "PRIVATE")), (0, Y.registerVersion)(el, "0.10.0"), (0, Y.registerVersion)(el, "0.10.0", "esm2017") }(); var pi = C(1954), vr = C(2631); const Cs = new class Go extends vr.v { }(class bi extends pi.o { constructor(U, ce) { super(U, ce), this.scheduler = U, this.work = ce } schedule(U, ce = 0) { return ce > 0 ? super.schedule(U, ce) : (this.delay = ce, this.state = U, this.scheduler.flush(this), this) } execute(U, ce) { return ce > 0 || this.closed ? super.execute(U, ce) : this._execute(U, ce) } requestAsyncId(U, ce, Ze = 0) { return null != Ze && Ze > 0 || null == Ze && this.delay > 0 ? super.requestAsyncId(U, ce, Ze) : (U.flush(this), 0) } }); var No = C(6321), to = C(5592), Ua = C(9397), wa = C(3093), or = C(5137); const Is = new a.GfV("7.6.1"), _o = "__angularfire_symbol__analyticsIsSupportedValue", Va = "__angularfire_symbol__analyticsIsSupported", ur = "__angularfire_symbol__remoteConfigIsSupportedValue", Ha = "__angularfire_symbol__remoteConfigIsSupported", Fo = "__angularfire_symbol__messagingIsSupportedValue", Zr = "__angularfire_symbol__messagingIsSupported"; function ud(O, U, ce) { if (U) { if (1 === U.length) return U[0]; const Ut = U.filter(ln => ln.app === ce); if (1 === Ut.length) return Ut[0] } return ce.container.getProvider(O).getImmediate({ optional: !0 }) } globalThis[Va] || (globalThis[Va] = Mo().then(O => globalThis[_o] = O).catch(() => globalThis[_o] = !1)), globalThis[Zr] || (globalThis[Zr] = $t().then(O => globalThis[Fo] = O).catch(() => globalThis[Fo] = !1)), globalThis[Ha] || (globalThis[Ha] = Qo().then(O => globalThis[ur] = O).catch(() => globalThis[ur] = !1)); const Lo = (O, U) => { const ce = U ? [U] : (0, y.C6)(), Ze = []; return ce.forEach(Ct => { Ct.container.getProvider(O).instances.forEach(ln => { Ze.includes(ln) || Ze.push(ln) }) }), Ze }; function xa() { } class ja { constructor(U, ce = Cs) { this.zone = U, this.delegate = ce } now() { return this.delegate.now() } schedule(U, ce, Ze) { const Ct = this.zone; return this.delegate.schedule(function (ln) { Ct.runGuarded(() => { U.apply(this, [ln]) }) }, ce, Ze) } } class vo { constructor(U) { this.zone = U, this.task = null } call(U, ce) { const Ze = this.unscheduleTask.bind(this); return this.task = this.zone.run(() => Zone.current.scheduleMacroTask("firebaseZoneBlock", xa, {}, xa, xa)), ce.pipe((0, Ua.b)({ next: Ze, complete: Ze, error: Ze })).subscribe(U).add(Ze) } unscheduleTask() { setTimeout(() => { null != this.task && "scheduled" === this.task.state && (this.task.invoke(), this.task = null) }, 10) } } let Ea = (() => { class O { constructor(ce) { this.ngZone = ce, this.outsideAngular = ce.runOutsideAngular(() => new ja(Zone.current)), this.insideAngular = ce.run(() => new ja(Zone.current, No.z)), globalThis.\u0275AngularFireScheduler || (globalThis.\u0275AngularFireScheduler = this) } } return O.\u0275fac = function (ce) { return new (ce || O)(a.LFG(a.R0b)) }, O.\u0275prov = a.Yz7({ token: O, factory: O.\u0275fac, providedIn: "root" }), O })(); function Oa() { const O = globalThis.\u0275AngularFireScheduler; if (!O) throw new Error("Either AngularFireModule has not been provided in your AppModule (this can be done manually or implictly using\nprovideFirebaseApp) or you're calling an AngularFire method outside of an NgModule (which is not supported)."); return O } function qs(O) { return Oa().ngZone.run(() => O()) } function tl(O) { return O.pipe((0, wa.Q)(Oa().outsideAngular)) } function Ds(O) { return Oa(), function Il(O) { return function (ce) { return (ce = ce.lift(new vo(O.ngZone))).pipe((0, or.R)(O.outsideAngular), (0, wa.Q)(O.insideAngular)) } }(Oa())(O) } const la = (O, U) => function () { const Ze = arguments; return U && setTimeout(() => { "scheduled" === U.state && U.invoke() }, 10), qs(() => O.apply(void 0, Ze)) }, Ns = (O, U) => function () { let ce; const Ze = arguments; for (let Ut = 0; Ut < arguments.length; Ut++)"function" == typeof Ze[Ut] && (U && (ce || (ce = qs(() => Zone.current.scheduleMacroTask("firebaseZoneBlock", xa, {}, xa, xa)))), Ze[Ut] = la(Ze[Ut], ce)); const Ct = function hl(O) { return Oa().ngZone.runOutsideAngular(() => O()) }(() => O.apply(this, Ze)); if (!U) { if (Ct instanceof to.y) { const Ut = Oa(); return Ct.pipe((0, or.R)(Ut.outsideAngular), (0, wa.Q)(Ut.insideAngular)) } return qs(() => Ct) } return Ct instanceof to.y ? Ct.pipe(Ds) : Ct instanceof Promise ? qs(() => new Promise((Ut, ln) => Ct.then(Kn => qs(() => Ut(Kn)), Kn => qs(() => ln(Kn))))) : "function" == typeof Ct && ce ? function () { return setTimeout(() => { ce && "scheduled" === ce.state && ce.invoke() }, 10), Ct.apply(this, arguments) } : qs(() => Ct) } }, 6878: (nn, Qe, C) => { C.d(Qe, { $: () => K, A: () => _e, D: () => Oe, I: () => sr, J: () => wn, L: () => Xn, N: () => st, P: () => dd, Q: () => qo, R: () => fi, U: () => zo, V: () => Qo, W: () => br, X: () => yo, Y: () => Gr, Z: () => us, _: () => ao, a: () => xo, a0: () => w, a1: () => ne, a2: () => mn, a3: () => ji, a4: () => ir, a5: () => gr, a6: () => Kr, a7: () => Sr, a8: () => $o, a9: () => rs, aA: () => ee, aB: () => O, aC: () => me, aD: () => Lt, aE: () => zs, aF: () => Nl, aG: () => Zr, aH: () => Vi, aL: () => ps, aO: () => po, aa: () => Jr, ab: () => Ka, ac: () => ks, ad: () => _r, ae: () => Ya, af: () => pa, ai: () => Ma, aj: () => ts, ak: () => lo, an: () => ys, ao: () => be, aq: () => ui, ar: () => Un, as: () => rt, at: () => F, au: () => pt, av: () => ie, aw: () => ec, ax: () => Ct, ay: () => J, az: () => Le, b: () => Cl, c: () => Go, d: () => to, e: () => Hs, f: () => Xd, g: () => Ea, h: () => xa, i: () => ul, j: () => qs, k: () => nc, l: () => Mo, m: () => ru, o: () => au, p: () => re, r: () => Ja, s: () => Po, u: () => Ra }); var a = C(5861), y = C(9058), v = C(6122), Y = C(7582), he = C(7879), Se = C(4537); const re = { FACEBOOK: "facebook.com", GITHUB: "github.com", GOOGLE: "google.com", PASSWORD: "password", PHONE: "phone", TWITTER: "twitter.com" }, _e = { EMAIL_SIGNIN: "EMAIL_SIGNIN", PASSWORD_RESET: "PASSWORD_RESET", RECOVER_EMAIL: "RECOVER_EMAIL", REVERT_SECOND_FACTOR_ADDITION: "REVERT_SECOND_FACTOR_ADDITION", VERIFY_AND_CHANGE_EMAIL: "VERIFY_AND_CHANGE_EMAIL", VERIFY_EMAIL: "VERIFY_EMAIL" }; const Oe = function xe() { return { "admin-restricted-operation": "This operation is restricted to administrators only.", "argument-error": "", "app-not-authorized": "This app, identified by the domain where it's hosted, is not authorized to use Firebase Authentication with the provided API key. Review your key configuration in the Google API console.", "app-not-installed": "The requested mobile application corresponding to the identifier (Android package name or iOS bundle ID) provided is not installed on this device.", "captcha-check-failed": "The reCAPTCHA response token provided is either invalid, expired, already used or the domain associated with it does not match the list of whitelisted domains.", "code-expired": "The SMS code has expired. Please re-send the verification code to try again.", "cordova-not-ready": "Cordova framework is not ready.", "cors-unsupported": "This browser is not supported.", "credential-already-in-use": "This credential is already associated with a different user account.", "custom-token-mismatch": "The custom token corresponds to a different audience.", "requires-recent-login": "This operation is sensitive and requires recent authentication. Log in again before retrying this request.", "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK.", "dynamic-link-not-activated": "Please activate Dynamic Links in the Firebase Console and agree to the terms and conditions.", "email-change-needs-verification": "Multi-factor users must always have a verified email.", "email-already-in-use": "The email address is already in use by another account.", "emulator-config-failed": 'Auth instance has already been used to make a network call. Auth can no longer be configured to use the emulator. Try calling "connectAuthEmulator()" sooner.', "expired-action-code": "The action code has expired.", "cancelled-popup-request": "This operation has been cancelled due to another conflicting popup being opened.", "internal-error": "An internal AuthError has occurred.", "invalid-app-credential": "The phone verification request contains an invalid application verifier. The reCAPTCHA token response is either invalid or expired.", "invalid-app-id": "The mobile app identifier is not registed for the current project.", "invalid-user-token": "This user's credential isn't valid for this project. This can happen if the user's token has been tampered with, or if the user isn't for the project associated with this API key.", "invalid-auth-event": "An internal AuthError has occurred.", "invalid-verification-code": "The SMS verification code used to create the phone auth credential is invalid. Please resend the verification code sms and be sure to use the verification code provided by the user.", "invalid-continue-uri": "The continue URL provided in the request is invalid.", "invalid-cordova-configuration": "The following Cordova plugins must be installed to enable OAuth sign-in: cordova-plugin-buildinfo, cordova-universal-links-plugin, cordova-plugin-browsertab, cordova-plugin-inappbrowser and cordova-plugin-customurlscheme.", "invalid-custom-token": "The custom token format is incorrect. Please check the documentation.", "invalid-dynamic-link-domain": "The provided dynamic link domain is not configured or authorized for the current project.", "invalid-email": "The email address is badly formatted.", "invalid-emulator-scheme": "Emulator URL must start with a valid scheme (http:// or https://).", "invalid-api-key": "Your API key is invalid, please check you have copied it correctly.", "invalid-cert-hash": "The SHA-1 certificate hash provided is invalid.", "invalid-credential": "The supplied auth credential is malformed or has expired.", "invalid-message-payload": "The email template corresponding to this action contains invalid characters in its message. Please fix by going to the Auth email templates section in the Firebase Console.", "invalid-multi-factor-session": "The request does not contain a valid proof of first factor successful sign-in.", "invalid-oauth-provider": "EmailAuthProvider is not supported for this operation. This operation only supports OAuth providers.", "invalid-oauth-client-id": "The OAuth client ID provided is either invalid or does not match the specified API key.", "unauthorized-domain": "This domain is not authorized for OAuth operations for your Firebase project. Edit the list of authorized domains from the Firebase console.", "invalid-action-code": "The action code is invalid. This can happen if the code is malformed, expired, or has already been used.", "wrong-password": "The password is invalid or the user does not have a password.", "invalid-persistence-type": "The specified persistence type is invalid. It can only be local, session or none.", "invalid-phone-number": "The format of the phone number provided is incorrect. Please enter the phone number in a format that can be parsed into E.164 format. E.164 phone numbers are written in the format [+][country code][subscriber number including area code].", "invalid-provider-id": "The specified provider ID is invalid.", "invalid-recipient-email": "The email corresponding to this action failed to send as the provided recipient email address is invalid.", "invalid-sender": "The email template corresponding to this action contains an invalid sender email or name. Please fix by going to the Auth email templates section in the Firebase Console.", "invalid-verification-id": "The verification ID used to create the phone auth credential is invalid.", "invalid-tenant-id": "The Auth instance's tenant ID is invalid.", "login-blocked": "Login blocked by user-provided method: {$originalMessage}", "missing-android-pkg-name": "An Android Package Name must be provided if the Android App is required to be installed.", "auth-domain-config-required": "Be sure to include authDomain when calling firebase.initializeApp(), by following the instructions in the Firebase console.", "missing-app-credential": "The phone verification request is missing an application verifier assertion. A reCAPTCHA response token needs to be provided.", "missing-verification-code": "The phone auth credential was created with an empty SMS verification code.", "missing-continue-uri": "A continue URL must be provided in the request.", "missing-iframe-start": "An internal AuthError has occurred.", "missing-ios-bundle-id": "An iOS Bundle ID must be provided if an App Store ID is provided.", "missing-or-invalid-nonce": "The request does not contain a valid nonce. This can occur if the SHA-256 hash of the provided raw nonce does not match the hashed nonce in the ID token payload.", "missing-password": "A non-empty password must be provided", "missing-multi-factor-info": "No second factor identifier is provided.", "missing-multi-factor-session": "The request is missing proof of first factor successful sign-in.", "missing-phone-number": "To send verification codes, provide a phone number for the recipient.", "missing-verification-id": "The phone auth credential was created with an empty verification ID.", "app-deleted": "This instance of FirebaseApp has been deleted.", "multi-factor-info-not-found": "The user does not have a second factor matching the identifier provided.", "multi-factor-auth-required": "Proof of ownership of a second factor is required to complete sign-in.", "account-exists-with-different-credential": "An account already exists with the same email address but different sign-in credentials. Sign in using a provider associated with this email address.", "network-request-failed": "A network AuthError (such as timeout, interrupted connection or unreachable host) has occurred.", "no-auth-event": "An internal AuthError has occurred.", "no-such-provider": "User was not linked to an account with the given provider.", "null-user": "A null user object was provided as the argument for an operation which requires a non-null user object.", "operation-not-allowed": "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section.", "operation-not-supported-in-this-environment": 'This operation is not supported in the environment this application is running on. "location.protocol" must be http, https or chrome-extension and web storage must be enabled.', "popup-blocked": "Unable to establish a connection with the popup. It may have been blocked by the browser.", "popup-closed-by-user": "The popup has been closed by the user before finalizing the operation.", "provider-already-linked": "User can only be linked to one identity for the given provider.", "quota-exceeded": "The project's quota for this operation has been exceeded.", "redirect-cancelled-by-user": "The redirect operation has been cancelled by the user before finalizing.", "redirect-operation-pending": "A redirect sign-in operation is already pending.", "rejected-credential": "The request contains malformed or mismatching credentials.", "second-factor-already-in-use": "The second factor is already enrolled on this account.", "maximum-second-factor-count-exceeded": "The maximum allowed number of second factors on a user has been exceeded.", "tenant-id-mismatch": "The provided tenant ID does not match the Auth instance's tenant ID", timeout: "The operation has timed out.", "user-token-expired": "The user's credential is no longer valid. The user must sign in again.", "too-many-requests": "We have blocked all requests from this device due to unusual activity. Try again later.", "unauthorized-continue-uri": "The domain of the continue URL is not whitelisted.  Please whitelist the domain in the Firebase console.", "unsupported-first-factor": "Enrolling a second factor or signing in with a multi-factor account requires sign-in with a supported first factor.", "unsupported-persistence-type": "The current environment does not support the specified persistence type.", "unsupported-tenant-operation": "This operation is not supported in a multi-tenant context.", "unverified-email": "The operation requires a verified email.", "user-cancelled": "The user did not grant your application the permissions it requested.", "user-not-found": "There is no user record corresponding to this identifier. The user may have been deleted.", "user-disabled": "The user account has been disabled by an administrator.", "user-mismatch": "The supplied credentials do not correspond to the previously signed in user.", "user-signed-out": "", "weak-password": "The password must be 6 characters long or more.", "web-storage-unsupported": "This browser is not supported or 3rd party cookies and data may be disabled.", "already-initialized": "initializeAuth() has already been called with different options. To avoid this error, call initializeAuth() with the same options as when it was originally called, or call getAuth() to return the already initialized instance.", "missing-recaptcha-token": "The reCAPTCHA token is missing when sending request to the backend.", "invalid-recaptcha-token": "The reCAPTCHA token is invalid when sending request to the backend.", "invalid-recaptcha-action": "The reCAPTCHA action is invalid when sending request to the backend.", "recaptcha-not-enabled": "reCAPTCHA Enterprise integration is not enabled for this project.", "missing-client-type": "The reCAPTCHA client type is missing when sending request to the backend.", "missing-recaptcha-version": "The reCAPTCHA version is missing when sending request to the backend.", "invalid-req-type": "Invalid request parameters.", "invalid-recaptcha-version": "The reCAPTCHA version is invalid when sending request to the backend." } }, We = function ze() { return { "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK." } }, Pe = new y.LL("auth", "Firebase", { "dependent-sdk-initialized-before-auth": "Another Firebase SDK was initialized and is trying to use Auth before Auth is initialized. Please be sure to call `initializeAuth` or `getAuth` before starting any other Firebase SDK." }), tt = new he.Yd("@firebase/auth"); function ut(T, ...g) { tt.logLevel <= he.in.ERROR && tt.error(`Auth (${v.SDK_VERSION}): ${T}`, ...g) } function ie(T, ...g) { throw ue(T, ...g) } function Le(T, ...g) { return ue(T, ...g) } function le(T, g, b) { const k = Object.assign(Object.assign({}, We()), { [g]: b }); return new y.LL("auth", "Firebase", k).create(g, { appName: T.name }) } function ge(T, g, b) { if (!(g instanceof b)) throw b.name !== g.constructor.name && ie(T, "argument-error"), le(T, "argument-error", `Type of ${g.constructor.name} does not match expected instance.Did you pass a reference from a different Auth SDK?`) } function ue(T, ...g) { if ("string" != typeof T) { const b = g[0], k = [...g.slice(1)]; return k[0] && (k[0].appName = T.name), T._errorFactory.create(b, ...k) } return Pe.create(T, ...g) } function ee(T, g, ...b) { if (!T) throw ue(g, ...b) } function $e(T) { const g = "INTERNAL ASSERTION FAILED: " + T; throw ut(g), new Error(g) } function rt(T, g) { T || $e(g) } function Kt() { var T; return typeof self < "u" && (null === (T = self.location) || void 0 === T ? void 0 : T.href) || "" } function bn() { return "http:" === Dn() || "https:" === Dn() } function Dn() { var T; return typeof self < "u" && (null === (T = self.location) || void 0 === T ? void 0 : T.protocol) || null } class Wn { constructor(g, b) { this.shortDelay = g, this.longDelay = b, rt(b > g, "Short delay should be less than long delay!"), this.isMobile = (0, y.uI)() || (0, y.b$)() } get() { return function Mn() { return !(typeof navigator < "u" && navigator && "onLine" in navigator && "boolean" == typeof navigator.onLine && (bn() || (0, y.ru)() || "connection" in navigator)) || navigator.onLine }() ? this.isMobile ? this.longDelay : this.shortDelay : Math.min(5e3, this.shortDelay) } } function Hn(T, g) { rt(T.emulator, "Emulator should always be set here"); const { url: b } = T.emulator; return g ? `${b}${g.startsWith("/") ? g.slice(1) : g}` : b } class at { static initialize(g, b, k) { this.fetchImpl = g, b && (this.headersImpl = b), k && (this.responseImpl = k) } static fetch() { return this.fetchImpl ? this.fetchImpl : typeof self < "u" && "fetch" in self ? self.fetch : void $e("Could not find fetch implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } static headers() { return this.headersImpl ? this.headersImpl : typeof self < "u" && "Headers" in self ? self.Headers : void $e("Could not find Headers implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } static response() { return this.responseImpl ? this.responseImpl : typeof self < "u" && "Response" in self ? self.Response : void $e("Could not find Response implementation, make sure you call FetchProvider.initialize() with an appropriate polyfill") } } const vt = { CREDENTIAL_MISMATCH: "custom-token-mismatch", MISSING_CUSTOM_TOKEN: "internal-error", INVALID_IDENTIFIER: "invalid-email", MISSING_CONTINUE_URI: "internal-error", INVALID_PASSWORD: "wrong-password", MISSING_PASSWORD: "missing-password", EMAIL_EXISTS: "email-already-in-use", PASSWORD_LOGIN_DISABLED: "operation-not-allowed", INVALID_IDP_RESPONSE: "invalid-credential", INVALID_PENDING_TOKEN: "invalid-credential", FEDERATED_USER_ID_ALREADY_LINKED: "credential-already-in-use", MISSING_REQ_TYPE: "internal-error", EMAIL_NOT_FOUND: "user-not-found", RESET_PASSWORD_EXCEED_LIMIT: "too-many-requests", EXPIRED_OOB_CODE: "expired-action-code", INVALID_OOB_CODE: "invalid-action-code", MISSING_OOB_CODE: "internal-error", CREDENTIAL_TOO_OLD_LOGIN_AGAIN: "requires-recent-login", INVALID_ID_TOKEN: "invalid-user-token", TOKEN_EXPIRED: "user-token-expired", USER_NOT_FOUND: "user-token-expired", TOO_MANY_ATTEMPTS_TRY_LATER: "too-many-requests", INVALID_CODE: "invalid-verification-code", INVALID_SESSION_INFO: "invalid-verification-id", INVALID_TEMPORARY_PROOF: "invalid-credential", MISSING_SESSION_INFO: "missing-verification-id", SESSION_EXPIRED: "code-expired", MISSING_ANDROID_PACKAGE_NAME: "missing-android-pkg-name", UNAUTHORIZED_DOMAIN: "unauthorized-continue-uri", INVALID_OAUTH_CLIENT_ID: "invalid-oauth-client-id", ADMIN_ONLY_OPERATION: "admin-restricted-operation", INVALID_MFA_PENDING_CREDENTIAL: "invalid-multi-factor-session", MFA_ENROLLMENT_NOT_FOUND: "multi-factor-info-not-found", MISSING_MFA_ENROLLMENT_ID: "missing-multi-factor-info", MISSING_MFA_PENDING_CREDENTIAL: "missing-multi-factor-session", SECOND_FACTOR_EXISTS: "second-factor-already-in-use", SECOND_FACTOR_LIMIT_EXCEEDED: "maximum-second-factor-count-exceeded", BLOCKING_FUNCTION_ERROR_RESPONSE: "internal-error", RECAPTCHA_NOT_ENABLED: "recaptcha-not-enabled", MISSING_RECAPTCHA_TOKEN: "missing-recaptcha-token", INVALID_RECAPTCHA_TOKEN: "invalid-recaptcha-token", INVALID_RECAPTCHA_ACTION: "invalid-recaptcha-action", MISSING_CLIENT_TYPE: "missing-client-type", MISSING_RECAPTCHA_VERSION: "missing-recaptcha-version", INVALID_RECAPTCHA_VERSION: "invalid-recaptcha-version", INVALID_REQ_TYPE: "invalid-req-type" }, xt = new Wn(3e4, 6e4); function it(T, g) { return T.tenantId && !g.tenantId ? Object.assign(Object.assign({}, g), { tenantId: T.tenantId }) : g } function Ft(T, g, b, k) { return Wt.apply(this, arguments) } function Wt() { return (Wt = (0, a.Z)(function* (T, g, b, k, oe = {}) { return rn(T, oe, (0, a.Z)(function* () { let De = {}, Tt = {}; k && ("GET" === g ? Tt = k : De = { body: JSON.stringify(k) }); const Xt = (0, y.xO)(Object.assign({ key: T.config.apiKey }, Tt)).slice(1), Nn = yield T._getAdditionalHeaders(); return Nn["Content-Type"] = "application/json", T.languageCode && (Nn["X-Firebase-Locale"] = T.languageCode), at.fetch()(ht(T, T.config.apiHost, b, Xt), Object.assign({ method: g, headers: Nn, referrerPolicy: "no-referrer" }, De)) })) })).apply(this, arguments) } function rn(T, g, b) { return Jt.apply(this, arguments) } function Jt() { return (Jt = (0, a.Z)(function* (T, g, b) { T._canInitEmulator = !1; const k = Object.assign(Object.assign({}, vt), g); try { const oe = new Ae(T), De = yield Promise.race([b(), oe.promise]); oe.clearNetworkTimeout(); const Tt = yield De.json(); if ("needConfirmation" in Tt) throw nt(T, "account-exists-with-different-credential", Tt); if (De.ok && !("errorMessage" in Tt)) return Tt; { const Xt = De.ok ? Tt.errorMessage : Tt.error.message, [Nn, zn] = Xt.split(" : "); if ("FEDERATED_USER_ID_ALREADY_LINKED" === Nn) throw nt(T, "credential-already-in-use", Tt); if ("EMAIL_EXISTS" === Nn) throw nt(T, "email-already-in-use", Tt); if ("USER_DISABLED" === Nn) throw nt(T, "user-disabled", Tt); const vi = k[Nn] || Nn.toLowerCase().replace(/[_\s]+/g, "-"); if (zn) throw le(T, vi, zn); ie(T, vi) } } catch (oe) { if (oe instanceof y.ZR) throw oe; ie(T, "network-request-failed", { message: String(oe) }) } })).apply(this, arguments) } function tn(T, g, b, k) { return St.apply(this, arguments) } function St() { return (St = (0, a.Z)(function* (T, g, b, k, oe = {}) { const De = yield Ft(T, g, b, k, oe); return "mfaPendingCredential" in De && ie(T, "multi-factor-auth-required", { _serverResponse: De }), De })).apply(this, arguments) } function ht(T, g, b, k) { const oe = `${g}${b}?${k}`; return T.config.emulator ? Hn(T.config, oe) : `${T.config.apiScheme}://${oe}` } class Ae { constructor(g) { this.auth = g, this.timer = null, this.promise = new Promise((b, k) => { this.timer = setTimeout(() => k(Le(this.auth, "network-request-failed")), xt.get()) }) } clearNetworkTimeout() { clearTimeout(this.timer) } } function nt(T, g, b) { const k = { appName: T.name }; b.email && (k.email = b.email), b.phoneNumber && (k.phoneNumber = b.phoneNumber); const oe = Le(T, g, k); return oe.customData._tokenResponse = b, oe } function jt() { return (jt = (0, a.Z)(function* (T, g) { return Ft(T, "POST", "/v1/accounts:delete", g) })).apply(this, arguments) } function qe() { return (qe = (0, a.Z)(function* (T, g) { return Ft(T, "POST", "/v1/accounts:update", g) })).apply(this, arguments) } function on() { return (on = (0, a.Z)(function* (T, g) { return Ft(T, "POST", "/v1/accounts:lookup", g) })).apply(this, arguments) } function Zt(T) { if (T) try { const g = new Date(Number(T)); if (!isNaN(g.getTime())) return g.toUTCString() } catch { } } function Fn() { return (Fn = (0, a.Z)(function* (T, g = !1) { const b = (0, y.m9)(T), k = yield b.getIdToken(g), oe = se(k); ee(oe && oe.exp && oe.auth_time && oe.iat, b.auth, "internal-error"); const De = "object" == typeof oe.firebase ? oe.firebase : void 0, Tt = De?.sign_in_provider; return { claims: oe, token: k, authTime: Zt(Ke(oe.auth_time)), issuedAtTime: Zt(Ke(oe.iat)), expirationTime: Zt(Ke(oe.exp)), signInProvider: Tt || null, signInSecondFactor: De?.sign_in_second_factor || null } })).apply(this, arguments) } function Ke(T) { return 1e3 * Number(T) } function se(T) { const [g, b, k] = T.split("."); if (void 0 === g || void 0 === b || void 0 === k) return ut("JWT malformed, contained fewer than 3 sections"), null; try { const oe = (0, y.tV)(b); return oe ? JSON.parse(oe) : (ut("Failed to decode base64 JWT payload"), null) } catch (oe) { return ut("Caught error parsing JWT payload as JSON", oe?.toString()), null } } function Xe(T, g) { return Ot.apply(this, arguments) } function Ot() { return (Ot = (0, a.Z)(function* (T, g, b = !1) { if (b) return g; try { return yield g } catch (k) { throw k instanceof y.ZR && function ve({ code: T }) { return "auth/user-disabled" === T || "auth/user-token-expired" === T }(k) && T.auth.currentUser === T && (yield T.auth.signOut()), k } })).apply(this, arguments) } class Ue { constructor(g) { this.user = g, this.isRunning = !1, this.timerId = null, this.errorBackoff = 3e4 } _start() { this.isRunning || (this.isRunning = !0, this.schedule()) } _stop() { this.isRunning && (this.isRunning = !1, null !== this.timerId && clearTimeout(this.timerId)) } getInterval(g) { var b; if (g) { const k = this.errorBackoff; return this.errorBackoff = Math.min(2 * this.errorBackoff, 96e4), k } { this.errorBackoff = 3e4; const oe = (null !== (b = this.user.stsTokenManager.expirationTime) && void 0 !== b ? b : 0) - Date.now() - 3e5; return Math.max(0, oe) } } schedule(g = !1) { var b = this; if (!this.isRunning) return; const k = this.getInterval(g); this.timerId = setTimeout((0, a.Z)(function* () { yield b.iteration() }), k) } iteration() { var g = this; return (0, a.Z)(function* () { try { yield g.user.getIdToken(!0) } catch (b) { return void ("auth/network-request-failed" === b?.code && g.schedule(!0)) } g.schedule() })() } } class Z { constructor(g, b) { this.createdAt = g, this.lastLoginAt = b, this._initializeTime() } _initializeTime() { this.lastSignInTime = Zt(this.lastLoginAt), this.creationTime = Zt(this.createdAt) } _copy(g) { this.createdAt = g.createdAt, this.lastLoginAt = g.lastLoginAt, this._initializeTime() } toJSON() { return { createdAt: this.createdAt, lastLoginAt: this.lastLoginAt } } } function Fe(T) { return ct.apply(this, arguments) } function ct() { return ct = (0, a.Z)(function* (T) { var g; const b = T.auth, k = yield T.getIdToken(), oe = yield Xe(T, function Nt(T, g) { return on.apply(this, arguments) }(b, { idToken: k })); ee(oe?.users.length, b, "internal-error"); const De = oe.users[0]; T._notifyReloadListener(De); const Tt = null !== (g = De.providerUserInfo) && void 0 !== g && g.length ? function En(T) { return T.map(g => { var { providerId: b } = g, k = (0, Y._T)(g, ["providerId"]); return { providerId: b, uid: k.rawId || "", displayName: k.displayName || null, email: k.email || null, phoneNumber: k.phoneNumber || null, photoURL: k.photoUrl || null } }) }(De.providerUserInfo) : [], Xt = function fn(T, g) { return [...T.filter(k => !g.some(oe => oe.providerId === k.providerId)), ...g] }(T.providerData, Tt), vi = !!T.isAnonymous && !(T.email && De.passwordHash || Xt?.length), hr = { uid: De.localId, displayName: De.displayName || null, photoURL: De.photoUrl || null, email: De.email || null, emailVerified: De.emailVerified || !1, phoneNumber: De.phoneNumber || null, tenantId: De.tenantId || null, providerData: Xt, metadata: new Z(De.createdAt, De.lastLoginAt), isAnonymous: vi }; Object.assign(T, hr) }), ct.apply(this, arguments) } function Qt() { return (Qt = (0, a.Z)(function* (T) { const g = (0, y.m9)(T); yield Fe(g), yield g.auth._persistUserIfCurrent(g), g.auth._notifyListenersIfCurrent(g) })).apply(this, arguments) } function In() { return (In = (0, a.Z)(function* (T, g) { const b = yield rn(T, {}, (0, a.Z)(function* () { const k = (0, y.xO)({ grant_type: "refresh_token", refresh_token: g }).slice(1), { tokenApiHost: oe, apiKey: De } = T.config, Tt = ht(T, oe, "/v1/token", `key=${De}`), Xt = yield T._getAdditionalHeaders(); return Xt["Content-Type"] = "application/x-www-form-urlencoded", at.fetch()(Tt, { method: "POST", headers: Xt, body: k }) })); return { accessToken: b.access_token, expiresIn: b.expires_in, refreshToken: b.refresh_token } })).apply(this, arguments) } class Et { constructor() { this.refreshToken = null, this.accessToken = null, this.expirationTime = null } get isExpired() { return !this.expirationTime || Date.now() > this.expirationTime - 3e4 } updateFromServerResponse(g) { ee(g.idToken, "internal-error"), ee(typeof g.idToken < "u", "internal-error"), ee(typeof g.refreshToken < "u", "internal-error"); const b = "expiresIn" in g && typeof g.expiresIn < "u" ? Number(g.expiresIn) : function Me(T) { const g = se(T); return ee(g, "internal-error"), ee(typeof g.exp < "u", "internal-error"), ee(typeof g.iat < "u", "internal-error"), Number(g.exp) - Number(g.iat) }(g.idToken); this.updateTokensAndExpiration(g.idToken, g.refreshToken, b) } getToken(g, b = !1) { var k = this; return (0, a.Z)(function* () { return ee(!k.accessToken || k.refreshToken, g, "user-token-expired"), b || !k.accessToken || k.isExpired ? k.refreshToken ? (yield k.refresh(g, k.refreshToken), k.accessToken) : null : k.accessToken })() } clearRefreshToken() { this.refreshToken = null } refresh(g, b) { var k = this; return (0, a.Z)(function* () { const { accessToken: oe, refreshToken: De, expiresIn: Tt } = yield function Ln(T, g) { return In.apply(this, arguments) }(g, b); k.updateTokensAndExpiration(oe, De, Number(Tt)) })() } updateTokensAndExpiration(g, b, k) { this.refreshToken = b || null, this.accessToken = g || null, this.expirationTime = Date.now() + 1e3 * k } static fromJSON(g, b) { const { refreshToken: k, accessToken: oe, expirationTime: De } = b, Tt = new Et; return k && (ee("string" == typeof k, "internal-error", { appName: g }), Tt.refreshToken = k), oe && (ee("string" == typeof oe, "internal-error", { appName: g }), Tt.accessToken = oe), De && (ee("number" == typeof De, "internal-error", { appName: g }), Tt.expirationTime = De), Tt } toJSON() { return { refreshToken: this.refreshToken, accessToken: this.accessToken, expirationTime: this.expirationTime } } _assign(g) { this.accessToken = g.accessToken, this.refreshToken = g.refreshToken, this.expirationTime = g.expirationTime } _clone() { return Object.assign(new Et, this.toJSON()) } _performRefresh() { return $e("not implemented") } } function _t(T, g) { ee("string" == typeof T || typeof T > "u", "internal-error", { appName: g }) } class G { constructor(g) { var { uid: b, auth: k, stsTokenManager: oe } = g, De = (0, Y._T)(g, ["uid", "auth", "stsTokenManager"]); this.providerId = "firebase", this.proactiveRefresh = new Ue(this), this.reloadUserInfo = null, this.reloadListener = null, this.uid = b, this.auth = k, this.stsTokenManager = oe, this.accessToken = oe.accessToken, this.displayName = De.displayName || null, this.email = De.email || null, this.emailVerified = De.emailVerified || !1, this.phoneNumber = De.phoneNumber || null, this.photoURL = De.photoURL || null, this.isAnonymous = De.isAnonymous || !1, this.tenantId = De.tenantId || null, this.providerData = De.providerData ? [...De.providerData] : [], this.metadata = new Z(De.createdAt || void 0, De.lastLoginAt || void 0) } getIdToken(g) { var b = this; return (0, a.Z)(function* () { const k = yield Xe(b, b.stsTokenManager.getToken(b.auth, g)); return ee(k, b.auth, "internal-error"), b.accessToken !== k && (b.accessToken = k, yield b.auth._persistUserIfCurrent(b), b.auth._notifyListenersIfCurrent(b)), k })() } getIdTokenResult(g) { return function $n(T) { return Fn.apply(this, arguments) }(this, g) } reload() { return function Mt(T) { return Qt.apply(this, arguments) }(this) } _assign(g) { this !== g && (ee(this.uid === g.uid, this.auth, "internal-error"), this.displayName = g.displayName, this.photoURL = g.photoURL, this.email = g.email, this.emailVerified = g.emailVerified, this.phoneNumber = g.phoneNumber, this.isAnonymous = g.isAnonymous, this.tenantId = g.tenantId, this.providerData = g.providerData.map(b => Object.assign({}, b)), this.metadata._copy(g.metadata), this.stsTokenManager._assign(g.stsTokenManager)) } _clone(g) { const b = new G(Object.assign(Object.assign({}, this), { auth: g, stsTokenManager: this.stsTokenManager._clone() })); return b.metadata._copy(this.metadata), b } _onReload(g) { ee(!this.reloadListener, this.auth, "internal-error"), this.reloadListener = g, this.reloadUserInfo && (this._notifyReloadListener(this.reloadUserInfo), this.reloadUserInfo = null) } _notifyReloadListener(g) { this.reloadListener ? this.reloadListener(g) : this.reloadUserInfo = g } _startProactiveRefresh() { this.proactiveRefresh._start() } _stopProactiveRefresh() { this.proactiveRefresh._stop() } _updateTokensIfNecessary(g, b = !1) { var k = this; return (0, a.Z)(function* () { let oe = !1; g.idToken && g.idToken !== k.stsTokenManager.accessToken && (k.stsTokenManager.updateFromServerResponse(g), oe = !0), b && (yield Fe(k)), yield k.auth._persistUserIfCurrent(k), oe && k.auth._notifyListenersIfCurrent(k) })() } delete() { var g = this; return (0, a.Z)(function* () { const b = yield g.getIdToken(); return yield Xe(g, function qt(T, g) { return jt.apply(this, arguments) }(g.auth, { idToken: b })), g.stsTokenManager.clearRefreshToken(), g.auth.signOut() })() } toJSON() { return Object.assign(Object.assign({ uid: this.uid, email: this.email || void 0, emailVerified: this.emailVerified, displayName: this.displayName || void 0, isAnonymous: this.isAnonymous, photoURL: this.photoURL || void 0, phoneNumber: this.phoneNumber || void 0, tenantId: this.tenantId || void 0, providerData: this.providerData.map(g => Object.assign({}, g)), stsTokenManager: this.stsTokenManager.toJSON(), _redirectEventId: this._redirectEventId }, this.metadata.toJSON()), { apiKey: this.auth.config.apiKey, appName: this.auth.name }) } get refreshToken() { return this.stsTokenManager.refreshToken || "" } static _fromJSON(g, b) { var k, oe, De, Tt, Xt, Nn, zn, vi; const hr = null !== (k = b.displayName) && void 0 !== k ? k : void 0, $s = null !== (oe = b.email) && void 0 !== oe ? oe : void 0, Xs = null !== (De = b.phoneNumber) && void 0 !== De ? De : void 0, lu = null !== (Tt = b.photoURL) && void 0 !== Tt ? Tt : void 0, ca = null !== (Xt = b.tenantId) && void 0 !== Xt ? Xt : void 0, cu = null !== (Nn = b._redirectEventId) && void 0 !== Nn ? Nn : void 0, Nc = null !== (zn = b.createdAt) && void 0 !== zn ? zn : void 0, du = null !== (vi = b.lastLoginAt) && void 0 !== vi ? vi : void 0, { uid: Js, emailVerified: Fc, isAnonymous: Hl, providerData: pd, stsTokenManager: uu } = b; ee(Js && uu, g, "internal-error"); const Oi = Et.fromJSON(this.name, uu); ee("string" == typeof Js, g, "internal-error"), _t(hr, g.name), _t($s, g.name), ee("boolean" == typeof Fc, g, "internal-error"), ee("boolean" == typeof Hl, g, "internal-error"), _t(Xs, g.name), _t(lu, g.name), _t(ca, g.name), _t(cu, g.name), _t(Nc, g.name), _t(du, g.name); const gd = new G({ uid: Js, auth: g, email: $s, emailVerified: Fc, displayName: hr, isAnonymous: Hl, photoURL: lu, phoneNumber: Xs, tenantId: ca, stsTokenManager: Oi, createdAt: Nc, lastLoginAt: du }); return pd && Array.isArray(pd) && (gd.providerData = pd.map(_d => Object.assign({}, _d))), cu && (gd._redirectEventId = cu), gd } static _fromIdTokenResponse(g, b, k = !1) { return (0, a.Z)(function* () { const oe = new Et; oe.updateFromServerResponse(b); const De = new G({ uid: b.localId, auth: g, stsTokenManager: oe, isAnonymous: k }); return yield Fe(De), De })() } } const W = new Map; function me(T) { rt(T instanceof Function, "Expected a class definition"); let g = W.get(T); return g ? (rt(g instanceof T, "Instance stored in cache mismatched with class"), g) : (g = new T, W.set(T, g), g) } const st = (() => { class T { constructor() { this.type = "NONE", this.storage = {} } _isAvailable() { return (0, a.Z)(function* () { return !0 })() } _set(b, k) { var oe = this; return (0, a.Z)(function* () { oe.storage[b] = k })() } _get(b) { var k = this; return (0, a.Z)(function* () { const oe = k.storage[b]; return void 0 === oe ? null : oe })() } _remove(b) { var k = this; return (0, a.Z)(function* () { delete k.storage[b] })() } _addListener(b, k) { } _removeListener(b, k) { } } return T.type = "NONE", T })(); function Lt(T, g, b) { return `firebase:${T}:${g}:${b}` } class He { constructor(g, b, k) { this.persistence = g, this.auth = b, this.userKey = k; const { config: oe, name: De } = this.auth; this.fullUserKey = Lt(this.userKey, oe.apiKey, De), this.fullPersistenceKey = Lt("persistence", oe.apiKey, De), this.boundEventHandler = b._onStorageEvent.bind(b), this.persistence._addListener(this.fullUserKey, this.boundEventHandler) } setCurrentUser(g) { return this.persistence._set(this.fullUserKey, g.toJSON()) } getCurrentUser() { var g = this; return (0, a.Z)(function* () { const b = yield g.persistence._get(g.fullUserKey); return b ? G._fromJSON(g.auth, b) : null })() } removeCurrentUser() { return this.persistence._remove(this.fullUserKey) } savePersistenceForRedirect() { return this.persistence._set(this.fullPersistenceKey, this.persistence.type) } setPersistence(g) { var b = this; return (0, a.Z)(function* () { if (b.persistence === g) return; const k = yield b.getCurrentUser(); return yield b.removeCurrentUser(), b.persistence = g, k ? b.setCurrentUser(k) : void 0 })() } delete() { this.persistence._removeListener(this.fullUserKey, this.boundEventHandler) } static create(g, b, k = "authUser") { return (0, a.Z)(function* () { if (!b.length) return new He(me(st), g, k); const oe = (yield Promise.all(b.map(function () { var zn = (0, a.Z)(function* (vi) { if (yield vi._isAvailable()) return vi }); return function (vi) { return zn.apply(this, arguments) } }()))).filter(zn => zn); let De = oe[0] || me(st); const Tt = Lt(k, g.config.apiKey, g.name); let Xt = null; for (const zn of b) try { const vi = yield zn._get(Tt); if (vi) { const hr = G._fromJSON(g, vi); zn !== De && (Xt = hr), De = zn; break } } catch { } const Nn = oe.filter(zn => zn._shouldAllowMigration); return De._shouldAllowMigration && Nn.length ? (De = Nn[0], Xt && (yield De._set(Tt, Xt.toJSON())), yield Promise.all(b.map(function () { var zn = (0, a.Z)(function* (vi) { if (vi !== De) try { yield vi._remove(Tt) } catch { } }); return function (vi) { return zn.apply(this, arguments) } }())), new He(De, g, k)) : new He(De, g, k) })() } } function ae(T) { const g = T.toLowerCase(); if (g.includes("opera/") || g.includes("opr/") || g.includes("opios/")) return "Opera"; if (Ne(g)) return "IEMobile"; if (g.includes("msie") || g.includes("trident/")) return "IE"; if (g.includes("edge/")) return "Edge"; if (z(g)) return "Firefox"; if (g.includes("silk/")) return "Silk"; if (pe(g)) return "Blackberry"; if (fe(g)) return "Webos"; if (L(g)) return "Safari"; if ((g.includes("chrome/") || H(g)) && !g.includes("edge/")) return "Chrome"; if (pt(g)) return "Android"; { const k = T.match(/([a-zA-Z\d\.]+)\/[a-zA-Z\d\.]*$/); if (2 === k?.length) return k[1] } return "Other" } function z(T = (0, y.z$)()) { return /firefox\//i.test(T) } function L(T = (0, y.z$)()) { const g = T.toLowerCase(); return g.includes("safari/") && !g.includes("chrome/") && !g.includes("crios/") && !g.includes("android") } function H(T = (0, y.z$)()) { return /crios\//i.test(T) } function Ne(T = (0, y.z$)()) { return /iemobile/i.test(T) } function pt(T = (0, y.z$)()) { return /android/i.test(T) } function pe(T = (0, y.z$)()) { return /blackberry/i.test(T) } function fe(T = (0, y.z$)()) { return /webos/i.test(T) } function F(T = (0, y.z$)()) { return /iphone|ipad|ipod/i.test(T) || /macintosh/i.test(T) && /mobile/i.test(T) } function J(T = (0, y.z$)()) { return /(iPad|iPhone|iPod).*OS 7_\d/i.test(T) || /(iPad|iPhone|iPod).*OS 8_\d/i.test(T) } function gt(T = (0, y.z$)()) { return F(T) || pt(T) || fe(T) || pe(T) || /windows phone/i.test(T) || Ne(T) } function un(T, g = []) { let b; switch (T) { case "Browser": b = ae((0, y.z$)()); break; case "Worker": b = `${ae((0, y.z$)())}-${T}`; break; default: b = T }const k = g.length ? g.join(",") : "FirebaseCore-web"; return `${b}/JsCore/${v.SDK_VERSION}/${k}` } function It() { return (It = (0, a.Z)(function* (T) { return (yield Ft(T, "GET", "/v1/recaptchaParams")).recaptchaSiteKey || "" })).apply(this, arguments) } function dn(T, g) { return Pn.apply(this, arguments) } function Pn() { return (Pn = (0, a.Z)(function* (T, g) { return Ft(T, "GET", "/v2/recaptchaConfig", it(T, g)) })).apply(this, arguments) } function qn(T) { return void 0 !== T && void 0 !== T.getResponse } function ni(T) { return void 0 !== T && void 0 !== T.enterprise } class si { constructor(g) { if (this.siteKey = "", this.emailPasswordEnabled = !1, void 0 === g.recaptchaKey) throw new Error("recaptchaKey undefined"); this.siteKey = g.recaptchaKey.split("/")[3], this.emailPasswordEnabled = g.recaptchaEnforcementState.some(b => "EMAIL_PASSWORD_PROVIDER" === b.provider && "OFF" !== b.enforcementState) } } function Li(T) { return new Promise((g, b) => { const k = document.createElement("script"); k.setAttribute("src", T), k.onload = g, k.onerror = oe => { const De = Le("internal-error"); De.customData = oe, b(De) }, k.type = "text/javascript", k.charset = "UTF-8", function Ai() { var T, g; return null !== (g = null === (T = document.getElementsByTagName("head")) || void 0 === T ? void 0 : T[0]) && void 0 !== g ? g : document }().appendChild(k) }) } function ho(T) { return `__${T}${Math.floor(1e6 * Math.random())}` } class Ti { constructor(g) { this.type = "recaptcha-enterprise", this.auth = Vi(g) } verify(g = "verify", b = !1) { var k = this; return (0, a.Z)(function* () { function De() { return De = (0, a.Z)(function* (Xt) { if (!b) { if (null == Xt.tenantId && null != Xt._agentRecaptchaConfig) return Xt._agentRecaptchaConfig.siteKey; if (null != Xt.tenantId && void 0 !== Xt._tenantRecaptchaConfigs[Xt.tenantId]) return Xt._tenantRecaptchaConfigs[Xt.tenantId].siteKey } return new Promise(function () { var Nn = (0, a.Z)(function* (zn, vi) { dn(Xt, { clientType: "CLIENT_TYPE_WEB", version: "RECAPTCHA_ENTERPRISE" }).then(hr => { if (void 0 !== hr.recaptchaKey) { const $s = new si(hr); return null == Xt.tenantId ? Xt._agentRecaptchaConfig = $s : Xt._tenantRecaptchaConfigs[Xt.tenantId] = $s, zn($s.siteKey) } vi(new Error("recaptcha Enterprise site key undefined")) }).catch(hr => { vi(hr) }) }); return function (zn, vi) { return Nn.apply(this, arguments) } }()) }), De.apply(this, arguments) } function Tt(Xt, Nn, zn) { const vi = window.grecaptcha; ni(vi) ? vi.enterprise.ready(() => { vi.enterprise.execute(Xt, { action: g }).then(hr => { Nn(hr) }).catch(() => { Nn("NO_RECAPTCHA") }) }) : zn(Error("No reCAPTCHA enterprise script loaded.")) } return new Promise((Xt, Nn) => { (function oe(Xt) { return De.apply(this, arguments) })(k.auth).then(zn => { if (!b && ni(window.grecaptcha)) Tt(zn, Xt, Nn); else { if (typeof window > "u") return void Nn(new Error("RecaptchaVerifier is only supported in browser")); Li("https://www.google.com/recaptcha/enterprise.js?render=" + zn).then(() => { Tt(zn, Xt, Nn) }).catch(vi => { Nn(vi) }) } }).catch(zn => { Nn(zn) }) }) })() } } function Pr(T, g, b) { return Ir.apply(this, arguments) } function Ir() { return (Ir = (0, a.Z)(function* (T, g, b, k = !1) { const oe = new Ti(T); let De; try { De = yield oe.verify(b) } catch { De = yield oe.verify(b, !0) } const Tt = Object.assign({}, g); return Object.assign(Tt, k ? { captchaResp: De } : { captchaResponse: De }), Object.assign(Tt, { clientType: "CLIENT_TYPE_WEB" }), Object.assign(Tt, { recaptchaVersion: "RECAPTCHA_ENTERPRISE" }), Tt })).apply(this, arguments) } class bo { constructor(g) { this.auth = g, this.queue = [] } pushCallback(g, b) { const k = De => new Promise((Tt, Xt) => { try { Tt(g(De)) } catch (Nn) { Xt(Nn) } }); k.onAbort = b, this.queue.push(k); const oe = this.queue.length - 1; return () => { this.queue[oe] = () => Promise.resolve() } } runMiddleware(g) { var b = this; return (0, a.Z)(function* () { if (b.auth.currentUser === g) return; const k = []; try { for (const oe of b.queue) yield oe(g), oe.onAbort && k.push(oe.onAbort) } catch (oe) { k.reverse(); for (const De of k) try { De() } catch { } throw b.auth._errorFactory.create("login-blocked", { originalMessage: oe?.message }) } })() } } class Nr { constructor(g, b, k, oe) { this.app = g, this.heartbeatServiceProvider = b, this.appCheckServiceProvider = k, this.config = oe, this.currentUser = null, this.emulatorConfig = null, this.operations = Promise.resolve(), this.authStateSubscription = new cs(this), this.idTokenSubscription = new cs(this), this.beforeStateQueue = new bo(this), this.redirectUser = null, this.isProactiveRefreshEnabled = !1, this._canInitEmulator = !0, this._isInitialized = !1, this._deleted = !1, this._initializationPromise = null, this._popupRedirectResolver = null, this._errorFactory = Pe, this._agentRecaptchaConfig = null, this._tenantRecaptchaConfigs = {}, this.lastNotifiedUid = void 0, this.languageCode = null, this.tenantId = null, this.settings = { appVerificationDisabledForTesting: !1 }, this.frameworks = [], this.name = g.name, this.clientVersion = oe.sdkClientVersion } _initializeWithPersistence(g, b) { var k = this; return b && (this._popupRedirectResolver = me(b)), this._initializationPromise = this.queue((0, a.Z)(function* () { var oe, De; if (!k._deleted && (k.persistenceManager = yield He.create(k, g), !k._deleted)) { if (null !== (oe = k._popupRedirectResolver) && void 0 !== oe && oe._shouldInitProactively) try { yield k._popupRedirectResolver._initialize(k) } catch { } yield k.initializeCurrentUser(b), k.lastNotifiedUid = (null === (De = k.currentUser) || void 0 === De ? void 0 : De.uid) || null, !k._deleted && (k._isInitialized = !0) } })), this._initializationPromise } _onStorageEvent() { var g = this; return (0, a.Z)(function* () { if (g._deleted) return; const b = yield g.assertedPersistence.getCurrentUser(); if (g.currentUser || b) { if (g.currentUser && b && g.currentUser.uid === b.uid) return g._currentUser._assign(b), void (yield g.currentUser.getIdToken()); yield g._updateCurrentUser(b, !0) } })() } initializeCurrentUser(g) { var b = this; return (0, a.Z)(function* () { var k; const oe = yield b.assertedPersistence.getCurrentUser(); let De = oe, Tt = !1; if (g && b.config.authDomain) { yield b.getOrInitRedirectPersistenceManager(); const Xt = null === (k = b.redirectUser) || void 0 === k ? void 0 : k._redirectEventId, Nn = De?._redirectEventId, zn = yield b.tryRedirectSignIn(g); (!Xt || Xt === Nn) && zn?.user && (De = zn.user, Tt = !0) } if (!De) return b.directlySetCurrentUser(null); if (!De._redirectEventId) { if (Tt) try { yield b.beforeStateQueue.runMiddleware(De) } catch (Xt) { De = oe, b._popupRedirectResolver._overrideRedirectResult(b, () => Promise.reject(Xt)) } return De ? b.reloadAndSetCurrentUserOrClear(De) : b.directlySetCurrentUser(null) } return ee(b._popupRedirectResolver, b, "argument-error"), yield b.getOrInitRedirectPersistenceManager(), b.redirectUser && b.redirectUser._redirectEventId === De._redirectEventId ? b.directlySetCurrentUser(De) : b.reloadAndSetCurrentUserOrClear(De) })() } tryRedirectSignIn(g) { var b = this; return (0, a.Z)(function* () { let k = null; try { k = yield b._popupRedirectResolver._completeRedirectFn(b, g, !0) } catch { yield b._setRedirectUser(null) } return k })() } reloadAndSetCurrentUserOrClear(g) { var b = this; return (0, a.Z)(function* () { try { yield Fe(g) } catch (k) { if ("auth/network-request-failed" !== k?.code) return b.directlySetCurrentUser(null) } return b.directlySetCurrentUser(g) })() } useDeviceLanguage() { this.languageCode = function On() { if (typeof navigator > "u") return null; const T = navigator; return T.languages && T.languages[0] || T.language || null }() } _delete() { var g = this; return (0, a.Z)(function* () { g._deleted = !0 })() } updateCurrentUser(g) { var b = this; return (0, a.Z)(function* () { const k = g ? (0, y.m9)(g) : null; return k && ee(k.auth.config.apiKey === b.config.apiKey, b, "invalid-user-token"), b._updateCurrentUser(k && k._clone(b)) })() } _updateCurrentUser(g, b = !1) { var k = this; return (0, a.Z)(function* () { if (!k._deleted) return g && ee(k.tenantId === g.tenantId, k, "tenant-id-mismatch"), b || (yield k.beforeStateQueue.runMiddleware(g)), k.queue((0, a.Z)(function* () { yield k.directlySetCurrentUser(g), k.notifyAuthListeners() })) })() } signOut() { var g = this; return (0, a.Z)(function* () { return yield g.beforeStateQueue.runMiddleware(null), (g.redirectPersistenceManager || g._popupRedirectResolver) && (yield g._setRedirectUser(null)), g._updateCurrentUser(null, !0) })() } setPersistence(g) { var b = this; return this.queue((0, a.Z)(function* () { yield b.assertedPersistence.setPersistence(me(g)) })) } initializeRecaptchaConfig() { var g = this; return (0, a.Z)(function* () { const b = yield dn(g, { clientType: "CLIENT_TYPE_WEB", version: "RECAPTCHA_ENTERPRISE" }), k = new si(b); null == g.tenantId ? g._agentRecaptchaConfig = k : g._tenantRecaptchaConfigs[g.tenantId] = k, k.emailPasswordEnabled && new Ti(g).verify() })() } _getRecaptchaConfig() { return null == this.tenantId ? this._agentRecaptchaConfig : this._tenantRecaptchaConfigs[this.tenantId] } _getPersistence() { return this.assertedPersistence.persistence.type } _updateErrorMap(g) { this._errorFactory = new y.LL("auth", "Firebase", g()) } onAuthStateChanged(g, b, k) { return this.registerStateListener(this.authStateSubscription, g, b, k) } beforeAuthStateChanged(g, b) { return this.beforeStateQueue.pushCallback(g, b) } onIdTokenChanged(g, b, k) { return this.registerStateListener(this.idTokenSubscription, g, b, k) } toJSON() { var g; return { apiKey: this.config.apiKey, authDomain: this.config.authDomain, appName: this.name, currentUser: null === (g = this._currentUser) || void 0 === g ? void 0 : g.toJSON() } } _setRedirectUser(g, b) { var k = this; return (0, a.Z)(function* () { const oe = yield k.getOrInitRedirectPersistenceManager(b); return null === g ? oe.removeCurrentUser() : oe.setCurrentUser(g) })() } getOrInitRedirectPersistenceManager(g) { var b = this; return (0, a.Z)(function* () { if (!b.redirectPersistenceManager) { const k = g && me(g) || b._popupRedirectResolver; ee(k, b, "argument-error"), b.redirectPersistenceManager = yield He.create(b, [me(k._redirectPersistence)], "redirectUser"), b.redirectUser = yield b.redirectPersistenceManager.getCurrentUser() } return b.redirectPersistenceManager })() } _redirectUserForId(g) { var b = this; return (0, a.Z)(function* () { var k, oe; return b._isInitialized && (yield b.queue((0, a.Z)(function* () { }))), (null === (k = b._currentUser) || void 0 === k ? void 0 : k._redirectEventId) === g ? b._currentUser : (null === (oe = b.redirectUser) || void 0 === oe ? void 0 : oe._redirectEventId) === g ? b.redirectUser : null })() } _persistUserIfCurrent(g) { var b = this; return (0, a.Z)(function* () { if (g === b.currentUser) return b.queue((0, a.Z)(function* () { return b.directlySetCurrentUser(g) })) })() } _notifyListenersIfCurrent(g) { g === this.currentUser && this.notifyAuthListeners() } _key() { return `${this.config.authDomain}:${this.config.apiKey}:${this.name}` } _startProactiveRefresh() { this.isProactiveRefreshEnabled = !0, this.currentUser && this._currentUser._startProactiveRefresh() } _stopProactiveRefresh() { this.isProactiveRefreshEnabled = !1, this.currentUser && this._currentUser._stopProactiveRefresh() } get _currentUser() { return this.currentUser } notifyAuthListeners() { var g, b; if (!this._isInitialized) return; this.idTokenSubscription.next(this.currentUser); const k = null !== (b = null === (g = this.currentUser) || void 0 === g ? void 0 : g.uid) && void 0 !== b ? b : null; this.lastNotifiedUid !== k && (this.lastNotifiedUid = k, this.authStateSubscription.next(this.currentUser)) } registerStateListener(g, b, k, oe) { if (this._deleted) return () => { }; const De = "function" == typeof b ? b : b.next.bind(b), Tt = this._isInitialized ? Promise.resolve() : this._initializationPromise; return ee(Tt, this, "internal-error"), Tt.then(() => De(this.currentUser)), "function" == typeof b ? g.addObserver(b, k, oe) : g.addObserver(b) } directlySetCurrentUser(g) { var b = this; return (0, a.Z)(function* () { b.currentUser && b.currentUser !== g && b._currentUser._stopProactiveRefresh(), g && b.isProactiveRefreshEnabled && g._startProactiveRefresh(), b.currentUser = g, g ? yield b.assertedPersistence.setCurrentUser(g) : yield b.assertedPersistence.removeCurrentUser() })() } queue(g) { return this.operations = this.operations.then(g, g), this.operations } get assertedPersistence() { return ee(this.persistenceManager, this, "internal-error"), this.persistenceManager } _logFramework(g) { !g || this.frameworks.includes(g) || (this.frameworks.push(g), this.frameworks.sort(), this.clientVersion = un(this.config.clientPlatform, this._getFrameworks())) } _getFrameworks() { return this.frameworks } _getAdditionalHeaders() { var g = this; return (0, a.Z)(function* () { var b; const k = { "X-Client-Version": g.clientVersion }; g.app.options.appId && (k["X-Firebase-gmpid"] = g.app.options.appId); const oe = yield null === (b = g.heartbeatServiceProvider.getImmediate({ optional: !0 })) || void 0 === b ? void 0 : b.getHeartbeatsHeader(); oe && (k["X-Firebase-Client"] = oe); const De = yield g._getAppCheckToken(); return De && (k["X-Firebase-AppCheck"] = De), k })() } _getAppCheckToken() { var g = this; return (0, a.Z)(function* () { var b; const k = yield null === (b = g.appCheckServiceProvider.getImmediate({ optional: !0 })) || void 0 === b ? void 0 : b.getToken(); return k?.error && function Ye(T, ...g) { tt.logLevel <= he.in.WARN && tt.warn(`Auth (${v.SDK_VERSION}): ${T}`, ...g) }(`Error while retrieving App Check token: ${k.error}`), k?.token })() } } function Vi(T) { return (0, y.m9)(T) } class cs { constructor(g) { this.auth = g, this.observer = null, this.addObserver = (0, y.ne)(b => this.observer = b) } get next() { return ee(this.observer, this.auth, "internal-error"), this.observer.next.bind(this.observer) } } function sr(T, g, b) { const k = Vi(T); ee(k._canInitEmulator, k, "emulator-config-failed"), ee(/^https?:\/\//.test(g), k, "invalid-emulator-scheme"); const oe = !!b?.disableWarnings, De = wt(g), { host: Tt, port: Xt } = function bt(T) { const g = wt(T), b = /(\/\/)?([^?#/]+)/.exec(T.substr(g.length)); if (!b) return { host: "", port: null }; const k = b[2].split("@").pop() || "", oe = /^(\[[^\]]+\])(:|$)/.exec(k); if (oe) { const De = oe[1]; return { host: De, port: Rt(k.substr(De.length + 1)) } } { const [De, Tt] = k.split(":"); return { host: De, port: Rt(Tt) } } }(g); k.config.emulator = { url: `${De}//${Tt}${null === Xt ? "" : `:${Xt}`}/` }, k.settings.appVerificationDisabledForTesting = !0, k.emulatorConfig = Object.freeze({ host: Tt, port: Xt, protocol: De.replace(":", ""), options: Object.freeze({ disableWarnings: oe }) }), oe || function sn() { function T() { const g = document.createElement("p"), b = g.style; g.innerText = "Running in emulator mode. Do not use with production credentials.", b.position = "fixed", b.width = "100%", b.backgroundColor = "#ffffff", b.border = ".1em solid #000000", b.color = "#b50000", b.bottom = "0px", b.left = "0px", b.margin = "0px", b.zIndex = "10000", b.textAlign = "center", g.classList.add("firebase-emulator-warning"), document.body.appendChild(g) } typeof console < "u" && "function" == typeof console.info && console.info("WARNING: You are using the Auth Emulator, which is intended for local testing only.  Do not use with production credentials."), typeof window < "u" && typeof document < "u" && ("loading" === document.readyState ? window.addEventListener("DOMContentLoaded", T) : T()) }() } function wt(T) { const g = T.indexOf(":"); return g < 0 ? "" : T.substr(0, g + 1) } function Rt(T) { if (!T) return null; const g = Number(T); return isNaN(g) ? null : g } class wn { constructor(g, b) { this.providerId = g, this.signInMethod = b } toJSON() { return $e("not implemented") } _getIdTokenResponse(g) { return $e("not implemented") } _linkToIdToken(g, b) { return $e("not implemented") } _getReauthenticationResolver(g) { return $e("not implemented") } } function dt(T, g) { return Be.apply(this, arguments) } function Be() { return (Be = (0, a.Z)(function* (T, g) { return Ft(T, "POST", "/v1/accounts:resetPassword", it(T, g)) })).apply(this, arguments) } function ye(T, g) { return et.apply(this, arguments) } function et() { return (et = (0, a.Z)(function* (T, g) { return Ft(T, "POST", "/v1/accounts:update", g) })).apply(this, arguments) } function At() { return (At = (0, a.Z)(function* (T, g) { return Ft(T, "POST", "/v1/accounts:update", it(T, g)) })).apply(this, arguments) } function cn(T, g) { return Tn.apply(this, arguments) } function Tn() { return (Tn = (0, a.Z)(function* (T, g) { return tn(T, "POST", "/v1/accounts:signInWithPassword", it(T, g)) })).apply(this, arguments) } function ii(T, g) { return wi.apply(this, arguments) } function wi() { return (wi = (0, a.Z)(function* (T, g) { return Ft(T, "POST", "/v1/accounts:sendOobCode", it(T, g)) })).apply(this, arguments) } function Dr() { return (Dr = (0, a.Z)(function* (T, g) { return ii(T, g) })).apply(this, arguments) } function xr(T, g) { return Ko.apply(this, arguments) } function Ko() { return (Ko = (0, a.Z)(function* (T, g) { return ii(T, g) })).apply(this, arguments) } function mo(T, g) { return _i.apply(this, arguments) } function _i() { return (_i = (0, a.Z)(function* (T, g) { return ii(T, g) })).apply(this, arguments) } function ci() { return (ci = (0, a.Z)(function* (T, g) { return ii(T, g) })).apply(this, arguments) } function tr() { return (tr = (0, a.Z)(function* (T, g) { return tn(T, "POST", "/v1/accounts:signInWithEmailLink", it(T, g)) })).apply(this, arguments) } function nr() { return (nr = (0, a.Z)(function* (T, g) { return tn(T, "POST", "/v1/accounts:signInWithEmailLink", it(T, g)) })).apply(this, arguments) } class io extends wn { constructor(g, b, k, oe = null) { super("password", k), this._email = g, this._password = b, this._tenantId = oe } static _fromEmailAndPassword(g, b) { return new io(g, b, "password") } static _fromEmailAndCode(g, b, k = null) { return new io(g, b, "emailLink", k) } toJSON() { return { email: this._email, password: this._password, signInMethod: this.signInMethod, tenantId: this._tenantId } } static fromJSON(g) { const b = "string" == typeof g ? JSON.parse(g) : g; if (b?.email && b?.password) { if ("password" === b.signInMethod) return this._fromEmailAndPassword(b.email, b.password); if ("emailLink" === b.signInMethod) return this._fromEmailAndCode(b.email, b.password, b.tenantId) } return null } _getIdTokenResponse(g) { var b = this; return (0, a.Z)(function* () { var k; switch (b.signInMethod) { case "password": const oe = { returnSecureToken: !0, email: b._email, password: b._password, clientType: "CLIENT_TYPE_WEB" }; if (null !== (k = g._getRecaptchaConfig()) && void 0 !== k && k.emailPasswordEnabled) { const De = yield Pr(g, oe, "signInWithPassword"); return cn(g, De) } return cn(g, oe).catch(function () { var De = (0, a.Z)(function* (Tt) { if ("auth/missing-recaptcha-token" === Tt.code) { console.log("Sign-in with email address and password is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-in flow."); const Xt = yield Pr(g, oe, "signInWithPassword"); return cn(g, Xt) } return Promise.reject(Tt) }); return function (Tt) { return De.apply(this, arguments) } }()); case "emailLink": return function ki(T, g) { return tr.apply(this, arguments) }(g, { email: b._email, oobCode: b._password }); default: ie(g, "internal-error") } })() } _linkToIdToken(g, b) { var k = this; return (0, a.Z)(function* () { switch (k.signInMethod) { case "password": return ye(g, { idToken: b, returnSecureToken: !0, email: k._email, password: k._password }); case "emailLink": return function Lr(T, g) { return nr.apply(this, arguments) }(g, { idToken: b, email: k._email, oobCode: k._password }); default: ie(g, "internal-error") } })() } _getReauthenticationResolver(g) { return this._getIdTokenResponse(g) } } function di(T, g) { return qr.apply(this, arguments) } function qr() { return (qr = (0, a.Z)(function* (T, g) { return tn(T, "POST", "/v1/accounts:signInWithIdp", it(T, g)) })).apply(this, arguments) } class Xn extends wn { constructor() { super(...arguments), this.pendingToken = null } static _fromParams(g) { const b = new Xn(g.providerId, g.signInMethod); return g.idToken || g.accessToken ? (g.idToken && (b.idToken = g.idToken), g.accessToken && (b.accessToken = g.accessToken), g.nonce && !g.pendingToken && (b.nonce = g.nonce), g.pendingToken && (b.pendingToken = g.pendingToken)) : g.oauthToken && g.oauthTokenSecret ? (b.accessToken = g.oauthToken, b.secret = g.oauthTokenSecret) : ie("argument-error"), b } toJSON() { return { idToken: this.idToken, accessToken: this.accessToken, secret: this.secret, nonce: this.nonce, pendingToken: this.pendingToken, providerId: this.providerId, signInMethod: this.signInMethod } } static fromJSON(g) { const b = "string" == typeof g ? JSON.parse(g) : g, { providerId: k, signInMethod: oe } = b, De = (0, Y._T)(b, ["providerId", "signInMethod"]); if (!k || !oe) return null; const Tt = new Xn(k, oe); return Tt.idToken = De.idToken || void 0, Tt.accessToken = De.accessToken || void 0, Tt.secret = De.secret, Tt.nonce = De.nonce, Tt.pendingToken = De.pendingToken || null, Tt } _getIdTokenResponse(g) { return di(g, this.buildRequest()) } _linkToIdToken(g, b) { const k = this.buildRequest(); return k.idToken = b, di(g, k) } _getReauthenticationResolver(g) { const b = this.buildRequest(); return b.autoCreate = !1, di(g, b) } buildRequest() { const g = { requestUri: "http://localhost", returnSecureToken: !0 }; if (this.pendingToken) g.pendingToken = this.pendingToken; else { const b = {}; this.idToken && (b.id_token = this.idToken), this.accessToken && (b.access_token = this.accessToken), this.secret && (b.oauth_token_secret = this.secret), b.providerId = this.providerId, this.nonce && !this.pendingToken && (b.nonce = this.nonce), g.postBody = (0, y.xO)(b) } return g } } function Ao() { return (Ao = (0, a.Z)(function* (T, g) { return Ft(T, "POST", "/v1/accounts:sendVerificationCode", it(T, g)) })).apply(this, arguments) } function cr() { return (cr = (0, a.Z)(function* (T, g) { return tn(T, "POST", "/v1/accounts:signInWithPhoneNumber", it(T, g)) })).apply(this, arguments) } function ds() { return (ds = (0, a.Z)(function* (T, g) { const b = yield tn(T, "POST", "/v1/accounts:signInWithPhoneNumber", it(T, g)); if (b.temporaryProof) throw nt(T, "account-exists-with-different-credential", b); return b })).apply(this, arguments) } const oo = { USER_NOT_FOUND: "user-not-found" }; function es() { return (es = (0, a.Z)(function* (T, g) { return tn(T, "POST", "/v1/accounts:signInWithPhoneNumber", it(T, Object.assign(Object.assign({}, g), { operation: "REAUTH" })), oo) })).apply(this, arguments) } class Tr extends wn { constructor(g) { super("phone", "phone"), this.params = g } static _fromVerification(g, b) { return new Tr({ verificationId: g, verificationCode: b }) } static _fromTokenResponse(g, b) { return new Tr({ phoneNumber: g, temporaryProof: b }) } _getIdTokenResponse(g) { return function ko(T, g) { return cr.apply(this, arguments) }(g, this._makeVerificationRequest()) } _linkToIdToken(g, b) { return function Zo(T, g) { return ds.apply(this, arguments) }(g, Object.assign({ idToken: b }, this._makeVerificationRequest())) } _getReauthenticationResolver(g) { return function Qr(T, g) { return es.apply(this, arguments) }(g, this._makeVerificationRequest()) } _makeVerificationRequest() { const { temporaryProof: g, phoneNumber: b, verificationId: k, verificationCode: oe } = this.params; return g && b ? { temporaryProof: g, phoneNumber: b } : { sessionInfo: k, code: oe } } toJSON() { const g = { providerId: this.providerId }; return this.params.phoneNumber && (g.phoneNumber = this.params.phoneNumber), this.params.temporaryProof && (g.temporaryProof = this.params.temporaryProof), this.params.verificationCode && (g.verificationCode = this.params.verificationCode), this.params.verificationId && (g.verificationId = this.params.verificationId), g } static fromJSON(g) { "string" == typeof g && (g = JSON.parse(g)); const { verificationId: b, verificationCode: k, phoneNumber: oe, temporaryProof: De } = g; return k || b || oe || De ? new Tr({ verificationId: b, verificationCode: k, phoneNumber: oe, temporaryProof: De }) : null } } class so { constructor(g) { var b, k, oe, De, Tt, Xt; const Nn = (0, y.zd)((0, y.pd)(g)), zn = null !== (b = Nn.apiKey) && void 0 !== b ? b : null, vi = null !== (k = Nn.oobCode) && void 0 !== k ? k : null, hr = function Br(T) { switch (T) { case "recoverEmail": return "RECOVER_EMAIL"; case "resetPassword": return "PASSWORD_RESET"; case "signIn": return "EMAIL_SIGNIN"; case "verifyEmail": return "VERIFY_EMAIL"; case "verifyAndChangeEmail": return "VERIFY_AND_CHANGE_EMAIL"; case "revertSecondFactorAddition": return "REVERT_SECOND_FACTOR_ADDITION"; default: return null } }(null !== (oe = Nn.mode) && void 0 !== oe ? oe : null); ee(zn && vi && hr, "argument-error"), this.apiKey = zn, this.operation = hr, this.code = vi, this.continueUrl = null !== (De = Nn.continueUrl) && void 0 !== De ? De : null, this.languageCode = null !== (Tt = Nn.languageCode) && void 0 !== Tt ? Tt : null, this.tenantId = null !== (Xt = Nn.tenantId) && void 0 !== Xt ? Xt : null } static parseLink(g) { const b = function Yo(T) { const g = (0, y.zd)((0, y.pd)(T)).link, b = g ? (0, y.zd)((0, y.pd)(g)).deep_link_id : null, k = (0, y.zd)((0, y.pd)(T)).deep_link_id; return (k ? (0, y.zd)((0, y.pd)(k)).link : null) || k || b || g || T }(g); try { return new so(b) } catch { return null } } } let qo = (() => { class T { constructor() { this.providerId = T.PROVIDER_ID } static credential(b, k) { return io._fromEmailAndPassword(b, k) } static credentialWithLink(b, k) { const oe = so.parseLink(k); return ee(oe, "argument-error"), io._fromEmailAndCode(b, oe.code, oe.tenantId) } } return T.PROVIDER_ID = "password", T.EMAIL_PASSWORD_SIGN_IN_METHOD = "password", T.EMAIL_LINK_SIGN_IN_METHOD = "emailLink", T })(); class Ho { constructor(g) { this.providerId = g, this.defaultLanguageCode = null, this.customParameters = {} } setDefaultLanguage(g) { this.defaultLanguageCode = g } setCustomParameters(g) { return this.customParameters = g, this } getCustomParameters() { return this.customParameters } } class Ro extends Ho { constructor() { super(...arguments), this.scopes = [] } addScope(g) { return this.scopes.includes(g) || this.scopes.push(g), this } getScopes() { return [...this.scopes] } } class yo extends Ro { static credentialFromJSON(g) { const b = "string" == typeof g ? JSON.parse(g) : g; return ee("providerId" in b && "signInMethod" in b, "argument-error"), Xn._fromParams(b) } credential(g) { return this._credential(Object.assign(Object.assign({}, g), { nonce: g.rawNonce })) } _credential(g) { return ee(g.idToken || g.accessToken, "argument-error"), Xn._fromParams(Object.assign(Object.assign({}, g), { providerId: this.providerId, signInMethod: this.providerId })) } static credentialFromResult(g) { return yo.oauthCredentialFromTaggedObject(g) } static credentialFromError(g) { return yo.oauthCredentialFromTaggedObject(g.customData || {}) } static oauthCredentialFromTaggedObject({ _tokenResponse: g }) { if (!g) return null; const { oauthIdToken: b, oauthAccessToken: k, oauthTokenSecret: oe, pendingToken: De, nonce: Tt, providerId: Xt } = g; if (!k && !oe && !b && !De || !Xt) return null; try { return new yo(Xt)._credential({ idToken: b, accessToken: k, nonce: Tt, pendingToken: De }) } catch { return null } } } let zo = (() => { class T extends Ro { constructor() { super("facebook.com") } static credential(b) { return Xn._fromParams({ providerId: T.PROVIDER_ID, signInMethod: T.FACEBOOK_SIGN_IN_METHOD, accessToken: b }) } static credentialFromResult(b) { return T.credentialFromTaggedObject(b) } static credentialFromError(b) { return T.credentialFromTaggedObject(b.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: b }) { if (!b || !("oauthAccessToken" in b) || !b.oauthAccessToken) return null; try { return T.credential(b.oauthAccessToken) } catch { return null } } } return T.FACEBOOK_SIGN_IN_METHOD = "facebook.com", T.PROVIDER_ID = "facebook.com", T })(), Qo = (() => { class T extends Ro { constructor() { super("google.com"), this.addScope("profile") } static credential(b, k) { return Xn._fromParams({ providerId: T.PROVIDER_ID, signInMethod: T.GOOGLE_SIGN_IN_METHOD, idToken: b, accessToken: k }) } static credentialFromResult(b) { return T.credentialFromTaggedObject(b) } static credentialFromError(b) { return T.credentialFromTaggedObject(b.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: b }) { if (!b) return null; const { oauthIdToken: k, oauthAccessToken: oe } = b; if (!k && !oe) return null; try { return T.credential(k, oe) } catch { return null } } } return T.GOOGLE_SIGN_IN_METHOD = "google.com", T.PROVIDER_ID = "google.com", T })(), br = (() => { class T extends Ro { constructor() { super("github.com") } static credential(b) { return Xn._fromParams({ providerId: T.PROVIDER_ID, signInMethod: T.GITHUB_SIGN_IN_METHOD, accessToken: b }) } static credentialFromResult(b) { return T.credentialFromTaggedObject(b) } static credentialFromError(b) { return T.credentialFromTaggedObject(b.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: b }) { if (!b || !("oauthAccessToken" in b) || !b.oauthAccessToken) return null; try { return T.credential(b.oauthAccessToken) } catch { return null } } } return T.GITHUB_SIGN_IN_METHOD = "github.com", T.PROVIDER_ID = "github.com", T })(); class po extends wn { constructor(g, b) { super(g, g), this.pendingToken = b } _getIdTokenResponse(g) { return di(g, this.buildRequest()) } _linkToIdToken(g, b) { const k = this.buildRequest(); return k.idToken = b, di(g, k) } _getReauthenticationResolver(g) { const b = this.buildRequest(); return b.autoCreate = !1, di(g, b) } toJSON() { return { signInMethod: this.signInMethod, providerId: this.providerId, pendingToken: this.pendingToken } } static fromJSON(g) { const b = "string" == typeof g ? JSON.parse(g) : g, { providerId: k, signInMethod: oe, pendingToken: De } = b; return k && oe && De && k === oe ? new po(k, De) : null } static _create(g, b) { return new po(g, b) } buildRequest() { return { requestUri: "http://localhost", returnSecureToken: !0, pendingToken: this.pendingToken } } } class Gr extends Ho { constructor(g) { ee(g.startsWith("saml."), "argument-error"), super(g) } static credentialFromResult(g) { return Gr.samlCredentialFromTaggedObject(g) } static credentialFromError(g) { return Gr.samlCredentialFromTaggedObject(g.customData || {}) } static credentialFromJSON(g) { const b = po.fromJSON(g); return ee(b, "argument-error"), b } static samlCredentialFromTaggedObject({ _tokenResponse: g }) { if (!g) return null; const { pendingToken: b, providerId: k } = g; if (!b || !k) return null; try { return po._create(k, b) } catch { return null } } } let us = (() => { class T extends Ro { constructor() { super("twitter.com") } static credential(b, k) { return Xn._fromParams({ providerId: T.PROVIDER_ID, signInMethod: T.TWITTER_SIGN_IN_METHOD, oauthToken: b, oauthTokenSecret: k }) } static credentialFromResult(b) { return T.credentialFromTaggedObject(b) } static credentialFromError(b) { return T.credentialFromTaggedObject(b.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: b }) { if (!b) return null; const { oauthAccessToken: k, oauthTokenSecret: oe } = b; if (!k || !oe) return null; try { return T.credential(k, oe) } catch { return null } } } return T.TWITTER_SIGN_IN_METHOD = "twitter.com", T.PROVIDER_ID = "twitter.com", T })(); function dr(T, g) { return Wr.apply(this, arguments) } function Wr() { return (Wr = (0, a.Z)(function* (T, g) { return tn(T, "POST", "/v1/accounts:signUp", it(T, g)) })).apply(this, arguments) } class Ni { constructor(g) { this.user = g.user, this.providerId = g.providerId, this._tokenResponse = g._tokenResponse, this.operationType = g.operationType } static _fromIdTokenResponse(g, b, k, oe = !1) { return (0, a.Z)(function* () { const De = yield G._fromIdTokenResponse(g, k, oe), Tt = As(k); return new Ni({ user: De, providerId: Tt, _tokenResponse: k, operationType: b }) })() } static _forOperation(g, b, k) { return (0, a.Z)(function* () { yield g._updateTokensIfNecessary(k, !0); const oe = As(k); return new Ni({ user: g, providerId: oe, _tokenResponse: k, operationType: b }) })() } } function As(T) { return T.providerId ? T.providerId : "phoneNumber" in T ? "phone" : null } function ao(T) { return Xr.apply(this, arguments) } function Xr() { return (Xr = (0, a.Z)(function* (T) { var g; const b = Vi(T); if (yield b._initializationPromise, null !== (g = b.currentUser) && void 0 !== g && g.isAnonymous) return new Ni({ user: b.currentUser, providerId: null, operationType: "signIn" }); const k = yield dr(b, { returnSecureToken: !0 }), oe = yield Ni._fromIdTokenResponse(b, "signIn", k, !0); return yield b._updateCurrentUser(oe.user), oe })).apply(this, arguments) } class bs extends y.ZR { constructor(g, b, k, oe) { var De; super(b.code, b.message), this.operationType = k, this.user = oe, Object.setPrototypeOf(this, bs.prototype), this.customData = { appName: g.name, tenantId: null !== (De = g.tenantId) && void 0 !== De ? De : void 0, _serverResponse: b.customData._serverResponse, operationType: k } } static _fromErrorAndOperation(g, b, k, oe) { return new bs(g, b, k, oe) } } function ta(T, g, b, k) { return ("reauthenticate" === g ? b._getReauthenticationResolver(T) : b._getIdTokenResponse(T)).catch(De => { throw "auth/multi-factor-auth-required" === De.code ? bs._fromErrorAndOperation(T, De, g, k) : De }) } function Ci(T) { return new Set(T.map(({ providerId: g }) => g).filter(g => !!g)) } function ys(T, g) { return Da.apply(this, arguments) } function Da() { return Da = (0, a.Z)(function* (T, g) { const b = (0, y.m9)(T); yield ha(!0, b, g); const { providerUserInfo: k } = yield function Pt(T, g) { return qe.apply(this, arguments) }(b.auth, { idToken: yield b.getIdToken(), deleteProvider: [g] }), oe = Ci(k || []); return b.providerData = b.providerData.filter(De => oe.has(De.providerId)), oe.has("phone") || (b.phoneNumber = null), yield b.auth._persistUserIfCurrent(b), b }), Da.apply(this, arguments) } function Ws(T, g) { return na.apply(this, arguments) } function na() { return (na = (0, a.Z)(function* (T, g, b = !1) { const k = yield Xe(T, g._linkToIdToken(T.auth, yield T.getIdToken()), b); return Ni._forOperation(T, "link", k) })).apply(this, arguments) } function ha(T, g, b) { return fa.apply(this, arguments) } function fa() { return (fa = (0, a.Z)(function* (T, g, b) { yield Fe(g); const oe = !1 === T ? "provider-already-linked" : "no-such-provider"; ee(Ci(g.providerData).has(b) === T, g.auth, oe) })).apply(this, arguments) } function ws(T, g) { return is.apply(this, arguments) } function is() { return (is = (0, a.Z)(function* (T, g, b = !1) { const { auth: k } = T, oe = "reauthenticate"; try { const De = yield Xe(T, ta(k, oe, g, T), b); ee(De.idToken, k, "internal-error"); const Tt = se(De.idToken); ee(Tt, k, "internal-error"); const { sub: Xt } = Tt; return ee(T.uid === Xt, k, "user-mismatch"), Ni._forOperation(T, oe, De) } catch (De) { throw "auth/user-not-found" === De?.code && ie(k, "user-mismatch"), De } })).apply(this, arguments) } function Ks(T, g) { return jo.apply(this, arguments) } function jo() { return (jo = (0, a.Z)(function* (T, g, b = !1) { const k = "signIn", oe = yield ta(T, k, g), De = yield Ni._fromIdTokenResponse(T, k, oe); return b || (yield T._updateCurrentUser(De.user)), De })).apply(this, arguments) } function K(T, g) { return V.apply(this, arguments) } function V() { return (V = (0, a.Z)(function* (T, g) { return Ks(Vi(T), g) })).apply(this, arguments) } function w(T, g) { return D.apply(this, arguments) } function D() { return (D = (0, a.Z)(function* (T, g) { const b = (0, y.m9)(T); return yield ha(!1, b, g.providerId), Ws(b, g) })).apply(this, arguments) } function ne(T, g) { return Re.apply(this, arguments) } function Re() { return (Re = (0, a.Z)(function* (T, g) { return ws((0, y.m9)(T), g) })).apply(this, arguments) } function kt() { return (kt = (0, a.Z)(function* (T, g) { return tn(T, "POST", "/v1/accounts:signInWithCustomToken", it(T, g)) })).apply(this, arguments) } function mn(T, g) { return Gn.apply(this, arguments) } function Gn() { return Gn = (0, a.Z)(function* (T, g) { const b = Vi(T), k = yield function mt(T, g) { return kt.apply(this, arguments) }(b, { token: g, returnSecureToken: !0 }), oe = yield Ni._fromIdTokenResponse(b, "signIn", k); return yield b._updateCurrentUser(oe.user), oe }), Gn.apply(this, arguments) } class jn { constructor(g, b) { this.factorId = g, this.uid = b.mfaEnrollmentId, this.enrollmentTime = new Date(b.enrolledAt).toUTCString(), this.displayName = b.displayName } static _fromServerResponse(g, b) { return "phoneInfo" in b ? gi._fromServerResponse(g, b) : "totpInfo" in b ? Ii._fromServerResponse(g, b) : ie(g, "internal-error") } } class gi extends jn { constructor(g) { super("phone", g), this.phoneNumber = g.phoneInfo } static _fromServerResponse(g, b) { return new gi(b) } } class Ii extends jn { constructor(g) { super("totp", g) } static _fromServerResponse(g, b) { return new Ii(b) } } function Zi(T, g, b) { var k; ee((null === (k = b.url) || void 0 === k ? void 0 : k.length) > 0, T, "invalid-continue-uri"), ee(typeof b.dynamicLinkDomain > "u" || b.dynamicLinkDomain.length > 0, T, "invalid-dynamic-link-domain"), g.continueUrl = b.url, g.dynamicLinkDomain = b.dynamicLinkDomain, g.canHandleCodeInApp = b.handleCodeInApp, b.iOS && (ee(b.iOS.bundleId.length > 0, T, "missing-ios-bundle-id"), g.iOSBundleId = b.iOS.bundleId), b.android && (ee(b.android.packageName.length > 0, T, "missing-android-pkg-name"), g.androidInstallApp = b.android.installApp, g.androidMinimumVersionCode = b.android.minimumVersion, g.androidPackageName = b.android.packageName) } function ji(T, g, b) { return Bi.apply(this, arguments) } function Bi() { return Bi = (0, a.Z)(function* (T, g, b) { var k; const oe = Vi(T), De = { requestType: "PASSWORD_RESET", email: g, clientType: "CLIENT_TYPE_WEB" }; if (null !== (k = oe._getRecaptchaConfig()) && void 0 !== k && k.emailPasswordEnabled) { const Tt = yield Pr(oe, De, "getOobCode", !0); b && Zi(oe, Tt, b), yield xr(oe, Tt) } else b && Zi(oe, De, b), yield xr(oe, De).catch(function () { var Tt = (0, a.Z)(function* (Xt) { if ("auth/missing-recaptcha-token" !== Xt.code) return Promise.reject(Xt); { console.log("Password resets are protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the password reset flow."); const Nn = yield Pr(oe, De, "getOobCode", !0); b && Zi(oe, Nn, b), yield xr(oe, Nn) } }); return function (Xt) { return Tt.apply(this, arguments) } }()) }), Bi.apply(this, arguments) } function ir(T, g, b) { return ar.apply(this, arguments) } function ar() { return (ar = (0, a.Z)(function* (T, g, b) { yield dt((0, y.m9)(T), { oobCode: g, newPassword: b }) })).apply(this, arguments) } function gr(T, g) { return Yi.apply(this, arguments) } function Yi() { return Yi = (0, a.Z)(function* (T, g) { yield function Vt(T, g) { return At.apply(this, arguments) }((0, y.m9)(T), { oobCode: g }) }), Yi.apply(this, arguments) } function Kr(T, g) { return Mr.apply(this, arguments) } function Mr() { return (Mr = (0, a.Z)(function* (T, g) { const b = (0, y.m9)(T), k = yield dt(b, { oobCode: g }), oe = k.requestType; switch (ee(oe, b, "internal-error"), oe) { case "EMAIL_SIGNIN": break; case "VERIFY_AND_CHANGE_EMAIL": ee(k.newEmail, b, "internal-error"); break; case "REVERT_SECOND_FACTOR_ADDITION": ee(k.mfaInfo, b, "internal-error"); default: ee(k.email, b, "internal-error") }let De = null; return k.mfaInfo && (De = jn._fromServerResponse(Vi(b), k.mfaInfo)), { data: { email: ("VERIFY_AND_CHANGE_EMAIL" === k.requestType ? k.newEmail : k.email) || null, previousEmail: ("VERIFY_AND_CHANGE_EMAIL" === k.requestType ? k.email : k.newEmail) || null, multiFactorInfo: De }, operation: oe } })).apply(this, arguments) } function Sr(T, g) { return Do.apply(this, arguments) } function Do() { return (Do = (0, a.Z)(function* (T, g) { const { data: b } = yield Kr((0, y.m9)(T), g); return b.email })).apply(this, arguments) } function $o(T, g, b) { return hs.apply(this, arguments) } function hs() { return hs = (0, a.Z)(function* (T, g, b) { var k; const oe = Vi(T), De = { returnSecureToken: !0, email: g, password: b, clientType: "CLIENT_TYPE_WEB" }; let Tt; if (null !== (k = oe._getRecaptchaConfig()) && void 0 !== k && k.emailPasswordEnabled) { const zn = yield Pr(oe, De, "signUpPassword"); Tt = dr(oe, zn) } else Tt = dr(oe, De).catch(function () { var zn = (0, a.Z)(function* (vi) { if ("auth/missing-recaptcha-token" === vi.code) { console.log("Sign-up is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-up flow."); const hr = yield Pr(oe, De, "signUpPassword"); return dr(oe, hr) } return Promise.reject(vi) }); return function (vi) { return zn.apply(this, arguments) } }()); const Xt = yield Tt.catch(zn => Promise.reject(zn)), Nn = yield Ni._fromIdTokenResponse(oe, "signIn", Xt); return yield oe._updateCurrentUser(Nn.user), Nn }), hs.apply(this, arguments) } function rs(T, g, b) { return K((0, y.m9)(T), qo.credential(g, b)) } function Jr(T, g, b) { return os.apply(this, arguments) } function os() { return os = (0, a.Z)(function* (T, g, b) { var k; const oe = Vi(T), De = { requestType: "EMAIL_SIGNIN", email: g, clientType: "CLIENT_TYPE_WEB" }; function Tt(Xt, Nn) { ee(Nn.handleCodeInApp, oe, "argument-error"), Nn && Zi(oe, Xt, Nn) } if (null !== (k = oe._getRecaptchaConfig()) && void 0 !== k && k.emailPasswordEnabled) { const Xt = yield Pr(oe, De, "getOobCode", !0); Tt(Xt, b), yield mo(oe, Xt) } else Tt(De, b), yield mo(oe, De).catch(function () { var Xt = (0, a.Z)(function* (Nn) { if ("auth/missing-recaptcha-token" !== Nn.code) return Promise.reject(Nn); { console.log("Email link sign-in is protected by reCAPTCHA for this project. Automatically triggering the reCAPTCHA flow and restarting the sign-in flow."); const zn = yield Pr(oe, De, "getOobCode", !0); Tt(zn, b), yield mo(oe, zn) } }); return function (Nn) { return Xt.apply(this, arguments) } }()) }), os.apply(this, arguments) } function Ka(T, g) { const b = so.parseLink(g); return "EMAIL_SIGNIN" === b?.operation } function ks(T, g, b) { return sl.apply(this, arguments) } function sl() { return (sl = (0, a.Z)(function* (T, g, b) { const k = (0, y.m9)(T), oe = qo.credentialWithLink(g, b || Kt()); return ee(oe._tenantId === (k.tenantId || null), k, "tenant-id-mismatch"), K(k, oe) })).apply(this, arguments) } function Za() { return (Za = (0, a.Z)(function* (T, g) { return Ft(T, "POST", "/v1/accounts:createAuthUri", it(T, g)) })).apply(this, arguments) } function _r(T, g) { return ma.apply(this, arguments) } function ma() { return ma = (0, a.Z)(function* (T, g) { const k = { identifier: g, continueUri: bn() ? Kt() : "http://localhost" }, { signinMethods: oe } = yield function fs(T, g) { return Za.apply(this, arguments) }((0, y.m9)(T), k); return oe || [] }), ma.apply(this, arguments) } function Ya(T, g) { return To.apply(this, arguments) } function To() { return To = (0, a.Z)(function* (T, g) { const b = (0, y.m9)(T), oe = { requestType: "VERIFY_EMAIL", idToken: yield T.getIdToken() }; g && Zi(b.auth, oe, g); const { email: De } = yield function Xi(T, g) { return Dr.apply(this, arguments) }(b.auth, oe); De !== T.email && (yield T.reload()) }), To.apply(this, arguments) } function pa(T, g, b) { return ia.apply(this, arguments) } function ia() { return ia = (0, a.Z)(function* (T, g, b) { const k = (0, y.m9)(T), De = { requestType: "VERIFY_AND_CHANGE_EMAIL", idToken: yield T.getIdToken(), newEmail: g }; b && Zi(k.auth, De, b); const { email: Tt } = yield function Sn(T, g) { return ci.apply(this, arguments) }(k.auth, De); Tt !== T.email && (yield T.reload()) }), ia.apply(this, arguments) } function Ta() { return (Ta = (0, a.Z)(function* (T, g) { return Ft(T, "POST", "/v1/accounts:update", g) })).apply(this, arguments) } function Ma(T, g) { return ms.apply(this, arguments) } function ms() { return ms = (0, a.Z)(function* (T, { displayName: g, photoURL: b }) { if (void 0 === g && void 0 === b) return; const k = (0, y.m9)(T), De = { idToken: yield k.getIdToken(), displayName: g, photoUrl: b, returnSecureToken: !0 }, Tt = yield Xe(k, function Bs(T, g) { return Ta.apply(this, arguments) }(k.auth, De)); k.displayName = Tt.displayName || null, k.photoURL = Tt.photoUrl || null; const Xt = k.providerData.find(({ providerId: Nn }) => "password" === Nn); Xt && (Xt.displayName = k.displayName, Xt.photoURL = k.photoURL), yield k._updateTokensIfNecessary(Tt) }), ms.apply(this, arguments) } function ts(T, g) { return Rs((0, y.m9)(T), g, null) } function lo(T, g) { return Rs((0, y.m9)(T), null, g) } function Rs(T, g, b) { return go.apply(this, arguments) } function go() { return (go = (0, a.Z)(function* (T, g, b) { const { auth: k } = T, De = { idToken: yield T.getIdToken(), returnSecureToken: !0 }; g && (De.email = g), b && (De.password = b); const Tt = yield Xe(T, ye(k, De)); yield T._updateTokensIfNecessary(Tt, !0) })).apply(this, arguments) } class xs { constructor(g, b, k = {}) { this.isNewUser = g, this.providerId = b, this.profile = k } } class yr extends xs { constructor(g, b, k, oe) { super(g, b, k), this.username = oe } } class Oo extends xs { constructor(g, b) { super(g, "facebook.com", b) } } class P extends yr { constructor(g, b) { super(g, "github.com", b, "string" == typeof b?.login ? b?.login : null) } } class X extends xs { constructor(g, b) { super(g, "google.com", b) } } class B extends yr { constructor(g, b, k) { super(g, "twitter.com", b, k) } } function be(T) { const { user: g, _tokenResponse: b } = T; return g.isAnonymous && !b ? { providerId: null, isNewUser: !1, profile: null } : function Os(T) { var g, b; if (!T) return null; const { providerId: k } = T, oe = T.rawUserInfo ? JSON.parse(T.rawUserInfo) : {}, De = T.isNewUser || "identitytoolkit#SignupNewUserResponse" === T.kind; if (!k && T?.idToken) { const Tt = null === (b = null === (g = se(T.idToken)) || void 0 === g ? void 0 : g.firebase) || void 0 === b ? void 0 : b.sign_in_provider; if (Tt) return new xs(De, "anonymous" !== Tt && "custom" !== Tt ? Tt : null) } if (!k) return null; switch (k) { case "facebook.com": return new Oo(De, oe); case "github.com": return new P(De, oe); case "google.com": return new X(De, oe); case "twitter.com": return new B(De, oe, T.screenName || null); case "custom": case "anonymous": return new xs(De, null); default: return new xs(De, k, oe) } }(b) } class rr { constructor(g, b, k) { this.type = g, this.credential = b, this.auth = k } static _fromIdtoken(g, b) { return new rr("enroll", g, b) } static _fromMfaPendingCredential(g) { return new rr("signin", g) } toJSON() { return { multiFactorSession: { ["enroll" === this.type ? "idToken" : "pendingCredential"]: this.credential } } } static fromJSON(g) { var b, k; if (g?.multiFactorSession) { if (null !== (b = g.multiFactorSession) && void 0 !== b && b.pendingCredential) return rr._fromMfaPendingCredential(g.multiFactorSession.pendingCredential); if (null !== (k = g.multiFactorSession) && void 0 !== k && k.idToken) return rr._fromIdtoken(g.multiFactorSession.idToken) } return null } } class lr { constructor(g, b, k) { this.session = g, this.hints = b, this.signInResolver = k } static _fromError(g, b) { const k = Vi(g), oe = b.customData._serverResponse, De = (oe.mfaInfo || []).map(Xt => jn._fromServerResponse(k, Xt)); ee(oe.mfaPendingCredential, k, "internal-error"); const Tt = rr._fromMfaPendingCredential(oe.mfaPendingCredential); return new lr(Tt, De, function () { var Xt = (0, a.Z)(function* (Nn) { const zn = yield Nn._process(k, Tt); delete oe.mfaInfo, delete oe.mfaPendingCredential; const vi = Object.assign(Object.assign({}, oe), { idToken: zn.idToken, refreshToken: zn.refreshToken }); switch (b.operationType) { case "signIn": const hr = yield Ni._fromIdTokenResponse(k, b.operationType, vi); return yield k._updateCurrentUser(hr.user), hr; case "reauthenticate": return ee(b.user, k, "internal-error"), Ni._forOperation(b.user, b.operationType, vi); default: ie(k, "internal-error") } }); return function (Nn) { return Xt.apply(this, arguments) } }()) } resolveSignIn(g) { var b = this; return (0, a.Z)(function* () { return b.signInResolver(g) })() } } function ui(T, g) { var b; const k = (0, y.m9)(T), oe = g; return ee(g.customData.operationType, k, "argument-error"), ee(null === (b = oe.customData._serverResponse) || void 0 === b ? void 0 : b.mfaPendingCredential, k, "argument-error"), lr._fromError(k, oe) } class ai { constructor(g) { this.user = g, this.enrolledFactors = [], g._onReload(b => { b.mfaInfo && (this.enrolledFactors = b.mfaInfo.map(k => jn._fromServerResponse(g.auth, k))) }) } static _fromUser(g) { return new ai(g) } getSession() { var g = this; return (0, a.Z)(function* () { return rr._fromIdtoken(yield g.user.getIdToken(), g.user.auth) })() } enroll(g, b) { var k = this; return (0, a.Z)(function* () { const oe = g, De = yield k.getSession(), Tt = yield Xe(k.user, oe._process(k.user.auth, De, b)); return yield k.user._updateTokensIfNecessary(Tt), k.user.reload() })() } unenroll(g) { var b = this; return (0, a.Z)(function* () { const k = "string" == typeof g ? g : g.uid, oe = yield b.user.getIdToken(); try { const De = yield Xe(b.user, function Cn(T, g) { return Ft(T, "POST", "/v2/accounts/mfaEnrollment:withdraw", it(T, g)) }(b.user.auth, { idToken: oe, mfaEnrollmentId: k })); b.enrolledFactors = b.enrolledFactors.filter(({ uid: Tt }) => Tt !== k), yield b.user._updateTokensIfNecessary(De), yield b.user.reload() } catch (De) { throw De } })() } } const co = new WeakMap; function Un(T) { const g = (0, y.m9)(T); return co.has(g) || co.set(g, ai._fromUser(g)), co.get(g) } const Yt = "__sak"; class _n { constructor(g, b) { this.storageRetriever = g, this.type = b } _isAvailable() { try { return this.storage ? (this.storage.setItem(Yt, "1"), this.storage.removeItem(Yt), Promise.resolve(!0)) : Promise.resolve(!1) } catch { return Promise.resolve(!1) } } _set(g, b) { return this.storage.setItem(g, JSON.stringify(b)), Promise.resolve() } _get(g) { const b = this.storage.getItem(g); return Promise.resolve(b ? JSON.parse(b) : null) } _remove(g) { return this.storage.removeItem(g), Promise.resolve() } get storage() { return this.storageRetriever() } } const Cl = (() => { class T extends _n { constructor() { super(() => window.localStorage, "LOCAL"), this.boundEventHandler = (b, k) => this.onStorageEvent(b, k), this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.safariLocalStorageNotSynced = function eo() { const T = (0, y.z$)(); return L(T) || F(T) }() && function Ht() { try { return !(!window || window === window.top) } catch { return !1 } }(), this.fallbackToPolling = gt(), this._shouldAllowMigration = !0 } forAllChangedKeys(b) { for (const k of Object.keys(this.listeners)) { const oe = this.storage.getItem(k), De = this.localCache[k]; oe !== De && b(k, De, oe) } } onStorageEvent(b, k = !1) { if (!b.key) return void this.forAllChangedKeys((Xt, Nn, zn) => { this.notifyListeners(Xt, zn) }); const oe = b.key; if (k ? this.detachListener() : this.stopPolling(), this.safariLocalStorageNotSynced) { const Xt = this.storage.getItem(oe); if (b.newValue !== Xt) null !== b.newValue ? this.storage.setItem(oe, b.newValue) : this.storage.removeItem(oe); else if (this.localCache[oe] === b.newValue && !k) return } const De = () => { const Xt = this.storage.getItem(oe); !k && this.localCache[oe] === Xt || this.notifyListeners(oe, Xt) }, Tt = this.storage.getItem(oe); !function lt() { return (0, y.w1)() && 10 === document.documentMode }() || Tt === b.newValue || b.newValue === b.oldValue ? De() : setTimeout(De, 10) } notifyListeners(b, k) { this.localCache[b] = k; const oe = this.listeners[b]; if (oe) for (const De of Array.from(oe)) De(k && JSON.parse(k)) } startPolling() { this.stopPolling(), this.pollTimer = setInterval(() => { this.forAllChangedKeys((b, k, oe) => { this.onStorageEvent(new StorageEvent("storage", { key: b, oldValue: k, newValue: oe }), !0) }) }, 1e3) } stopPolling() { this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null) } attachListener() { window.addEventListener("storage", this.boundEventHandler) } detachListener() { window.removeEventListener("storage", this.boundEventHandler) } _addListener(b, k) { 0 === Object.keys(this.listeners).length && (this.fallbackToPolling ? this.startPolling() : this.attachListener()), this.listeners[b] || (this.listeners[b] = new Set, this.localCache[b] = this.storage.getItem(b)), this.listeners[b].add(k) } _removeListener(b, k) { this.listeners[b] && (this.listeners[b].delete(k), 0 === this.listeners[b].size && delete this.listeners[b]), 0 === Object.keys(this.listeners).length && (this.detachListener(), this.stopPolling()) } _set(b, k) { var oe = () => super._set, De = this; return (0, a.Z)(function* () { yield oe().call(De, b, k), De.localCache[b] = JSON.stringify(k) })() } _get(b) { var k = () => super._get, oe = this; return (0, a.Z)(function* () { const De = yield k().call(oe, b); return oe.localCache[b] = JSON.stringify(De), De })() } _remove(b) { var k = () => super._remove, oe = this; return (0, a.Z)(function* () { yield k().call(oe, b), delete oe.localCache[b] })() } } return T.type = "LOCAL", T })(), xo = (() => { class T extends _n { constructor() { super(() => window.sessionStorage, "SESSION") } _addListener(b, k) { } _removeListener(b, k) { } } return T.type = "SESSION", T })(); let ga = (() => { class T { constructor(b) { this.eventTarget = b, this.handlersMap = {}, this.boundEventHandler = this.handleEvent.bind(this) } static _getInstance(b) { const k = this.receivers.find(De => De.isListeningto(b)); if (k) return k; const oe = new T(b); return this.receivers.push(oe), oe } isListeningto(b) { return this.eventTarget === b } handleEvent(b) { var k = this; return (0, a.Z)(function* () { const oe = b, { eventId: De, eventType: Tt, data: Xt } = oe.data, Nn = k.handlersMap[Tt]; if (!Nn?.size) return; oe.ports[0].postMessage({ status: "ack", eventId: De, eventType: Tt }); const zn = Array.from(Nn).map(function () { var hr = (0, a.Z)(function* ($s) { return $s(oe.origin, Xt) }); return function ($s) { return hr.apply(this, arguments) } }()), vi = yield function qa(T) { return Promise.all(T.map(function () { var g = (0, a.Z)(function* (b) { try { return { fulfilled: !0, value: yield b } } catch (k) { return { fulfilled: !1, reason: k } } }); return function (b) { return g.apply(this, arguments) } }())) }(zn); oe.ports[0].postMessage({ status: "done", eventId: De, eventType: Tt, response: vi }) })() } _subscribe(b, k) { 0 === Object.keys(this.handlersMap).length && this.eventTarget.addEventListener("message", this.boundEventHandler), this.handlersMap[b] || (this.handlersMap[b] = new Set), this.handlersMap[b].add(k) } _unsubscribe(b, k) { this.handlersMap[b] && k && this.handlersMap[b].delete(k), (!k || 0 === this.handlersMap[b].size) && delete this.handlersMap[b], 0 === Object.keys(this.handlersMap).length && this.eventTarget.removeEventListener("message", this.boundEventHandler) } } return T.receivers = [], T })(); function ps(T = "", g = 10) { let b = ""; for (let k = 0; k < g; k++)b += Math.floor(10 * Math.random()); return T + b } class Qa { constructor(g) { this.target = g, this.handlers = new Set } removeMessageHandler(g) { g.messageChannel && (g.messageChannel.port1.removeEventListener("message", g.onMessage), g.messageChannel.port1.close()), this.handlers.delete(g) } _send(g, b, k = 50) { var oe = this; return (0, a.Z)(function* () { const De = typeof MessageChannel < "u" ? new MessageChannel : null; if (!De) throw new Error("connection_unavailable"); let Tt, Xt; return new Promise((Nn, zn) => { const vi = ps("", 20); De.port1.start(); const hr = setTimeout(() => { zn(new Error("unsupported_event")) }, k); Xt = { messageChannel: De, onMessage($s) { const Xs = $s; if (Xs.data.eventId === vi) switch (Xs.data.status) { case "ack": clearTimeout(hr), Tt = setTimeout(() => { zn(new Error("timeout")) }, 3e3); break; case "done": clearTimeout(Tt), Nn(Xs.data.response); break; default: clearTimeout(hr), clearTimeout(Tt), zn(new Error("invalid_response")) } } }, oe.handlers.add(Xt), De.port1.addEventListener("message", Xt.onMessage), oe.target.postMessage({ eventType: g, eventId: vi, data: b }, [De.port2]) }).finally(() => { Xt && oe.removeMessageHandler(Xt) }) })() } } function Vr() { return window } function _a() { return typeof Vr().WorkerGlobalScope < "u" && "function" == typeof Vr().importScripts } function Ri() { return (Ri = (0, a.Z)(function* () { if (!navigator?.serviceWorker) return null; try { return (yield navigator.serviceWorker.ready).active } catch { return null } })).apply(this, arguments) } const Pi = "firebaseLocalStorageDb", Hr = "firebaseLocalStorage", Bn = "fbase_key"; class Vs { constructor(g) { this.request = g } toPromise() { return new Promise((g, b) => { this.request.addEventListener("success", () => { g(this.request.result) }), this.request.addEventListener("error", () => { b(this.request.error) }) }) } } function Zs(T, g) { return T.transaction([Hr], g ? "readwrite" : "readonly").objectStore(Hr) } function Sa() { const T = indexedDB.open(Pi, 1); return new Promise((g, b) => { T.addEventListener("error", () => { b(T.error) }), T.addEventListener("upgradeneeded", () => { const k = T.result; try { k.createObjectStore(Hr, { keyPath: Bn }) } catch (oe) { b(oe) } }), T.addEventListener("success", (0, a.Z)(function* () { const k = T.result; k.objectStoreNames.contains(Hr) ? g(k) : (k.close(), yield function Ys() { const T = indexedDB.deleteDatabase(Pi); return new Vs(T).toPromise() }(), g(yield Sa())) })) }) } function Ba(T, g, b) { return Aa.apply(this, arguments) } function Aa() { return (Aa = (0, a.Z)(function* (T, g, b) { const k = Zs(T, !0).put({ [Bn]: g, value: b }); return new Vs(k).toPromise() })).apply(this, arguments) } function va() { return (va = (0, a.Z)(function* (T, g) { const b = Zs(T, !1).get(g), k = yield new Vs(b).toPromise(); return void 0 === k ? null : k.value })).apply(this, arguments) } function Xa(T, g) { const b = Zs(T, !0).delete(g); return new Vs(b).toPromise() } const ul = (() => { class T { constructor() { this.type = "LOCAL", this._shouldAllowMigration = !0, this.listeners = {}, this.localCache = {}, this.pollTimer = null, this.pendingWrites = 0, this.receiver = null, this.sender = null, this.serviceWorkerReceiverAvailable = !1, this.activeServiceWorker = null, this._workerInitializationPromise = this.initializeServiceWorkerMessaging().then(() => { }, () => { }) } _openDb() { var b = this; return (0, a.Z)(function* () { return b.db || (b.db = yield Sa()), b.db })() } _withRetries(b) { var k = this; return (0, a.Z)(function* () { let oe = 0; for (; ;)try { const De = yield k._openDb(); return yield b(De) } catch (De) { if (oe++ > 3) throw De; k.db && (k.db.close(), k.db = void 0) } })() } initializeServiceWorkerMessaging() { var b = this; return (0, a.Z)(function* () { return _a() ? b.initializeReceiver() : b.initializeSender() })() } initializeReceiver() { var b = this; return (0, a.Z)(function* () { b.receiver = ga._getInstance(function ra() { return _a() ? self : null }()), b.receiver._subscribe("keyChanged", function () { var k = (0, a.Z)(function* (oe, De) { return { keyProcessed: (yield b._poll()).includes(De.key) } }); return function (oe, De) { return k.apply(this, arguments) } }()), b.receiver._subscribe("ping", function () { var k = (0, a.Z)(function* (oe, De) { return ["keyChanged"] }); return function (oe, De) { return k.apply(this, arguments) } }()) })() } initializeSender() { var b = this; return (0, a.Z)(function* () { var k, oe; if (b.activeServiceWorker = yield function ll() { return Ri.apply(this, arguments) }(), !b.activeServiceWorker) return; b.sender = new Qa(b.activeServiceWorker); const De = yield b.sender._send("ping", {}, 800); De && null !== (k = De[0]) && void 0 !== k && k.fulfilled && null !== (oe = De[0]) && void 0 !== oe && oe.value.includes("keyChanged") && (b.serviceWorkerReceiverAvailable = !0) })() } notifyServiceWorker(b) { var k = this; return (0, a.Z)(function* () { if (k.sender && k.activeServiceWorker && function Jn() { var T; return (null === (T = navigator?.serviceWorker) || void 0 === T ? void 0 : T.controller) || null }() === k.activeServiceWorker) try { yield k.sender._send("keyChanged", { key: b }, k.serviceWorkerReceiverAvailable ? 800 : 50) } catch { } })() } _isAvailable() { return (0, a.Z)(function* () { try { if (!indexedDB) return !1; const b = yield Sa(); return yield Ba(b, Yt, "1"), yield Xa(b, Yt), !0 } catch { } return !1 })() } _withPendingWrite(b) { var k = this; return (0, a.Z)(function* () { k.pendingWrites++; try { yield b() } finally { k.pendingWrites-- } })() } _set(b, k) { var oe = this; return (0, a.Z)(function* () { return oe._withPendingWrite((0, a.Z)(function* () { return yield oe._withRetries(De => Ba(De, b, k)), oe.localCache[b] = k, oe.notifyServiceWorker(b) })) })() } _get(b) { var k = this; return (0, a.Z)(function* () { const oe = yield k._withRetries(De => function ka(T, g) { return va.apply(this, arguments) }(De, b)); return k.localCache[b] = oe, oe })() } _remove(b) { var k = this; return (0, a.Z)(function* () { return k._withPendingWrite((0, a.Z)(function* () { return yield k._withRetries(oe => Xa(oe, b)), delete k.localCache[b], k.notifyServiceWorker(b) })) })() } _poll() { var b = this; return (0, a.Z)(function* () { const k = yield b._withRetries(Tt => { const Xt = Zs(Tt, !1).getAll(); return new Vs(Xt).toPromise() }); if (!k) return []; if (0 !== b.pendingWrites) return []; const oe = [], De = new Set; for (const { fbase_key: Tt, value: Xt } of k) De.add(Tt), JSON.stringify(b.localCache[Tt]) !== JSON.stringify(Xt) && (b.notifyListeners(Tt, Xt), oe.push(Tt)); for (const Tt of Object.keys(b.localCache)) b.localCache[Tt] && !De.has(Tt) && (b.notifyListeners(Tt, null), oe.push(Tt)); return oe })() } notifyListeners(b, k) { this.localCache[b] = k; const oe = this.listeners[b]; if (oe) for (const De of Array.from(oe)) De(k) } startPolling() { var b = this; this.stopPolling(), this.pollTimer = setInterval((0, a.Z)(function* () { return b._poll() }), 800) } stopPolling() { this.pollTimer && (clearInterval(this.pollTimer), this.pollTimer = null) } _addListener(b, k) { 0 === Object.keys(this.listeners).length && this.startPolling(), this.listeners[b] || (this.listeners[b] = new Set, this._get(b)), this.listeners[b].add(k) } _removeListener(b, k) { this.listeners[b] && (this.listeners[b].delete(k), 0 === this.listeners[b].size && delete this.listeners[b]), 0 === Object.keys(this.listeners).length && this.stopPolling() } } return T.type = "LOCAL", T })(), h = 1e12; class x { constructor(g) { this.auth = g, this.counter = h, this._widgets = new Map } render(g, b) { const k = this.counter; return this._widgets.set(k, new M(g, this.auth.name, b || {})), this.counter++, k } reset(g) { var b; const k = g || h; null === (b = this._widgets.get(k)) || void 0 === b || b.delete(), this._widgets.delete(k) } getResponse(g) { var b; return (null === (b = this._widgets.get(g || h)) || void 0 === b ? void 0 : b.getResponse()) || "" } execute(g) { var b = this; return (0, a.Z)(function* () { var k; return null === (k = b._widgets.get(g || h)) || void 0 === k || k.execute(), "" })() } } class M { constructor(g, b, k) { this.params = k, this.timerId = null, this.deleted = !1, this.responseToken = null, this.clickHandler = () => { this.execute() }; const oe = "string" == typeof g ? document.getElementById(g) : g; ee(oe, "argument-error", { appName: b }), this.container = oe, this.isVisible = "invisible" !== this.params.size, this.isVisible ? this.execute() : this.container.addEventListener("click", this.clickHandler) } getResponse() { return this.checkIfDeleted(), this.responseToken } delete() { this.checkIfDeleted(), this.deleted = !0, this.timerId && (clearTimeout(this.timerId), this.timerId = null), this.container.removeEventListener("click", this.clickHandler) } execute() { this.checkIfDeleted(), !this.timerId && (this.timerId = window.setTimeout(() => { this.responseToken = function $(T) { const g = [], b = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; for (let k = 0; k < T; k++)g.push(b.charAt(Math.floor(62 * Math.random()))); return g.join("") }(50); const { callback: g, "expired-callback": b } = this.params; if (g) try { g(this.responseToken) } catch { } this.timerId = window.setTimeout(() => { if (this.timerId = null, this.responseToken = null, b) try { b() } catch { } this.isVisible && this.execute() }, 6e4) }, 500)) } checkIfDeleted() { if (this.deleted) throw new Error("reCAPTCHA mock was already deleted!") } } const Ee = ho("rcb"), je = new Wn(3e4, 6e4); class zt { constructor() { var g; this.hostLanguage = "", this.counter = 0, this.librarySeparatelyLoaded = !(null === (g = Vr().grecaptcha) || void 0 === g || !g.render) } load(g, b = "") { return ee(function xn(T) { return T.length <= 6 && /^\s*[a-zA-Z0-9\-]*\s*$/.test(T) }(b), g, "argument-error"), this.shouldResolveImmediately(b) && qn(Vr().grecaptcha) ? Promise.resolve(Vr().grecaptcha) : new Promise((k, oe) => { const De = Vr().setTimeout(() => { oe(Le(g, "network-request-failed")) }, je.get()); Vr()[Ee] = () => { Vr().clearTimeout(De), delete Vr()[Ee]; const Xt = Vr().grecaptcha; if (!Xt || !qn(Xt)) return void oe(Le(g, "internal-error")); const Nn = Xt.render; Xt.render = (zn, vi) => { const hr = Nn(zn, vi); return this.counter++, hr }, this.hostLanguage = b, k(Xt) }, Li(`https://www.google.com/recaptcha/api.js??${(0, y.xO)({ onload: Ee, render: "explicit", hl: b })}`).catch(() => { clearTimeout(De), oe(Le(g, "internal-error")) }) }) } clearedOneInstance() { this.counter-- } shouldResolveImmediately(g) { var b; return !(null === (b = Vr().grecaptcha) || void 0 === b || !b.render) && (g === this.hostLanguage || this.counter > 0 || this.librarySeparatelyLoaded) } } class An { load(g) { return (0, a.Z)(function* () { return new x(g) })() } clearedOneInstance() { } } const ri = "recaptcha", hi = { theme: "light", type: "image" }; class fi { constructor(g, b = Object.assign({}, hi), k) { this.parameters = b, this.type = ri, this.destroyed = !1, this.widgetId = null, this.tokenChangeListeners = new Set, this.renderPromise = null, this.recaptcha = null, this.auth = Vi(k), this.isInvisible = "invisible" === this.parameters.size, ee(typeof document < "u", this.auth, "operation-not-supported-in-this-environment"); const oe = "string" == typeof g ? document.getElementById(g) : g; ee(oe, this.auth, "argument-error"), this.container = oe, this.parameters.callback = this.makeTokenCallback(this.parameters.callback), this._recaptchaLoader = this.auth.settings.appVerificationDisabledForTesting ? new An : new zt, this.validateStartingState() } verify() { var g = this; return (0, a.Z)(function* () { g.assertNotDestroyed(); const b = yield g.render(), k = g.getAssertedRecaptcha(); return k.getResponse(b) || new Promise(De => { const Tt = Xt => { Xt && (g.tokenChangeListeners.delete(Tt), De(Xt)) }; g.tokenChangeListeners.add(Tt), g.isInvisible && k.execute(b) }) })() } render() { try { this.assertNotDestroyed() } catch (g) { return Promise.reject(g) } return this.renderPromise || (this.renderPromise = this.makeRenderPromise().catch(g => { throw this.renderPromise = null, g })), this.renderPromise } _reset() { this.assertNotDestroyed(), null !== this.widgetId && this.getAssertedRecaptcha().reset(this.widgetId) } clear() { this.assertNotDestroyed(), this.destroyed = !0, this._recaptchaLoader.clearedOneInstance(), this.isInvisible || this.container.childNodes.forEach(g => { this.container.removeChild(g) }) } validateStartingState() { ee(!this.parameters.sitekey, this.auth, "argument-error"), ee(this.isInvisible || !this.container.hasChildNodes(), this.auth, "argument-error"), ee(typeof document < "u", this.auth, "operation-not-supported-in-this-environment") } makeTokenCallback(g) { return b => { if (this.tokenChangeListeners.forEach(k => k(b)), "function" == typeof g) g(b); else if ("string" == typeof g) { const k = Vr()[g]; "function" == typeof k && k(b) } } } assertNotDestroyed() { ee(!this.destroyed, this.auth, "internal-error") } makeRenderPromise() { var g = this; return (0, a.Z)(function* () { if (yield g.init(), !g.widgetId) { let b = g.container; if (!g.isInvisible) { const k = document.createElement("div"); b.appendChild(k), b = k } g.widgetId = g.getAssertedRecaptcha().render(b, g.parameters) } return g.widgetId })() } init() { var g = this; return (0, a.Z)(function* () { ee(bn() && !_a(), g.auth, "internal-error"), yield function ei() { let T = null; return new Promise(g => { "complete" !== document.readyState ? (T = () => g(), window.addEventListener("load", T)) : g() }).catch(g => { throw T && window.removeEventListener("load", T), g }) }(), g.recaptcha = yield g._recaptchaLoader.load(g.auth, g.auth.languageCode || void 0); const b = yield function yt(T) { return It.apply(this, arguments) }(g.auth); ee(b, g.auth, "internal-error"), g.parameters.sitekey = b })() } getAssertedRecaptcha() { return ee(this.recaptcha, this.auth, "internal-error"), this.recaptcha } } class zr { constructor(g, b) { this.verificationId = g, this.onConfirmation = b } confirm(g) { const b = Tr._fromVerification(this.verificationId, g); return this.onConfirmation(b) } } function Po(T, g, b) { return Ar.apply(this, arguments) } function Ar() { return (Ar = (0, a.Z)(function* (T, g, b) { const k = Vi(T), oe = yield Eo(k, g, (0, y.m9)(b)); return new zr(oe, De => K(k, De)) })).apply(this, arguments) } function Mo(T, g, b) { return Fr.apply(this, arguments) } function Fr() { return (Fr = (0, a.Z)(function* (T, g, b) { const k = (0, y.m9)(T); yield ha(!1, k, "phone"); const oe = yield Eo(k.auth, g, (0, y.m9)(b)); return new zr(oe, De => w(k, De)) })).apply(this, arguments) } function Ja(T, g, b) { return oa.apply(this, arguments) } function oa() { return (oa = (0, a.Z)(function* (T, g, b) { const k = (0, y.m9)(T), oe = yield Eo(k.auth, g, (0, y.m9)(b)); return new zr(oe, De => ne(k, De)) })).apply(this, arguments) } function Eo(T, g, b) { return ba.apply(this, arguments) } function ba() { return ba = (0, a.Z)(function* (T, g, b) { var k; const oe = yield b.verify(); try { let De; if (ee("string" == typeof oe, T, "argument-error"), ee(b.type === ri, T, "argument-error"), De = "string" == typeof g ? { phoneNumber: g } : g, "session" in De) { const Tt = De.session; if ("phoneNumber" in De) return ee("enroll" === Tt.type, T, "internal-error"), (yield function pn(T, g) { return Ft(T, "POST", "/v2/accounts/mfaEnrollment:start", it(T, g)) }(T, { idToken: Tt.credential, phoneEnrollmentInfo: { phoneNumber: De.phoneNumber, recaptchaToken: oe } })).phoneSessionInfo.sessionInfo; { ee("signin" === Tt.type, T, "internal-error"); const Xt = (null === (k = De.multiFactorHint) || void 0 === k ? void 0 : k.uid) || De.multiFactorUid; return ee(Xt, T, "missing-multi-factor-info"), (yield function Ps(T, g) { return Ft(T, "POST", "/v2/accounts/mfaSignIn:start", it(T, g)) }(T, { mfaPendingCredential: Tt.credential, mfaEnrollmentId: Xt, phoneSignInInfo: { recaptchaToken: oe } })).phoneResponseInfo.sessionInfo } } { const { sessionInfo: Tt } = yield function vs(T, g) { return Ao.apply(this, arguments) }(T, { phoneNumber: De.phoneNumber, recaptchaToken: oe }); return Tt } } finally { b._reset() } }), ba.apply(this, arguments) } function Ra(T, g) { return sa.apply(this, arguments) } function sa() { return (sa = (0, a.Z)(function* (T, g) { yield Ws((0, y.m9)(T), g) })).apply(this, arguments) } let dd = (() => { class T { constructor(b) { this.providerId = T.PROVIDER_ID, this.auth = Vi(b) } verifyPhoneNumber(b, k) { return Eo(this.auth, b, (0, y.m9)(k)) } static credential(b, k) { return Tr._fromVerification(b, k) } static credentialFromResult(b) { return T.credentialFromTaggedObject(b) } static credentialFromError(b) { return T.credentialFromTaggedObject(b.customData || {}) } static credentialFromTaggedObject({ _tokenResponse: b }) { if (!b) return null; const { phoneNumber: k, temporaryProof: oe } = b; return k && oe ? Tr._fromTokenResponse(k, oe) : null } } return T.PROVIDER_ID = "phone", T.PHONE_SIGN_IN_METHOD = "phone", T })(); function aa(T, g) { return g ? me(g) : (ee(T._popupRedirectResolver, T, "argument-error"), T._popupRedirectResolver) } class ya extends wn { constructor(g) { super("custom", "custom"), this.params = g } _getIdTokenResponse(g) { return di(g, this._buildIdpRequest()) } _linkToIdToken(g, b) { return di(g, this._buildIdpRequest(b)) } _getReauthenticationResolver(g) { return di(g, this._buildIdpRequest()) } _buildIdpRequest(g) { const b = { requestUri: this.params.requestUri, sessionId: this.params.sessionId, postBody: this.params.postBody, tenantId: this.params.tenantId, pendingToken: this.params.pendingToken, returnSecureToken: !0, returnIdpCredential: !0 }; return g && (b.idToken = g), b } } function el(T) { return Ks(T.auth, new ya(T), T.bypassAuthState) } function Pl(T) { const { auth: g, user: b } = T; return ee(b, g, "internal-error"), ws(b, new ya(T), T.bypassAuthState) } function oi(T) { return pi.apply(this, arguments) } function pi() { return (pi = (0, a.Z)(function* (T) { const { auth: g, user: b } = T; return ee(b, g, "internal-error"), Ws(b, new ya(T), T.bypassAuthState) })).apply(this, arguments) } class bi { constructor(g, b, k, oe, De = !1) { this.auth = g, this.resolver = k, this.user = oe, this.bypassAuthState = De, this.pendingPromise = null, this.eventManager = null, this.filter = Array.isArray(b) ? b : [b] } execute() { var g = this; return new Promise(function () { var b = (0, a.Z)(function* (k, oe) { g.pendingPromise = { resolve: k, reject: oe }; try { g.eventManager = yield g.resolver._initialize(g.auth), yield g.onExecution(), g.eventManager.registerConsumer(g) } catch (De) { g.reject(De) } }); return function (k, oe) { return b.apply(this, arguments) } }()) } onAuthEvent(g) { var b = this; return (0, a.Z)(function* () { const { urlResponse: k, sessionId: oe, postBody: De, tenantId: Tt, error: Xt, type: Nn } = g; if (Xt) return void b.reject(Xt); const zn = { auth: b.auth, requestUri: k, sessionId: oe, tenantId: Tt || void 0, postBody: De || void 0, user: b.user, bypassAuthState: b.bypassAuthState }; try { b.resolve(yield b.getIdpTask(Nn)(zn)) } catch (vi) { b.reject(vi) } })() } onError(g) { this.reject(g) } getIdpTask(g) { switch (g) { case "signInViaPopup": case "signInViaRedirect": return el; case "linkViaPopup": case "linkViaRedirect": return oi; case "reauthViaPopup": case "reauthViaRedirect": return Pl; default: ie(this.auth, "internal-error") } } resolve(g) { rt(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.resolve(g), this.unregisterAndCleanUp() } reject(g) { rt(this.pendingPromise, "Pending promise was never set"), this.pendingPromise.reject(g), this.unregisterAndCleanUp() } unregisterAndCleanUp() { this.eventManager && this.eventManager.unregisterConsumer(this), this.pendingPromise = null, this.cleanUp() } } const vr = new Wn(2e3, 1e4); function Go(T, g, b) { return Cs.apply(this, arguments) } function Cs() { return (Cs = (0, a.Z)(function* (T, g, b) { const k = Vi(T); ge(T, g, Ho); const oe = aa(k, b); return new wa(k, "signInViaPopup", g, oe).executeNotNull() })).apply(this, arguments) } function Hs(T, g, b) { return No.apply(this, arguments) } function No() { return (No = (0, a.Z)(function* (T, g, b) { const k = (0, y.m9)(T); ge(k.auth, g, Ho); const oe = aa(k.auth, b); return new wa(k.auth, "reauthViaPopup", g, oe, k).executeNotNull() })).apply(this, arguments) } function to(T, g, b) { return Ua.apply(this, arguments) } function Ua() { return (Ua = (0, a.Z)(function* (T, g, b) { const k = (0, y.m9)(T); ge(k.auth, g, Ho); const oe = aa(k.auth, b); return new wa(k.auth, "linkViaPopup", g, oe, k).executeNotNull() })).apply(this, arguments) } let wa = (() => { class T extends bi { constructor(b, k, oe, De, Tt) { super(b, k, De, Tt), this.provider = oe, this.authWindow = null, this.pollId = null, T.currentPopupAction && T.currentPopupAction.cancel(), T.currentPopupAction = this } executeNotNull() { var b = this; return (0, a.Z)(function* () { const k = yield b.execute(); return ee(k, b.auth, "internal-error"), k })() } onExecution() { var b = this; return (0, a.Z)(function* () { rt(1 === b.filter.length, "Popup operations only handle one event"); const k = ps(); b.authWindow = yield b.resolver._openPopup(b.auth, b.provider, b.filter[0], k), b.authWindow.associatedEvent = k, b.resolver._originValidation(b.auth).catch(oe => { b.reject(oe) }), b.resolver._isIframeWebStorageSupported(b.auth, oe => { oe || b.reject(Le(b.auth, "web-storage-unsupported")) }), b.pollUserCancellation() })() } get eventId() { var b; return (null === (b = this.authWindow) || void 0 === b ? void 0 : b.associatedEvent) || null } cancel() { this.reject(Le(this.auth, "cancelled-popup-request")) } cleanUp() { this.authWindow && this.authWindow.close(), this.pollId && window.clearTimeout(this.pollId), this.authWindow = null, this.pollId = null, T.currentPopupAction = null } pollUserCancellation() { const b = () => { var k, oe; this.pollId = null !== (oe = null === (k = this.authWindow) || void 0 === k ? void 0 : k.window) && void 0 !== oe && oe.closed ? window.setTimeout(() => { this.pollId = null, this.reject(Le(this.auth, "popup-closed-by-user")) }, 8e3) : window.setTimeout(b, vr.get()) }; b() } } return T.currentPopupAction = null, T })(); const or = "pendingRedirect", Is = new Map; class _o extends bi { constructor(g, b, k = !1) { super(g, ["signInViaRedirect", "linkViaRedirect", "reauthViaRedirect", "unknown"], b, void 0, k), this.eventId = null } execute() { var g = () => super.execute, b = this; return (0, a.Z)(function* () { let k = Is.get(b.auth._key()); if (!k) { try { const De = (yield function Va(T, g) { return ur.apply(this, arguments) }(b.resolver, b.auth)) ? yield g().call(b) : null; k = () => Promise.resolve(De) } catch (oe) { k = () => Promise.reject(oe) } Is.set(b.auth._key(), k) } return b.bypassAuthState || Is.set(b.auth._key(), () => Promise.resolve(null)), k() })() } onAuthEvent(g) { var b = () => super.onAuthEvent, k = this; return (0, a.Z)(function* () { if ("signInViaRedirect" === g.type) return b().call(k, g); if ("unknown" !== g.type) { if (g.eventId) { const oe = yield k.auth._redirectUserForId(g.eventId); if (oe) return k.user = oe, b().call(k, g); k.resolve(null) } } else k.resolve(null) })() } onExecution() { return (0, a.Z)(function* () { })() } cleanUp() { } } function ur() { return (ur = (0, a.Z)(function* (T, g) { const b = Xo(g), k = za(T); if (!(yield k._isAvailable())) return !1; const oe = "true" === (yield k._get(b)); return yield k._remove(b), oe })).apply(this, arguments) } function Ha(T, g) { return Fo.apply(this, arguments) } function Fo() { return (Fo = (0, a.Z)(function* (T, g) { return za(T)._set(Xo(g), "true") })).apply(this, arguments) } function Zr() { Is.clear() } function Nl(T, g) { Is.set(T._key(), g) } function za(T) { return me(T._redirectPersistence) } function Xo(T) { return Lt(or, T.config.apiKey, T.name) } function Xd(T, g, b) { return function ud(T, g, b) { return Lo.apply(this, arguments) }(T, g, b) } function Lo() { return (Lo = (0, a.Z)(function* (T, g, b) { const k = Vi(T); ge(T, g, Ho), yield k._initializationPromise; const oe = aa(k, b); return yield Ha(oe, k), oe._openRedirect(k, g, "signInViaRedirect") })).apply(this, arguments) } function xa(T, g, b) { return function ja(T, g, b) { return vo.apply(this, arguments) }(T, g, b) } function vo() { return (vo = (0, a.Z)(function* (T, g, b) { const k = (0, y.m9)(T); ge(k.auth, g, Ho), yield k.auth._initializationPromise; const oe = aa(k.auth, b); yield Ha(oe, k.auth); const De = yield Il(k); return oe._openRedirect(k.auth, g, "reauthViaRedirect", De) })).apply(this, arguments) } function Ea(T, g, b) { return function Oa(T, g, b) { return hl.apply(this, arguments) }(T, g, b) } function hl() { return (hl = (0, a.Z)(function* (T, g, b) { const k = (0, y.m9)(T); ge(k.auth, g, Ho), yield k.auth._initializationPromise; const oe = aa(k.auth, b); yield ha(!1, k, g.providerId), yield Ha(oe, k.auth); const De = yield Il(k); return oe._openRedirect(k.auth, g, "linkViaRedirect", De) })).apply(this, arguments) } function qs(T, g) { return tl.apply(this, arguments) } function tl() { return (tl = (0, a.Z)(function* (T, g) { return yield Vi(T)._initializationPromise, zs(T, g, !1) })).apply(this, arguments) } function zs(T, g) { return Ds.apply(this, arguments) } function Ds() { return (Ds = (0, a.Z)(function* (T, g, b = !1) { const k = Vi(T), oe = aa(k, g), Tt = yield new _o(k, oe, b).execute(); return Tt && !b && (delete Tt.user._redirectEventId, yield k._persistUserIfCurrent(Tt.user), yield k._setRedirectUser(null, g)), Tt })).apply(this, arguments) } function Il(T) { return la.apply(this, arguments) } function la() { return (la = (0, a.Z)(function* (T) { const g = ps(`${T.uid}:::`); return T._redirectEventId = g, yield T.auth._setRedirectUser(T), yield T.auth._persistUserIfCurrent(T), g })).apply(this, arguments) } class O { constructor(g) { this.auth = g, this.cachedEventUids = new Set, this.consumers = new Set, this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1, this.lastProcessedEventTime = Date.now() } registerConsumer(g) { this.consumers.add(g), this.queuedRedirectEvent && this.isEventForConsumer(this.queuedRedirectEvent, g) && (this.sendToConsumer(this.queuedRedirectEvent, g), this.saveEventToCache(this.queuedRedirectEvent), this.queuedRedirectEvent = null) } unregisterConsumer(g) { this.consumers.delete(g) } onEvent(g) { if (this.hasEventBeenHandled(g)) return !1; let b = !1; return this.consumers.forEach(k => { this.isEventForConsumer(g, k) && (b = !0, this.sendToConsumer(g, k), this.saveEventToCache(g)) }), this.hasHandledPotentialRedirect || !function Ze(T) { switch (T.type) { case "signInViaRedirect": case "linkViaRedirect": case "reauthViaRedirect": return !0; case "unknown": return ce(T); default: return !1 } }(g) || (this.hasHandledPotentialRedirect = !0, b || (this.queuedRedirectEvent = g, b = !0)), b } sendToConsumer(g, b) { var k; if (g.error && !ce(g)) { const oe = (null === (k = g.error.code) || void 0 === k ? void 0 : k.split("auth/")[1]) || "internal-error"; b.onError(Le(this.auth, oe)) } else b.onAuthEvent(g) } isEventForConsumer(g, b) { const k = null === b.eventId || !!g.eventId && g.eventId === b.eventId; return b.filter.includes(g.type) && k } hasEventBeenHandled(g) { return Date.now() - this.lastProcessedEventTime >= 6e5 && this.cachedEventUids.clear(), this.cachedEventUids.has(U(g)) } saveEventToCache(g) { this.cachedEventUids.add(U(g)), this.lastProcessedEventTime = Date.now() } } function U(T) { return [T.type, T.eventId, T.sessionId, T.tenantId].filter(g => g).join("-") } function ce({ type: T, error: g }) { return "unknown" === T && "auth/no-auth-event" === g?.code } function Ct(T) { return Ut.apply(this, arguments) } function Ut() { return (Ut = (0, a.Z)(function* (T, g = {}) { return Ft(T, "GET", "/v1/projects", g) })).apply(this, arguments) } const ln = /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/, Kn = /^https?/; function mi() { return (mi = (0, a.Z)(function* (T) { if (T.config.emulator) return; const { authorizedDomains: g } = yield Ct(T); for (const b of g) try { if (Ui(b)) return } catch { } ie(T, "unauthorized-domain") })).apply(this, arguments) } function Ui(T) { const g = Kt(), { protocol: b, hostname: k } = new URL(g); if (T.startsWith("chrome-extension://")) { const Tt = new URL(T); return "" === Tt.hostname && "" === k ? "chrome-extension:" === b && T.replace("chrome-extension://", "") === g.replace("chrome-extension://", "") : "chrome-extension:" === b && Tt.hostname === k } if (!Kn.test(b)) return !1; if (ln.test(T)) return k === T; const oe = T.replace(/\./g, "\\."); return new RegExp("^(.+\\." + oe + "|" + oe + ")$", "i").test(k) } const li = new Wn(3e4, 6e4); function gs() { const T = Vr().___jsl; if (T?.H) for (const g of Object.keys(T.H)) if (T.H[g].r = T.H[g].r || [], T.H[g].L = T.H[g].L || [], T.H[g].r = [...T.H[g].L], T.CP) for (let b = 0; b < T.CP.length; b++)T.CP[b] = null } let fl = null; const Pa = new Wn(5e3, 15e3), Qs = "__/auth/iframe", no = "emulator/auth/iframe", ml = { style: { position: "absolute", top: "-100px", width: "1px", height: "1px" }, "aria-hidden": "true", tabindex: "-1" }, So = new Map([["identitytoolkit.googleapis.com", "p"], ["staging-identitytoolkit.sandbox.googleapis.com", "s"], ["test-identitytoolkit.sandbox.googleapis.com", "t"]]); function Fl(T) { const g = T.config; ee(g.authDomain, T, "auth-domain-config-required"); const b = g.emulator ? Hn(g, no) : `https://${T.config.authDomain}/${Qs}`, k = { apiKey: g.apiKey, appName: T.name, v: v.SDK_VERSION }, oe = So.get(T.config.apiHost); oe && (k.eid = oe); const De = T._getFrameworks(); return De.length && (k.fw = De.join(",")), `${b}?${(0, y.xO)(k).slice(1)}` } function Jd() { return Jd = (0, a.Z)(function* (T) { const g = yield function js(T) { return fl = fl || function Bo(T) { return new Promise((g, b) => { var k, oe, De; function Tt() { gs(), gapi.load("gapi.iframes", { callback: () => { g(gapi.iframes.getContext()) }, ontimeout: () => { gs(), b(Le(T, "network-request-failed")) }, timeout: li.get() }) } if (null !== (oe = null === (k = Vr().gapi) || void 0 === k ? void 0 : k.iframes) && void 0 !== oe && oe.Iframe) g(gapi.iframes.getContext()); else { if (null === (De = Vr().gapi) || void 0 === De || !De.load) { const Xt = ho("iframefcb"); return Vr()[Xt] = () => { gapi.load ? Tt() : b(Le(T, "network-request-failed")) }, Li(`https://apis.google.com/js/api.js?onload=${Xt}`).catch(Nn => b(Nn)) } Tt() } }).catch(g => { throw fl = null, g }) }(T), fl }(T), b = Vr().gapi; return ee(b, T, "internal-error"), g.open({ where: document.body, url: Fl(T), messageHandlersFilter: b.iframes.CROSS_ORIGIN_IFRAMES_FILTER, attributes: ml, dontclear: !0 }, k => new Promise(function () { var oe = (0, a.Z)(function* (De, Tt) { yield k.restyle({ setHideOnLeave: !1 }); const Xt = Le(T, "network-request-failed"), Nn = Vr().setTimeout(() => { Tt(Xt) }, Pa.get()); function zn() { Vr().clearTimeout(Nn), De(k) } k.ping(zn).then(zn, () => { Tt(Xt) }) }); return function (De, Tt) { return oe.apply(this, arguments) } }())) }), Jd.apply(this, arguments) } const Ts = { location: "yes", resizable: "yes", statusbar: "yes", toolbar: "no" }; class Bl { constructor(g) { this.window = g, this.associatedEvent = null } close() { if (this.window) try { this.window.close() } catch { } } } const dh = "__/auth/handler", iu = "emulator/auth/handler", uh = encodeURIComponent("fac"); function ec(T, g, b, k, oe, De) { return Ul.apply(this, arguments) } function Ul() { return (Ul = (0, a.Z)(function* (T, g, b, k, oe, De) { ee(T.config.authDomain, T, "auth-domain-config-required"), ee(T.config.apiKey, T, "invalid-api-key"); const Tt = { apiKey: T.config.apiKey, appName: T.name, authType: b, redirectUrl: k, v: v.SDK_VERSION, eventId: oe }; if (g instanceof Ho) { g.setDefaultLanguage(T.languageCode), Tt.providerId = g.providerId || "", (0, y.xb)(g.getCustomParameters()) || (Tt.customParameters = JSON.stringify(g.getCustomParameters())); for (const [vi, hr] of Object.entries(De || {})) Tt[vi] = hr } if (g instanceof Ro) { const vi = g.getScopes().filter(hr => "" !== hr); vi.length > 0 && (Tt.scopes = vi.join(",")) } T.tenantId && (Tt.tid = T.tenantId); const Xt = Tt; for (const vi of Object.keys(Xt)) void 0 === Xt[vi] && delete Xt[vi]; const Nn = yield T._getAppCheckToken(), zn = Nn ? `#${uh}=${encodeURIComponent(Nn)}` : ""; return `${function kf({ config: T }) { return T.emulator ? Hn(T, iu) : `https://${T.authDomain}/${dh}` }(T)}?${(0, y.xO)(Xt).slice(1)}${zn}` })).apply(this, arguments) } const tc = "webStorageSupport", nc = class Rf { constructor() { this.eventManagers = {}, this.iframes = {}, this.originValidationPromises = {}, this._redirectPersistence = xo, this._completeRedirectFn = zs, this._overrideRedirectResult = Nl } _openPopup(g, b, k, oe) { var De = this; return (0, a.Z)(function* () { var Tt; rt(null === (Tt = De.eventManagers[g._key()]) || void 0 === Tt ? void 0 : Tt.manager, "_initialize() not called before _openPopup()"); const Xt = yield ec(g, b, k, Kt(), oe); return function tu(T, g, b, k = 500, oe = 600) { const De = Math.max((window.screen.availHeight - oe) / 2, 0).toString(), Tt = Math.max((window.screen.availWidth - k) / 2, 0).toString(); let Xt = ""; const Nn = Object.assign(Object.assign({}, Ts), { width: k.toString(), height: oe.toString(), top: De, left: Tt }), zn = (0, y.z$)().toLowerCase(); b && (Xt = H(zn) ? "_blank" : b), z(zn) && (g = g || "http://localhost", Nn.scrollbars = "yes"); const vi = Object.entries(Nn).reduce(($s, [Xs, lu]) => `${$s}${Xs}=${lu},`, ""); if (function Te(T = (0, y.z$)()) { var g; return F(T) && !(null === (g = window.navigator) || void 0 === g || !g.standalone) }(zn) && "_self" !== Xt) return function nu(T, g) { const b = document.createElement("a"); b.href = T, b.target = g; const k = document.createEvent("MouseEvent"); k.initMouseEvent("click", !0, !0, window, 1, 0, 0, 0, 0, !1, !1, !1, !1, 1, null), b.dispatchEvent(k) }(g || "", Xt), new Bl(null); const hr = window.open(g || "", Xt, vi); ee(hr, T, "popup-blocked"); try { hr.focus() } catch { } return new Bl(hr) }(g, Xt, ps()) })() } _openRedirect(g, b, k, oe) { var De = this; return (0, a.Z)(function* () { return yield De._originValidation(g), function Ei(T) { Vr().location.href = T }(yield ec(g, b, k, Kt(), oe)), new Promise(() => { }) })() } _initialize(g) { const b = g._key(); if (this.eventManagers[b]) { const { manager: oe, promise: De } = this.eventManagers[b]; return oe ? Promise.resolve(oe) : (rt(De, "If manager is not set, promise should be"), De) } const k = this.initAndGetManager(g); return this.eventManagers[b] = { promise: k }, k.catch(() => { delete this.eventManagers[b] }), k } initAndGetManager(g) { var b = this; return (0, a.Z)(function* () { const k = yield function ch(T) { return Jd.apply(this, arguments) }(g), oe = new O(g); return k.register("authEvent", De => (ee(De?.authEvent, g, "invalid-auth-event"), { status: oe.onEvent(De.authEvent) ? "ACK" : "ERROR" }), gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER), b.eventManagers[g._key()] = { manager: oe }, b.iframes[g._key()] = k, oe })() } _isIframeWebStorageSupported(g, b) { this.iframes[g._key()].send(tc, { type: tc }, oe => { var De; const Tt = null === (De = oe?.[0]) || void 0 === De ? void 0 : De[tc]; void 0 !== Tt && b(!!Tt), ie(g, "internal-error") }, gapi.iframes.CROSS_ORIGIN_IFRAMES_FILTER) } _originValidation(g) { const b = g._key(); return this.originValidationPromises[b] || (this.originValidationPromises[b] = function Vn(T) { return mi.apply(this, arguments) }(g)), this.originValidationPromises[b] } get _shouldInitProactively() { return gt() || L() || F() } }; class Of { constructor(g) { this.factorId = g } _process(g, b, k) { switch (b.type) { case "enroll": return this._finalizeEnroll(g, b.credential, k); case "signin": return this._finalizeSignIn(g, b.credential); default: return $e("unexpected MultiFactorSessionType") } } } class Pc extends Of { constructor(g) { super("phone"), this.credential = g } static _fromCredential(g) { return new Pc(g) } _finalizeEnroll(g, b, k) { return function er(T, g) { return Ft(T, "POST", "/v2/accounts/mfaEnrollment:finalize", it(T, g)) }(g, { idToken: b, displayName: k, phoneVerificationInfo: this.credential._makeVerificationRequest() }) } _finalizeSignIn(g, b) { return function S(T, g) { return Ft(T, "POST", "/v2/accounts/mfaSignIn:finalize", it(T, g)) }(g, { mfaPendingCredential: b, phoneVerificationInfo: this.credential._makeVerificationRequest() }) } } let ru = (() => { class T { constructor() { } static assertion(b) { return Pc._fromCredential(b) } } return T.FACTOR_ID = "phone", T })(); var $a = "@firebase/auth"; class md { constructor(g) { this.auth = g, this.internalListeners = new Map } getUid() { var g; return this.assertAuthConfigured(), (null === (g = this.auth.currentUser) || void 0 === g ? void 0 : g.uid) || null } getToken(g) { var b = this; return (0, a.Z)(function* () { return b.assertAuthConfigured(), yield b.auth._initializationPromise, b.auth.currentUser ? { accessToken: yield b.auth.currentUser.getIdToken(g) } : null })() } addAuthTokenListener(g) { if (this.assertAuthConfigured(), this.internalListeners.has(g)) return; const b = this.auth.onIdTokenChanged(k => { g(k?.stsTokenManager.accessToken || null) }); this.internalListeners.set(g, b), this.updateProactiveRefresh() } removeAuthTokenListener(g) { this.assertAuthConfigured(); const b = this.internalListeners.get(g); b && (this.internalListeners.delete(g), b(), this.updateProactiveRefresh()) } assertAuthConfigured() { ee(this.auth._initializationPromise, "dependent-sdk-initialized-before-auth") } updateProactiveRefresh() { this.internalListeners.size > 0 ? this.auth._startProactiveRefresh() : this.auth._stopProactiveRefresh() } } const Nf = (0, y.Pz)("authIdTokenMaxAge") || 300; let Vl = null; const hh = T => function () { var g = (0, a.Z)(function* (b) { const k = b && (yield b.getIdTokenResult()), oe = k && ((new Date).getTime() - Date.parse(k.issuedAtTime)) / 1e3; if (oe && oe > Nf) return; const De = k?.token; Vl !== De && (Vl = De, yield fetch(T, { method: De ? "POST" : "DELETE", headers: De ? { Authorization: `Bearer ${De}` } : {} })) }); return function (b) { return g.apply(this, arguments) } }(); function au(T = (0, v.getApp)()) { const g = (0, v._getProvider)(T, "auth"); if (g.isInitialized()) return g.getImmediate(); const b = function fo(T, g) { const b = (0, v._getProvider)(T, "auth"); if (b.isInitialized()) { const oe = b.getImmediate(), De = b.getOptions(); if ((0, y.vZ)(De, g ?? {})) return oe; ie(oe, "already-initialized") } return b.initialize({ options: g }) }(T, { popupRedirectResolver: nc, persistence: [ul, Cl, xo] }), k = (0, y.Pz)("authTokenSyncURL"); if (k) { const De = hh(k); (function Zn(T, g, b) { (0, y.m9)(T).beforeAuthStateChanged(g, b) })(b, De, () => De(b.currentUser)), function en(T, g, b, k) { (0, y.m9)(T).onIdTokenChanged(g, b, k) }(b, Tt => De(Tt)) } const oe = (0, y.q4)("auth"); return oe && sr(b, `http://${oe}`), b } !function su(T) { (0, v._registerComponent)(new Se.wA("auth", (g, { options: b }) => { const k = g.getProvider("app").getImmediate(), oe = g.getProvider("heartbeat"), De = g.getProvider("app-check-internal"), { apiKey: Tt, authDomain: Xt } = k.options; ee(Tt && !Tt.includes(":"), "invalid-api-key", { appName: k.name }); const Nn = { apiKey: Tt, authDomain: Xt, clientPlatform: T, apiHost: "identitytoolkit.googleapis.com", tokenApiHost: "securetoken.googleapis.com", apiScheme: "https", sdkClientVersion: un(T) }, zn = new Nr(k, oe, De, Nn); return function Jo(T, g) { const b = g?.persistence || [], k = (Array.isArray(b) ? b : [b]).map(me); g?.errorMap && T._updateErrorMap(g.errorMap), T._initializeWithPersistence(k, g?.popupRedirectResolver) }(zn, b), zn }, "PUBLIC").setInstantiationMode("EXPLICIT").setInstanceCreatedCallback((g, b, k) => { g.getProvider("auth-internal").initialize() })), (0, v._registerComponent)(new Se.wA("auth-internal", g => { const b = Vi(g.getProvider("auth").getImmediate()); return new md(b) }, "PRIVATE").setInstantiationMode("EXPLICIT")), (0, v.registerVersion)($a, "0.23.2", function Pf(T) { switch (T) { case "Node": return "node"; case "ReactNative": return "rn"; case "Worker": return "webworker"; case "Cordova": return "cordova"; default: return } }(T)), (0, v.registerVersion)($a, "0.23.2", "esm2017") }("Browser") }, 5776: (nn, Qe, C) => { C.d(Qe, { u7: () => Dp, Jj: () => Ic, IX: () => $d, my: () => as, xU: () => ql, Lz: () => Dc, WA: () => _n, F8: () => up, $q: () => Yd, W: () => Sc, EK: () => Ri, PU: () => Ap, l7: () => zs, Ky: () => Bn, Xb: () => Hr, Cf: () => kr, K9: () => co, Me: () => ud, yq: () => wo, Wi: () => g_, ET: () => Mp, Ab: () => Ib, vr: () => Rl, Fc: () => y_, hJ: () => da, B$: () => sd, at: () => ff, oe: () => cd, AK: () => kp, TF: () => E_, JU: () => Ku, ST: () => v_, fH: () => b_, Ix: () => x_, Wu: () => hb, Lx: () => S_, qY: () => Vo, GL: () => sh, QT: () => P_, kl: () => N_, Xk: () => F_, PL: () => Cf, UQ: () => Ac, zN: () => vb, ad: () => Gd, nP: () => Db, b9: () => db, vh: () => ub, Pb: () => C_, L$: () => dp, cf: () => yb, sc: () => Sp, Xo: () => Ep, IO: () => cb, iE: () => Zu, Eo: () => rl, i3: () => Dy, Bt: () => Rp, pl: () => bb, Ub: () => ui, qK: () => O_, TQ: () => yf, e0: () => bf, r7: () => Tp, Mx: () => w_, ar: () => wp }); var re, a = C(5861), y = C(6122), v = C(4537), Y = C(7879), he = C(9058), Se = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}, ke = {}, Ie = Ie || {}, Q = Se || self; function _e(r) { var e = typeof r; return "array" == (e = "object" != e ? e : r ? Array.isArray(r) ? "array" : e : "null") || "object" == e && "number" == typeof r.length } function xe(r) { var e = typeof r; return "object" == e && null != r || "function" == e } var Oe = "closure_uid_" + (1e9 * Math.random() >>> 0), We = 0; function Pe(r, e, t) { return r.call.apply(r.bind, arguments) } function Ve(r, e, t) { if (!r) throw Error(); if (2 < arguments.length) { var s = Array.prototype.slice.call(arguments, 2); return function () { var c = Array.prototype.slice.call(arguments); return Array.prototype.unshift.apply(c, s), r.apply(e, c) } } return function () { return r.apply(e, arguments) } } function tt(r, e, t) { return (tt = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf("native code") ? Pe : Ve).apply(null, arguments) } function Ye(r, e) { var t = Array.prototype.slice.call(arguments, 1); return function () { var s = t.slice(); return s.push.apply(s, arguments), r.apply(this, s) } } function ut(r, e) { function t() { } t.prototype = e.prototype, r.$ = e.prototype, r.prototype = new t, r.prototype.constructor = r, r.ac = function (s, c, f) { for (var _ = Array(arguments.length - 2), R = 2; R < arguments.length; R++)_[R - 2] = arguments[R]; return e.prototype[c].apply(s, _) } } function ie() { this.s = this.s, this.o = this.o } ie.prototype.s = !1, ie.prototype.sa = function () { !this.s && (this.s = !0, this.N(), 0) && function ze(r) { Object.prototype.hasOwnProperty.call(r, Oe) && r[Oe] || (r[Oe] = ++We) }(this) }, ie.prototype.N = function () { if (this.o) for (; this.o.length;)this.o.shift()() }; const le = Array.prototype.indexOf ? function (r, e) { return Array.prototype.indexOf.call(r, e, void 0) } : function (r, e) { if ("string" == typeof r) return "string" != typeof e || 1 != e.length ? -1 : r.indexOf(e, 0); for (let t = 0; t < r.length; t++)if (t in r && r[t] === e) return t; return -1 }; function ge(r) { const e = r.length; if (0 < e) { const t = Array(e); for (let s = 0; s < e; s++)t[s] = r[s]; return t } return [] } function ue(r, e) { for (let t = 1; t < arguments.length; t++) { const s = arguments[t]; if (_e(s)) { const c = r.length || 0, f = s.length || 0; r.length = c + f; for (let _ = 0; _ < f; _++)r[c + _] = s[_] } else r.push(s) } } function ee(r, e) { this.type = r, this.g = this.target = e, this.defaultPrevented = !1 } ee.prototype.h = function () { this.defaultPrevented = !0 }; var $e = function () { if (!Q.addEventListener || !Object.defineProperty) return !1; var r = !1, e = Object.defineProperty({}, "passive", { get: function () { r = !0 } }); try { Q.addEventListener("test", () => { }, e), Q.removeEventListener("test", () => { }, e) } catch { } return r }(); function rt(r) { return /^[\s\xa0]*$/.test(r) } function Kt() { var r = Q.navigator; return r && (r = r.userAgent) ? r : "" } function bn(r) { return -1 != Kt().indexOf(r) } function Dn(r) { return Dn[" "](r), r } Dn[" "] = function () { }; var Ft, r, On = bn("Opera"), Wn = bn("Trident") || bn("MSIE"), Hn = bn("Edge"), at = Hn || Wn, vt = bn("Gecko") && !(-1 != Kt().toLowerCase().indexOf("webkit") && !bn("Edge")) && !(bn("Trident") || bn("MSIE")) && !bn("Edge"), xt = -1 != Kt().toLowerCase().indexOf("webkit") && !bn("Edge"); function it() { var r = Q.document; return r ? r.documentMode : void 0 } e: { var Wt = "", rn = (r = Kt(), vt ? /rv:([^\);]+)(\)|;)/.exec(r) : Hn ? /Edge\/([\d\.]+)/.exec(r) : Wn ? /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/.exec(r) : xt ? /WebKit\/(\S+)/.exec(r) : On ? /(?:Version)[ \/]?(\S+)/.exec(r) : void 0); if (rn && (Wt = rn ? rn[1] : ""), Wn) { var Jt = it(); if (null != Jt && Jt > parseFloat(Wt)) { Ft = String(Jt); break e } } Ft = Wt } var ht = Q.document && Wn && (it() || parseInt(Ft, 10)) || void 0; function Ae(r, e) { if (ee.call(this, r ? r.type : ""), this.relatedTarget = this.g = this.target = null, this.button = this.screenY = this.screenX = this.clientY = this.clientX = 0, this.key = "", this.metaKey = this.shiftKey = this.altKey = this.ctrlKey = !1, this.state = null, this.pointerId = 0, this.pointerType = "", this.i = null, r) { var t = this.type = r.type, s = r.changedTouches && r.changedTouches.length ? r.changedTouches[0] : null; if (this.target = r.target || r.srcElement, this.g = e, e = r.relatedTarget) { if (vt) { e: { try { Dn(e.nodeName); var c = !0; break e } catch { } c = !1 } c || (e = null) } } else "mouseover" == t ? e = r.fromElement : "mouseout" == t && (e = r.toElement); this.relatedTarget = e, s ? (this.clientX = void 0 !== s.clientX ? s.clientX : s.pageX, this.clientY = void 0 !== s.clientY ? s.clientY : s.pageY, this.screenX = s.screenX || 0, this.screenY = s.screenY || 0) : (this.clientX = void 0 !== r.clientX ? r.clientX : r.pageX, this.clientY = void 0 !== r.clientY ? r.clientY : r.pageY, this.screenX = r.screenX || 0, this.screenY = r.screenY || 0), this.button = r.button, this.key = r.key || "", this.ctrlKey = r.ctrlKey, this.altKey = r.altKey, this.shiftKey = r.shiftKey, this.metaKey = r.metaKey, this.pointerId = r.pointerId || 0, this.pointerType = "string" == typeof r.pointerType ? r.pointerType : nt[r.pointerType] || "", this.state = r.state, this.i = r, r.defaultPrevented && Ae.$.h.call(this) } } ut(Ae, ee); var nt = { 2: "touch", 3: "pen", 4: "mouse" }; Ae.prototype.h = function () { Ae.$.h.call(this); var r = this.i; r.preventDefault ? r.preventDefault() : r.returnValue = !1 }; var qt = "closure_listenable_" + (1e6 * Math.random() | 0), jt = 0; function Pt(r, e, t, s, c) { this.listener = r, this.proxy = null, this.src = e, this.type = t, this.capture = !!s, this.la = c, this.key = ++jt, this.fa = this.ia = !1 } function qe(r) { r.fa = !0, r.listener = null, r.proxy = null, r.src = null, r.la = null } function Nt(r, e, t) { for (const s in r) e.call(t, r[s], s, r) } function Zt(r) { const e = {}; for (const t in r) e[t] = r[t]; return e } const gn = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split(" "); function $n(r, e) { let t, s; for (let c = 1; c < arguments.length; c++) { for (t in s = arguments[c], s) r[t] = s[t]; for (let f = 0; f < gn.length; f++)t = gn[f], Object.prototype.hasOwnProperty.call(s, t) && (r[t] = s[t]) } } function Fn(r) { this.src = r, this.g = {}, this.h = 0 } function Ke(r, e) { var t = e.type; if (t in r.g) { var f, s = r.g[t], c = le(s, e); (f = 0 <= c) && Array.prototype.splice.call(s, c, 1), f && (qe(e), 0 == r.g[t].length && (delete r.g[t], r.h--)) } } function se(r, e, t, s) { for (var c = 0; c < r.length; ++c) { var f = r[c]; if (!f.fa && f.listener == e && f.capture == !!t && f.la == s) return c } return -1 } Fn.prototype.add = function (r, e, t, s, c) { var f = r.toString(); (r = this.g[f]) || (r = this.g[f] = [], this.h++); var _ = se(r, e, s, c); return -1 < _ ? (e = r[_], t || (e.ia = !1)) : ((e = new Pt(e, this.src, f, !!s, c)).ia = t, r.push(e)), e }; var Me = "closure_lm_" + (1e6 * Math.random() | 0), Xe = {}; function Ot(r, e, t, s, c) { if (s && s.once) return Z(r, e, t, s, c); if (Array.isArray(e)) { for (var f = 0; f < e.length; f++)Ot(r, e[f], t, s, c); return null } return t = Ln(t), r && r[qt] ? r.O(e, t, xe(s) ? !!s.capture : !!s, c) : ve(r, e, t, !1, s, c) } function ve(r, e, t, s, c, f) { if (!e) throw Error("Invalid event type"); var _ = xe(c) ? !!c.capture : !!c, R = fn(r); if (R || (r[Me] = R = new Fn(r)), (t = R.add(e, t, s, _, f)).proxy) return t; if (s = function Ue() { const e = Qt; return function r(t) { return e.call(r.src, r.listener, t) } }(), t.proxy = s, s.src = r, s.listener = t, r.addEventListener) $e || (c = _), void 0 === c && (c = !1), r.addEventListener(e.toString(), s, c); else if (r.attachEvent) r.attachEvent(Mt(e.toString()), s); else { if (!r.addListener || !r.removeListener) throw Error("addEventListener and attachEvent are unavailable."); r.addListener(s) } return t } function Z(r, e, t, s, c) { if (Array.isArray(e)) { for (var f = 0; f < e.length; f++)Z(r, e[f], t, s, c); return null } return t = Ln(t), r && r[qt] ? r.P(e, t, xe(s) ? !!s.capture : !!s, c) : ve(r, e, t, !0, s, c) } function Fe(r, e, t, s, c) { if (Array.isArray(e)) for (var f = 0; f < e.length; f++)Fe(r, e[f], t, s, c); else s = xe(s) ? !!s.capture : !!s, t = Ln(t), r && r[qt] ? (r = r.i, (e = String(e).toString()) in r.g && -1 < (t = se(f = r.g[e], t, s, c)) && (qe(f[t]), Array.prototype.splice.call(f, t, 1), 0 == f.length && (delete r.g[e], r.h--))) : r && (r = fn(r)) && (e = r.g[e.toString()], r = -1, e && (r = se(e, t, s, c)), (t = -1 < r ? e[r] : null) && ct(t)) } function ct(r) { if ("number" != typeof r && r && !r.fa) { var e = r.src; if (e && e[qt]) Ke(e.i, r); else { var t = r.type, s = r.proxy; e.removeEventListener ? e.removeEventListener(t, s, r.capture) : e.detachEvent ? e.detachEvent(Mt(t), s) : e.addListener && e.removeListener && e.removeListener(s), (t = fn(e)) ? (Ke(t, r), 0 == t.h && (t.src = null, e[Me] = null)) : qe(r) } } } function Mt(r) { return r in Xe ? Xe[r] : Xe[r] = "on" + r } function Qt(r, e) { if (r.fa) r = !0; else { e = new Ae(e, this); var t = r.listener, s = r.la || r.src; r.ia && ct(r), r = t.call(s, e) } return r } function fn(r) { return (r = r[Me]) instanceof Fn ? r : null } var En = "__closure_events_fn_" + (1e9 * Math.random() >>> 0); function Ln(r) { return "function" == typeof r ? r : (r[En] || (r[En] = function (e) { return r.handleEvent(e) }), r[En]) } function In() { ie.call(this), this.i = new Fn(this), this.S = this, this.J = null } function Et(r, e) { var t, s = r.J; if (s) for (t = []; s; s = s.J)t.push(s); if (r = r.S, s = e.type || e, "string" == typeof e) e = new ee(e, r); else if (e instanceof ee) e.target = e.target || r; else { var c = e; $n(e = new ee(s, r), c) } if (c = !0, t) for (var f = t.length - 1; 0 <= f; f--) { var _ = e.g = t[f]; c = _t(_, s, !0, e) && c } if (c = _t(_ = e.g = r, s, !0, e) && c, c = _t(_, s, !1, e) && c, t) for (f = 0; f < t.length; f++)c = _t(_ = e.g = t[f], s, !1, e) && c } function _t(r, e, t, s) { if (!(e = r.i.g[String(e)])) return !0; e = e.concat(); for (var c = !0, f = 0; f < e.length; ++f) { var _ = e[f]; if (_ && !_.fa && _.capture == t) { var R = _.listener, j = _.la || _.src; _.ia && Ke(r.i, _), c = !1 !== R.call(j, s) && c } } return c && !s.defaultPrevented } ut(In, ie), In.prototype[qt] = !0, In.prototype.removeEventListener = function (r, e, t, s) { Fe(this, r, e, t, s) }, In.prototype.N = function () { if (In.$.N.call(this), this.i) { var e, r = this.i; for (e in r.g) { for (var t = r.g[e], s = 0; s < t.length; s++)qe(t[s]); delete r.g[e], r.h-- } } this.J = null }, In.prototype.O = function (r, e, t, s) { return this.i.add(String(r), e, !1, t, s) }, In.prototype.P = function (r, e, t, s) { return this.i.add(String(r), e, !0, t, s) }; var G = Q.JSON.stringify; function me() { var r = H; let e = null; return r.g && (e = r.g, r.g = r.g.next, r.g || (r.h = null), e.next = null), e } var st = new class W { constructor(e, t) { this.i = e, this.j = t, this.h = 0, this.g = null } get() { let e; return 0 < this.h ? (this.h--, e = this.g, this.g = e.next, e.next = null) : e = this.i(), e } }(() => new Lt, r => r.reset()); class Lt { constructor() { this.next = this.g = this.h = null } set(e, t) { this.h = e, this.g = t, this.next = null } reset() { this.next = this.g = this.h = null } } function He(r) { var e = 1; r = r.split(":"); const t = []; for (; 0 < e && r.length;)t.push(r.shift()), e--; return r.length && t.push(r.join(":")), t } function ae(r) { Q.setTimeout(() => { throw r }, 0) } let z, L = !1, H = new class de { constructor() { this.h = this.g = null } add(e, t) { const s = st.get(); s.set(e, t), this.h ? this.h.next = s : this.g = s, this.h = s } }, Ne = () => { const r = Q.Promise.resolve(void 0); z = () => { r.then(pt) } }; var pt = () => { for (var r; r = me();) { try { r.h.call(r.g) } catch (t) { ae(t) } var e = st; e.j(r), 100 > e.h && (e.h++, r.next = e.g, e.g = r) } L = !1 }; function pe(r, e) { In.call(this), this.h = r || 1, this.g = e || Q, this.j = tt(this.qb, this), this.l = Date.now() } function fe(r) { r.ga = !1, r.T && (r.g.clearTimeout(r.T), r.T = null) } function F(r, e, t) { if ("function" == typeof r) t && (r = tt(r, t)); else { if (!r || "function" != typeof r.handleEvent) throw Error("Invalid listener argument"); r = tt(r.handleEvent, r) } return 2147483647 < Number(e) ? -1 : Q.setTimeout(r, e || 0) } function J(r) { r.g = F(() => { r.g = null, r.i && (r.i = !1, J(r)) }, r.j); const e = r.h; r.h = null, r.m.apply(null, e) } ut(pe, In), (re = pe.prototype).ga = !1, re.T = null, re.qb = function () { if (this.ga) { var r = Date.now() - this.l; 0 < r && r < .8 * this.h ? this.T = this.g.setTimeout(this.j, this.h - r) : (this.T && (this.g.clearTimeout(this.T), this.T = null), Et(this, "tick"), this.ga && (fe(this), this.start())) } }, re.start = function () { this.ga = !0, this.T || (this.T = this.g.setTimeout(this.j, this.h), this.l = Date.now()) }, re.N = function () { pe.$.N.call(this), fe(this), delete this.g }; class Te extends ie { constructor(e, t) { super(), this.m = e, this.j = t, this.h = null, this.i = !1, this.g = null } l(e) { this.h = arguments, this.g ? this.i = !0 : J(this) } N() { super.N(), this.g && (Q.clearTimeout(this.g), this.g = null, this.i = !1, this.h = null) } } function lt(r) { ie.call(this), this.h = r, this.g = {} } ut(lt, ie); var gt = []; function Ht(r, e, t, s) { Array.isArray(t) || (t && (gt[0] = t.toString()), t = gt); for (var c = 0; c < t.length; c++) { var f = Ot(e, t[c], s || r.handleEvent, !1, r.h || r); if (!f) break; r.g[f.key] = f } } function un(r) { Nt(r.g, function (e, t) { this.g.hasOwnProperty(t) && ct(e) }, r), r.g = {} } function yt() { this.g = !0 } function Pn(r, e, t, s) { r.info(function () { return "XMLHTTP TEXT (" + e + "): " + function ni(r, e) { if (!r.g) return e; if (!e) return null; try { var t = JSON.parse(e); if (t) for (r = 0; r < t.length; r++)if (Array.isArray(t[r])) { var s = t[r]; if (!(2 > s.length)) { var c = s[1]; if (Array.isArray(c) && !(1 > c.length)) { var f = c[0]; if ("noop" != f && "stop" != f && "close" != f) for (var _ = 1; _ < c.length; _++)c[_] = "" } } } return G(t) } catch { return e } }(r, t) + (s ? " " + s : "") }) } lt.prototype.N = function () { lt.$.N.call(this), un(this) }, lt.prototype.handleEvent = function () { throw Error("EventHandler.handleEvent not implemented") }, yt.prototype.Ea = function () { this.g = !1 }, yt.prototype.info = function () { }; var si = {}, Ai = null; function Li() { return Ai = Ai || new In } function ho(r) { ee.call(this, si.Ta, r) } function $r(r) { const e = Li(); Et(e, new ho(e)) } function Io(r, e) { ee.call(this, si.STAT_EVENT, r), this.stat = e } function zi(r) { const e = Li(); Et(e, new Io(e, r)) } function Ti(r, e) { ee.call(this, si.Ua, r), this.size = e } function Pr(r, e) { if ("function" != typeof r) throw Error("Fn must not be null and must be a function"); return Q.setTimeout(function () { r() }, e) } si.Ta = "serverreachability", ut(ho, ee), si.STAT_EVENT = "statevent", ut(Io, ee), si.Ua = "timingevent", ut(Ti, ee); var Ir = { NO_ERROR: 0, rb: 1, Eb: 2, Db: 3, yb: 4, Cb: 5, Fb: 6, Qa: 7, TIMEOUT: 8, Ib: 9 }, bo = { wb: "complete", Sb: "success", Ra: "error", Qa: "abort", Kb: "ready", Lb: "readystatechange", TIMEOUT: "timeout", Gb: "incrementaldata", Jb: "progress", zb: "downloadprogress", $b: "uploadprogress" }; function Nr() { } function cs() { } Nr.prototype.h = null; var wt, fo = { OPEN: "a", vb: "b", Ra: "c", Hb: "d" }; function Jo() { ee.call(this, "d") } function sr() { ee.call(this, "c") } function bt() { } function Rt(r, e, t, s) { this.l = r, this.j = e, this.m = t, this.W = s || 1, this.U = new lt(this), this.P = wn, this.V = new pe(r = at ? 125 : void 0), this.I = null, this.i = !1, this.s = this.A = this.v = this.L = this.G = this.Y = this.B = null, this.F = [], this.g = null, this.C = 0, this.o = this.u = null, this.ca = -1, this.J = !1, this.O = 0, this.M = null, this.ba = this.K = this.aa = this.S = !1, this.h = new sn } function sn() { this.i = null, this.g = "", this.h = !1 } ut(Jo, ee), ut(sr, ee), ut(bt, Nr), bt.prototype.g = function () { return new XMLHttpRequest }, bt.prototype.i = function () { return {} }, wt = new bt; var wn = 45e3, dt = {}, Be = {}; function ye(r, e, t) { r.L = 1, r.v = qr(tr(e)), r.s = t, r.S = !0, et(r, null) } function et(r, e) { r.G = Date.now(), Tn(r), r.A = tr(r.v); var t = r.A, s = r.W; Array.isArray(s) || (s = [String(s)]), Br(t.i, "t", s), r.C = 0, t = r.l.J, r.h = new sn, r.g = $o(r.l, t ? e : null, !r.s), 0 < r.O && (r.M = new Te(tt(r.Pa, r, r.g), r.O)), Ht(r.U, r.g, "readystatechange", r.nb), e = r.I ? Zt(r.I) : {}, r.s ? (r.u || (r.u = "POST"), e["Content-Type"] = "application/x-www-form-urlencoded", r.g.ha(r.A, r.u, r.s, e)) : (r.u = "GET", r.g.ha(r.A, r.u, null, e)), $r(), function It(r, e, t, s, c, f) { r.info(function () { if (r.g) if (f) for (var _ = "", R = f.split("&"), j = 0; j < R.length; j++) { var te = R[j].split("="); if (1 < te.length) { var Ce = te[0]; te = te[1]; var ot = Ce.split("_"); _ = 2 <= ot.length && "type" == ot[1] ? _ + (Ce + "=") + te + "&" : _ + (Ce + "=redacted&") } } else _ = null; else _ = f; return "XMLHTTP REQ (" + s + ") [attempt " + c + "]: " + e + "\n" + t + "\n" + _ }) }(r.j, r.u, r.A, r.m, r.W, r.s) } function Vt(r) { return !!r.g && "GET" == r.u && 2 != r.L && r.l.Ha } function At(r, e, t) { let c, s = !0; for (; !r.J && r.C < t.length;) { if (c = cn(r, t), c == Be) { 4 == e && (r.o = 4, zi(14), s = !1), Pn(r.j, r.m, null, "[Incomplete Response]"); break } if (c == dt) { r.o = 4, zi(15), Pn(r.j, r.m, t, "[Invalid Chunk]"), s = !1; break } Pn(r.j, r.m, c, null), xr(r, c) } Vt(r) && c != Be && c != dt && (r.h.g = "", r.C = 0), 4 != e || 0 != t.length || r.h.h || (r.o = 1, zi(16), s = !1), r.i = r.i && s, s ? 0 < t.length && !r.ba && (r.ba = !0, (e = r.l).g == r && e.ca && !e.M && (e.l.info("Great, no buffering proxy detected. Bytes received: " + t.length), ir(e), e.M = !0, zi(11))) : (Pn(r.j, r.m, t, "[Invalid Chunked Response]"), Dr(r), Xi(r)) } function cn(r, e) { var t = r.C, s = e.indexOf("\n", t); return -1 == s ? Be : (t = Number(e.substring(t, s)), isNaN(t) ? dt : (s += 1) + t > e.length ? Be : (e = e.slice(s, s + t), r.C = s + t, e)) } function Tn(r) { r.Y = Date.now() + r.P, ii(r, r.P) } function ii(r, e) { if (null != r.B) throw Error("WatchDog timer not null"); r.B = Pr(tt(r.lb, r), e) } function wi(r) { r.B && (Q.clearTimeout(r.B), r.B = null) } function Xi(r) { 0 == r.l.H || r.J || Yi(r.l, r) } function Dr(r) { wi(r); var e = r.M; e && "function" == typeof e.sa && e.sa(), r.M = null, fe(r.V), un(r.U), r.g && (e = r.g, r.g = null, e.abort(), e.sa()) } function xr(r, e) { try { var t = r.l; if (0 != t.H && (t.g == r || zo(t.i, r))) if (!r.K && zo(t.i, r) && 3 == t.H) { try { var s = t.Ja.g.parse(e) } catch { s = null } if (Array.isArray(s) && 3 == s.length) { var c = s; if (0 == c[0]) { e: if (!t.u) { if (t.g) { if (!(t.g.G + 3e3 < r.G)) break e; gr(t), kt(t) } Bi(t), zi(18) } } else t.Fa = c[1], 0 < t.Fa - t.V && 37500 > c[2] && t.G && 0 == t.A && !t.v && (t.v = Pr(tt(t.ib, t), 6e3)); if (1 >= yo(t.i) && t.oa) { try { t.oa() } catch { } t.oa = void 0 } } else Mr(t, 11) } else if ((r.K || t.g == r) && gr(t), !rt(e)) for (c = t.Ja.g.parse(e), e = 0; e < c.length; e++) { let te = c[e]; if (t.V = te[0], te = te[1], 2 == t.H) if ("c" == te[0]) { t.K = te[1], t.pa = te[2]; const Ce = te[3]; null != Ce && (t.ra = Ce, t.l.info("VER=" + t.ra)); const ot = te[4]; null != ot && (t.Ga = ot, t.l.info("SVER=" + t.Ga)); const Gt = te[5]; null != Gt && "number" == typeof Gt && 0 < Gt && (t.L = s = 1.5 * Gt, t.l.info("backChannelRequestTimeoutMs_=" + s)), s = t; const an = r.g; if (an) { const kn = an.g ? an.g.getResponseHeader("X-Client-Wire-Protocol") : null; if (kn) { var f = s.i; f.g || -1 == kn.indexOf("spdy") && -1 == kn.indexOf("quic") && -1 == kn.indexOf("h2") || (f.j = f.l, f.g = new Set, f.h && (Qo(f, f.h), f.h = null)) } if (s.F) { const Yn = an.g ? an.g.getResponseHeader("X-HTTP-Session-Id") : null; Yn && (s.Da = Yn, di(s.I, s.F, Yn)) } } t.H = 3, t.h && t.h.Ba(), t.ca && (t.S = Date.now() - r.G, t.l.info("Handshake RTT: " + t.S + "ms")); var _ = r; if ((s = t).wa = Do(s, s.J ? s.pa : null, s.Y), _.K) { br(s.i, _); var R = _, j = s.L; j && R.setTimeout(j), R.B && (wi(R), Tn(R)), s.g = _ } else ji(s); 0 < t.j.length && Gn(t) } else "stop" != te[0] && "close" != te[0] || Mr(t, 7); else 3 == t.H && ("stop" == te[0] || "close" == te[0] ? "stop" == te[0] ? Mr(t, 7) : mt(t) : "noop" != te[0] && t.h && t.h.Aa(te), t.A = 0) } $r() } catch { } } function _i(r, e) { if (r.forEach && "function" == typeof r.forEach) r.forEach(e, void 0); else if (_e(r) || "string" == typeof r) Array.prototype.forEach.call(r, e, void 0); else for (var t = function mo(r) { if (r.ta && "function" == typeof r.ta) return r.ta(); if (!r.Z || "function" != typeof r.Z) { if (typeof Map < "u" && r instanceof Map) return Array.from(r.keys()); if (!(typeof Set < "u" && r instanceof Set)) { if (_e(r) || "string" == typeof r) { var e = []; r = r.length; for (var t = 0; t < r; t++)e.push(t); return e } e = [], t = 0; for (const s in r) e[t++] = s; return e } } }(r), s = function Ko(r) { if (r.Z && "function" == typeof r.Z) return r.Z(); if (typeof Map < "u" && r instanceof Map || typeof Set < "u" && r instanceof Set) return Array.from(r.values()); if ("string" == typeof r) return r.split(""); if (_e(r)) { for (var e = [], t = r.length, s = 0; s < t; s++)e.push(r[s]); return e } for (s in e = [], t = 0, r) e[t++] = r[s]; return e }(r), c = s.length, f = 0; f < c; f++)e.call(void 0, s[f], t && t[f], r) } (re = Rt.prototype).setTimeout = function (r) { this.P = r }, re.nb = function (r) { r = r.target; const e = this.M; e && 3 == jo(r) ? e.l() : this.Pa(r) }, re.Pa = function (r) { try { if (r == this.g) e: { const Ce = jo(this.g); var e = this.g.Ia(); if (this.g.da(), !(3 > Ce) && (3 != Ce || at || this.g && (this.h.h || this.g.ja() || K(this.g)))) { this.J || 4 != Ce || 7 == e || $r(), wi(this); var t = this.g.da(); this.ca = t; t: if (Vt(this)) { var s = K(this.g); r = ""; var c = s.length, f = 4 == jo(this.g); if (!this.h.i) { if (typeof TextDecoder > "u") { Dr(this), Xi(this); var _ = ""; break t } this.h.i = new Q.TextDecoder } for (e = 0; e < c; e++)this.h.h = !0, r += this.h.i.decode(s[e], { stream: f && e == c - 1 }); s.splice(0, c), this.h.g += r, this.C = 0, _ = this.h.g } else _ = this.g.ja(); if (this.i = 200 == t, function dn(r, e, t, s, c, f, _) { r.info(function () { return "XMLHTTP RESP (" + s + ") [ attempt " + c + "]: " + e + "\n" + t + "\n" + f + " " + _ }) }(this.j, this.u, this.A, this.m, this.W, Ce, t), this.i) { if (this.aa && !this.K) { t: { if (this.g) { var R, j = this.g; if ((R = j.g ? j.g.getResponseHeader("X-HTTP-Initial-Response") : null) && !rt(R)) { var te = R; break t } } te = null } if (!(t = te)) { this.i = !1, this.o = 3, zi(12), Dr(this), Xi(this); break e } Pn(this.j, this.m, t, "Initial handshake response via X-HTTP-Initial-Response"), this.K = !0, xr(this, t) } this.S ? (At(this, Ce, _), at && this.i && 3 == Ce && (Ht(this.U, this.V, "tick", this.mb), this.V.start())) : (Pn(this.j, this.m, _, null), xr(this, _)), 4 == Ce && Dr(this), this.i && !this.J && (4 == Ce ? Yi(this.l, this) : (this.i = !1, Tn(this))) } else (function V(r) { const e = {}; r = (r.g && 2 <= jo(r) && r.g.getAllResponseHeaders() || "").split("\r\n"); for (let s = 0; s < r.length; s++) { if (rt(r[s])) continue; var t = He(r[s]); const c = t[0]; if ("string" != typeof (t = t[1])) continue; t = t.trim(); const f = e[c] || []; e[c] = f, f.push(t) } !function on(r, e) { for (const t in r) e.call(void 0, r[t], t, r) }(e, function (s) { return s.join(", ") }) })(this.g), 400 == t && 0 < _.indexOf("Unknown SID") ? (this.o = 3, zi(12)) : (this.o = 0, zi(13)), Dr(this), Xi(this) } } } catch { } }, re.mb = function () { if (this.g) { var r = jo(this.g), e = this.g.ja(); this.C < e.length && (wi(this), At(this, r, e), this.i && 4 != r && Tn(this)) } }, re.cancel = function () { this.J = !0, Dr(this) }, re.lb = function () { this.B = null; const r = Date.now(); 0 <= r - this.Y ? (function qn(r, e) { r.info(function () { return "TIMEOUT: " + e }) }(this.j, this.A), 2 != this.L && ($r(), zi(17)), Dr(this), this.o = 2, Xi(this)) : ii(this, this.Y - r) }; var Sn = RegExp("^(?:([^:/?#.]+):)?(?://(?:([^\\\\/?#]*)@)?([^\\\\/?#]*?)(?::([0-9]+))?(?=[\\\\/?#]|$))?([^?#]+)?(?:\\?([^#]*))?(?:#([\\s\\S]*))?$"); function ki(r) { if (this.g = this.s = this.j = "", this.m = null, this.o = this.l = "", this.h = !1, r instanceof ki) { this.h = r.h, Lr(this, r.j), this.s = r.s, this.g = r.g, nr(this, r.m), this.l = r.l; var e = r.i, t = new oo; t.i = e.i, e.g && (t.g = new Map(e.g), t.h = e.h), io(this, t), this.o = r.o } else r && (e = String(r).match(Sn)) ? (this.h = !1, Lr(this, e[1] || "", !0), this.s = ro(e[2] || ""), this.g = ro(e[3] || "", !0), nr(this, e[4]), this.l = ro(e[5] || "", !0), io(this, e[6] || "", !0), this.o = ro(e[7] || "")) : (this.h = !1, this.i = new oo(null, this.h)) } function tr(r) { return new ki(r) } function Lr(r, e, t) { r.j = t ? ro(e, !0) : e, r.j && (r.j = r.j.replace(/:$/, "")) } function nr(r, e) { if (e) { if (e = Number(e), isNaN(e) || 0 > e) throw Error("Bad port number " + e); r.m = e } else r.m = null } function io(r, e, t) { e instanceof oo ? (r.i = e, function so(r, e) { e && !r.j && (Qr(r), r.i = null, r.g.forEach(function (t, s) { var c = s.toLowerCase(); s != c && (es(this, s), Br(this, c, t)) }, r)), r.j = e }(r.i, r.h)) : (t || (e = Xn(e, Zo)), r.i = new oo(e, r.h)) } function di(r, e, t) { r.i.set(e, t) } function qr(r) { return di(r, "zx", Math.floor(2147483648 * Math.random()).toString(36) + Math.abs(Math.floor(2147483648 * Math.random()) ^ Date.now()).toString(36)), r } function ro(r, e) { return r ? e ? decodeURI(r.replace(/%25/g, "%2525")) : decodeURIComponent(r) : "" } function Xn(r, e, t) { return "string" == typeof r ? (r = encodeURI(r).replace(e, vs), t && (r = r.replace(/%25([0-9a-fA-F]{2})/g, "%$1")), r) : null } function vs(r) { return "%" + ((r = r.charCodeAt(0)) >> 4 & 15).toString(16) + (15 & r).toString(16) } ki.prototype.toString = function () { var r = [], e = this.j; e && r.push(Xn(e, Ao, !0), ":"); var t = this.g; return (t || "file" == e) && (r.push("//"), (e = this.s) && r.push(Xn(e, Ao, !0), "@"), r.push(encodeURIComponent(String(t)).replace(/%25([0-9a-fA-F]{2})/g, "%$1")), null != (t = this.m) && r.push(":", String(t))), (t = this.l) && (this.g && "/" != t.charAt(0) && r.push("/"), r.push(Xn(t, "/" == t.charAt(0) ? cr : ko, !0))), (t = this.i.toString()) && r.push("?", t), (t = this.o) && r.push("#", Xn(t, ds)), r.join("") }; var Ao = /[#\/\?@]/g, ko = /[#\?:]/g, cr = /[#\?]/g, Zo = /[#\?@]/g, ds = /#/g; function oo(r, e) { this.h = this.g = null, this.i = r || null, this.j = !!e } function Qr(r) { r.g || (r.g = new Map, r.h = 0, r.i && function ci(r, e) { if (r) { r = r.split("&"); for (var t = 0; t < r.length; t++) { var s = r[t].indexOf("="), c = null; if (0 <= s) { var f = r[t].substring(0, s); c = r[t].substring(s + 1) } else f = r[t]; e(f, c ? decodeURIComponent(c.replace(/\+/g, " ")) : "") } } }(r.i, function (e, t) { r.add(decodeURIComponent(e.replace(/\+/g, " ")), t) })) } function es(r, e) { Qr(r), e = Yo(r, e), r.g.has(e) && (r.i = null, r.h -= r.g.get(e).length, r.g.delete(e)) } function Tr(r, e) { return Qr(r), e = Yo(r, e), r.g.has(e) } function Br(r, e, t) { es(r, e), 0 < t.length && (r.i = null, r.g.set(Yo(r, e), ge(t)), r.h += t.length) } function Yo(r, e) { return e = String(e), r.j && (e = e.toLowerCase()), e } function qo(r) { this.l = r || Ho, r = Q.PerformanceNavigationTiming ? 0 < (r = Q.performance.getEntriesByType("navigation")).length && ("hq" == r[0].nextHopProtocol || "h2" == r[0].nextHopProtocol) : !!(Q.g && Q.g.Ka && Q.g.Ka() && Q.g.Ka().ec), this.j = r ? this.l : 1, this.g = null, 1 < this.j && (this.g = new Set), this.h = null, this.i = [] } (re = oo.prototype).add = function (r, e) { Qr(this), this.i = null, r = Yo(this, r); var t = this.g.get(r); return t || this.g.set(r, t = []), t.push(e), this.h += 1, this }, re.forEach = function (r, e) { Qr(this), this.g.forEach(function (t, s) { t.forEach(function (c) { r.call(e, c, s, this) }, this) }, this) }, re.ta = function () { Qr(this); const r = Array.from(this.g.values()), e = Array.from(this.g.keys()), t = []; for (let s = 0; s < e.length; s++) { const c = r[s]; for (let f = 0; f < c.length; f++)t.push(e[s]) } return t }, re.Z = function (r) { Qr(this); let e = []; if ("string" == typeof r) Tr(this, r) && (e = e.concat(this.g.get(Yo(this, r)))); else { r = Array.from(this.g.values()); for (let t = 0; t < r.length; t++)e = e.concat(r[t]) } return e }, re.set = function (r, e) { return Qr(this), this.i = null, Tr(this, r = Yo(this, r)) && (this.h -= this.g.get(r).length), this.g.set(r, [e]), this.h += 1, this }, re.get = function (r, e) { return r && 0 < (r = this.Z(r)).length ? String(r[0]) : e }, re.toString = function () { if (this.i) return this.i; if (!this.g) return ""; const r = [], e = Array.from(this.g.keys()); for (var t = 0; t < e.length; t++) { var s = e[t]; const f = encodeURIComponent(String(s)), _ = this.Z(s); for (s = 0; s < _.length; s++) { var c = f; "" !== _[s] && (c += "=" + encodeURIComponent(String(_[s]))), r.push(c) } } return this.i = r.join("&") }; var Ho = 10; function Ro(r) { return !!r.h || !!r.g && r.g.size >= r.j } function yo(r) { return r.h ? 1 : r.g ? r.g.size : 0 } function zo(r, e) { return r.h ? r.h == e : !!r.g && r.g.has(e) } function Qo(r, e) { r.g ? r.g.add(e) : r.h = e } function br(r, e) { r.h && r.h == e ? r.h = null : r.g && r.g.has(e) && r.g.delete(e) } function Ki(r) { if (null != r.h) return r.i.concat(r.h.F); if (null != r.g && 0 !== r.g.size) { let e = r.i; for (const t of r.g.values()) e = e.concat(t.F); return e } return ge(r.i) } qo.prototype.cancel = function () { if (this.i = Ki(this), this.h) this.h.cancel(), this.h = null; else if (this.g && 0 !== this.g.size) { for (const r of this.g.values()) r.cancel(); this.g.clear() } }; var po = class { stringify(r) { return Q.JSON.stringify(r, void 0) } parse(r) { return Q.JSON.parse(r, void 0) } }; function Er() { this.g = new po } function Gr(r, e, t) { const s = t || ""; try { _i(r, function (c, f) { let _ = c; xe(c) && (_ = G(c)), e.push(s + f + "=" + encodeURIComponent(_)) }) } catch (c) { throw e.push(s + "type=" + encodeURIComponent("_badmap")), c } } function dr(r, e, t, s, c) { try { e.onload = null, e.onerror = null, e.onabort = null, e.ontimeout = null, c(s) } catch { } } function Wr(r) { this.l = r.fc || null, this.j = r.ob || !1 } function Ni(r, e) { In.call(this), this.F = r, this.u = e, this.m = void 0, this.readyState = As, this.status = 0, this.responseType = this.responseText = this.response = this.statusText = "", this.onreadystatechange = null, this.v = new Headers, this.h = null, this.C = "GET", this.B = "", this.g = !1, this.A = this.j = this.l = null } ut(Wr, Nr), Wr.prototype.g = function () { return new Ni(this.l, this.j) }, Wr.prototype.i = function (r) { return function () { return r } }({}), ut(Ni, In); var As = 0; function ao(r) { r.j.read().then(r.Xa.bind(r)).catch(r.ka.bind(r)) } function Xr(r) { r.readyState = 4, r.l = null, r.j = null, r.A = null, bs(r) } function bs(r) { r.onreadystatechange && r.onreadystatechange.call(r) } (re = Ni.prototype).open = function (r, e) { if (this.readyState != As) throw this.abort(), Error("Error reopening a connection"); this.C = r, this.B = e, this.readyState = 1, bs(this) }, re.send = function (r) { if (1 != this.readyState) throw this.abort(), Error("need to call open() first. "); this.g = !0; const e = { headers: this.v, method: this.C, credentials: this.m, cache: void 0 }; r && (e.body = r), (this.F || Q).fetch(new Request(this.B, e)).then(this.$a.bind(this), this.ka.bind(this)) }, re.abort = function () { this.response = this.responseText = "", this.v = new Headers, this.status = 0, this.j && this.j.cancel("Request was aborted.").catch(() => { }), 1 <= this.readyState && this.g && 4 != this.readyState && (this.g = !1, Xr(this)), this.readyState = As }, re.$a = function (r) { if (this.g && (this.l = r, this.h || (this.status = this.l.status, this.statusText = this.l.statusText, this.h = r.headers, this.readyState = 2, bs(this)), this.g && (this.readyState = 3, bs(this), this.g))) if ("arraybuffer" === this.responseType) r.arrayBuffer().then(this.Ya.bind(this), this.ka.bind(this)); else if (typeof Q.ReadableStream < "u" && "body" in r) { if (this.j = r.body.getReader(), this.u) { if (this.responseType) throw Error('responseType must be empty for "streamBinaryChunks" mode responses.'); this.response = [] } else this.response = this.responseText = "", this.A = new TextDecoder; ao(this) } else r.text().then(this.Za.bind(this), this.ka.bind(this)) }, re.Xa = function (r) { if (this.g) { if (this.u && r.value) this.response.push(r.value); else if (!this.u) { var e = r.value ? r.value : new Uint8Array(0); (e = this.A.decode(e, { stream: !r.done })) && (this.response = this.responseText += e) } r.done ? Xr(this) : bs(this), 3 == this.readyState && ao(this) } }, re.Za = function (r) { this.g && (this.response = this.responseText = r, Xr(this)) }, re.Ya = function (r) { this.g && (this.response = r, Xr(this)) }, re.ka = function () { this.g && Xr(this) }, re.setRequestHeader = function (r, e) { this.v.append(r, e) }, re.getResponseHeader = function (r) { return this.h && this.h.get(r.toLowerCase()) || "" }, re.getAllResponseHeaders = function () { if (!this.h) return ""; const r = [], e = this.h.entries(); for (var t = e.next(); !t.done;)r.push((t = t.value)[0] + ": " + t[1]), t = e.next(); return r.join("\r\n") }, Object.defineProperty(Ni.prototype, "withCredentials", { get: function () { return "include" === this.m }, set: function (r) { this.m = r ? "include" : "same-origin" } }); var ta = Q.JSON.parse; function Ci(r) { In.call(this), this.headers = new Map, this.u = r || null, this.h = !1, this.C = this.g = null, this.I = "", this.m = 0, this.j = "", this.l = this.G = this.v = this.F = !1, this.B = 0, this.A = null, this.K = ys, this.L = this.M = !1 } ut(Ci, In); var ys = "", Da = /^https?$/i, Ws = ["POST", "PUT"]; function ha(r, e) { r.h = !1, r.g && (r.l = !0, r.g.abort(), r.l = !1), r.j = e, r.m = 5, fa(r), is(r) } function fa(r) { r.F || (r.F = !0, Et(r, "complete"), Et(r, "error")) } function ws(r) { if (r.h && typeof Ie < "u" && (!r.C[1] || 4 != jo(r) || 2 != r.da())) if (r.v && 4 == jo(r)) F(r.La, 0, r); else if (Et(r, "readystatechange"), 4 == jo(r)) { r.h = !1; try { const _ = r.da(); e: switch (_) { case 200: case 201: case 202: case 204: case 206: case 304: case 1223: var e = !0; break e; default: e = !1 }var t; if (!(t = e)) { var s; if (s = 0 === _) { var c = String(r.I).match(Sn)[1] || null; !c && Q.self && Q.self.location && (c = Q.self.location.protocol.slice(0, -1)), s = !Da.test(c ? c.toLowerCase() : "") } t = s } if (t) Et(r, "complete"), Et(r, "success"); else { r.m = 6; try { var f = 2 < jo(r) ? r.g.statusText : "" } catch { f = "" } r.j = f + " [" + r.da() + "]", fa(r) } } finally { is(r) } } } function is(r, e) { if (r.g) { Ks(r); const t = r.g, s = r.C[0] ? () => { } : null; r.g = null, r.C = null, e || Et(r, "ready"); try { t.onreadystatechange = s } catch { } } } function Ks(r) { r.g && r.L && (r.g.ontimeout = null), r.A && (Q.clearTimeout(r.A), r.A = null) } function jo(r) { return r.g ? r.g.readyState : 0 } function K(r) { try { if (!r.g) return null; if ("response" in r.g) return r.g.response; switch (r.K) { case ys: case "text": return r.g.responseText; case "arraybuffer": if ("mozResponseArrayBuffer" in r.g) return r.g.mozResponseArrayBuffer }return null } catch { return null } } function w(r) { let e = ""; return Nt(r, function (t, s) { e += s, e += ":", e += t, e += "\r\n" }), e } function D(r, e, t) { e: { for (s in t) { var s = !1; break e } s = !0 } s || (t = w(t), "string" == typeof r ? null != t && encodeURIComponent(String(t)) : di(r, e, t)) } function ne(r, e, t) { return t && t.internalChannelParams && t.internalChannelParams[r] || e } function Re(r) { this.Ga = 0, this.j = [], this.l = new yt, this.pa = this.wa = this.I = this.Y = this.g = this.Da = this.F = this.na = this.o = this.U = this.s = null, this.fb = this.W = 0, this.cb = ne("failFast", !1, r), this.G = this.v = this.u = this.m = this.h = null, this.aa = !0, this.Fa = this.V = -1, this.ba = this.A = this.C = 0, this.ab = ne("baseRetryDelayMs", 5e3, r), this.hb = ne("retryDelaySeedMs", 1e4, r), this.eb = ne("forwardChannelMaxRetries", 2, r), this.xa = ne("forwardChannelRequestTimeoutMs", 2e4, r), this.va = r && r.xmlHttpFactory || void 0, this.Ha = r && r.dc || !1, this.L = void 0, this.J = r && r.supportsCrossDomainXhr || !1, this.K = "", this.i = new qo(r && r.concurrentRequestLimit), this.Ja = new Er, this.P = r && r.fastHandshake || !1, this.O = r && r.encodeInitMessageHeaders || !1, this.P && this.O && (this.O = !1), this.bb = r && r.bc || !1, r && r.Ea && this.l.Ea(), r && r.forceLongPolling && (this.aa = !1), this.ca = !this.P && this.aa && r && r.detectBufferingProxy || !1, this.qa = void 0, r && r.longPollingTimeout && 0 < r.longPollingTimeout && (this.qa = r.longPollingTimeout), this.oa = void 0, this.S = 0, this.M = !1, this.ma = this.B = null } function mt(r) { if (mn(r), 3 == r.H) { var e = r.W++, t = tr(r.I); if (di(t, "SID", r.K), di(t, "RID", e), di(t, "TYPE", "terminate"), Ii(r, t), (e = new Rt(r, r.l, e)).L = 2, e.v = qr(tr(t)), t = !1, Q.navigator && Q.navigator.sendBeacon) try { t = Q.navigator.sendBeacon(e.v.toString(), "") } catch { } !t && Q.Image && ((new Image).src = e.v, t = !0), t || (e.g = $o(e.l, null), e.g.ha(e.v)), e.G = Date.now(), Tn(e) } Sr(r) } function kt(r) { r.g && (ir(r), r.g.cancel(), r.g = null) } function mn(r) { kt(r), r.u && (Q.clearTimeout(r.u), r.u = null), gr(r), r.i.cancel(), r.m && ("number" == typeof r.m && Q.clearTimeout(r.m), r.m = null) } function Gn(r) { if (!Ro(r.i) && !r.m) { r.m = !0; var e = r.Na; z || Ne(), L || (z(), L = !0), H.add(e, r), r.C = 0 } } function gi(r, e) { var t; t = e ? e.m : r.W++; const s = tr(r.I); di(s, "SID", r.K), di(s, "RID", t), di(s, "AID", r.V), Ii(r, s), r.o && r.s && D(s, r.o, r.s), t = new Rt(r, r.l, t, r.C + 1), null === r.o && (t.I = r.s), e && (r.j = e.F.concat(r.j)), e = Zi(r, t, 1e3), t.setTimeout(Math.round(.5 * r.xa) + Math.round(.5 * r.xa * Math.random())), Qo(r.i, t), ye(t, s, e) } function Ii(r, e) { r.na && Nt(r.na, function (t, s) { di(e, s, t) }), r.h && _i({}, function (t, s) { di(e, s, t) }) } function Zi(r, e, t) { t = Math.min(r.j.length, t); var s = r.h ? tt(r.h.Va, r.h, r) : null; e: { var c = r.j; let f = -1; for (; ;) { const _ = ["count=" + t]; -1 == f ? 0 < t ? (f = c[0].g, _.push("ofs=" + f)) : f = 0 : _.push("ofs=" + f); let R = !0; for (let j = 0; j < t; j++) { let te = c[j].g; const Ce = c[j].map; if (te -= f, 0 > te) f = Math.max(0, c[j].g - 100), R = !1; else try { Gr(Ce, _, "req" + te + "_") } catch { s && s(Ce) } } if (R) { s = _.join("&"); break e } } } return r = r.j.splice(0, t), e.F = r, s } function ji(r) { if (!r.g && !r.u) { r.ba = 1; var e = r.Ma; z || Ne(), L || (z(), L = !0), H.add(e, r), r.A = 0 } } function Bi(r) { return !(r.g || r.u || 3 <= r.A || (r.ba++, r.u = Pr(tt(r.Ma, r), Kr(r, r.A)), r.A++, 0)) } function ir(r) { null != r.B && (Q.clearTimeout(r.B), r.B = null) } function ar(r) { r.g = new Rt(r, r.l, "rpc", r.ba), null === r.o && (r.g.I = r.s), r.g.O = 0; var e = tr(r.wa); di(e, "RID", "rpc"), di(e, "SID", r.K), di(e, "AID", r.V), di(e, "CI", r.G ? "0" : "1"), !r.G && r.qa && di(e, "TO", r.qa), di(e, "TYPE", "xmlhttp"), Ii(r, e), r.o && r.s && D(e, r.o, r.s), r.L && r.g.setTimeout(r.L); var t = r.g; r = r.pa, t.L = 1, t.v = qr(tr(e)), t.s = null, t.S = !0, et(t, r) } function gr(r) { null != r.v && (Q.clearTimeout(r.v), r.v = null) } function Yi(r, e) { var t = null; if (r.g == e) { gr(r), ir(r), r.g = null; var s = 2 } else { if (!zo(r.i, e)) return; t = e.F, br(r.i, e), s = 1 } if (0 != r.H) if (e.i) if (1 == s) { t = e.s ? e.s.length : 0, e = Date.now() - e.G; var c = r.C; Et(s = Li(), new Ti(s, t)), Gn(r) } else ji(r); else if (3 == (c = e.o) || 0 == c && 0 < e.ca || !(1 == s && function jn(r, e) { return !(yo(r.i) >= r.i.j - (r.m ? 1 : 0) || (r.m ? (r.j = e.F.concat(r.j), 0) : 1 == r.H || 2 == r.H || r.C >= (r.cb ? 0 : r.eb) || (r.m = Pr(tt(r.Na, r, e), Kr(r, r.C)), r.C++, 0))) }(r, e) || 2 == s && Bi(r))) switch (t && 0 < t.length && (e = r.i, e.i = e.i.concat(t)), c) { case 1: Mr(r, 5); break; case 4: Mr(r, 10); break; case 3: Mr(r, 6); break; default: Mr(r, 2) } } function Kr(r, e) { let t = r.ab + Math.floor(Math.random() * r.hb); return r.isActive() || (t *= 2), t * e } function Mr(r, e) { if (r.l.info("Error code " + e), 2 == e) { var t = null; r.h && (t = null); var s = tt(r.pb, r); t || (t = new ki("//www.google.com/images/cleardot.gif"), Q.location && "http" == Q.location.protocol || Lr(t, "https"), qr(t)), function us(r, e) { const t = new yt; if (Q.Image) { const s = new Image; s.onload = Ye(dr, t, s, "TestLoadImage: loaded", !0, e), s.onerror = Ye(dr, t, s, "TestLoadImage: error", !1, e), s.onabort = Ye(dr, t, s, "TestLoadImage: abort", !1, e), s.ontimeout = Ye(dr, t, s, "TestLoadImage: timeout", !1, e), Q.setTimeout(function () { s.ontimeout && s.ontimeout() }, 1e4), s.src = r } else e(!1) }(t.toString(), s) } else zi(2); r.H = 0, r.h && r.h.za(e), Sr(r), mn(r) } function Sr(r) { if (r.H = 0, r.ma = [], r.h) { const e = Ki(r.i); (0 != e.length || 0 != r.j.length) && (ue(r.ma, e), ue(r.ma, r.j), r.i.i.length = 0, ge(r.j), r.j.length = 0), r.h.ya() } } function Do(r, e, t) { var s = t instanceof ki ? tr(t) : new ki(t); if ("" != s.g) e && (s.g = e + "." + s.g), nr(s, s.m); else { var c = Q.location; s = c.protocol, e = e ? e + "." + c.hostname : c.hostname, c = +c.port; var f = new ki(null); s && Lr(f, s), e && (f.g = e), c && nr(f, c), t && (f.l = t), s = f } return e = r.Da, (t = r.F) && e && di(s, t, e), di(s, "VER", r.ra), Ii(r, s), s } function $o(r, e, t) { if (e && !r.J) throw Error("Can't create secondary domain capable XhrIo object."); return (e = new Ci(t && r.Ha && !r.va ? new Wr({ ob: !0 }) : r.va)).Oa(r.J), e } function hs() { } function rs() { if (Wn && !(10 <= Number(ht))) throw Error("Environmental error: no available transport.") } function Jr(r, e) { In.call(this), this.g = new Re(e), this.l = r, this.h = e && e.messageUrlParams || null, r = e && e.messageHeaders || null, e && e.clientProtocolHeaderRequired && (r ? r["X-Client-Protocol"] = "webchannel" : r = { "X-Client-Protocol": "webchannel" }), this.g.s = r, r = e && e.initMessageHeaders || null, e && e.messageContentType && (r ? r["X-WebChannel-Content-Type"] = e.messageContentType : r = { "X-WebChannel-Content-Type": e.messageContentType }), e && e.Ca && (r ? r["X-WebChannel-Client-Profile"] = e.Ca : r = { "X-WebChannel-Client-Profile": e.Ca }), this.g.U = r, (r = e && e.cc) && !rt(r) && (this.g.o = r), this.A = e && e.supportsCrossDomainXhr || !1, this.v = e && e.sendRawJson || !1, (e = e && e.httpSessionIdParam) && !rt(e) && (this.g.F = e, null !== (r = this.h) && e in r && e in (r = this.h) && delete r[e]), this.j = new ks(this) } function os(r) { Jo.call(this), r.__headers__ && (this.headers = r.__headers__, this.statusCode = r.__status__, delete r.__headers__, delete r.__status__); var e = r.__sm__; if (e) { e: { for (const t in e) { r = t; break e } r = void 0 } (this.i = r) && (r = this.i, e = null !== e && r in e ? e[r] : void 0), this.data = e } else this.data = r } function Ka() { sr.call(this), this.status = 1 } function ks(r) { this.g = r } function fs() { this.blockSize = -1, this.blockSize = 64, this.g = Array(4), this.m = Array(this.blockSize), this.i = this.h = 0, this.reset() } function Za(r, e, t) { t || (t = 0); var s = Array(16); if ("string" == typeof e) for (var c = 0; 16 > c; ++c)s[c] = e.charCodeAt(t++) | e.charCodeAt(t++) << 8 | e.charCodeAt(t++) << 16 | e.charCodeAt(t++) << 24; else for (c = 0; 16 > c; ++c)s[c] = e[t++] | e[t++] << 8 | e[t++] << 16 | e[t++] << 24; var f = r.g[3], _ = (e = r.g[0]) + (f ^ (t = r.g[1]) & ((c = r.g[2]) ^ f)) + s[0] + 3614090360 & 4294967295; _ = (t = (c = (f = (e = (t = (c = (f = (e = (t = (c = (f = (e = (t = (c = (f = (e = (t = (c = (f = (e = (t = (c = (f = (e = (t = (c = (f = (e = (t = (c = (f = (e = (t = (c = (f = (e = (t = (c = (f = (e = (t = (c = (f = (e = (t = (c = (f = (e = (t = (c = (f = (e = (t = (c = (f = (e = (t = (c = (f = (e = t + (_ << 7 & 4294967295 | _ >>> 25)) + ((_ = f + (c ^ e & (t ^ c)) + s[1] + 3905402710 & 4294967295) << 12 & 4294967295 | _ >>> 20)) + ((_ = c + (t ^ f & (e ^ t)) + s[2] + 606105819 & 4294967295) << 17 & 4294967295 | _ >>> 15)) + ((_ = t + (e ^ c & (f ^ e)) + s[3] + 3250441966 & 4294967295) << 22 & 4294967295 | _ >>> 10)) + ((_ = e + (f ^ t & (c ^ f)) + s[4] + 4118548399 & 4294967295) << 7 & 4294967295 | _ >>> 25)) + ((_ = f + (c ^ e & (t ^ c)) + s[5] + 1200080426 & 4294967295) << 12 & 4294967295 | _ >>> 20)) + ((_ = c + (t ^ f & (e ^ t)) + s[6] + 2821735955 & 4294967295) << 17 & 4294967295 | _ >>> 15)) + ((_ = t + (e ^ c & (f ^ e)) + s[7] + 4249261313 & 4294967295) << 22 & 4294967295 | _ >>> 10)) + ((_ = e + (f ^ t & (c ^ f)) + s[8] + 1770035416 & 4294967295) << 7 & 4294967295 | _ >>> 25)) + ((_ = f + (c ^ e & (t ^ c)) + s[9] + 2336552879 & 4294967295) << 12 & 4294967295 | _ >>> 20)) + ((_ = c + (t ^ f & (e ^ t)) + s[10] + 4294925233 & 4294967295) << 17 & 4294967295 | _ >>> 15)) + ((_ = t + (e ^ c & (f ^ e)) + s[11] + 2304563134 & 4294967295) << 22 & 4294967295 | _ >>> 10)) + ((_ = e + (f ^ t & (c ^ f)) + s[12] + 1804603682 & 4294967295) << 7 & 4294967295 | _ >>> 25)) + ((_ = f + (c ^ e & (t ^ c)) + s[13] + 4254626195 & 4294967295) << 12 & 4294967295 | _ >>> 20)) + ((_ = c + (t ^ f & (e ^ t)) + s[14] + 2792965006 & 4294967295) << 17 & 4294967295 | _ >>> 15)) + ((_ = t + (e ^ c & (f ^ e)) + s[15] + 1236535329 & 4294967295) << 22 & 4294967295 | _ >>> 10)) + ((_ = e + (c ^ f & (t ^ c)) + s[1] + 4129170786 & 4294967295) << 5 & 4294967295 | _ >>> 27)) + ((_ = f + (t ^ c & (e ^ t)) + s[6] + 3225465664 & 4294967295) << 9 & 4294967295 | _ >>> 23)) + ((_ = c + (e ^ t & (f ^ e)) + s[11] + 643717713 & 4294967295) << 14 & 4294967295 | _ >>> 18)) + ((_ = t + (f ^ e & (c ^ f)) + s[0] + 3921069994 & 4294967295) << 20 & 4294967295 | _ >>> 12)) + ((_ = e + (c ^ f & (t ^ c)) + s[5] + 3593408605 & 4294967295) << 5 & 4294967295 | _ >>> 27)) + ((_ = f + (t ^ c & (e ^ t)) + s[10] + 38016083 & 4294967295) << 9 & 4294967295 | _ >>> 23)) + ((_ = c + (e ^ t & (f ^ e)) + s[15] + 3634488961 & 4294967295) << 14 & 4294967295 | _ >>> 18)) + ((_ = t + (f ^ e & (c ^ f)) + s[4] + 3889429448 & 4294967295) << 20 & 4294967295 | _ >>> 12)) + ((_ = e + (c ^ f & (t ^ c)) + s[9] + 568446438 & 4294967295) << 5 & 4294967295 | _ >>> 27)) + ((_ = f + (t ^ c & (e ^ t)) + s[14] + 3275163606 & 4294967295) << 9 & 4294967295 | _ >>> 23)) + ((_ = c + (e ^ t & (f ^ e)) + s[3] + 4107603335 & 4294967295) << 14 & 4294967295 | _ >>> 18)) + ((_ = t + (f ^ e & (c ^ f)) + s[8] + 1163531501 & 4294967295) << 20 & 4294967295 | _ >>> 12)) + ((_ = e + (c ^ f & (t ^ c)) + s[13] + 2850285829 & 4294967295) << 5 & 4294967295 | _ >>> 27)) + ((_ = f + (t ^ c & (e ^ t)) + s[2] + 4243563512 & 4294967295) << 9 & 4294967295 | _ >>> 23)) + ((_ = c + (e ^ t & (f ^ e)) + s[7] + 1735328473 & 4294967295) << 14 & 4294967295 | _ >>> 18)) + ((_ = t + (f ^ e & (c ^ f)) + s[12] + 2368359562 & 4294967295) << 20 & 4294967295 | _ >>> 12)) + ((_ = e + (t ^ c ^ f) + s[5] + 4294588738 & 4294967295) << 4 & 4294967295 | _ >>> 28)) + ((_ = f + (e ^ t ^ c) + s[8] + 2272392833 & 4294967295) << 11 & 4294967295 | _ >>> 21)) + ((_ = c + (f ^ e ^ t) + s[11] + 1839030562 & 4294967295) << 16 & 4294967295 | _ >>> 16)) + ((_ = t + (c ^ f ^ e) + s[14] + 4259657740 & 4294967295) << 23 & 4294967295 | _ >>> 9)) + ((_ = e + (t ^ c ^ f) + s[1] + 2763975236 & 4294967295) << 4 & 4294967295 | _ >>> 28)) + ((_ = f + (e ^ t ^ c) + s[4] + 1272893353 & 4294967295) << 11 & 4294967295 | _ >>> 21)) + ((_ = c + (f ^ e ^ t) + s[7] + 4139469664 & 4294967295) << 16 & 4294967295 | _ >>> 16)) + ((_ = t + (c ^ f ^ e) + s[10] + 3200236656 & 4294967295) << 23 & 4294967295 | _ >>> 9)) + ((_ = e + (t ^ c ^ f) + s[13] + 681279174 & 4294967295) << 4 & 4294967295 | _ >>> 28)) + ((_ = f + (e ^ t ^ c) + s[0] + 3936430074 & 4294967295) << 11 & 4294967295 | _ >>> 21)) + ((_ = c + (f ^ e ^ t) + s[3] + 3572445317 & 4294967295) << 16 & 4294967295 | _ >>> 16)) + ((_ = t + (c ^ f ^ e) + s[6] + 76029189 & 4294967295) << 23 & 4294967295 | _ >>> 9)) + ((_ = e + (t ^ c ^ f) + s[9] + 3654602809 & 4294967295) << 4 & 4294967295 | _ >>> 28)) + ((_ = f + (e ^ t ^ c) + s[12] + 3873151461 & 4294967295) << 11 & 4294967295 | _ >>> 21)) + ((_ = c + (f ^ e ^ t) + s[15] + 530742520 & 4294967295) << 16 & 4294967295 | _ >>> 16)) + ((_ = t + (c ^ f ^ e) + s[2] + 3299628645 & 4294967295) << 23 & 4294967295 | _ >>> 9)) + ((_ = e + (c ^ (t | ~f)) + s[0] + 4096336452 & 4294967295) << 6 & 4294967295 | _ >>> 26)) + ((_ = f + (t ^ (e | ~c)) + s[7] + 1126891415 & 4294967295) << 10 & 4294967295 | _ >>> 22)) + ((_ = c + (e ^ (f | ~t)) + s[14] + 2878612391 & 4294967295) << 15 & 4294967295 | _ >>> 17)) + ((_ = t + (f ^ (c | ~e)) + s[5] + 4237533241 & 4294967295) << 21 & 4294967295 | _ >>> 11)) + ((_ = e + (c ^ (t | ~f)) + s[12] + 1700485571 & 4294967295) << 6 & 4294967295 | _ >>> 26)) + ((_ = f + (t ^ (e | ~c)) + s[3] + 2399980690 & 4294967295) << 10 & 4294967295 | _ >>> 22)) + ((_ = c + (e ^ (f | ~t)) + s[10] + 4293915773 & 4294967295) << 15 & 4294967295 | _ >>> 17)) + ((_ = t + (f ^ (c | ~e)) + s[1] + 2240044497 & 4294967295) << 21 & 4294967295 | _ >>> 11)) + ((_ = e + (c ^ (t | ~f)) + s[8] + 1873313359 & 4294967295) << 6 & 4294967295 | _ >>> 26)) + ((_ = f + (t ^ (e | ~c)) + s[15] + 4264355552 & 4294967295) << 10 & 4294967295 | _ >>> 22)) + ((_ = c + (e ^ (f | ~t)) + s[6] + 2734768916 & 4294967295) << 15 & 4294967295 | _ >>> 17)) + ((_ = t + (f ^ (c | ~e)) + s[13] + 1309151649 & 4294967295) << 21 & 4294967295 | _ >>> 11)) + ((f = (e = t + ((_ = e + (c ^ (t | ~f)) + s[4] + 4149444226 & 4294967295) << 6 & 4294967295 | _ >>> 26)) + ((_ = f + (t ^ (e | ~c)) + s[11] + 3174756917 & 4294967295) << 10 & 4294967295 | _ >>> 22)) ^ ((c = f + ((_ = c + (e ^ (f | ~t)) + s[2] + 718787259 & 4294967295) << 15 & 4294967295 | _ >>> 17)) | ~e)) + s[9] + 3951481745 & 4294967295, r.g[0] = r.g[0] + e & 4294967295, r.g[1] = r.g[1] + (c + (_ << 21 & 4294967295 | _ >>> 11)) & 4294967295, r.g[2] = r.g[2] + c & 4294967295, r.g[3] = r.g[3] + f & 4294967295 } function _r(r, e) { this.h = e; for (var t = [], s = !0, c = r.length - 1; 0 <= c; c--) { var f = 0 | r[c]; s && f == e || (t[c] = f, s = !1) } this.g = t } (re = Ci.prototype).Oa = function (r) { this.M = r }, re.ha = function (r, e, t, s) { if (this.g) throw Error("[goog.net.XhrIo] Object is active with another request=" + this.I + "; newUri=" + r); e = e ? e.toUpperCase() : "GET", this.I = r, this.j = "", this.m = 0, this.F = !1, this.h = !0, this.g = this.u ? this.u.g() : wt.g(), this.C = function Vi(r) { return r.h || (r.h = r.i()) }(this.u ? this.u : wt), this.g.onreadystatechange = tt(this.La, this); try { this.G = !0, this.g.open(e, String(r), !0), this.G = !1 } catch (f) { return void ha(this, f) } if (r = t || "", t = new Map(this.headers), s) if (Object.getPrototypeOf(s) === Object.prototype) for (var c in s) t.set(c, s[c]); else { if ("function" != typeof s.keys || "function" != typeof s.get) throw Error("Unknown input type for opt_headers: " + String(s)); for (const f of s.keys()) t.set(f, s.get(f)) } s = Array.from(t.keys()).find(f => "content-type" == f.toLowerCase()), c = Q.FormData && r instanceof Q.FormData, !(0 <= le(Ws, e)) || s || c || t.set("Content-Type", "application/x-www-form-urlencoded;charset=utf-8"); for (const [f, _] of t) this.g.setRequestHeader(f, _); this.K && (this.g.responseType = this.K), "withCredentials" in this.g && this.g.withCredentials !== this.M && (this.g.withCredentials = this.M); try { Ks(this), 0 < this.B && ((this.L = function na(r) { return Wn && "number" == typeof r.timeout && void 0 !== r.ontimeout }(this.g)) ? (this.g.timeout = this.B, this.g.ontimeout = tt(this.ua, this)) : this.A = F(this.ua, this.B, this)), this.v = !0, this.g.send(r), this.v = !1 } catch (f) { ha(this, f) } }, re.ua = function () { typeof Ie < "u" && this.g && (this.j = "Timed out after " + this.B + "ms, aborting", this.m = 8, Et(this, "timeout"), this.abort(8)) }, re.abort = function (r) { this.g && this.h && (this.h = !1, this.l = !0, this.g.abort(), this.l = !1, this.m = r || 7, Et(this, "complete"), Et(this, "abort"), is(this)) }, re.N = function () { this.g && (this.h && (this.h = !1, this.l = !0, this.g.abort(), this.l = !1), is(this, !0)), Ci.$.N.call(this) }, re.La = function () { this.s || (this.G || this.v || this.l ? ws(this) : this.kb()) }, re.kb = function () { ws(this) }, re.isActive = function () { return !!this.g }, re.da = function () { try { return 2 < jo(this) ? this.g.status : -1 } catch { return -1 } }, re.ja = function () { try { return this.g ? this.g.responseText : "" } catch { return "" } }, re.Wa = function (r) { if (this.g) { var e = this.g.responseText; return r && 0 == e.indexOf(r) && (e = e.substring(r.length)), ta(e) } }, re.Ia = function () { return this.m }, re.Sa = function () { return "string" == typeof this.j ? this.j : String(this.j) }, (re = Re.prototype).ra = 8, re.H = 1, re.Na = function (r) { if (this.m) if (this.m = null, 1 == this.H) { if (!r) { this.W = Math.floor(1e5 * Math.random()), r = this.W++; const c = new Rt(this, this.l, r); let f = this.s; if (this.U && (f ? (f = Zt(f), $n(f, this.U)) : f = this.U), null !== this.o || this.O || (c.I = f, f = null), this.P) e: { for (var e = 0, t = 0; t < this.j.length; t++) { var s = this.j[t]; if (void 0 === (s = "__data__" in s.map && "string" == typeof (s = s.map.__data__) ? s.length : void 0)) break; if (4096 < (e += s)) { e = t; break e } if (4096 === e || t === this.j.length - 1) { e = t + 1; break e } } e = 1e3 } else e = 1e3; e = Zi(this, c, e), di(t = tr(this.I), "RID", r), di(t, "CVER", 22), this.F && di(t, "X-HTTP-Session-Id", this.F), Ii(this, t), f && (this.O ? e = "headers=" + encodeURIComponent(String(w(f))) + "&" + e : this.o && D(t, this.o, f)), Qo(this.i, c), this.bb && di(t, "TYPE", "init"), this.P ? (di(t, "$req", e), di(t, "SID", "null"), c.aa = !0, ye(c, t, null)) : ye(c, t, e), this.H = 2 } } else 3 == this.H && (r ? gi(this, r) : 0 == this.j.length || Ro(this.i) || gi(this)) }, re.Ma = function () { if (this.u = null, ar(this), this.ca && !(this.M || null == this.g || 0 >= this.S)) { var r = 2 * this.S; this.l.info("BP detection timer enabled: " + r), this.B = Pr(tt(this.jb, this), r) } }, re.jb = function () { this.B && (this.B = null, this.l.info("BP detection timeout reached."), this.l.info("Buffering proxy detected and switch to long-polling!"), this.G = !1, this.M = !0, zi(10), kt(this), ar(this)) }, re.ib = function () { null != this.v && (this.v = null, kt(this), Bi(this), zi(19)) }, re.pb = function (r) { r ? (this.l.info("Successfully pinged google.com"), zi(2)) : (this.l.info("Failed to ping google.com"), zi(1)) }, re.isActive = function () { return !!this.h && this.h.isActive(this) }, (re = hs.prototype).Ba = function () { }, re.Aa = function () { }, re.za = function () { }, re.ya = function () { }, re.isActive = function () { return !0 }, re.Va = function () { }, rs.prototype.g = function (r, e) { return new Jr(r, e) }, ut(Jr, In), Jr.prototype.m = function () { this.g.h = this.j, this.A && (this.g.J = !0); var r = this.g, e = this.l, t = this.h || void 0; zi(0), r.Y = e, r.na = t || {}, r.G = r.aa, r.I = Do(r, null, r.Y), Gn(r) }, Jr.prototype.close = function () { mt(this.g) }, Jr.prototype.u = function (r) { var e = this.g; if ("string" == typeof r) { var t = {}; t.__data__ = r, r = t } else this.v && ((t = {}).__data__ = G(r), r = t); e.j.push(new class { constructor(r, e) { this.g = r, this.map = e } }(e.fb++, r)), 3 == e.H && Gn(e) }, Jr.prototype.N = function () { this.g.h = null, delete this.j, mt(this.g), delete this.g, Jr.$.N.call(this) }, ut(os, Jo), ut(Ka, sr), ut(ks, hs), ks.prototype.Ba = function () { Et(this.g, "a") }, ks.prototype.Aa = function (r) { Et(this.g, new os(r)) }, ks.prototype.za = function (r) { Et(this.g, new Ka) }, ks.prototype.ya = function () { Et(this.g, "b") }, ut(fs, function sl() { this.blockSize = -1 }), fs.prototype.reset = function () { this.g[0] = 1732584193, this.g[1] = 4023233417, this.g[2] = 2562383102, this.g[3] = 271733878, this.i = this.h = 0 }, fs.prototype.j = function (r, e) { void 0 === e && (e = r.length); for (var t = e - this.blockSize, s = this.m, c = this.h, f = 0; f < e;) { if (0 == c) for (; f <= t;)Za(this, r, f), f += this.blockSize; if ("string" == typeof r) { for (; f < e;)if (s[c++] = r.charCodeAt(f++), c == this.blockSize) { Za(this, s), c = 0; break } } else for (; f < e;)if (s[c++] = r[f++], c == this.blockSize) { Za(this, s), c = 0; break } } this.h = c, this.i += e }, fs.prototype.l = function () { var r = Array((56 > this.h ? this.blockSize : 2 * this.blockSize) - this.h); r[0] = 128; for (var e = 1; e < r.length - 8; ++e)r[e] = 0; var t = 8 * this.i; for (e = r.length - 8; e < r.length; ++e)r[e] = 255 & t, t /= 256; for (this.j(r), r = Array(16), e = t = 0; 4 > e; ++e)for (var s = 0; 32 > s; s += 8)r[t++] = this.g[e] >>> s & 255; return r }; var ma = {}; function Ya(r) { return -128 <= r && 128 > r ? function Mn(r, e) { var t = ma; return Object.prototype.hasOwnProperty.call(t, r) ? t[r] : t[r] = e(r) }(r, function (e) { return new _r([0 | e], 0 > e ? -1 : 0) }) : new _r([0 | r], 0 > r ? -1 : 0) } function To(r) { if (isNaN(r) || !isFinite(r)) return Bs; if (0 > r) return lo(To(-r)); for (var e = [], t = 1, s = 0; r >= t; s++)e[s] = r / t | 0, t *= ia; return new _r(e, 0) } var ia = 4294967296, Bs = Ya(0), Ta = Ya(1), Ma = Ya(16777216); function ms(r) { if (0 != r.h) return !1; for (var e = 0; e < r.g.length; e++)if (0 != r.g[e]) return !1; return !0 } function ts(r) { return -1 == r.h } function lo(r) { for (var e = r.g.length, t = [], s = 0; s < e; s++)t[s] = ~r.g[s]; return new _r(t, ~r.h).add(Ta) } function Rs(r, e) { return r.add(lo(e)) } function go(r, e) { for (; (65535 & r[e]) != r[e];)r[e + 1] += r[e] >>> 16, r[e] &= 65535, e++ } function Os(r, e) { this.g = r, this.h = e } function xs(r, e) { if (ms(e)) throw Error("division by zero"); if (ms(r)) return new Os(Bs, Bs); if (ts(r)) return e = xs(lo(r), e), new Os(lo(e.g), lo(e.h)); if (ts(e)) return e = xs(r, lo(e)), new Os(lo(e.g), e.h); if (30 < r.g.length) { if (ts(r) || ts(e)) throw Error("slowDivide_ only works with positive integers."); for (var t = Ta, s = e; 0 >= s.X(r);)t = yr(t), s = yr(s); var c = Oo(t, 1), f = Oo(s, 1); for (s = Oo(s, 2), t = Oo(t, 2); !ms(s);) { var _ = f.add(s); 0 >= _.X(r) && (c = c.add(t), f = _), s = Oo(s, 1), t = Oo(t, 1) } return e = Rs(r, c.R(e)), new Os(c, e) } for (c = Bs; 0 <= r.X(e);) { for (t = Math.max(1, Math.floor(r.ea() / e.ea())), s = 48 >= (s = Math.ceil(Math.log(t) / Math.LN2)) ? 1 : Math.pow(2, s - 48), _ = (f = To(t)).R(e); ts(_) || 0 < _.X(r);)_ = (f = To(t -= s)).R(e); ms(f) && (f = Ta), c = c.add(f), r = Rs(r, _) } return new Os(c, r) } function yr(r) { for (var e = r.g.length + 1, t = [], s = 0; s < e; s++)t[s] = r.D(s) << 1 | r.D(s - 1) >>> 31; return new _r(t, r.h) } function Oo(r, e) { var t = e >> 5; e %= 32; for (var s = r.g.length - t, c = [], f = 0; f < s; f++)c[f] = 0 < e ? r.D(f + t) >>> e | r.D(f + t + 1) << 32 - e : r.D(f + t); return new _r(c, r.h) } (re = _r.prototype).ea = function () { if (ts(this)) return -lo(this).ea(); for (var r = 0, e = 1, t = 0; t < this.g.length; t++) { var s = this.D(t); r += (0 <= s ? s : ia + s) * e, e *= ia } return r }, re.toString = function (r) { if (2 > (r = r || 10) || 36 < r) throw Error("radix out of range: " + r); if (ms(this)) return "0"; if (ts(this)) return "-" + lo(this).toString(r); for (var e = To(Math.pow(r, 6)), t = this, s = ""; ;) { var c = xs(t, e).g, f = ((0 < (t = Rs(t, c.R(e))).g.length ? t.g[0] : t.h) >>> 0).toString(r); if (ms(t = c)) return f + s; for (; 6 > f.length;)f = "0" + f; s = f + s } }, re.D = function (r) { return 0 > r ? 0 : r < this.g.length ? this.g[r] : this.h }, re.X = function (r) { return ts(r = Rs(this, r)) ? -1 : ms(r) ? 0 : 1 }, re.abs = function () { return ts(this) ? lo(this) : this }, re.add = function (r) { for (var e = Math.max(this.g.length, r.g.length), t = [], s = 0, c = 0; c <= e; c++) { var f = s + (65535 & this.D(c)) + (65535 & r.D(c)), _ = (f >>> 16) + (this.D(c) >>> 16) + (r.D(c) >>> 16); s = _ >>> 16, t[c] = (_ &= 65535) << 16 | (f &= 65535) } return new _r(t, -2147483648 & t[t.length - 1] ? -1 : 0) }, re.R = function (r) { if (ms(this) || ms(r)) return Bs; if (ts(this)) return ts(r) ? lo(this).R(lo(r)) : lo(lo(this).R(r)); if (ts(r)) return lo(this.R(lo(r))); if (0 > this.X(Ma) && 0 > r.X(Ma)) return To(this.ea() * r.ea()); for (var e = this.g.length + r.g.length, t = [], s = 0; s < 2 * e; s++)t[s] = 0; for (s = 0; s < this.g.length; s++)for (var c = 0; c < r.g.length; c++) { var f = this.D(s) >>> 16, _ = 65535 & this.D(s), R = r.D(c) >>> 16, j = 65535 & r.D(c); t[2 * s + 2 * c] += _ * j, go(t, 2 * s + 2 * c), t[2 * s + 2 * c + 1] += f * j, go(t, 2 * s + 2 * c + 1), t[2 * s + 2 * c + 1] += _ * R, go(t, 2 * s + 2 * c + 1), t[2 * s + 2 * c + 2] += f * R, go(t, 2 * s + 2 * c + 2) } for (s = 0; s < e; s++)t[s] = t[2 * s + 1] << 16 | t[2 * s]; for (s = e; s < 2 * e; s++)t[s] = 0; return new _r(t, 0) }, re.gb = function (r) { return xs(this, r).h }, re.and = function (r) { for (var e = Math.max(this.g.length, r.g.length), t = [], s = 0; s < e; s++)t[s] = this.D(s) & r.D(s); return new _r(t, this.h & r.h) }, re.or = function (r) { for (var e = Math.max(this.g.length, r.g.length), t = [], s = 0; s < e; s++)t[s] = this.D(s) | r.D(s); return new _r(t, this.h | r.h) }, re.xor = function (r) { for (var e = Math.max(this.g.length, r.g.length), t = [], s = 0; s < e; s++)t[s] = this.D(s) ^ r.D(s); return new _r(t, this.h ^ r.h) }, rs.prototype.createWebChannel = rs.prototype.g, Jr.prototype.send = Jr.prototype.u, Jr.prototype.open = Jr.prototype.m, Jr.prototype.close = Jr.prototype.close, Ir.NO_ERROR = 0, Ir.TIMEOUT = 8, Ir.HTTP_ERROR = 6, bo.COMPLETE = "complete", cs.EventType = fo, fo.OPEN = "a", fo.CLOSE = "b", fo.ERROR = "c", fo.MESSAGE = "d", In.prototype.listen = In.prototype.O, Ci.prototype.listenOnce = Ci.prototype.P, Ci.prototype.getLastError = Ci.prototype.Sa, Ci.prototype.getLastErrorCode = Ci.prototype.Ia, Ci.prototype.getStatus = Ci.prototype.da, Ci.prototype.getResponseJson = Ci.prototype.Wa, Ci.prototype.getResponseText = Ci.prototype.ja, Ci.prototype.send = Ci.prototype.ha, Ci.prototype.setWithCredentials = Ci.prototype.Oa, fs.prototype.digest = fs.prototype.l, fs.prototype.reset = fs.prototype.reset, fs.prototype.update = fs.prototype.j, _r.prototype.add = _r.prototype.add, _r.prototype.multiply = _r.prototype.R, _r.prototype.modulo = _r.prototype.gb, _r.prototype.compare = _r.prototype.X, _r.prototype.toNumber = _r.prototype.ea, _r.prototype.toString = _r.prototype.toString, _r.prototype.getBits = _r.prototype.D, _r.fromNumber = To, _r.fromString = function pa(r, e) { if (0 == r.length) throw Error("number format error: empty string"); if (2 > (e = e || 10) || 36 < e) throw Error("radix out of range: " + e); if ("-" == r.charAt(0)) return lo(pa(r.substring(1), e)); if (0 <= r.indexOf("-")) throw Error('number format error: interior "-" character'); for (var t = To(Math.pow(e, 8)), s = Bs, c = 0; c < r.length; c += 8) { var f = Math.min(8, r.length - c), _ = parseInt(r.substring(c, c + f), e); 8 > f ? (f = To(Math.pow(e, f)), s = s.R(f).add(To(_))) : s = (s = s.R(t)).add(To(_)) } return s }; var P = ke.createWebChannelTransport = function () { return new rs }, X = ke.getStatEventTarget = function () { return Li() }, B = ke.ErrorCode = Ir, be = ke.EventType = bo, Je = ke.Event = si, $t = ke.Stat = { xb: 0, Ab: 1, Bb: 2, Ub: 3, Zb: 4, Wb: 5, Xb: 6, Vb: 7, Tb: 8, Yb: 9, PROXY: 10, NOPROXY: 11, Rb: 12, Nb: 13, Ob: 14, Mb: 15, Pb: 16, Qb: 17, tb: 18, sb: 19, ub: 20 }, en = ke.FetchXmlHttpFactory = Wr, Zn = ke.WebChannel = cs, Ji = ke.XhrIo = Ci, xi = ke.Md5 = fs, Hi = ke.Integer = _r; const Fi = "@firebase/firestore"; class Di { constructor(e) { this.uid = e } isAuthenticated() { return null != this.uid } toKey() { return this.isAuthenticated() ? "uid:" + this.uid : "anonymous-user" } isEqual(e) { return e.uid === this.uid } } Di.UNAUTHENTICATED = new Di(null), Di.GOOGLE_CREDENTIALS = new Di("google-credentials-uid"), Di.FIRST_PARTY = new Di("first-party-uid"), Di.MOCK_USER = new Di("mock-user"); let qi = "9.23.0"; const rr = new Y.Yd("@firebase/firestore"); function lr() { return rr.logLevel } function ui(r) { rr.setLogLevel(r) } function pn(r, ...e) { if (rr.logLevel <= Y.in.DEBUG) { const t = e.map(Ur); rr.debug(`Firestore (${qi}): ${r}`, ...t) } } function er(r, ...e) { if (rr.logLevel <= Y.in.ERROR) { const t = e.map(Ur); rr.error(`Firestore (${qi}): ${r}`, ...t) } } function wo(r, ...e) { if (rr.logLevel <= Y.in.WARN) { const t = e.map(Ur); rr.warn(`Firestore (${qi}): ${r}`, ...t) } } function Ur(r) { if ("string" == typeof r) return r; try { return JSON.stringify(r) } catch { return r } } function Cn(r = "Unexpected state") { const e = `FIRESTORE (${qi}) INTERNAL ASSERTION FAILED: ` + r; throw er(e), new Error(e) } function ai(r, e) { r || Cn() } function co(r, e) { r || Cn() } function Un(r, e) { return r } const Yt = { OK: "ok", CANCELLED: "cancelled", UNKNOWN: "unknown", INVALID_ARGUMENT: "invalid-argument", DEADLINE_EXCEEDED: "deadline-exceeded", NOT_FOUND: "not-found", ALREADY_EXISTS: "already-exists", PERMISSION_DENIED: "permission-denied", UNAUTHENTICATED: "unauthenticated", RESOURCE_EXHAUSTED: "resource-exhausted", FAILED_PRECONDITION: "failed-precondition", ABORTED: "aborted", OUT_OF_RANGE: "out-of-range", UNIMPLEMENTED: "unimplemented", INTERNAL: "internal", UNAVAILABLE: "unavailable", DATA_LOSS: "data-loss" }; class _n extends he.ZR { constructor(e, t) { super(e, t), this.code = e, this.message = t, this.toString = () => `${this.name}: [code=${this.code}]: ${this.message}` } } class eo { constructor() { this.promise = new Promise((e, t) => { this.resolve = e, this.reject = t }) } } class Us { constructor(e, t) { this.user = t, this.type = "OAuth", this.headers = new Map, this.headers.set("Authorization", `Bearer ${e}`) } } class vn { getToken() { return Promise.resolve(null) } invalidateToken() { } start(e, t) { e.enqueueRetryable(() => t(Di.UNAUTHENTICATED)) } shutdown() { } } class $i { constructor(e) { this.token = e, this.changeListener = null } getToken() { return Promise.resolve(this.token) } invalidateToken() { } start(e, t) { this.changeListener = t, e.enqueueRetryable(() => t(this.token.user)) } shutdown() { this.changeListener = null } } class Cl { constructor(e) { this.t = e, this.currentUser = Di.UNAUTHENTICATED, this.i = 0, this.forceRefresh = !1, this.auth = null } start(e, t) { var s = this; let c = this.i; const f = te => this.i !== c ? (c = this.i, t(te)) : Promise.resolve(); let _ = new eo; this.o = () => { this.i++, this.currentUser = this.u(), _.resolve(), _ = new eo, e.enqueueRetryable(() => f(this.currentUser)) }; const R = () => { const te = _; e.enqueueRetryable((0, a.Z)(function* () { yield te.promise, yield f(s.currentUser) })) }, j = te => { pn("FirebaseAuthCredentialsProvider", "Auth detected"), this.auth = te, this.auth.addAuthTokenListener(this.o), R() }; this.t.onInit(te => j(te)), setTimeout(() => { if (!this.auth) { const te = this.t.getImmediate({ optional: !0 }); te ? j(te) : (pn("FirebaseAuthCredentialsProvider", "Auth not yet detected"), _.resolve(), _ = new eo) } }, 0), R() } getToken() { const e = this.i, t = this.forceRefresh; return this.forceRefresh = !1, this.auth ? this.auth.getToken(t).then(s => this.i !== e ? (pn("FirebaseAuthCredentialsProvider", "getToken aborted due to token change."), this.getToken()) : s ? (ai("string" == typeof s.accessToken), new Us(s.accessToken, this.currentUser)) : null) : Promise.resolve(null) } invalidateToken() { this.forceRefresh = !0 } shutdown() { this.auth && this.auth.removeAuthTokenListener(this.o) } u() { const e = this.auth && this.auth.getUid(); return ai(null === e || "string" == typeof e), new Di(e) } } class al { constructor(e, t, s) { this.h = e, this.l = t, this.m = s, this.type = "FirstParty", this.user = Di.FIRST_PARTY, this.g = new Map } p() { return this.m ? this.m() : null } get headers() { this.g.set("X-Goog-AuthUser", this.h); const e = this.p(); return e && this.g.set("Authorization", e), this.l && this.g.set("X-Goog-Iam-Authorization-Token", this.l), this.g } } class xo { constructor(e, t, s) { this.h = e, this.l = t, this.m = s } getToken() { return Promise.resolve(new al(this.h, this.l, this.m)) } start(e, t) { e.enqueueRetryable(() => t(Di.FIRST_PARTY)) } shutdown() { } invalidateToken() { } } class qa { constructor(e) { this.value = e, this.type = "AppCheck", this.headers = new Map, e && e.length > 0 && this.headers.set("x-firebase-appcheck", this.value) } } class ga { constructor(e) { this.I = e, this.forceRefresh = !1, this.appCheck = null, this.T = null } start(e, t) { const s = f => { null != f.error && pn("FirebaseAppCheckTokenProvider", `Error getting App Check token; using placeholder token instead. Error: ${f.error.message}`); const _ = f.token !== this.T; return this.T = f.token, pn("FirebaseAppCheckTokenProvider", `Received ${_ ? "new" : "existing"} token.`), _ ? t(f.token) : Promise.resolve() }; this.o = f => { e.enqueueRetryable(() => s(f)) }; const c = f => { pn("FirebaseAppCheckTokenProvider", "AppCheck detected"), this.appCheck = f, this.appCheck.addTokenListener(this.o) }; this.I.onInit(f => c(f)), setTimeout(() => { if (!this.appCheck) { const f = this.I.getImmediate({ optional: !0 }); f ? c(f) : pn("FirebaseAppCheckTokenProvider", "AppCheck not yet detected") } }, 0) } getToken() { const e = this.forceRefresh; return this.forceRefresh = !1, this.appCheck ? this.appCheck.getToken(e).then(t => t ? (ai("string" == typeof t.token), this.T = t.token, new qa(t.token)) : null) : Promise.resolve(null) } invalidateToken() { this.forceRefresh = !0 } shutdown() { this.appCheck && this.appCheck.removeTokenListener(this.o) } } function Qa(r) { const e = typeof self < "u" && (self.crypto || self.msCrypto), t = new Uint8Array(r); if (e && "function" == typeof e.getRandomValues) e.getRandomValues(t); else for (let s = 0; s < r; s++)t[s] = Math.floor(256 * Math.random()); return t } class Vr { static A() { const t = 62 * Math.floor(256 / 62); let s = ""; for (; s.length < 20;) { const c = Qa(40); for (let f = 0; f < c.length; ++f)s.length < 20 && c[f] < t && (s += "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".charAt(c[f] % 62)) } return s } } function Ei(r, e) { return r < e ? -1 : r > e ? 1 : 0 } function _a(r, e, t) { return r.length === e.length && r.every((s, c) => t(s, e[c])) } function ll(r) { return r + "\0" } class Ri { constructor(e, t) { if (this.seconds = e, this.nanoseconds = t, t < 0) throw new _n(Yt.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + t); if (t >= 1e9) throw new _n(Yt.INVALID_ARGUMENT, "Timestamp nanoseconds out of range: " + t); if (e < -62135596800) throw new _n(Yt.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e); if (e >= 253402300800) throw new _n(Yt.INVALID_ARGUMENT, "Timestamp seconds out of range: " + e) } static now() { return Ri.fromMillis(Date.now()) } static fromDate(e) { return Ri.fromMillis(e.getTime()) } static fromMillis(e) { const t = Math.floor(e / 1e3), s = Math.floor(1e6 * (e - 1e3 * t)); return new Ri(t, s) } toDate() { return new Date(this.toMillis()) } toMillis() { return 1e3 * this.seconds + this.nanoseconds / 1e6 } _compareTo(e) { return this.seconds === e.seconds ? Ei(this.nanoseconds, e.nanoseconds) : Ei(this.seconds, e.seconds) } isEqual(e) { return e.seconds === this.seconds && e.nanoseconds === this.nanoseconds } toString() { return "Timestamp(seconds=" + this.seconds + ", nanoseconds=" + this.nanoseconds + ")" } toJSON() { return { seconds: this.seconds, nanoseconds: this.nanoseconds } } valueOf() { return String(this.seconds - -62135596800).padStart(12, "0") + "." + String(this.nanoseconds).padStart(9, "0") } } class Jn { constructor(e) { this.timestamp = e } static fromTimestamp(e) { return new Jn(e) } static min() { return new Jn(new Ri(0, 0)) } static max() { return new Jn(new Ri(253402300799, 999999999)) } compareTo(e) { return this.timestamp._compareTo(e.timestamp) } isEqual(e) { return this.timestamp.isEqual(e.timestamp) } toMicroseconds() { return 1e6 * this.timestamp.seconds + this.timestamp.nanoseconds / 1e3 } toString() { return "SnapshotVersion(" + this.timestamp.toString() + ")" } toTimestamp() { return this.timestamp } } class ra { constructor(e, t, s) { void 0 === t ? t = 0 : t > e.length && Cn(), void 0 === s ? s = e.length - t : s > e.length - t && Cn(), this.segments = e, this.offset = t, this.len = s } get length() { return this.len } isEqual(e) { return 0 === ra.comparator(this, e) } child(e) { const t = this.segments.slice(this.offset, this.limit()); return e instanceof ra ? e.forEach(s => { t.push(s) }) : t.push(e), this.construct(t) } limit() { return this.offset + this.length } popFirst(e) { return this.construct(this.segments, this.offset + (e = void 0 === e ? 1 : e), this.length - e) } popLast() { return this.construct(this.segments, this.offset, this.length - 1) } firstSegment() { return this.segments[this.offset] } lastSegment() { return this.get(this.length - 1) } get(e) { return this.segments[this.offset + e] } isEmpty() { return 0 === this.length } isPrefixOf(e) { if (e.length < this.length) return !1; for (let t = 0; t < this.length; t++)if (this.get(t) !== e.get(t)) return !1; return !0 } isImmediateParentOf(e) { if (this.length + 1 !== e.length) return !1; for (let t = 0; t < this.length; t++)if (this.get(t) !== e.get(t)) return !1; return !0 } forEach(e) { for (let t = this.offset, s = this.limit(); t < s; t++)e(this.segments[t]) } toArray() { return this.segments.slice(this.offset, this.limit()) } static comparator(e, t) { const s = Math.min(e.length, t.length); for (let c = 0; c < s; c++) { const f = e.get(c), _ = t.get(c); if (f < _) return -1; if (f > _) return 1 } return e.length < t.length ? -1 : e.length > t.length ? 1 : 0 } } class Pi extends ra { construct(e, t, s) { return new Pi(e, t, s) } canonicalString() { return this.toArray().join("/") } toString() { return this.canonicalString() } static fromString(...e) { const t = []; for (const s of e) { if (s.indexOf("//") >= 0) throw new _n(Yt.INVALID_ARGUMENT, `Invalid segment (${s}). Paths must not contain // in them.`); t.push(...s.split("/").filter(c => c.length > 0)) } return new Pi(t) } static emptyPath() { return new Pi([]) } } const Es = /^[_a-zA-Z][_a-zA-Z0-9]*$/; class Hr extends ra { construct(e, t, s) { return new Hr(e, t, s) } static isValidIdentifier(e) { return Es.test(e) } canonicalString() { return this.toArray().map(e => (e = e.replace(/\\/g, "\\\\").replace(/`/g, "\\`"), Hr.isValidIdentifier(e) || (e = "`" + e + "`"), e)).join(".") } toString() { return this.canonicalString() } isKeyField() { return 1 === this.length && "__name__" === this.get(0) } static keyField() { return new Hr(["__name__"]) } static fromServerFormat(e) { const t = []; let s = "", c = 0; const f = () => { if (0 === s.length) throw new _n(Yt.INVALID_ARGUMENT, `Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`); t.push(s), s = "" }; let _ = !1; for (; c < e.length;) { const R = e[c]; if ("\\" === R) { if (c + 1 === e.length) throw new _n(Yt.INVALID_ARGUMENT, "Path has trailing escape character: " + e); const j = e[c + 1]; if ("\\" !== j && "." !== j && "`" !== j) throw new _n(Yt.INVALID_ARGUMENT, "Path has invalid escape sequence: " + e); s += j, c += 2 } else "`" === R ? (_ = !_, c++) : "." !== R || _ ? (s += R, c++) : (f(), c++) } if (f(), _) throw new _n(Yt.INVALID_ARGUMENT, "Unterminated ` in path: " + e); return new Hr(t) } static emptyPath() { return new Hr([]) } } class Bn { constructor(e) { this.path = e } static fromPath(e) { return new Bn(Pi.fromString(e)) } static fromName(e) { return new Bn(Pi.fromString(e).popFirst(5)) } static empty() { return new Bn(Pi.emptyPath()) } get collectionGroup() { return this.path.popLast().lastSegment() } hasCollectionId(e) { return this.path.length >= 2 && this.path.get(this.path.length - 2) === e } getCollectionGroup() { return this.path.get(this.path.length - 2) } getCollectionPath() { return this.path.popLast() } isEqual(e) { return null !== e && 0 === Pi.comparator(this.path, e.path) } toString() { return this.path.toString() } static comparator(e, t) { return Pi.comparator(e.path, t.path) } static isDocumentKey(e) { return e.length % 2 == 0 } static fromSegments(e) { return new Bn(new Pi(e.slice())) } } class Vs { constructor(e, t, s, c) { this.indexId = e, this.collectionGroup = t, this.fields = s, this.indexState = c } } function Zs(r) { return r.fields.find(e => 2 === e.kind) } function Ys(r) { return r.fields.filter(e => 2 !== e.kind) } Vs.UNKNOWN_ID = -1; class Ba { constructor(e, t) { this.fieldPath = e, this.kind = t } } class ka { constructor(e, t) { this.sequenceNumber = e, this.offset = t } static empty() { return new ka(0, ns.min()) } } function va(r, e) { const t = r.toTimestamp().seconds, s = r.toTimestamp().nanoseconds + 1, c = Jn.fromTimestamp(1e9 === s ? new Ri(t + 1, 0) : new Ri(t, s)); return new ns(c, Bn.empty(), e) } function Xa(r) { return new ns(r.readTime, r.key, -1) } class ns { constructor(e, t, s) { this.readTime = e, this.documentKey = t, this.largestBatchId = s } static min() { return new ns(Jn.min(), Bn.empty(), -1) } static max() { return new ns(Jn.max(), Bn.empty(), -1) } } function cl(r, e) { let t = r.readTime.compareTo(e.readTime); return 0 !== t ? t : (t = Bn.comparator(r.documentKey, e.documentKey), 0 !== t ? t : Ei(r.largestBatchId, e.largestBatchId)) } const dl = "The current tab is not in the required state to perform this operation. It might be necessary to refresh the browser tab."; class ul { constructor() { this.onCommittedListeners = [] } addOnCommittedListener(e) { this.onCommittedListeners.push(e) } raiseOnCommittedEvent() { this.onCommittedListeners.forEach(e => e()) } } function Ps(r) { return S.apply(this, arguments) } function S() { return S = (0, a.Z)(function* (r) { if (r.code !== Yt.FAILED_PRECONDITION || r.message !== dl) throw r; pn("LocalStore", "Unexpectedly lost primary lease") }), S.apply(this, arguments) } class I { constructor(e) { this.nextCallback = null, this.catchCallback = null, this.result = void 0, this.error = void 0, this.isDone = !1, this.callbackAttached = !1, e(t => { this.isDone = !0, this.result = t, this.nextCallback && this.nextCallback(t) }, t => { this.isDone = !0, this.error = t, this.catchCallback && this.catchCallback(t) }) } catch(e) { return this.next(void 0, e) } next(e, t) { return this.callbackAttached && Cn(), this.callbackAttached = !0, this.isDone ? this.error ? this.wrapFailure(t, this.error) : this.wrapSuccess(e, this.result) : new I((s, c) => { this.nextCallback = f => { this.wrapSuccess(e, f).next(s, c) }, this.catchCallback = f => { this.wrapFailure(t, f).next(s, c) } }) } toPromise() { return new Promise((e, t) => { this.next(e, t) }) } wrapUserFunction(e) { try { const t = e(); return t instanceof I ? t : I.resolve(t) } catch (t) { return I.reject(t) } } wrapSuccess(e, t) { return e ? this.wrapUserFunction(() => e(t)) : I.resolve(t) } wrapFailure(e, t) { return e ? this.wrapUserFunction(() => e(t)) : I.reject(t) } static resolve(e) { return new I((t, s) => { t(e) }) } static reject(e) { return new I((t, s) => { s(e) }) } static waitFor(e) { return new I((t, s) => { let c = 0, f = 0, _ = !1; e.forEach(R => { ++c, R.next(() => { ++f, _ && f === c && t() }, j => s(j)) }), _ = !0, f === c && t() }) } static or(e) { let t = I.resolve(!1); for (const s of e) t = t.next(c => c ? I.resolve(c) : s()); return t } static forEach(e, t) { const s = []; return e.forEach((c, f) => { s.push(t.call(this, c, f)) }), this.waitFor(s) } static mapArray(e, t) { return new I((s, c) => { const f = e.length, _ = new Array(f); let R = 0; for (let j = 0; j < f; j++) { const te = j; t(e[te]).next(Ce => { _[te] = Ce, ++R, R === f && s(_) }, Ce => c(Ce)) } }) } static doWhile(e, t) { return new I((s, c) => { const f = () => { !0 === e() ? t().next(() => { f() }, c) : s() }; f() }) } } class m { constructor(e, t) { this.action = e, this.transaction = t, this.aborted = !1, this.v = new eo, this.transaction.oncomplete = () => { this.v.resolve() }, this.transaction.onabort = () => { t.error ? this.v.reject(new x(e, t.error)) : this.v.resolve() }, this.transaction.onerror = s => { const c = ft(s.target.error); this.v.reject(new x(e, c)) } } static open(e, t, s, c) { try { return new m(t, e.transaction(c, s)) } catch (f) { throw new x(t, f) } } get R() { return this.v.promise } abort(e) { e && this.v.reject(e), this.aborted || (pn("SimpleDb", "Aborting transaction:", e ? e.message : "Client-initiated abort"), this.aborted = !0, this.transaction.abort()) } P() { const e = this.transaction; this.aborted || "function" != typeof e.commit || e.commit() } store(e) { const t = this.transaction.objectStore(e); return new $(t) } } class u { constructor(e, t, s) { this.name = e, this.version = t, this.V = s, 12.2 === u.S((0, he.z$)()) && er("Firestore persistence suffers from a bug in iOS 12.2 Safari that may cause your app to stop working. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.") } static delete(e) { return pn("SimpleDb", "Removing database:", e), Ee(window.indexedDB.deleteDatabase(e)).toPromise() } static D() { if (!(0, he.hl)()) return !1; if (u.C()) return !0; const e = (0, he.z$)(), t = u.S(e), s = 0 < t && t < 10, c = u.N(e), f = 0 < c && c < 4.5; return !(e.indexOf("MSIE ") > 0 || e.indexOf("Trident/") > 0 || e.indexOf("Edge/") > 0 || s || f) } static C() { var e; return typeof process < "u" && "YES" === (null === (e = process.env) || void 0 === e ? void 0 : e.k) } static M(e, t) { return e.store(t) } static S(e) { const t = e.match(/i(?:phone|pad|pod) os ([\d_]+)/i), s = t ? t[1].split("_").slice(0, 2).join(".") : "-1"; return Number(s) } static N(e) { const t = e.match(/Android ([\d.]+)/i), s = t ? t[1].split(".").slice(0, 2).join(".") : "-1"; return Number(s) } $(e) { var t = this; return (0, a.Z)(function* () { return t.db || (pn("SimpleDb", "Opening database:", t.name), t.db = yield new Promise((s, c) => { const f = indexedDB.open(t.name, t.version); f.onsuccess = _ => { s(_.target.result) }, f.onblocked = () => { c(new x(e, "Cannot upgrade IndexedDB schema while another tab is open. Close all tabs that access Firestore and reload this page to proceed.")) }, f.onerror = _ => { const R = _.target.error; c("VersionError" === R.name ? new _n(Yt.FAILED_PRECONDITION, "A newer version of the Firestore SDK was previously used and so the persisted data is not compatible with the version of the SDK you are now using. The SDK will operate with persistence disabled. If you need persistence, please re-upgrade to a newer version of the SDK or else clear the persisted IndexedDB data for your app to start fresh.") : "InvalidStateError" === R.name ? new _n(Yt.FAILED_PRECONDITION, "Unable to open an IndexedDB connection. This could be due to running in a private browsing session on a browser whose private browsing sessions do not support IndexedDB: " + R) : new x(e, R)) }, f.onupgradeneeded = _ => { pn("SimpleDb", 'Database "' + t.name + '" requires upgrade from version:', _.oldVersion), t.V.O(_.target.result, f.transaction, _.oldVersion, t.version).next(() => { pn("SimpleDb", "Database upgrade to version " + t.version + " complete") }) } })), t.F && (t.db.onversionchange = s => t.F(s)), t.db })() } B(e) { this.F = e, this.db && (this.db.onversionchange = t => e(t)) } runTransaction(e, t, s, c) { var f = this; return (0, a.Z)(function* () { const _ = "readonly" === t; let R = 0; for (; ;) { ++R; try { f.db = yield f.$(e); const j = m.open(f.db, e, _ ? "readonly" : "readwrite", s), te = c(j).next(Ce => (j.P(), Ce)).catch(Ce => (j.abort(Ce), I.reject(Ce))).toPromise(); return te.catch(() => { }), yield j.R, te } catch (j) { const te = j, Ce = "FirebaseError" !== te.name && R < 3; if (pn("SimpleDb", "Transaction failed with error:", te.message, "Retrying:", Ce), f.close(), !Ce) return Promise.reject(te) } } })() } close() { this.db && this.db.close(), this.db = void 0 } } class h { constructor(e) { this.L = e, this.q = !1, this.U = null } get isDone() { return this.q } get K() { return this.U } set cursor(e) { this.L = e } done() { this.q = !0 } G(e) { this.U = e } delete() { return Ee(this.L.delete()) } } class x extends _n { constructor(e, t) { super(Yt.UNAVAILABLE, `IndexedDB transaction '${e}' failed: ${t}`), this.name = "IndexedDbTransactionError" } } function M(r) { return "IndexedDbTransactionError" === r.name } class $ { constructor(e) { this.store = e } put(e, t) { let s; return void 0 !== t ? (pn("SimpleDb", "PUT", this.store.name, e, t), s = this.store.put(t, e)) : (pn("SimpleDb", "PUT", this.store.name, "<auto-key>", e), s = this.store.put(e)), Ee(s) } add(e) { return pn("SimpleDb", "ADD", this.store.name, e, e), Ee(this.store.add(e)) } get(e) { return Ee(this.store.get(e)).next(t => (void 0 === t && (t = null), pn("SimpleDb", "GET", this.store.name, e, t), t)) } delete(e) { return pn("SimpleDb", "DELETE", this.store.name, e), Ee(this.store.delete(e)) } count() { return pn("SimpleDb", "COUNT", this.store.name), Ee(this.store.count()) } j(e, t) { const s = this.options(e, t); if (s.index || "function" != typeof this.store.getAll) { const c = this.cursor(s), f = []; return this.W(c, (_, R) => { f.push(R) }).next(() => f) } { const c = this.store.getAll(s.range); return new I((f, _) => { c.onerror = R => { _(R.target.error) }, c.onsuccess = R => { f(R.target.result) } }) } } H(e, t) { const s = this.store.getAll(e, null === t ? void 0 : t); return new I((c, f) => { s.onerror = _ => { f(_.target.error) }, s.onsuccess = _ => { c(_.target.result) } }) } J(e, t) { pn("SimpleDb", "DELETE ALL", this.store.name); const s = this.options(e, t); s.Y = !1; const c = this.cursor(s); return this.W(c, (f, _, R) => R.delete()) } X(e, t) { let s; t ? s = e : (s = {}, t = e); const c = this.cursor(s); return this.W(c, t) } Z(e) { const t = this.cursor({}); return new I((s, c) => { t.onerror = f => { const _ = ft(f.target.error); c(_) }, t.onsuccess = f => { const _ = f.target.result; _ ? e(_.primaryKey, _.value).next(R => { R ? _.continue() : s() }) : s() } }) } W(e, t) { const s = []; return new I((c, f) => { e.onerror = _ => { f(_.target.error) }, e.onsuccess = _ => { const R = _.target.result; if (!R) return void c(); const j = new h(R), te = t(R.primaryKey, R.value, j); if (te instanceof I) { const Ce = te.catch(ot => (j.done(), I.reject(ot))); s.push(Ce) } j.isDone ? c() : null === j.K ? R.continue() : R.continue(j.K) } }).next(() => I.waitFor(s)) } options(e, t) { let s; return void 0 !== e && ("string" == typeof e ? s = e : t = e), { index: s, range: t } } cursor(e) { let t = "next"; if (e.reverse && (t = "prev"), e.index) { const s = this.store.index(e.index); return e.Y ? s.openKeyCursor(e.range, t) : s.openCursor(e.range, t) } return this.store.openCursor(e.range, t) } } function Ee(r) { return new I((e, t) => { r.onsuccess = s => { e(s.target.result) }, r.onerror = s => { const c = ft(s.target.error); t(c) } }) } let je = !1; function ft(r) { const e = u.S((0, he.z$)()); if (e >= 12.2 && e < 13) { const t = "An internal error was encountered in the Indexed Database server"; if (r.message.indexOf(t) >= 0) { const s = new _n("internal", `IOS_INDEXEDDB_BUG1: IndexedDb has thrown '${t}'. This is likely due to an unavoidable bug in iOS. See https://stackoverflow.com/q/56496296/110915 for details and a potential workaround.`); return je || (je = !0, setTimeout(() => { throw s }, 0)), s } } return r } class zt { constructor(e, t) { this.asyncQueue = e, this.tt = t, this.task = null } start() { this.et(15e3) } stop() { this.task && (this.task.cancel(), this.task = null) } get started() { return null !== this.task } et(e) { var t = this; pn("IndexBackiller", `Scheduled in ${e}ms`), this.task = this.asyncQueue.enqueueAfterDelay("index_backfill", e, (0, a.Z)(function* () { t.task = null; try { pn("IndexBackiller", `Documents written: ${yield t.tt.nt()}`) } catch (s) { M(s) ? pn("IndexBackiller", "Ignoring IndexedDB error during index backfill: ", s) : yield Ps(s) } yield t.et(6e4) })) } } class xn { constructor(e, t) { this.localStore = e, this.persistence = t } nt(e = 50) { var t = this; return (0, a.Z)(function* () { return t.persistence.runTransaction("Backfill Indexes", "readwrite-primary", s => t.st(s, e)) })() } st(e, t) { const s = new Set; let c = t, f = !0; return I.doWhile(() => !0 === f && c > 0, () => this.localStore.indexManager.getNextCollectionGroupToUpdate(e).next(_ => { if (null !== _ && !s.has(_)) return pn("IndexBackiller", `Processing collection: ${_}`), this.it(e, _, c).next(R => { c -= R, s.add(_) }); f = !1 })).next(() => t - c) } it(e, t, s) { return this.localStore.indexManager.getMinOffsetFromCollectionGroup(e, t).next(c => this.localStore.localDocuments.getNextDocuments(e, t, c, s).next(f => { const _ = f.changes; return this.localStore.indexManager.updateIndexEntries(e, _).next(() => this.rt(c, f)).next(R => (pn("IndexBackiller", `Updating offset: ${R}`), this.localStore.indexManager.updateCollectionGroup(e, t, R))).next(() => _.size) })) } rt(e, t) { let s = e; return t.changes.forEach((c, f) => { const _ = Xa(f); cl(_, s) > 0 && (s = _) }), new ns(s.readTime, s.documentKey, Math.max(t.batchId, e.largestBatchId)) } } let An = (() => { class r { constructor(t, s) { this.previousValue = t, s && (s.sequenceNumberHandler = c => this.ot(c), this.ut = c => s.writeSequenceNumber(c)) } ot(t) { return this.previousValue = Math.max(t, this.previousValue), this.previousValue } next() { const t = ++this.previousValue; return this.ut && this.ut(t), t } } return r.ct = -1, r })(); function ri(r) { return null == r } function hi(r) { return 0 === r && 1 / r == -1 / 0 } function fi(r) { return "number" == typeof r && Number.isInteger(r) && !hi(r) && r <= Number.MAX_SAFE_INTEGER && r >= Number.MIN_SAFE_INTEGER } function ei(r) { let e = ""; for (let t = 0; t < r.length; t++)e.length > 0 && (e = Po(e)), e = zr(r.get(t), e); return Po(e) } function zr(r, e) { let t = e; const s = r.length; for (let c = 0; c < s; c++) { const f = r.charAt(c); switch (f) { case "\0": t += "\x01\x10"; break; case "\x01": t += "\x01\x11"; break; default: t += f } } return t } function Po(r) { return r + "\x01\x01" } function Ar(r) { const e = r.length; if (ai(e >= 2), 2 === e) return ai("\x01" === r.charAt(0) && "\x01" === r.charAt(1)), Pi.emptyPath(); const t = e - 2, s = []; let c = ""; for (let f = 0; f < e;) { const _ = r.indexOf("\x01", f); switch ((_ < 0 || _ > t) && Cn(), r.charAt(_ + 1)) { case "\x01": const R = r.substring(f, _); let j; 0 === c.length ? j = R : (c += R, j = c, c = ""), s.push(j); break; case "\x10": c += r.substring(f, _), c += "\0"; break; case "\x11": c += r.substring(f, _ + 1); break; default: Cn() }f = _ + 2 } return new Pi(s) } const Mo = ["userId", "batchId"]; function Fr(r, e) { return [r, ei(e)] } function Ja(r, e, t) { return [r, ei(e), t] } const oa = {}, Eo = ["prefixPath", "collectionGroup", "readTime", "documentId"], ba = ["prefixPath", "collectionGroup", "documentId"], Ra = ["collectionGroup", "readTime", "prefixPath", "documentId"], sa = ["canonicalId", "targetId"], dd = ["targetId", "path"], aa = ["path", "targetId"], ya = ["collectionId", "parent"], el = ["indexId", "uid"], Pl = ["uid", "sequenceNumber"], oi = ["indexId", "uid", "arrayValue", "directionalValue", "orderedDocumentKey", "documentKey"], pi = ["indexId", "uid", "orderedDocumentKey"], bi = ["userId", "collectionPath", "documentId"], vr = ["userId", "collectionPath", "largestBatchId"], Go = ["userId", "collectionGroup", "largestBatchId"], Cs = ["mutationQueues", "mutations", "documentMutations", "remoteDocuments", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries"], Hs = [...Cs, "documentOverlays"], No = ["mutationQueues", "mutations", "documentMutations", "remoteDocumentsV14", "targets", "owner", "targetGlobal", "targetDocuments", "clientMetadata", "remoteDocumentGlobal", "collectionParents", "bundles", "namedQueries", "documentOverlays"], to = No, Ua = [...to, "indexConfiguration", "indexState", "indexEntries"]; class wa extends ul { constructor(e, t) { super(), this.ht = e, this.currentSequenceNumber = t } } function or(r, e) { const t = Un(r); return u.M(t.ht, e) } function Is(r) { let e = 0; for (const t in r) Object.prototype.hasOwnProperty.call(r, t) && e++; return e } function _o(r, e) { for (const t in r) Object.prototype.hasOwnProperty.call(r, t) && e(t, r[t]) } function Va(r) { for (const e in r) if (Object.prototype.hasOwnProperty.call(r, e)) return !1; return !0 } class ur { constructor(e, t) { this.comparator = e, this.root = t || Fo.EMPTY } insert(e, t) { return new ur(this.comparator, this.root.insert(e, t, this.comparator).copy(null, null, Fo.BLACK, null, null)) } remove(e) { return new ur(this.comparator, this.root.remove(e, this.comparator).copy(null, null, Fo.BLACK, null, null)) } get(e) { let t = this.root; for (; !t.isEmpty();) { const s = this.comparator(e, t.key); if (0 === s) return t.value; s < 0 ? t = t.left : s > 0 && (t = t.right) } return null } indexOf(e) { let t = 0, s = this.root; for (; !s.isEmpty();) { const c = this.comparator(e, s.key); if (0 === c) return t + s.left.size; c < 0 ? s = s.left : (t += s.left.size + 1, s = s.right) } return -1 } isEmpty() { return this.root.isEmpty() } get size() { return this.root.size } minKey() { return this.root.minKey() } maxKey() { return this.root.maxKey() } inorderTraversal(e) { return this.root.inorderTraversal(e) } forEach(e) { this.inorderTraversal((t, s) => (e(t, s), !1)) } toString() { const e = []; return this.inorderTraversal((t, s) => (e.push(`${t}:${s}`), !1)), `{${e.join(", ")}}` } reverseTraversal(e) { return this.root.reverseTraversal(e) } getIterator() { return new Ha(this.root, null, this.comparator, !1) } getIteratorFrom(e) { return new Ha(this.root, e, this.comparator, !1) } getReverseIterator() { return new Ha(this.root, null, this.comparator, !0) } getReverseIteratorFrom(e) { return new Ha(this.root, e, this.comparator, !0) } } class Ha { constructor(e, t, s, c) { this.isReverse = c, this.nodeStack = []; let f = 1; for (; !e.isEmpty();)if (f = t ? s(e.key, t) : 1, t && c && (f *= -1), f < 0) e = this.isReverse ? e.left : e.right; else { if (0 === f) { this.nodeStack.push(e); break } this.nodeStack.push(e), e = this.isReverse ? e.right : e.left } } getNext() { let e = this.nodeStack.pop(); const t = { key: e.key, value: e.value }; if (this.isReverse) for (e = e.left; !e.isEmpty();)this.nodeStack.push(e), e = e.right; else for (e = e.right; !e.isEmpty();)this.nodeStack.push(e), e = e.left; return t } hasNext() { return this.nodeStack.length > 0 } peek() { if (0 === this.nodeStack.length) return null; const e = this.nodeStack[this.nodeStack.length - 1]; return { key: e.key, value: e.value } } } class Fo { constructor(e, t, s, c, f) { this.key = e, this.value = t, this.color = s ?? Fo.RED, this.left = c ?? Fo.EMPTY, this.right = f ?? Fo.EMPTY, this.size = this.left.size + 1 + this.right.size } copy(e, t, s, c, f) { return new Fo(e ?? this.key, t ?? this.value, s ?? this.color, c ?? this.left, f ?? this.right) } isEmpty() { return !1 } inorderTraversal(e) { return this.left.inorderTraversal(e) || e(this.key, this.value) || this.right.inorderTraversal(e) } reverseTraversal(e) { return this.right.reverseTraversal(e) || e(this.key, this.value) || this.left.reverseTraversal(e) } min() { return this.left.isEmpty() ? this : this.left.min() } minKey() { return this.min().key } maxKey() { return this.right.isEmpty() ? this.key : this.right.maxKey() } insert(e, t, s) { let c = this; const f = s(e, c.key); return c = f < 0 ? c.copy(null, null, null, c.left.insert(e, t, s), null) : 0 === f ? c.copy(null, t, null, null, null) : c.copy(null, null, null, null, c.right.insert(e, t, s)), c.fixUp() } removeMin() { if (this.left.isEmpty()) return Fo.EMPTY; let e = this; return e.left.isRed() || e.left.left.isRed() || (e = e.moveRedLeft()), e = e.copy(null, null, null, e.left.removeMin(), null), e.fixUp() } remove(e, t) { let s, c = this; if (t(e, c.key) < 0) c.left.isEmpty() || c.left.isRed() || c.left.left.isRed() || (c = c.moveRedLeft()), c = c.copy(null, null, null, c.left.remove(e, t), null); else { if (c.left.isRed() && (c = c.rotateRight()), c.right.isEmpty() || c.right.isRed() || c.right.left.isRed() || (c = c.moveRedRight()), 0 === t(e, c.key)) { if (c.right.isEmpty()) return Fo.EMPTY; s = c.right.min(), c = c.copy(s.key, s.value, null, null, c.right.removeMin()) } c = c.copy(null, null, null, null, c.right.remove(e, t)) } return c.fixUp() } isRed() { return this.color } fixUp() { let e = this; return e.right.isRed() && !e.left.isRed() && (e = e.rotateLeft()), e.left.isRed() && e.left.left.isRed() && (e = e.rotateRight()), e.left.isRed() && e.right.isRed() && (e = e.colorFlip()), e } moveRedLeft() { let e = this.colorFlip(); return e.right.left.isRed() && (e = e.copy(null, null, null, null, e.right.rotateRight()), e = e.rotateLeft(), e = e.colorFlip()), e } moveRedRight() { let e = this.colorFlip(); return e.left.left.isRed() && (e = e.rotateRight(), e = e.colorFlip()), e } rotateLeft() { const e = this.copy(null, null, Fo.RED, null, this.right.left); return this.right.copy(null, null, this.color, e, null) } rotateRight() { const e = this.copy(null, null, Fo.RED, this.left.right, null); return this.left.copy(null, null, this.color, null, e) } colorFlip() { const e = this.left.copy(null, null, !this.left.color, null, null), t = this.right.copy(null, null, !this.right.color, null, null); return this.copy(null, null, !this.color, e, t) } checkMaxDepth() { const e = this.check(); return Math.pow(2, e) <= this.size + 1 } check() { if (this.isRed() && this.left.isRed() || this.right.isRed()) throw Cn(); const e = this.left.check(); if (e !== this.right.check()) throw Cn(); return e + (this.isRed() ? 0 : 1) } } Fo.EMPTY = null, Fo.RED = !0, Fo.BLACK = !1, Fo.EMPTY = new class { constructor() { this.size = 0 } get key() { throw Cn() } get value() { throw Cn() } get color() { throw Cn() } get left() { throw Cn() } get right() { throw Cn() } copy(r, e, t, s, c) { return this } insert(r, e, t) { return new Fo(r, e) } remove(r, e) { return this } isEmpty() { return !0 } inorderTraversal(r) { return !1 } reverseTraversal(r) { return !1 } minKey() { return null } maxKey() { return null } isRed() { return !1 } checkMaxDepth() { return !0 } check() { return 0 } }; class Zr { constructor(e) { this.comparator = e, this.data = new ur(this.comparator) } has(e) { return null !== this.data.get(e) } first() { return this.data.minKey() } last() { return this.data.maxKey() } get size() { return this.data.size } indexOf(e) { return this.data.indexOf(e) } forEach(e) { this.data.inorderTraversal((t, s) => (e(t), !1)) } forEachInRange(e, t) { const s = this.data.getIteratorFrom(e[0]); for (; s.hasNext();) { const c = s.getNext(); if (this.comparator(c.key, e[1]) >= 0) return; t(c.key) } } forEachWhile(e, t) { let s; for (s = void 0 !== t ? this.data.getIteratorFrom(t) : this.data.getIterator(); s.hasNext();)if (!e(s.getNext().key)) return } firstAfterOrEqual(e) { const t = this.data.getIteratorFrom(e); return t.hasNext() ? t.getNext().key : null } getIterator() { return new Nl(this.data.getIterator()) } getIteratorFrom(e) { return new Nl(this.data.getIteratorFrom(e)) } add(e) { return this.copy(this.data.remove(e).insert(e, !0)) } delete(e) { return this.has(e) ? this.copy(this.data.remove(e)) : this } isEmpty() { return this.data.isEmpty() } unionWith(e) { let t = this; return t.size < e.size && (t = e, e = this), e.forEach(s => { t = t.add(s) }), t } isEqual(e) { if (!(e instanceof Zr) || this.size !== e.size) return !1; const t = this.data.getIterator(), s = e.data.getIterator(); for (; t.hasNext();) { const c = t.getNext().key, f = s.getNext().key; if (0 !== this.comparator(c, f)) return !1 } return !0 } toArray() { const e = []; return this.forEach(t => { e.push(t) }), e } toString() { const e = []; return this.forEach(t => e.push(t)), "SortedSet(" + e.toString() + ")" } copy(e) { const t = new Zr(this.comparator); return t.data = e, t } } class Nl { constructor(e) { this.iter = e } getNext() { return this.iter.getNext().key } hasNext() { return this.iter.hasNext() } } function za(r) { return r.hasNext() ? r.getNext() : void 0 } class Xo { constructor(e) { this.fields = e, e.sort(Hr.comparator) } static empty() { return new Xo([]) } unionWith(e) { let t = new Zr(Hr.comparator); for (const s of this.fields) t = t.add(s); for (const s of e) t = t.add(s); return new Xo(t.toArray()) } covers(e) { for (const t of this.fields) if (t.isPrefixOf(e)) return !0; return !1 } isEqual(e) { return _a(this.fields, e.fields, (t, s) => t.isEqual(s)) } } class Xd extends Error { constructor() { super(...arguments), this.name = "Base64DecodeError" } } function ud() { return typeof atob < "u" } class Lo { constructor(e) { this.binaryString = e } static fromBase64String(e) { const t = function (s) { try { return atob(s) } catch (c) { throw typeof DOMException < "u" && c instanceof DOMException ? new Xd("Invalid base64 string: " + c) : c } }(e); return new Lo(t) } static fromUint8Array(e) { const t = function (s) { let c = ""; for (let f = 0; f < s.length; ++f)c += String.fromCharCode(s[f]); return c }(e); return new Lo(t) } [Symbol.iterator]() { let e = 0; return { next: () => e < this.binaryString.length ? { value: this.binaryString.charCodeAt(e++), done: !1 } : { value: void 0, done: !0 } } } toBase64() { return btoa(this.binaryString) } toUint8Array() { return function (e) { const t = new Uint8Array(e.length); for (let s = 0; s < e.length; s++)t[s] = e.charCodeAt(s); return t }(this.binaryString) } approximateByteSize() { return 2 * this.binaryString.length } compareTo(e) { return Ei(this.binaryString, e.binaryString) } isEqual(e) { return this.binaryString === e.binaryString } } Lo.EMPTY_BYTE_STRING = new Lo(""); const xa = new RegExp(/^\d{4}-\d\d-\d\dT\d\d:\d\d:\d\d(?:\.(\d+))?Z$/); function ja(r) { if (ai(!!r), "string" == typeof r) { let e = 0; const t = xa.exec(r); if (ai(!!t), t[1]) { let c = t[1]; c = (c + "000000000").substr(0, 9), e = Number(c) } const s = new Date(r); return { seconds: Math.floor(s.getTime() / 1e3), nanos: e } } return { seconds: vo(r.seconds), nanos: vo(r.nanos) } } function vo(r) { return "number" == typeof r ? r : "string" == typeof r ? Number(r) : 0 } function Ea(r) { return "string" == typeof r ? Lo.fromBase64String(r) : Lo.fromUint8Array(r) } function Oa(r) { var e, t; return "server_timestamp" === (null === (t = ((null === (e = r?.mapValue) || void 0 === e ? void 0 : e.fields) || {}).__type__) || void 0 === t ? void 0 : t.stringValue) } function hl(r) { const e = r.mapValue.fields.__previous_value__; return Oa(e) ? hl(e) : e } function qs(r) { const e = ja(r.mapValue.fields.__local_write_time__.timestampValue); return new Ri(e.seconds, e.nanos) } class tl { constructor(e, t, s, c, f, _, R, j, te) { this.databaseId = e, this.appId = t, this.persistenceKey = s, this.host = c, this.ssl = f, this.forceLongPolling = _, this.autoDetectLongPolling = R, this.longPollingOptions = j, this.useFetchStreams = te } } class zs { constructor(e, t) { this.projectId = e, this.database = t || "(default)" } static empty() { return new zs("", "") } get isDefaultDatabase() { return "(default)" === this.database } isEqual(e) { return e instanceof zs && e.projectId === this.projectId && e.database === this.database } } const Ds = { mapValue: { fields: { __type__: { stringValue: "__max__" } } } }, Il = { nullValue: "NULL_VALUE" }; function la(r) { return "nullValue" in r ? 0 : "booleanValue" in r ? 1 : "integerValue" in r || "doubleValue" in r ? 2 : "timestampValue" in r ? 3 : "stringValue" in r ? 5 : "bytesValue" in r ? 6 : "referenceValue" in r ? 7 : "geoPointValue" in r ? 8 : "arrayValue" in r ? 9 : "mapValue" in r ? Oa(r) ? 4 : Bo(r) ? 9007199254740991 : 10 : Cn() } function Ns(r, e) { if (r === e) return !0; const t = la(r); if (t !== la(e)) return !1; switch (t) { case 0: case 9007199254740991: return !0; case 1: return r.booleanValue === e.booleanValue; case 4: return qs(r).isEqual(qs(e)); case 3: return function (s, c) { if ("string" == typeof s.timestampValue && "string" == typeof c.timestampValue && s.timestampValue.length === c.timestampValue.length) return s.timestampValue === c.timestampValue; const f = ja(s.timestampValue), _ = ja(c.timestampValue); return f.seconds === _.seconds && f.nanos === _.nanos }(r, e); case 5: return r.stringValue === e.stringValue; case 6: return c = e, Ea(r.bytesValue).isEqual(Ea(c.bytesValue)); case 7: return r.referenceValue === e.referenceValue; case 8: return function (s, c) { return vo(s.geoPointValue.latitude) === vo(c.geoPointValue.latitude) && vo(s.geoPointValue.longitude) === vo(c.geoPointValue.longitude) }(r, e); case 2: return function (s, c) { if ("integerValue" in s && "integerValue" in c) return vo(s.integerValue) === vo(c.integerValue); if ("doubleValue" in s && "doubleValue" in c) { const f = vo(s.doubleValue), _ = vo(c.doubleValue); return f === _ ? hi(f) === hi(_) : isNaN(f) && isNaN(_) } return !1 }(r, e); case 9: return _a(r.arrayValue.values || [], e.arrayValue.values || [], Ns); case 10: return function (s, c) { const f = s.mapValue.fields || {}, _ = c.mapValue.fields || {}; if (Is(f) !== Is(_)) return !1; for (const R in f) if (f.hasOwnProperty(R) && (void 0 === _[R] || !Ns(f[R], _[R]))) return !1; return !0 }(r, e); default: return Cn() }var c } function O(r, e) { return void 0 !== (r.values || []).find(t => Ns(t, e)) } function U(r, e) { if (r === e) return 0; const t = la(r), s = la(e); if (t !== s) return Ei(t, s); switch (t) { case 0: case 9007199254740991: return 0; case 1: return Ei(r.booleanValue, e.booleanValue); case 2: return function (c, f) { const _ = vo(c.integerValue || c.doubleValue), R = vo(f.integerValue || f.doubleValue); return _ < R ? -1 : _ > R ? 1 : _ === R ? 0 : isNaN(_) ? isNaN(R) ? 0 : -1 : 1 }(r, e); case 3: return ce(r.timestampValue, e.timestampValue); case 4: return ce(qs(r), qs(e)); case 5: return Ei(r.stringValue, e.stringValue); case 6: return function (c, f) { const _ = Ea(c), R = Ea(f); return _.compareTo(R) }(r.bytesValue, e.bytesValue); case 7: return function (c, f) { const _ = c.split("/"), R = f.split("/"); for (let j = 0; j < _.length && j < R.length; j++) { const te = Ei(_[j], R[j]); if (0 !== te) return te } return Ei(_.length, R.length) }(r.referenceValue, e.referenceValue); case 8: return function (c, f) { const _ = Ei(vo(c.latitude), vo(f.latitude)); return 0 !== _ ? _ : Ei(vo(c.longitude), vo(f.longitude)) }(r.geoPointValue, e.geoPointValue); case 9: return function (c, f) { const _ = c.values || [], R = f.values || []; for (let j = 0; j < _.length && j < R.length; ++j) { const te = U(_[j], R[j]); if (te) return te } return Ei(_.length, R.length) }(r.arrayValue, e.arrayValue); case 10: return function (c, f) { if (c === Ds.mapValue && f === Ds.mapValue) return 0; if (c === Ds.mapValue) return 1; if (f === Ds.mapValue) return -1; const _ = c.fields || {}, R = Object.keys(_), j = f.fields || {}, te = Object.keys(j); R.sort(), te.sort(); for (let Ce = 0; Ce < R.length && Ce < te.length; ++Ce) { const ot = Ei(R[Ce], te[Ce]); if (0 !== ot) return ot; const Gt = U(_[R[Ce]], j[te[Ce]]); if (0 !== Gt) return Gt } return Ei(R.length, te.length) }(r.mapValue, e.mapValue); default: throw Cn() } } function ce(r, e) { if ("string" == typeof r && "string" == typeof e && r.length === e.length) return Ei(r, e); const t = ja(r), s = ja(e), c = Ei(t.seconds, s.seconds); return 0 !== c ? c : Ei(t.nanos, s.nanos) } function Ze(r) { return Ct(r) } function Ct(r) { return "nullValue" in r ? "null" : "booleanValue" in r ? "" + r.booleanValue : "integerValue" in r ? "" + r.integerValue : "doubleValue" in r ? "" + r.doubleValue : "timestampValue" in r ? function (s) { const c = ja(s); return `time(${c.seconds},${c.nanos})` }(r.timestampValue) : "stringValue" in r ? r.stringValue : "bytesValue" in r ? Ea(r.bytesValue).toBase64() : "referenceValue" in r ? Bn.fromName(r.referenceValue).toString() : "geoPointValue" in r ? `geo(${(e = r.geoPointValue).latitude},${e.longitude})` : "arrayValue" in r ? function (s) { let c = "[", f = !0; for (const _ of s.values || []) f ? f = !1 : c += ",", c += Ct(_); return c + "]" }(r.arrayValue) : "mapValue" in r ? function (s) { const c = Object.keys(s.fields || {}).sort(); let f = "{", _ = !0; for (const R of c) _ ? _ = !1 : f += ",", f += `${R}:${Ct(s.fields[R])}`; return f + "}" }(r.mapValue) : Cn(); var e } function ln(r, e) { return { referenceValue: `projects/${r.projectId}/databases/${r.database}/documents/${e.path.canonicalString()}` } } function Kn(r) { return !!r && "integerValue" in r } function Vn(r) { return !!r && "arrayValue" in r } function mi(r) { return !!r && "nullValue" in r } function Ui(r) { return !!r && "doubleValue" in r && isNaN(Number(r.doubleValue)) } function li(r) { return !!r && "mapValue" in r } function gs(r) { if (r.geoPointValue) return { geoPointValue: Object.assign({}, r.geoPointValue) }; if (r.timestampValue && "object" == typeof r.timestampValue) return { timestampValue: Object.assign({}, r.timestampValue) }; if (r.mapValue) { const e = { mapValue: { fields: {} } }; return _o(r.mapValue.fields, (t, s) => e.mapValue.fields[t] = gs(s)), e } if (r.arrayValue) { const e = { arrayValue: { values: [] } }; for (let t = 0; t < (r.arrayValue.values || []).length; ++t)e.arrayValue.values[t] = gs(r.arrayValue.values[t]); return e } return Object.assign({}, r) } function Bo(r) { return "__max__" === (((r.mapValue || {}).fields || {}).__type__ || {}).stringValue } function fl(r) { return "nullValue" in r ? Il : "booleanValue" in r ? { booleanValue: !1 } : "integerValue" in r || "doubleValue" in r ? { doubleValue: NaN } : "timestampValue" in r ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } } : "stringValue" in r ? { stringValue: "" } : "bytesValue" in r ? { bytesValue: "" } : "referenceValue" in r ? ln(zs.empty(), Bn.empty()) : "geoPointValue" in r ? { geoPointValue: { latitude: -90, longitude: -180 } } : "arrayValue" in r ? { arrayValue: {} } : "mapValue" in r ? { mapValue: {} } : Cn() } function js(r) { return "nullValue" in r ? { booleanValue: !1 } : "booleanValue" in r ? { doubleValue: NaN } : "integerValue" in r || "doubleValue" in r ? { timestampValue: { seconds: Number.MIN_SAFE_INTEGER } } : "timestampValue" in r ? { stringValue: "" } : "stringValue" in r ? { bytesValue: "" } : "bytesValue" in r ? ln(zs.empty(), Bn.empty()) : "referenceValue" in r ? { geoPointValue: { latitude: -90, longitude: -180 } } : "geoPointValue" in r ? { arrayValue: {} } : "arrayValue" in r ? { mapValue: {} } : "mapValue" in r ? Ds : Cn() } function Pa(r, e) { const t = U(r.value, e.value); return 0 !== t ? t : r.inclusive && !e.inclusive ? -1 : !r.inclusive && e.inclusive ? 1 : 0 } function Qs(r, e) { const t = U(r.value, e.value); return 0 !== t ? t : r.inclusive && !e.inclusive ? 1 : !r.inclusive && e.inclusive ? -1 : 0 } class no { constructor(e) { this.value = e } static empty() { return new no({ mapValue: {} }) } field(e) { if (e.isEmpty()) return this.value; { let t = this.value; for (let s = 0; s < e.length - 1; ++s)if (t = (t.mapValue.fields || {})[e.get(s)], !li(t)) return null; return t = (t.mapValue.fields || {})[e.lastSegment()], t || null } } set(e, t) { this.getFieldsMap(e.popLast())[e.lastSegment()] = gs(t) } setAll(e) { let t = Hr.emptyPath(), s = {}, c = []; e.forEach((_, R) => { if (!t.isImmediateParentOf(R)) { const j = this.getFieldsMap(t); this.applyChanges(j, s, c), s = {}, c = [], t = R.popLast() } _ ? s[R.lastSegment()] = gs(_) : c.push(R.lastSegment()) }); const f = this.getFieldsMap(t); this.applyChanges(f, s, c) } delete(e) { const t = this.field(e.popLast()); li(t) && t.mapValue.fields && delete t.mapValue.fields[e.lastSegment()] } isEqual(e) { return Ns(this.value, e.value) } getFieldsMap(e) { let t = this.value; t.mapValue.fields || (t.mapValue = { fields: {} }); for (let s = 0; s < e.length; ++s) { let c = t.mapValue.fields[e.get(s)]; li(c) && c.mapValue.fields || (c = { mapValue: { fields: {} } }, t.mapValue.fields[e.get(s)] = c), t = c } return t.mapValue.fields } applyChanges(e, t, s) { _o(t, (c, f) => e[c] = f); for (const c of s) delete e[c] } clone() { return new no(gs(this.value)) } } function ml(r) { const e = []; return _o(r.fields, (t, s) => { const c = new Hr([t]); if (li(s)) { const f = ml(s.mapValue).fields; if (0 === f.length) e.push(c); else for (const _ of f) e.push(c.child(_)) } else e.push(c) }), new Xo(e) } class So { constructor(e, t, s, c, f, _, R) { this.key = e, this.documentType = t, this.version = s, this.readTime = c, this.createTime = f, this.data = _, this.documentState = R } static newInvalidDocument(e) { return new So(e, 0, Jn.min(), Jn.min(), Jn.min(), no.empty(), 0) } static newFoundDocument(e, t, s, c) { return new So(e, 1, t, Jn.min(), s, c, 0) } static newNoDocument(e, t) { return new So(e, 2, t, Jn.min(), Jn.min(), no.empty(), 0) } static newUnknownDocument(e, t) { return new So(e, 3, t, Jn.min(), Jn.min(), no.empty(), 2) } convertToFoundDocument(e, t) { return !this.createTime.isEqual(Jn.min()) || 2 !== this.documentType && 0 !== this.documentType || (this.createTime = e), this.version = e, this.documentType = 1, this.data = t, this.documentState = 0, this } convertToNoDocument(e) { return this.version = e, this.documentType = 2, this.data = no.empty(), this.documentState = 0, this } convertToUnknownDocument(e) { return this.version = e, this.documentType = 3, this.data = no.empty(), this.documentState = 2, this } setHasCommittedMutations() { return this.documentState = 2, this } setHasLocalMutations() { return this.documentState = 1, this.version = Jn.min(), this } setReadTime(e) { return this.readTime = e, this } get hasLocalMutations() { return 1 === this.documentState } get hasCommittedMutations() { return 2 === this.documentState } get hasPendingWrites() { return this.hasLocalMutations || this.hasCommittedMutations } isValidDocument() { return 0 !== this.documentType } isFoundDocument() { return 1 === this.documentType } isNoDocument() { return 2 === this.documentType } isUnknownDocument() { return 3 === this.documentType } isEqual(e) { return e instanceof So && this.key.isEqual(e.key) && this.version.isEqual(e.version) && this.documentType === e.documentType && this.documentState === e.documentState && this.data.isEqual(e.data) } mutableCopy() { return new So(this.key, this.documentType, this.version, this.readTime, this.createTime, this.data.clone(), this.documentState) } toString() { return `Document(${this.key}, ${this.version}, ${JSON.stringify(this.data.value)}, {createTime: ${this.createTime}}), {documentType: ${this.documentType}}), {documentState: ${this.documentState}})` } } class Fl { constructor(e, t) { this.position = e, this.inclusive = t } } function ch(r, e, t) { let s = 0; for (let c = 0; c < r.position.length; c++) { const f = e[c], _ = r.position[c]; if (s = f.field.isKeyField() ? Bn.comparator(Bn.fromName(_.referenceValue), t.key) : U(_, t.data.field(f.field)), "desc" === f.dir && (s *= -1), 0 !== s) break } return s } function Jd(r, e) { if (null === r) return null === e; if (null === e || r.inclusive !== e.inclusive || r.position.length !== e.position.length) return !1; for (let t = 0; t < r.position.length; t++)if (!Ns(r.position[t], e.position[t])) return !1; return !0 } class Ts { constructor(e, t = "asc") { this.field = e, this.dir = t } } function eu(r, e) { return r.dir === e.dir && r.field.isEqual(e.field) } class Ll { } class wr extends Ll { constructor(e, t, s) { super(), this.field = e, this.op = t, this.value = s } static create(e, t, s) { return e.isKeyField() ? "in" === t || "not-in" === t ? this.createKeyFieldInFilter(e, t, s) : new kf(e, t, s) : "array-contains" === t ? new Of(e, s) : "in" === t ? new Pc(e, s) : "not-in" === t ? new ru(e, s) : "array-contains-any" === t ? new ou(e, s) : new wr(e, t, s) } static createKeyFieldInFilter(e, t, s) { return "in" === t ? new tc(e, s) : new Rf(e, s) } matches(e) { const t = e.data.field(this.field); return "!=" === this.op ? null !== t && this.matchesComparison(U(t, this.value)) : null !== t && la(this.value) === la(t) && this.matchesComparison(U(t, this.value)) } matchesComparison(e) { switch (this.op) { case "<": return e < 0; case "<=": return e <= 0; case "==": return 0 === e; case "!=": return 0 !== e; case ">": return e > 0; case ">=": return e >= 0; default: return Cn() } } isInequality() { return ["<", "<=", ">", ">=", "!=", "not-in"].indexOf(this.op) >= 0 } getFlattenedFilters() { return [this] } getFilters() { return [this] } getFirstInequalityField() { return this.isInequality() ? this.field : null } } class Yr extends Ll { constructor(e, t) { super(), this.filters = e, this.op = t, this.lt = null } static create(e, t) { return new Yr(e, t) } matches(e) { return Bl(this) ? void 0 === this.filters.find(t => !t.matches(e)) : void 0 !== this.filters.find(t => t.matches(e)) } getFlattenedFilters() { return null !== this.lt || (this.lt = this.filters.reduce((e, t) => e.concat(t.getFlattenedFilters()), [])), this.lt } getFilters() { return Object.assign([], this.filters) } getFirstInequalityField() { const e = this.ft(t => t.isInequality()); return null !== e ? e.field : null } ft(e) { for (const t of this.getFlattenedFilters()) if (e(t)) return t; return null } } function Bl(r) { return "and" === r.op } function tu(r) { return "or" === r.op } function nu(r) { return dh(r) && Bl(r) } function dh(r) { for (const e of r.filters) if (e instanceof Yr) return !1; return !0 } function iu(r) { if (r instanceof wr) return r.field.canonicalString() + r.op.toString() + Ze(r.value); if (nu(r)) return r.filters.map(e => iu(e)).join(","); { const e = r.filters.map(t => iu(t)).join(","); return `${r.op}(${e})` } } function uh(r, e) { return r instanceof wr ? (t = r, (s = e) instanceof wr && t.op === s.op && t.field.isEqual(s.field) && Ns(t.value, s.value)) : r instanceof Yr ? function (t, s) { return s instanceof Yr && t.op === s.op && t.filters.length === s.filters.length && t.filters.reduce((c, f, _) => c && uh(f, s.filters[_]), !0) }(r, e) : void Cn(); var t, s } function ec(r, e) { const t = r.filters.concat(e); return Yr.create(t, r.op) } function Ul(r) { return r instanceof wr ? `${(e = r).field.canonicalString()} ${e.op} ${Ze(e.value)}` : r instanceof Yr ? function (e) { return e.op.toString() + " {" + e.getFilters().map(Ul).join(" ,") + "}" }(r) : "Filter"; var e } class kf extends wr { constructor(e, t, s) { super(e, t, s), this.key = Bn.fromName(s.referenceValue) } matches(e) { const t = Bn.comparator(e.key, this.key); return this.matchesComparison(t) } } class tc extends wr { constructor(e, t) { super(e, "in", t), this.keys = nc(0, t) } matches(e) { return this.keys.some(t => t.isEqual(e.key)) } } class Rf extends wr { constructor(e, t) { super(e, "not-in", t), this.keys = nc(0, t) } matches(e) { return !this.keys.some(t => t.isEqual(e.key)) } } function nc(r, e) { var t; return ((null === (t = e.arrayValue) || void 0 === t ? void 0 : t.values) || []).map(s => Bn.fromName(s.referenceValue)) } class Of extends wr { constructor(e, t) { super(e, "array-contains", t) } matches(e) { const t = e.data.field(this.field); return Vn(t) && O(t.arrayValue, this.value) } } class Pc extends wr { constructor(e, t) { super(e, "in", t) } matches(e) { const t = e.data.field(this.field); return null !== t && O(this.value.arrayValue, t) } } class ru extends wr { constructor(e, t) { super(e, "not-in", t) } matches(e) { if (O(this.value.arrayValue, { nullValue: "NULL_VALUE" })) return !1; const t = e.data.field(this.field); return null !== t && !O(this.value.arrayValue, t) } } class ou extends wr { constructor(e, t) { super(e, "array-contains-any", t) } matches(e) { const t = e.data.field(this.field); return !(!Vn(t) || !t.arrayValue.values) && t.arrayValue.values.some(s => O(this.value.arrayValue, s)) } } class hd { constructor(e, t = null, s = [], c = [], f = null, _ = null, R = null) { this.path = e, this.collectionGroup = t, this.orderBy = s, this.filters = c, this.limit = f, this.startAt = _, this.endAt = R, this.dt = null } } function fd(r, e = null, t = [], s = [], c = null, f = null, _ = null) { return new hd(r, e, t, s, c, f, _) } function nl(r) { const e = Un(r); if (null === e.dt) { let t = e.path.canonicalString(); null !== e.collectionGroup && (t += "|cg:" + e.collectionGroup), t += "|f:", t += e.filters.map(s => iu(s)).join(","), t += "|ob:", t += e.orderBy.map(s => { return (c = s).field.canonicalString() + c.dir; var c }).join(","), ri(e.limit) || (t += "|l:", t += e.limit), e.startAt && (t += "|lb:", t += e.startAt.inclusive ? "b:" : "a:", t += e.startAt.position.map(s => Ze(s)).join(",")), e.endAt && (t += "|ub:", t += e.endAt.inclusive ? "a:" : "b:", t += e.endAt.position.map(s => Ze(s)).join(",")), e.dt = t } return e.dt } function $a(r, e) { if (r.limit !== e.limit || r.orderBy.length !== e.orderBy.length) return !1; for (let t = 0; t < r.orderBy.length; t++)if (!eu(r.orderBy[t], e.orderBy[t])) return !1; if (r.filters.length !== e.filters.length) return !1; for (let t = 0; t < r.filters.length; t++)if (!uh(r.filters[t], e.filters[t])) return !1; return r.collectionGroup === e.collectionGroup && !!r.path.isEqual(e.path) && !!Jd(r.startAt, e.startAt) && Jd(r.endAt, e.endAt) } function pl(r) { return Bn.isDocumentKey(r.path) && null === r.collectionGroup && 0 === r.filters.length } function md(r, e) { return r.filters.filter(t => t instanceof wr && t.field.isEqual(e)) } function Pf(r, e, t) { let s = Il, c = !0; for (const f of md(r, e)) { let _ = Il, R = !0; switch (f.op) { case "<": case "<=": _ = fl(f.value); break; case "==": case "in": case ">=": _ = f.value; break; case ">": _ = f.value, R = !1; break; case "!=": case "not-in": _ = Il }Pa({ value: s, inclusive: c }, { value: _, inclusive: R }) < 0 && (s = _, c = R) } if (null !== t) for (let f = 0; f < r.orderBy.length; ++f)if (r.orderBy[f].field.isEqual(e)) { const _ = t.position[f]; Pa({ value: s, inclusive: c }, { value: _, inclusive: t.inclusive }) < 0 && (s = _, c = t.inclusive); break } return { value: s, inclusive: c } } function su(r, e, t) { let s = Ds, c = !0; for (const f of md(r, e)) { let _ = Ds, R = !0; switch (f.op) { case ">=": case ">": _ = js(f.value), R = !1; break; case "==": case "in": case "<=": _ = f.value; break; case "<": _ = f.value, R = !1; break; case "!=": case "not-in": _ = Ds }Qs({ value: s, inclusive: c }, { value: _, inclusive: R }) > 0 && (s = _, c = R) } if (null !== t) for (let f = 0; f < r.orderBy.length; ++f)if (r.orderBy[f].field.isEqual(e)) { const _ = t.position[f]; Qs({ value: s, inclusive: c }, { value: _, inclusive: t.inclusive }) > 0 && (s = _, c = t.inclusive); break } return { value: s, inclusive: c } } class gl { constructor(e, t = null, s = [], c = [], f = null, _ = "F", R = null, j = null) { this.path = e, this.collectionGroup = t, this.explicitOrderBy = s, this.filters = c, this.limit = f, this.limitType = _, this.startAt = R, this.endAt = j, this.wt = null, this._t = null } } function Nf(r, e, t, s, c, f, _, R) { return new gl(r, e, t, s, c, f, _, R) } function Vl(r) { return new gl(r) } function hh(r) { return 0 === r.filters.length && null === r.limit && null == r.startAt && null == r.endAt && (0 === r.explicitOrderBy.length || 1 === r.explicitOrderBy.length && r.explicitOrderBy[0].field.isKeyField()) } function au(r) { return r.explicitOrderBy.length > 0 ? r.explicitOrderBy[0].field : null } function T(r) { for (const e of r.filters) { const t = e.getFirstInequalityField(); if (null !== t) return t } return null } function g(r) { return null !== r.collectionGroup } function b(r) { const e = Un(r); if (null === e.wt) { e.wt = []; const t = T(e), s = au(e); if (null !== t && null === s) t.isKeyField() || e.wt.push(new Ts(t)), e.wt.push(new Ts(Hr.keyField(), "asc")); else { let c = !1; for (const f of e.explicitOrderBy) e.wt.push(f), f.field.isKeyField() && (c = !0); if (!c) { const f = e.explicitOrderBy.length > 0 ? e.explicitOrderBy[e.explicitOrderBy.length - 1].dir : "asc"; e.wt.push(new Ts(Hr.keyField(), f)) } } } return e.wt } function k(r) { const e = Un(r); if (!e._t) if ("F" === e.limitType) e._t = fd(e.path, e.collectionGroup, b(e), e.filters, e.limit, e.startAt, e.endAt); else { const t = []; for (const f of b(e)) t.push(new Ts(f.field, "desc" === f.dir ? "asc" : "desc")); const s = e.endAt ? new Fl(e.endAt.position, e.endAt.inclusive) : null, c = e.startAt ? new Fl(e.startAt.position, e.startAt.inclusive) : null; e._t = fd(e.path, e.collectionGroup, t, e.filters, e.limit, s, c) } return e._t } function oe(r, e) { e.getFirstInequalityField(), T(r); const t = r.filters.concat([e]); return new gl(r.path, r.collectionGroup, r.explicitOrderBy.slice(), t, r.limit, r.limitType, r.startAt, r.endAt) } function De(r, e, t) { return new gl(r.path, r.collectionGroup, r.explicitOrderBy.slice(), r.filters.slice(), e, t, r.startAt, r.endAt) } function Tt(r, e) { return $a(k(r), k(e)) && r.limitType === e.limitType } function Xt(r) { return `${nl(k(r))}|lt:${r.limitType}` } function Nn(r) { return `Query(target=${function (e) { let t = e.path.canonicalString(); return null !== e.collectionGroup && (t += " collectionGroup=" + e.collectionGroup), e.filters.length > 0 && (t += `, filters: [${e.filters.map(s => Ul(s)).join(", ")}]`), ri(e.limit) || (t += ", limit: " + e.limit), e.orderBy.length > 0 && (t += `, orderBy: [${e.orderBy.map(s => { return `${(c = s).field.canonicalString()} (${c.dir})`; var c }).join(", ")}]`), e.startAt && (t += ", startAt: ", t += e.startAt.inclusive ? "b:" : "a:", t += e.startAt.position.map(s => Ze(s)).join(",")), e.endAt && (t += ", endAt: ", t += e.endAt.inclusive ? "a:" : "b:", t += e.endAt.position.map(s => Ze(s)).join(",")), `Target(${t})` }(k(r))}; limitType=${r.limitType})` } function zn(r, e) { return e.isFoundDocument() && function (t, s) { const c = s.key.path; return null !== t.collectionGroup ? s.key.hasCollectionId(t.collectionGroup) && t.path.isPrefixOf(c) : Bn.isDocumentKey(t.path) ? t.path.isEqual(c) : t.path.isImmediateParentOf(c) }(r, e) && function (t, s) { for (const c of b(t)) if (!c.field.isKeyField() && null === s.data.field(c.field)) return !1; return !0 }(r, e) && function (t, s) { for (const c of t.filters) if (!c.matches(s)) return !1; return !0 }(r, e) && (s = e, !((t = r).startAt && !function (c, f, _) { const R = ch(c, f, _); return c.inclusive ? R <= 0 : R < 0 }(t.startAt, b(t), s) || t.endAt && !function (c, f, _) { const R = ch(c, f, _); return c.inclusive ? R >= 0 : R > 0 }(t.endAt, b(t), s))); var t, s } function vi(r) { return r.collectionGroup || (r.path.length % 2 == 1 ? r.path.lastSegment() : r.path.get(r.path.length - 2)) } function hr(r) { return (e, t) => { let s = !1; for (const c of b(r)) { const f = $s(c, e, t); if (0 !== f) return f; s = s || c.field.isKeyField() } return 0 } } function $s(r, e, t) { const s = r.field.isKeyField() ? Bn.comparator(e.key, t.key) : function (c, f, _) { const R = f.data.field(c), j = _.data.field(c); return null !== R && null !== j ? U(R, j) : Cn() }(r.field, e, t); switch (r.dir) { case "asc": return s; case "desc": return -1 * s; default: return Cn() } } class Xs { constructor(e, t) { this.mapKeyFn = e, this.equalsFn = t, this.inner = {}, this.innerSize = 0 } get(e) { const t = this.mapKeyFn(e), s = this.inner[t]; if (void 0 !== s) for (const [c, f] of s) if (this.equalsFn(c, e)) return f } has(e) { return void 0 !== this.get(e) } set(e, t) { const s = this.mapKeyFn(e), c = this.inner[s]; if (void 0 === c) return this.inner[s] = [[e, t]], void this.innerSize++; for (let f = 0; f < c.length; f++)if (this.equalsFn(c[f][0], e)) return void (c[f] = [e, t]); c.push([e, t]), this.innerSize++ } delete(e) { const t = this.mapKeyFn(e), s = this.inner[t]; if (void 0 === s) return !1; for (let c = 0; c < s.length; c++)if (this.equalsFn(s[c][0], e)) return 1 === s.length ? delete this.inner[t] : s.splice(c, 1), this.innerSize--, !0; return !1 } forEach(e) { _o(this.inner, (t, s) => { for (const [c, f] of s) e(c, f) }) } isEmpty() { return Va(this.inner) } size() { return this.innerSize } } const lu = new ur(Bn.comparator); function ca() { return lu } const cu = new ur(Bn.comparator); function Nc(...r) { let e = cu; for (const t of r) e = e.insert(t.key, t); return e } function du(r) { let e = cu; return r.forEach((t, s) => e = e.insert(t, s.overlayedDocument)), e } function Js() { return Hl() } function Fc() { return Hl() } function Hl() { return new Xs(r => r.toString(), (r, e) => r.isEqual(e)) } const pd = new ur(Bn.comparator), uu = new Zr(Bn.comparator); function Oi(...r) { let e = uu; for (const t of r) e = e.add(t); return e } const gd = new Zr(Ei); function _d() { return gd } function hu(r, e) { if (r.useProto3Json) { if (isNaN(e)) return { doubleValue: "NaN" }; if (e === 1 / 0) return { doubleValue: "Infinity" }; if (e === -1 / 0) return { doubleValue: "-Infinity" } } return { doubleValue: hi(e) ? "-0" : e } } function fu(r) { return { integerValue: "" + r } } function _l(r, e) { return fi(e) ? fu(e) : hu(r, e) } class fh { constructor() { this._ = void 0 } } function iv(r, e, t) { return r instanceof ic ? function (s, c) { const f = { fields: { __type__: { stringValue: "server_timestamp" }, __local_write_time__: { timestampValue: { seconds: s.seconds, nanos: s.nanoseconds } } } }; return c && Oa(c) && (c = hl(c)), c && (f.fields.__previous_value__ = c), { mapValue: f } }(t, e) : r instanceof Lc ? jp(r, e) : r instanceof Bc ? Lf(r, e) : function (s, c) { const f = Ff(s, c), _ = $p(f) + $p(s.gt); return Kn(f) && Kn(s.gt) ? fu(_) : hu(s.serializer, _) }(r, e) } function rv(r, e, t) { return r instanceof Lc ? jp(r, e) : r instanceof Bc ? Lf(r, e) : t } function Ff(r, e) { return r instanceof vd ? Kn(t = e) || (s = t) && "doubleValue" in s ? e : { integerValue: 0 } : null; var s, t } class ic extends fh { } class Lc extends fh { constructor(e) { super(), this.elements = e } } function jp(r, e) { const t = Ca(e); for (const s of r.elements) t.some(c => Ns(c, s)) || t.push(s); return { arrayValue: { values: t } } } class Bc extends fh { constructor(e) { super(), this.elements = e } } function Lf(r, e) { let t = Ca(e); for (const s of r.elements) t = t.filter(c => !Ns(c, s)); return { arrayValue: { values: t } } } class vd extends fh { constructor(e, t) { super(), this.serializer = e, this.gt = t } } function $p(r) { return vo(r.integerValue || r.doubleValue) } function Ca(r) { return Vn(r) && r.arrayValue.values ? r.arrayValue.values.slice() : [] } class Uc { constructor(e, t) { this.field = e, this.transform = t } } class Bf { constructor(e, t) { this.version = e, this.transformResults = t } } class fr { constructor(e, t) { this.updateTime = e, this.exists = t } static none() { return new fr } static exists(e) { return new fr(void 0, e) } static updateTime(e) { return new fr(e) } get isNone() { return void 0 === this.updateTime && void 0 === this.exists } isEqual(e) { return this.exists === e.exists && (this.updateTime ? !!e.updateTime && this.updateTime.isEqual(e.updateTime) : !e.updateTime) } } function rc(r, e) { return void 0 !== r.updateTime ? e.isFoundDocument() && e.version.isEqual(r.updateTime) : void 0 === r.exists || r.exists === e.isFoundDocument() } class mu { } function Uf(r, e) { if (!r.hasLocalMutations || e && 0 === e.fields.length) return null; if (null === e) return r.isNoDocument() ? new oc(r.key, fr.none()) : new yd(r.key, r.data, fr.none()); { const t = r.data, s = no.empty(); let c = new Zr(Hr.comparator); for (let f of e.fields) if (!c.has(f)) { let _ = t.field(f); null === _ && f.length > 1 && (f = f.popLast(), _ = t.field(f)), null === _ ? s.delete(f) : s.set(f, _), c = c.add(f) } return new Dl(r.key, s, new Xo(c.toArray()), fr.none()) } } function ov(r, e, t) { r instanceof yd ? function (s, c, f) { const _ = s.value.clone(), R = Kp(s.fieldTransforms, c, f.transformResults); _.setAll(R), c.convertToFoundDocument(f.version, _).setHasCommittedMutations() }(r, e, t) : r instanceof Dl ? function (s, c, f) { if (!rc(s.precondition, c)) return void c.convertToUnknownDocument(f.version); const _ = Kp(s.fieldTransforms, c, f.transformResults), R = c.data; R.setAll(Wp(s)), R.setAll(_), c.convertToFoundDocument(f.version, R).setHasCommittedMutations() }(r, e, t) : e.convertToNoDocument(t.version).setHasCommittedMutations() } function bd(r, e, t, s) { return r instanceof yd ? function (c, f, _, R) { if (!rc(c.precondition, f)) return _; const j = c.value.clone(), te = mh(c.fieldTransforms, R, f); return j.setAll(te), f.convertToFoundDocument(f.version, j).setHasLocalMutations(), null }(r, e, t, s) : r instanceof Dl ? function (c, f, _, R) { if (!rc(c.precondition, f)) return _; const j = mh(c.fieldTransforms, R, f), te = f.data; return te.setAll(Wp(c)), te.setAll(j), f.convertToFoundDocument(f.version, te).setHasLocalMutations(), null === _ ? null : _.unionWith(c.fieldMask.fields).unionWith(c.fieldTransforms.map(Ce => Ce.field)) }(r, e, t, s) : (_ = t, rc(r.precondition, f = e) ? (f.convertToNoDocument(f.version).setHasLocalMutations(), null) : _); var f, _ } function sv(r, e) { let t = null; for (const s of r.fieldTransforms) { const c = e.data.field(s.field), f = Ff(s.transform, c || null); null != f && (null === t && (t = no.empty()), t.set(s.field, f)) } return t || null } function Vf(r, e) { return r.type === e.type && !!r.key.isEqual(e.key) && !!r.precondition.isEqual(e.precondition) && (s = e.fieldTransforms, !!(void 0 === (t = r.fieldTransforms) && void 0 === s || t && s && _a(t, s, (c, f) => function Gp(r, e) { return r.field.isEqual(e.field) && (s = e.transform, (t = r.transform) instanceof Lc && s instanceof Lc || t instanceof Bc && s instanceof Bc ? _a(t.elements, s.elements, Ns) : t instanceof vd && s instanceof vd ? Ns(t.gt, s.gt) : t instanceof ic && s instanceof ic); var t, s }(c, f)))) && (0 === r.type ? r.value.isEqual(e.value) : 1 !== r.type || r.data.isEqual(e.data) && r.fieldMask.isEqual(e.fieldMask)); var t, s } class yd extends mu { constructor(e, t, s, c = []) { super(), this.key = e, this.value = t, this.precondition = s, this.fieldTransforms = c, this.type = 0 } getFieldMask() { return null } } class Dl extends mu { constructor(e, t, s, c, f = []) { super(), this.key = e, this.data = t, this.fieldMask = s, this.precondition = c, this.fieldTransforms = f, this.type = 1 } getFieldMask() { return this.fieldMask } } function Wp(r) { const e = new Map; return r.fieldMask.fields.forEach(t => { if (!t.isEmpty()) { const s = r.data.field(t); e.set(t, s) } }), e } function Kp(r, e, t) { const s = new Map; ai(r.length === t.length); for (let c = 0; c < t.length; c++) { const f = r[c], _ = f.transform, R = e.data.field(f.field); s.set(f.field, rv(_, R, t[c])) } return s } function mh(r, e, t) { const s = new Map; for (const c of r) { const f = c.transform, _ = t.data.field(c.field); s.set(c.field, iv(f, _, e)) } return s } class oc extends mu { constructor(e, t) { super(), this.key = e, this.precondition = t, this.type = 2, this.fieldTransforms = [] } getFieldMask() { return null } } class Hf extends mu { constructor(e, t) { super(), this.key = e, this.precondition = t, this.type = 3, this.fieldTransforms = [] } getFieldMask() { return null } } class Vc { constructor(e, t, s, c) { this.batchId = e, this.localWriteTime = t, this.baseMutations = s, this.mutations = c } applyToRemoteDocument(e, t) { const s = t.mutationResults; for (let c = 0; c < this.mutations.length; c++) { const f = this.mutations[c]; f.key.isEqual(e.key) && ov(f, e, s[c]) } } applyToLocalView(e, t) { for (const s of this.baseMutations) s.key.isEqual(e.key) && (t = bd(s, e, t, this.localWriteTime)); for (const s of this.mutations) s.key.isEqual(e.key) && (t = bd(s, e, t, this.localWriteTime)); return t } applyToLocalDocumentSet(e, t) { const s = Fc(); return this.mutations.forEach(c => { const f = e.get(c.key), _ = f.overlayedDocument; let R = this.applyToLocalView(_, f.mutatedFields); R = t.has(c.key) ? null : R; const j = Uf(_, R); null !== j && s.set(c.key, j), _.isValidDocument() || _.convertToNoDocument(Jn.min()) }), s } keys() { return this.mutations.reduce((e, t) => e.add(t.key), Oi()) } isEqual(e) { return this.batchId === e.batchId && _a(this.mutations, e.mutations, (t, s) => Vf(t, s)) && _a(this.baseMutations, e.baseMutations, (t, s) => Vf(t, s)) } } class zf { constructor(e, t, s, c) { this.batch = e, this.commitVersion = t, this.mutationResults = s, this.docVersions = c } static from(e, t, s) { ai(e.mutations.length === s.length); let c = pd; const f = e.mutations; for (let _ = 0; _ < f.length; _++)c = c.insert(f[_].key, s[_].version); return new zf(e, t, s, c) } } class jf { constructor(e, t) { this.largestBatchId = e, this.mutation = t } getKey() { return this.mutation.key } isEqual(e) { return null !== e && this.mutation === e.mutation } toString() { return `Overlay{\n      largestBatchId: ${this.largestBatchId},\n      mutation: ${this.mutation.toString()}\n    }` } } class Yp { constructor(e, t) { this.count = e, this.unchangedNames = t } } var _s, mr; function pu(r) { switch (r) { default: return Cn(); case Yt.CANCELLED: case Yt.UNKNOWN: case Yt.DEADLINE_EXCEEDED: case Yt.RESOURCE_EXHAUSTED: case Yt.INTERNAL: case Yt.UNAVAILABLE: case Yt.UNAUTHENTICATED: return !1; case Yt.INVALID_ARGUMENT: case Yt.NOT_FOUND: case Yt.ALREADY_EXISTS: case Yt.PERMISSION_DENIED: case Yt.FAILED_PRECONDITION: case Yt.ABORTED: case Yt.OUT_OF_RANGE: case Yt.UNIMPLEMENTED: case Yt.DATA_LOSS: return !0 } } function $f(r) { if (void 0 === r) return er("GRPC error has no .code"), Yt.UNKNOWN; switch (r) { case _s.OK: return Yt.OK; case _s.CANCELLED: return Yt.CANCELLED; case _s.UNKNOWN: return Yt.UNKNOWN; case _s.DEADLINE_EXCEEDED: return Yt.DEADLINE_EXCEEDED; case _s.RESOURCE_EXHAUSTED: return Yt.RESOURCE_EXHAUSTED; case _s.INTERNAL: return Yt.INTERNAL; case _s.UNAVAILABLE: return Yt.UNAVAILABLE; case _s.UNAUTHENTICATED: return Yt.UNAUTHENTICATED; case _s.INVALID_ARGUMENT: return Yt.INVALID_ARGUMENT; case _s.NOT_FOUND: return Yt.NOT_FOUND; case _s.ALREADY_EXISTS: return Yt.ALREADY_EXISTS; case _s.PERMISSION_DENIED: return Yt.PERMISSION_DENIED; case _s.FAILED_PRECONDITION: return Yt.FAILED_PRECONDITION; case _s.ABORTED: return Yt.ABORTED; case _s.OUT_OF_RANGE: return Yt.OUT_OF_RANGE; case _s.UNIMPLEMENTED: return Yt.UNIMPLEMENTED; case _s.DATA_LOSS: return Yt.DATA_LOSS; default: return Cn() } } (mr = _s || (_s = {}))[mr.OK = 0] = "OK", mr[mr.CANCELLED = 1] = "CANCELLED", mr[mr.UNKNOWN = 2] = "UNKNOWN", mr[mr.INVALID_ARGUMENT = 3] = "INVALID_ARGUMENT", mr[mr.DEADLINE_EXCEEDED = 4] = "DEADLINE_EXCEEDED", mr[mr.NOT_FOUND = 5] = "NOT_FOUND", mr[mr.ALREADY_EXISTS = 6] = "ALREADY_EXISTS", mr[mr.PERMISSION_DENIED = 7] = "PERMISSION_DENIED", mr[mr.UNAUTHENTICATED = 16] = "UNAUTHENTICATED", mr[mr.RESOURCE_EXHAUSTED = 8] = "RESOURCE_EXHAUSTED", mr[mr.FAILED_PRECONDITION = 9] = "FAILED_PRECONDITION", mr[mr.ABORTED = 10] = "ABORTED", mr[mr.OUT_OF_RANGE = 11] = "OUT_OF_RANGE", mr[mr.UNIMPLEMENTED = 12] = "UNIMPLEMENTED", mr[mr.INTERNAL = 13] = "INTERNAL", mr[mr.UNAVAILABLE = 14] = "UNAVAILABLE", mr[mr.DATA_LOSS = 15] = "DATA_LOSS"; class gu { constructor() { this.onExistenceFilterMismatchCallbacks = new Map } static get instance() { return Hc } static getOrCreateInstance() { return null === Hc && (Hc = new gu), Hc } onExistenceFilterMismatch(e) { const t = Symbol(); return this.onExistenceFilterMismatchCallbacks.set(t, e), () => this.onExistenceFilterMismatchCallbacks.delete(t) } notifyOnExistenceFilterMismatch(e) { this.onExistenceFilterMismatchCallbacks.forEach(t => t(e)) } } let Hc = null; function qp() { return new TextEncoder } const av = new Hi([4294967295, 4294967295], 0); function Qp(r) { const e = qp().encode(r), t = new xi; return t.update(e), new Uint8Array(t.digest()) } function Xp(r) { const e = new DataView(r.buffer), t = e.getUint32(0, !0), s = e.getUint32(4, !0), c = e.getUint32(8, !0), f = e.getUint32(12, !0); return [new Hi([t, s], 0), new Hi([c, f], 0)] } class Gf { constructor(e, t, s) { if (this.bitmap = e, this.padding = t, this.hashCount = s, t < 0 || t >= 8) throw new _u(`Invalid padding: ${t}`); if (s < 0) throw new _u(`Invalid hash count: ${s}`); if (e.length > 0 && 0 === this.hashCount) throw new _u(`Invalid hash count: ${s}`); if (0 === e.length && 0 !== t) throw new _u(`Invalid padding when bitmap length is 0: ${t}`); this.It = 8 * e.length - t, this.Tt = Hi.fromNumber(this.It) } Et(e, t, s) { let c = e.add(t.multiply(Hi.fromNumber(s))); return 1 === c.compare(av) && (c = new Hi([c.getBits(0), c.getBits(1)], 0)), c.modulo(this.Tt).toNumber() } At(e) { return 0 != (this.bitmap[Math.floor(e / 8)] & 1 << e % 8) } vt(e) { if (0 === this.It) return !1; const t = Qp(e), [s, c] = Xp(t); for (let f = 0; f < this.hashCount; f++) { const _ = this.Et(s, c, f); if (!this.At(_)) return !1 } return !0 } static create(e, t, s) { const c = e % 8 == 0 ? 0 : 8 - e % 8, f = new Uint8Array(Math.ceil(e / 8)), _ = new Gf(f, c, t); return s.forEach(R => _.insert(R)), _ } insert(e) { if (0 === this.It) return; const t = Qp(e), [s, c] = Xp(t); for (let f = 0; f < this.hashCount; f++) { const _ = this.Et(s, c, f); this.Rt(_) } } Rt(e) { const t = Math.floor(e / 8); this.bitmap[t] |= 1 << e % 8 } } class _u extends Error { constructor() { super(...arguments), this.name = "BloomFilterError" } } class wd { constructor(e, t, s, c, f) { this.snapshotVersion = e, this.targetChanges = t, this.targetMismatches = s, this.documentUpdates = c, this.resolvedLimboDocuments = f } static createSynthesizedRemoteEventForCurrentChange(e, t, s) { const c = new Map; return c.set(e, zc.createSynthesizedTargetChangeForCurrentChange(e, t, s)), new wd(Jn.min(), c, new ur(Ei), ca(), Oi()) } } class zc { constructor(e, t, s, c, f) { this.resumeToken = e, this.current = t, this.addedDocuments = s, this.modifiedDocuments = c, this.removedDocuments = f } static createSynthesizedTargetChangeForCurrentChange(e, t, s) { return new zc(s, t, Oi(), Oi(), Oi()) } } class vu { constructor(e, t, s, c) { this.Pt = e, this.removedTargetIds = t, this.key = s, this.bt = c } } class ph { constructor(e, t) { this.targetId = e, this.Vt = t } } class Jp { constructor(e, t, s = Lo.EMPTY_BYTE_STRING, c = null) { this.state = e, this.targetIds = t, this.resumeToken = s, this.cause = c } } class eg { constructor() { this.St = 0, this.Dt = sc(), this.Ct = Lo.EMPTY_BYTE_STRING, this.xt = !1, this.Nt = !0 } get current() { return this.xt } get resumeToken() { return this.Ct } get kt() { return 0 !== this.St } get Mt() { return this.Nt } $t(e) { e.approximateByteSize() > 0 && (this.Nt = !0, this.Ct = e) } Ot() { let e = Oi(), t = Oi(), s = Oi(); return this.Dt.forEach((c, f) => { switch (f) { case 0: e = e.add(c); break; case 2: t = t.add(c); break; case 1: s = s.add(c); break; default: Cn() } }), new zc(this.Ct, this.xt, e, t, s) } Ft() { this.Nt = !1, this.Dt = sc() } Bt(e, t) { this.Nt = !0, this.Dt = this.Dt.insert(e, t) } Lt(e) { this.Nt = !0, this.Dt = this.Dt.remove(e) } qt() { this.St += 1 } Ut() { this.St -= 1 } Kt() { this.Nt = !0, this.xt = !0 } } class Wf { constructor(e) { this.Gt = e, this.Qt = new Map, this.jt = ca(), this.zt = Kf(), this.Wt = new ur(Ei) } Ht(e) { for (const t of e.Pt) e.bt && e.bt.isFoundDocument() ? this.Jt(t, e.bt) : this.Yt(t, e.key, e.bt); for (const t of e.removedTargetIds) this.Yt(t, e.key, e.bt) } Xt(e) { this.forEachTarget(e, t => { const s = this.Zt(t); switch (e.state) { case 0: this.te(t) && s.$t(e.resumeToken); break; case 1: s.Ut(), s.kt || s.Ft(), s.$t(e.resumeToken); break; case 2: s.Ut(), s.kt || this.removeTarget(t); break; case 3: this.te(t) && (s.Kt(), s.$t(e.resumeToken)); break; case 4: this.te(t) && (this.ee(t), s.$t(e.resumeToken)); break; default: Cn() } }) } forEachTarget(e, t) { e.targetIds.length > 0 ? e.targetIds.forEach(t) : this.Qt.forEach((s, c) => { this.te(c) && t(c) }) } ne(e) { var t; const s = e.targetId, c = e.Vt.count, f = this.se(s); if (f) { const _ = f.target; if (pl(_)) if (0 === c) { const R = new Bn(_.path); this.Yt(s, R, So.newNoDocument(R, Jn.min())) } else ai(1 === c); else { const R = this.ie(s); if (R !== c) { const j = this.re(e, R); 0 !== j && (this.ee(s), this.Wt = this.Wt.insert(s, 2 === j ? "TargetPurposeExistenceFilterMismatchBloom" : "TargetPurposeExistenceFilterMismatch")), null === (t = gu.instance) || void 0 === t || t.notifyOnExistenceFilterMismatch(function (te, Ce, ot) { var Gt, an, kn, Yn, ti, Qi; const Rr = { localCacheCount: Ce, existenceFilterCount: ot.count }, pr = ot.unchangedNames; return pr && (Rr.bloomFilter = { applied: 0 === te, hashCount: null !== (Gt = pr?.hashCount) && void 0 !== Gt ? Gt : 0, bitmapLength: null !== (Yn = null === (kn = null === (an = pr?.bits) || void 0 === an ? void 0 : an.bitmap) || void 0 === kn ? void 0 : kn.length) && void 0 !== Yn ? Yn : 0, padding: null !== (Qi = null === (ti = pr?.bits) || void 0 === ti ? void 0 : ti.padding) && void 0 !== Qi ? Qi : 0 }), Rr }(j, R, e.Vt)) } } } } re(e, t) { const { unchangedNames: s, count: c } = e.Vt; if (!s || !s.bits) return 1; const { bits: { bitmap: f = "", padding: _ = 0 }, hashCount: R = 0 } = s; let j, te; try { j = Ea(f).toUint8Array() } catch (Ce) { if (Ce instanceof Xd) return wo("Decoding the base64 bloom filter in existence filter failed (" + Ce.message + "); ignoring the bloom filter and falling back to full re-query."), 1; throw Ce } try { te = new Gf(j, _, R) } catch (Ce) { return wo(Ce instanceof _u ? "BloomFilter error: " : "Applying bloom filter failed: ", Ce), 1 } return 0 === te.It ? 1 : c !== t - this.oe(e.targetId, te) ? 2 : 0 } oe(e, t) { const s = this.Gt.getRemoteKeysForTarget(e); let c = 0; return s.forEach(f => { const _ = this.Gt.ue(), R = `projects/${_.projectId}/databases/${_.database}/documents/${f.path.canonicalString()}`; t.vt(R) || (this.Yt(e, f, null), c++) }), c } ce(e) { const t = new Map; this.Qt.forEach((f, _) => { const R = this.se(_); if (R) { if (f.current && pl(R.target)) { const j = new Bn(R.target.path); null !== this.jt.get(j) || this.ae(_, j) || this.Yt(_, j, So.newNoDocument(j, e)) } f.Mt && (t.set(_, f.Ot()), f.Ft()) } }); let s = Oi(); this.zt.forEach((f, _) => { let R = !0; _.forEachWhile(j => { const te = this.se(j); return !te || "TargetPurposeLimboResolution" === te.purpose || (R = !1, !1) }), R && (s = s.add(f)) }), this.jt.forEach((f, _) => _.setReadTime(e)); const c = new wd(e, t, this.Wt, this.jt, s); return this.jt = ca(), this.zt = Kf(), this.Wt = new ur(Ei), c } Jt(e, t) { if (!this.te(e)) return; const s = this.ae(e, t.key) ? 2 : 0; this.Zt(e).Bt(t.key, s), this.jt = this.jt.insert(t.key, t), this.zt = this.zt.insert(t.key, this.he(t.key).add(e)) } Yt(e, t, s) { if (!this.te(e)) return; const c = this.Zt(e); this.ae(e, t) ? c.Bt(t, 1) : c.Lt(t), this.zt = this.zt.insert(t, this.he(t).delete(e)), s && (this.jt = this.jt.insert(t, s)) } removeTarget(e) { this.Qt.delete(e) } ie(e) { const t = this.Zt(e).Ot(); return this.Gt.getRemoteKeysForTarget(e).size + t.addedDocuments.size - t.removedDocuments.size } qt(e) { this.Zt(e).qt() } Zt(e) { let t = this.Qt.get(e); return t || (t = new eg, this.Qt.set(e, t)), t } he(e) { let t = this.zt.get(e); return t || (t = new Zr(Ei), this.zt = this.zt.insert(e, t)), t } te(e) { const t = null !== this.se(e); return t || pn("WatchChangeAggregator", "Detected inactive target", e), t } se(e) { const t = this.Qt.get(e); return t && t.kt ? null : this.Gt.le(e) } ee(e) { this.Qt.set(e, new eg), this.Gt.getRemoteKeysForTarget(e).forEach(t => { this.Yt(e, t, null) }) } ae(e, t) { return this.Gt.getRemoteKeysForTarget(e).has(t) } } function Kf() { return new ur(Bn.comparator) } function sc() { return new ur(Bn.comparator) } const tg = { asc: "ASCENDING", desc: "DESCENDING" }, ng = { "<": "LESS_THAN", "<=": "LESS_THAN_OR_EQUAL", ">": "GREATER_THAN", ">=": "GREATER_THAN_OR_EQUAL", "==": "EQUAL", "!=": "NOT_EQUAL", "array-contains": "ARRAY_CONTAINS", in: "IN", "not-in": "NOT_IN", "array-contains-any": "ARRAY_CONTAINS_ANY" }, lv = { and: "AND", or: "OR" }; class fy { constructor(e, t) { this.databaseId = e, this.useProto3Json = t } } function xd(r, e) { return r.useProto3Json || ri(e) ? e : { value: e } } function Ed(r, e) { return r.useProto3Json ? `${new Date(1e3 * e.seconds).toISOString().replace(/\.\d*/, "").replace("Z", "")}.${("000000000" + e.nanoseconds).slice(-9)}Z` : { seconds: "" + e.seconds, nanos: e.nanoseconds } } function Zf(r, e) { return r.useProto3Json ? e.toBase64() : e.toUint8Array() } function ig(r, e) { return Ed(r, e.toTimestamp()) } function ss(r) { return ai(!!r), Jn.fromTimestamp(function (e) { const t = ja(e); return new Ri(t.seconds, t.nanos) }(r)) } function bu(r, e) { return (t = r, new Pi(["projects", t.projectId, "databases", t.database])).child("documents").child(e).canonicalString(); var t } function Yf(r) { const e = Pi.fromString(r); return ai(Eu(e)), e } function ac(r, e) { return bu(r.databaseId, e.path) } function Na(r, e) { const t = Yf(e); if (t.get(1) !== r.databaseId.projectId) throw new _n(Yt.INVALID_ARGUMENT, "Tried to deserialize key from different project: " + t.get(1) + " vs " + r.databaseId.projectId); if (t.get(3) !== r.databaseId.database) throw new _n(Yt.INVALID_ARGUMENT, "Tried to deserialize key from different database: " + t.get(3) + " vs " + r.databaseId.database); return new Bn(qf(t)) } function gh(r, e) { return bu(r.databaseId, e) } function _h(r) { const e = Yf(r); return 4 === e.length ? Pi.emptyPath() : qf(e) } function lc(r) { return new Pi(["projects", r.databaseId.projectId, "databases", r.databaseId.database]).canonicalString() } function qf(r) { return ai(r.length > 4 && "documents" === r.get(4)), r.popFirst(5) } function vh(r, e, t) { return { name: ac(r, e), fields: t.value.mapValue.fields } } function Cd(r, e, t) { const s = Na(r, e.name), c = ss(e.updateTime), f = e.createTime ? ss(e.createTime) : Jn.min(), _ = new no({ mapValue: { fields: e.fields } }), R = So.newFoundDocument(s, c, f, _); return t && R.setHasCommittedMutations(), t ? R.setHasCommittedMutations() : R } function yu(r, e) { let t; if (e instanceof yd) t = { update: vh(r, e.key, e.value) }; else if (e instanceof oc) t = { delete: ac(r, e.key) }; else if (e instanceof Dl) t = { update: vh(r, e.key, e.data), updateMask: xu(e.fieldMask) }; else { if (!(e instanceof Hf)) return Cn(); t = { verify: ac(r, e.key) } } return e.fieldTransforms.length > 0 && (t.updateTransforms = e.fieldTransforms.map(s => function (c, f) { const _ = f.transform; if (_ instanceof ic) return { fieldPath: f.field.canonicalString(), setToServerValue: "REQUEST_TIME" }; if (_ instanceof Lc) return { fieldPath: f.field.canonicalString(), appendMissingElements: { values: _.elements } }; if (_ instanceof Bc) return { fieldPath: f.field.canonicalString(), removeAllFromArray: { values: _.elements } }; if (_ instanceof vd) return { fieldPath: f.field.canonicalString(), increment: _.gt }; throw Cn() }(0, s))), e.precondition.isNone || (t.currentDocument = void 0 !== (c = e.precondition).updateTime ? { updateTime: ig(r, c.updateTime) } : void 0 !== c.exists ? { exists: c.exists } : Cn()), t; var c } function Qf(r, e) { const t = e.currentDocument ? void 0 !== (c = e.currentDocument).updateTime ? fr.updateTime(ss(c.updateTime)) : void 0 !== c.exists ? fr.exists(c.exists) : fr.none() : fr.none(), s = e.updateTransforms ? e.updateTransforms.map(c => function (f, _) { let R = null; "setToServerValue" in _ ? (ai("REQUEST_TIME" === _.setToServerValue), R = new ic) : "appendMissingElements" in _ ? R = new Lc(_.appendMissingElements.values || []) : "removeAllFromArray" in _ ? R = new Bc(_.removeAllFromArray.values || []) : "increment" in _ ? R = new vd(f, _.increment) : Cn(); const j = Hr.fromServerFormat(_.fieldPath); return new Uc(j, R) }(r, c)) : []; var c; if (e.update) { const c = Na(r, e.update.name), f = new no({ mapValue: { fields: e.update.fields } }); if (e.updateMask) { const _ = new Xo((e.updateMask.fieldPaths || []).map(te => Hr.fromServerFormat(te))); return new Dl(c, f, _, t, s) } return new yd(c, f, t, s) } if (e.delete) { const c = Na(r, e.delete); return new oc(c, t) } if (e.verify) { const c = Na(r, e.verify); return new Hf(c, t) } return Cn() } function Xf(r, e) { return { documents: [gh(r, e.path)] } } function bh(r, e) { const t = { structuredQuery: {} }, s = e.path; null !== e.collectionGroup ? (t.parent = gh(r, s), t.structuredQuery.from = [{ collectionId: e.collectionGroup, allDescendants: !0 }]) : (t.parent = gh(r, s.popLast()), t.structuredQuery.from = [{ collectionId: s.lastSegment() }]); const c = function (j) { if (0 !== j.length) return og(Yr.create(j, "and")) }(e.filters); c && (t.structuredQuery.where = c); const f = function (j) { if (0 !== j.length) return j.map(te => { return { field: cc((Ce = te).field), direction: uv(Ce.dir) }; var Ce }) }(e.orderBy); f && (t.structuredQuery.orderBy = f); const _ = xd(r, e.limit); var R, j; return null !== _ && (t.structuredQuery.limit = _), e.startAt && (t.structuredQuery.startAt = { before: (R = e.startAt).inclusive, values: R.position }), e.endAt && (t.structuredQuery.endAt = { before: !(j = e.endAt).inclusive, values: j.position }), t } function wu(r) { let e = _h(r.parent); const t = r.structuredQuery, s = t.from ? t.from.length : 0; let c = null; if (s > 0) { ai(1 === s); const Ce = t.from[0]; Ce.allDescendants ? c = Ce.collectionId : e = e.child(Ce.collectionId) } let f = []; t.where && (f = function (Ce) { const ot = jc(Ce); return ot instanceof Yr && nu(ot) ? ot.getFilters() : [ot] }(t.where)); let _ = []; t.orderBy && (_ = t.orderBy.map(Ce => { return new Ts(dc((ot = Ce).field), function (Gt) { switch (Gt) { case "ASCENDING": return "asc"; case "DESCENDING": return "desc"; default: return } }(ot.direction)); var ot })); let R = null; t.limit && (R = function (Ce) { let ot; return ot = "object" == typeof Ce ? Ce.value : Ce, ri(ot) ? null : ot }(t.limit)); let j = null; var Ce; t.startAt && (j = new Fl((Ce = t.startAt).values || [], !!Ce.before)); let te = null; return t.endAt && (te = function (Ce) { return new Fl(Ce.values || [], !Ce.before) }(t.endAt)), Nf(e, c, _, f, R, "F", j, te) } function jc(r) { return void 0 !== r.unaryFilter ? function (e) { switch (e.unaryFilter.op) { case "IS_NAN": const t = dc(e.unaryFilter.field); return wr.create(t, "==", { doubleValue: NaN }); case "IS_NULL": const s = dc(e.unaryFilter.field); return wr.create(s, "==", { nullValue: "NULL_VALUE" }); case "IS_NOT_NAN": const c = dc(e.unaryFilter.field); return wr.create(c, "!=", { doubleValue: NaN }); case "IS_NOT_NULL": const f = dc(e.unaryFilter.field); return wr.create(f, "!=", { nullValue: "NULL_VALUE" }); default: return Cn() } }(r) : void 0 !== r.fieldFilter ? wr.create(dc((e = r).fieldFilter.field), function (t) { switch (t) { case "EQUAL": return "=="; case "NOT_EQUAL": return "!="; case "GREATER_THAN": return ">"; case "GREATER_THAN_OR_EQUAL": return ">="; case "LESS_THAN": return "<"; case "LESS_THAN_OR_EQUAL": return "<="; case "ARRAY_CONTAINS": return "array-contains"; case "IN": return "in"; case "NOT_IN": return "not-in"; case "ARRAY_CONTAINS_ANY": return "array-contains-any"; default: return Cn() } }(e.fieldFilter.op), e.fieldFilter.value) : void 0 !== r.compositeFilter ? function (e) { return Yr.create(e.compositeFilter.filters.map(t => jc(t)), function (t) { switch (t) { case "AND": return "and"; case "OR": return "or"; default: return Cn() } }(e.compositeFilter.op)) }(r) : Cn(); var e } function uv(r) { return tg[r] } function hv(r) { return ng[r] } function my(r) { return lv[r] } function cc(r) { return { fieldPath: r.canonicalString() } } function dc(r) { return Hr.fromServerFormat(r.fieldPath) } function og(r) { return r instanceof wr ? function (e) { if ("==" === e.op) { if (Ui(e.value)) return { unaryFilter: { field: cc(e.field), op: "IS_NAN" } }; if (mi(e.value)) return { unaryFilter: { field: cc(e.field), op: "IS_NULL" } } } else if ("!=" === e.op) { if (Ui(e.value)) return { unaryFilter: { field: cc(e.field), op: "IS_NOT_NAN" } }; if (mi(e.value)) return { unaryFilter: { field: cc(e.field), op: "IS_NOT_NULL" } } } return { fieldFilter: { field: cc(e.field), op: hv(e.op), value: e.value } } }(r) : r instanceof Yr ? function (e) { const t = e.getFilters().map(s => og(s)); return 1 === t.length ? t[0] : { compositeFilter: { op: my(e.op), filters: t } } }(r) : Cn() } function xu(r) { const e = []; return r.fields.forEach(t => e.push(t.canonicalString())), { fieldPaths: e } } function Eu(r) { return r.length >= 4 && "projects" === r.get(0) && "databases" === r.get(2) } class vl { constructor(e, t, s, c, f = Jn.min(), _ = Jn.min(), R = Lo.EMPTY_BYTE_STRING, j = null) { this.target = e, this.targetId = t, this.purpose = s, this.sequenceNumber = c, this.snapshotVersion = f, this.lastLimboFreeSnapshotVersion = _, this.resumeToken = R, this.expectedCount = j } withSequenceNumber(e) { return new vl(this.target, this.targetId, this.purpose, e, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, this.expectedCount) } withResumeToken(e, t) { return new vl(this.target, this.targetId, this.purpose, this.sequenceNumber, t, this.lastLimboFreeSnapshotVersion, e, null) } withExpectedCount(e) { return new vl(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, this.lastLimboFreeSnapshotVersion, this.resumeToken, e) } withLastLimboFreeSnapshotVersion(e) { return new vl(this.target, this.targetId, this.purpose, this.sequenceNumber, this.snapshotVersion, e, this.resumeToken, this.expectedCount) } } class em { constructor(e) { this.fe = e } } function tm(r, e) { const t = e.key, s = { prefixPath: t.getCollectionPath().popLast().toArray(), collectionGroup: t.collectionGroup, documentId: t.path.lastSegment(), readTime: Tl(e.readTime), hasCommittedMutations: e.hasCommittedMutations }; if (e.isFoundDocument()) s.document = { name: ac(c = r.fe, (f = e).key), fields: f.data.value.mapValue.fields, updateTime: Ed(c, f.version.toTimestamp()), createTime: Ed(c, f.createTime.toTimestamp()) }; else if (e.isNoDocument()) s.noDocument = { path: t.path.toArray(), readTime: $c(e.version) }; else { if (!e.isUnknownDocument()) return Cn(); s.unknownDocument = { path: t.path.toArray(), version: $c(e.version) } } var c, f; return s } function Tl(r) { const e = r.toTimestamp(); return [e.seconds, e.nanoseconds] } function $c(r) { const e = r.toTimestamp(); return { seconds: e.seconds, nanoseconds: e.nanoseconds } } function Gc(r) { const e = new Ri(r.seconds, r.nanoseconds); return Jn.fromTimestamp(e) } function Wc(r, e) { const t = (e.baseMutations || []).map(f => Qf(r.fe, f)); for (let f = 0; f < e.mutations.length - 1; ++f)f + 1 < e.mutations.length && void 0 !== e.mutations[f + 1].transform && (e.mutations[f].updateTransforms = e.mutations[f + 1].transform.fieldTransforms, e.mutations.splice(f + 1, 1), ++f); const s = e.mutations.map(f => Qf(r.fe, f)), c = Ri.fromMillis(e.localWriteTimeMs); return new Vc(e.batchId, c, t, s) } function Cu(r) { const e = Gc(r.readTime), t = void 0 !== r.lastLimboFreeSnapshotVersion ? Gc(r.lastLimboFreeSnapshotVersion) : Jn.min(); let s; var c; return void 0 !== r.query.documents ? (ai(1 === (c = r.query).documents.length), s = k(Vl(_h(c.documents[0])))) : s = k(wu(r.query)), new vl(s, r.targetId, "TargetPurposeListen", r.lastListenSequenceNumber, e, t, Lo.fromBase64String(r.resumeToken)) } function ag(r, e) { const t = $c(e.snapshotVersion), s = $c(e.lastLimboFreeSnapshotVersion); let c; c = pl(e.target) ? Xf(r.fe, e.target) : bh(r.fe, e.target); const f = e.resumeToken.toBase64(); return { targetId: e.targetId, canonicalId: nl(e.target), readTime: t, resumeToken: f, lastListenSequenceNumber: e.sequenceNumber, lastLimboFreeSnapshotVersion: s, query: c } } function bl(r) { const e = wu({ parent: r.parent, structuredQuery: r.structuredQuery }); return "LAST" === r.limitType ? De(e, e.limit, "L") : e } function uc(r, e) { return new jf(e.largestBatchId, Qf(r.fe, e.overlayMutation)) } function lg(r, e) { const t = e.path.lastSegment(); return [r, ei(e.path.popLast()), t] } function cg(r, e, t, s) { return { indexId: r, uid: e.uid || "", sequenceNumber: t, readTime: $c(s.readTime), documentKey: ei(s.documentKey.path), largestBatchId: s.largestBatchId } } class fv { getBundleMetadata(e, t) { return dg(e).get(t).next(s => { if (s) return { id: (c = s).bundleId, createTime: Gc(c.createTime), version: c.version }; var c }) } saveBundleMetadata(e, t) { return dg(e).put({ bundleId: (s = t).id, createTime: $c(ss(s.createTime)), version: s.version }); var s } getNamedQuery(e, t) { return ug(e).get(t).next(s => { if (s) return { name: (c = s).name, query: bl(c.bundledQuery), readTime: Gc(c.readTime) }; var c }) } saveNamedQuery(e, t) { return ug(e).put({ name: (s = t).name, readTime: $c(ss(s.readTime)), bundledQuery: s.bundledQuery }); var s } } function dg(r) { return or(r, "bundles") } function ug(r) { return or(r, "namedQueries") } class yh { constructor(e, t) { this.serializer = e, this.userId = t } static de(e, t) { return new yh(e, t.uid || "") } getOverlay(e, t) { return Id(e).get(lg(this.userId, t)).next(s => s ? uc(this.serializer, s) : null) } getOverlays(e, t) { const s = Js(); return I.forEach(t, c => this.getOverlay(e, c).next(f => { null !== f && s.set(c, f) })).next(() => s) } saveOverlays(e, t, s) { const c = []; return s.forEach((f, _) => { const R = new jf(t, _); c.push(this.we(e, R)) }), I.waitFor(c) } removeOverlaysForBatchId(e, t, s) { const c = new Set; t.forEach(_ => c.add(ei(_.getCollectionPath()))); const f = []; return c.forEach(_ => { const R = IDBKeyRange.bound([this.userId, _, s], [this.userId, _, s + 1], !1, !0); f.push(Id(e).J("collectionPathOverlayIndex", R)) }), I.waitFor(f) } getOverlaysForCollection(e, t, s) { const c = Js(), f = ei(t), _ = IDBKeyRange.bound([this.userId, f, s], [this.userId, f, Number.POSITIVE_INFINITY], !0); return Id(e).j("collectionPathOverlayIndex", _).next(R => { for (const j of R) { const te = uc(this.serializer, j); c.set(te.getKey(), te) } return c }) } getOverlaysForCollectionGroup(e, t, s, c) { const f = Js(); let _; const R = IDBKeyRange.bound([this.userId, t, s], [this.userId, t, Number.POSITIVE_INFINITY], !0); return Id(e).X({ index: "collectionGroupOverlayIndex", range: R }, (j, te, Ce) => { const ot = uc(this.serializer, te); f.size() < c || ot.largestBatchId === _ ? (f.set(ot.getKey(), ot), _ = ot.largestBatchId) : Ce.done() }).next(() => f) } we(e, t) { return Id(e).put(function (s, c, f) { const [_, R, j] = lg(c, f.mutation.key); return { userId: c, collectionPath: R, documentId: j, collectionGroup: f.mutation.key.getCollectionGroup(), largestBatchId: f.largestBatchId, overlayMutation: yu(s.fe, f.mutation) } }(this.serializer, this.userId, t)) } } function Id(r) { return or(r, "documentOverlays") } class Kc { constructor() { } _e(e, t) { this.me(e, t), t.ge() } me(e, t) { if ("nullValue" in e) this.ye(t, 5); else if ("booleanValue" in e) this.ye(t, 10), t.pe(e.booleanValue ? 1 : 0); else if ("integerValue" in e) this.ye(t, 15), t.pe(vo(e.integerValue)); else if ("doubleValue" in e) { const s = vo(e.doubleValue); isNaN(s) ? this.ye(t, 13) : (this.ye(t, 15), hi(s) ? t.pe(0) : t.pe(s)) } else if ("timestampValue" in e) { const s = e.timestampValue; this.ye(t, 20), "string" == typeof s ? t.Ie(s) : (t.Ie(`${s.seconds || ""}`), t.pe(s.nanos || 0)) } else if ("stringValue" in e) this.Te(e.stringValue, t), this.Ee(t); else if ("bytesValue" in e) this.ye(t, 30), t.Ae(Ea(e.bytesValue)), this.Ee(t); else if ("referenceValue" in e) this.ve(e.referenceValue, t); else if ("geoPointValue" in e) { const s = e.geoPointValue; this.ye(t, 45), t.pe(s.latitude || 0), t.pe(s.longitude || 0) } else "mapValue" in e ? Bo(e) ? this.ye(t, Number.MAX_SAFE_INTEGER) : (this.Re(e.mapValue, t), this.Ee(t)) : "arrayValue" in e ? (this.Pe(e.arrayValue, t), this.Ee(t)) : Cn() } Te(e, t) { this.ye(t, 25), this.be(e, t) } be(e, t) { t.Ie(e) } Re(e, t) { const s = e.fields || {}; this.ye(t, 55); for (const c of Object.keys(s)) this.Te(c, t), this.me(s[c], t) } Pe(e, t) { const s = e.values || []; this.ye(t, 50); for (const c of s) this.me(c, t) } ve(e, t) { this.ye(t, 37), Bn.fromName(e).path.forEach(s => { this.ye(t, 60), this.be(s, t) }) } ye(e, t) { e.pe(t) } Ee(e) { e.pe(2) } } function mv(r) { if (0 === r) return 8; let e = 0; return !(r >> 4) && (e += 4, r <<= 4), !(r >> 6) && (e += 2, r <<= 2), !(r >> 7) && (e += 1), e } function hg(r) { const e = 64 - function (t) { let s = 0; for (let c = 0; c < 8; ++c) { const f = mv(255 & t[c]); if (s += f, 8 !== f) break } return s }(r); return Math.ceil(e / 8) } Kc.Ve = new Kc; class pv { constructor() { this.buffer = new Uint8Array(1024), this.position = 0 } Se(e) { const t = e[Symbol.iterator](); let s = t.next(); for (; !s.done;)this.De(s.value), s = t.next(); this.Ce() } xe(e) { const t = e[Symbol.iterator](); let s = t.next(); for (; !s.done;)this.Ne(s.value), s = t.next(); this.ke() } Me(e) { for (const t of e) { const s = t.charCodeAt(0); if (s < 128) this.De(s); else if (s < 2048) this.De(960 | s >>> 6), this.De(128 | 63 & s); else if (t < "\ud800" || "\udbff" < t) this.De(480 | s >>> 12), this.De(128 | 63 & s >>> 6), this.De(128 | 63 & s); else { const c = t.codePointAt(0); this.De(240 | c >>> 18), this.De(128 | 63 & c >>> 12), this.De(128 | 63 & c >>> 6), this.De(128 | 63 & c) } } this.Ce() } $e(e) { for (const t of e) { const s = t.charCodeAt(0); if (s < 128) this.Ne(s); else if (s < 2048) this.Ne(960 | s >>> 6), this.Ne(128 | 63 & s); else if (t < "\ud800" || "\udbff" < t) this.Ne(480 | s >>> 12), this.Ne(128 | 63 & s >>> 6), this.Ne(128 | 63 & s); else { const c = t.codePointAt(0); this.Ne(240 | c >>> 18), this.Ne(128 | 63 & c >>> 12), this.Ne(128 | 63 & c >>> 6), this.Ne(128 | 63 & c) } } this.ke() } Oe(e) { const t = this.Fe(e), s = hg(t); this.Be(1 + s), this.buffer[this.position++] = 255 & s; for (let c = t.length - s; c < t.length; ++c)this.buffer[this.position++] = 255 & t[c] } Le(e) { const t = this.Fe(e), s = hg(t); this.Be(1 + s), this.buffer[this.position++] = ~(255 & s); for (let c = t.length - s; c < t.length; ++c)this.buffer[this.position++] = ~(255 & t[c]) } qe() { this.Ue(255), this.Ue(255) } Ke() { this.Ge(255), this.Ge(255) } reset() { this.position = 0 } seed(e) { this.Be(e.length), this.buffer.set(e, this.position), this.position += e.length } Qe() { return this.buffer.slice(0, this.position) } Fe(e) { const t = function (c) { const f = new DataView(new ArrayBuffer(8)); return f.setFloat64(0, c, !1), new Uint8Array(f.buffer) }(e), s = 0 != (128 & t[0]); t[0] ^= s ? 255 : 128; for (let c = 1; c < t.length; ++c)t[c] ^= s ? 255 : 0; return t } De(e) { const t = 255 & e; 0 === t ? (this.Ue(0), this.Ue(255)) : 255 === t ? (this.Ue(255), this.Ue(0)) : this.Ue(t) } Ne(e) { const t = 255 & e; 0 === t ? (this.Ge(0), this.Ge(255)) : 255 === t ? (this.Ge(255), this.Ge(0)) : this.Ge(e) } Ce() { this.Ue(0), this.Ue(1) } ke() { this.Ge(0), this.Ge(1) } Ue(e) { this.Be(1), this.buffer[this.position++] = e } Ge(e) { this.Be(1), this.buffer[this.position++] = ~e } Be(e) { const t = e + this.position; if (t <= this.buffer.length) return; let s = 2 * this.buffer.length; s < t && (s = t); const c = new Uint8Array(s); c.set(this.buffer), this.buffer = c } } class wh { constructor(e) { this.je = e } Ae(e) { this.je.Se(e) } Ie(e) { this.je.Me(e) } pe(e) { this.je.Oe(e) } ge() { this.je.qe() } } class zl { constructor(e) { this.je = e } Ae(e) { this.je.xe(e) } Ie(e) { this.je.$e(e) } pe(e) { this.je.Le(e) } ge() { this.je.Ke() } } class jl { constructor() { this.je = new pv, this.ze = new wh(this.je), this.We = new zl(this.je) } seed(e) { this.je.seed(e) } He(e) { return 0 === e ? this.ze : this.We } Qe() { return this.je.Qe() } reset() { this.je.reset() } } class hc { constructor(e, t, s, c) { this.indexId = e, this.documentKey = t, this.arrayValue = s, this.directionalValue = c } Je() { const e = this.directionalValue.length, t = 0 === e || 255 === this.directionalValue[e - 1] ? e + 1 : e, s = new Uint8Array(t); return s.set(this.directionalValue, 0), t !== e ? s.set([0], this.directionalValue.length) : ++s[s.length - 1], new hc(this.indexId, this.documentKey, this.arrayValue, s) } } function $l(r, e) { let t = r.indexId - e.indexId; return 0 !== t ? t : (t = nm(r.arrayValue, e.arrayValue), 0 !== t ? t : (t = nm(r.directionalValue, e.directionalValue), 0 !== t ? t : Bn.comparator(r.documentKey, e.documentKey))) } function nm(r, e) { for (let t = 0; t < r.length && t < e.length; ++t) { const s = r[t] - e[t]; if (0 !== s) return s } return r.length - e.length } class py { constructor(e) { this.collectionId = null != e.collectionGroup ? e.collectionGroup : e.path.lastSegment(), this.Ye = e.orderBy, this.Xe = []; for (const t of e.filters) { const s = t; s.isInequality() ? this.Ze = s : this.Xe.push(s) } } tn(e) { ai(e.collectionGroup === this.collectionId); const t = Zs(e); if (void 0 !== t && !this.en(t)) return !1; const s = Ys(e); let c = new Set, f = 0, _ = 0; for (; f < s.length && this.en(s[f]); ++f)c = c.add(s[f].fieldPath.canonicalString()); if (f === s.length) return !0; if (void 0 !== this.Ze) { if (!c.has(this.Ze.field.canonicalString())) { const R = s[f]; if (!this.nn(this.Ze, R) || !this.sn(this.Ye[_++], R)) return !1 } ++f } for (; f < s.length; ++f)if (_ >= this.Ye.length || !this.sn(this.Ye[_++], s[f])) return !1; return !0 } en(e) { for (const t of this.Xe) if (this.nn(t, e)) return !0; return !1 } nn(e, t) { return !(void 0 === e || !e.field.isEqual(t.fieldPath)) && 2 === t.kind == ("array-contains" === e.op || "array-contains-any" === e.op) } sn(e, t) { return !!e.field.isEqual(t.fieldPath) && (0 === t.kind && "asc" === e.dir || 1 === t.kind && "desc" === e.dir) } } function gv(r) { var e, t; if (ai(r instanceof wr || r instanceof Yr), r instanceof wr) { if (r instanceof Pc) { const c = (null === (t = null === (e = r.value.arrayValue) || void 0 === e ? void 0 : e.values) || void 0 === t ? void 0 : t.map(f => wr.create(r.field, "==", f))) || []; return Yr.create(c, "or") } return r } const s = r.filters.map(c => gv(c)); return Yr.create(s, r.op) } function gy(r) { if (0 === r.getFilters().length) return []; const e = fg(gv(r)); return ai(_v(e)), Iu(e) || Du(e) ? [e] : e.getFilters() } function Iu(r) { return r instanceof wr } function Du(r) { return r instanceof Yr && nu(r) } function _v(r) { return Iu(r) || Du(r) || function (e) { if (e instanceof Yr && tu(e)) { for (const t of e.getFilters()) if (!Iu(t) && !Du(t)) return !1; return !0 } return !1 }(r) } function fg(r) { if (ai(r instanceof wr || r instanceof Yr), r instanceof wr) return r; if (1 === r.filters.length) return fg(r.filters[0]); const e = r.filters.map(s => fg(s)); let t = Yr.create(e, r.op); return t = Eh(t), _v(t) ? t : (ai(t instanceof Yr), ai(Bl(t)), ai(t.filters.length > 1), t.filters.reduce((s, c) => xh(s, c))) } function xh(r, e) { let t; return ai(r instanceof wr || r instanceof Yr), ai(e instanceof wr || e instanceof Yr), t = r instanceof wr ? e instanceof wr ? Yr.create([r, e], "and") : mg(r, e) : e instanceof wr ? mg(e, r) : function (s, c) { if (ai(s.filters.length > 0 && c.filters.length > 0), Bl(s) && Bl(c)) return ec(s, c.getFilters()); const f = tu(s) ? s : c, _ = tu(s) ? c : s, R = f.filters.map(j => xh(j, _)); return Yr.create(R, "or") }(r, e), Eh(t) } function mg(r, e) { if (Bl(e)) return ec(e, r.getFilters()); { const t = e.filters.map(s => xh(r, s)); return Yr.create(t, "or") } } function Eh(r) { if (ai(r instanceof wr || r instanceof Yr), r instanceof wr) return r; const e = r.getFilters(); if (1 === e.length) return Eh(e[0]); if (dh(r)) return r; const t = e.map(c => Eh(c)), s = []; return t.forEach(c => { c instanceof wr ? s.push(c) : c instanceof Yr && (c.op === r.op ? s.push(...c.filters) : s.push(c)) }), 1 === s.length ? s[0] : Yr.create(s, r.op) } class vv { constructor() { this.rn = new im } addToCollectionParentIndex(e, t) { return this.rn.add(t), I.resolve() } getCollectionParents(e, t) { return I.resolve(this.rn.getEntries(t)) } addFieldIndex(e, t) { return I.resolve() } deleteFieldIndex(e, t) { return I.resolve() } getDocumentsMatchingTarget(e, t) { return I.resolve(null) } getIndexType(e, t) { return I.resolve(0) } getFieldIndexes(e, t) { return I.resolve([]) } getNextCollectionGroupToUpdate(e) { return I.resolve(null) } getMinOffset(e, t) { return I.resolve(ns.min()) } getMinOffsetFromCollectionGroup(e, t) { return I.resolve(ns.min()) } updateCollectionGroup(e, t, s) { return I.resolve() } updateIndexEntries(e, t) { return I.resolve() } } class im { constructor() { this.index = {} } add(e) { const t = e.lastSegment(), s = e.popLast(), c = this.index[t] || new Zr(Pi.comparator), f = !c.has(s); return this.index[t] = c.add(s), f } has(e) { const t = e.lastSegment(), s = e.popLast(), c = this.index[t]; return c && c.has(s) } getEntries(e) { return (this.index[e] || new Zr(Pi.comparator)).toArray() } } const Tu = new Uint8Array(0); class Ch { constructor(e, t) { this.user = e, this.databaseId = t, this.on = new im, this.un = new Xs(s => nl(s), (s, c) => $a(s, c)), this.uid = e.uid || "" } addToCollectionParentIndex(e, t) { if (!this.on.has(t)) { const s = t.lastSegment(), c = t.popLast(); e.addOnCommittedListener(() => { this.on.add(t) }); const f = { collectionId: s, parent: ei(c) }; return rm(e).put(f) } return I.resolve() } getCollectionParents(e, t) { const s = [], c = IDBKeyRange.bound([t, ""], [ll(t), ""], !1, !0); return rm(e).j(c).next(f => { for (const _ of f) { if (_.collectionId !== t) break; s.push(Ar(_.parent)) } return s }) } addFieldIndex(e, t) { const s = Ih(e), c = { indexId: (_ = t).indexId, collectionGroup: _.collectionGroup, fields: _.fields.map(R => [R.fieldPath.canonicalString(), R.kind]) }; var _; delete c.indexId; const f = s.add(c); if (t.indexState) { const _ = Wo(e); return f.next(R => { _.put(cg(R, this.user, t.indexState.sequenceNumber, t.indexState.offset)) }) } return f.next() } deleteFieldIndex(e, t) { const s = Ih(e), c = Wo(e), f = Zc(e); return s.delete(t.indexId).next(() => c.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0))).next(() => f.delete(IDBKeyRange.bound([t.indexId], [t.indexId + 1], !1, !0))) } getDocumentsMatchingTarget(e, t) { const s = Zc(e); let c = !0; const f = new Map; return I.forEach(this.cn(t), _ => this.an(e, _).next(R => { c && (c = !!R), f.set(_, R) })).next(() => { if (c) { let _ = Oi(); const R = []; return I.forEach(f, (j, te) => { var Ce; pn("IndexedDbIndexManager", `Using index ${Ce = j, `id=${Ce.indexId}|cg=${Ce.collectionGroup}|f=${Ce.fields.map(pr => `${pr.fieldPath}:${pr.kind}`).join(",")}`} to execute ${nl(t)}`); const ot = function (pr, Ls) { const ls = Zs(Ls); if (void 0 === ls) return null; for (const Co of md(pr, ls.fieldPath)) switch (Co.op) { case "array-contains-any": return Co.value.arrayValue.values || []; case "array-contains": return [Co.value] }return null }(te, j), Gt = function (pr, Ls) { const ls = new Map; for (const Co of Ys(Ls)) for (const ua of md(pr, Co.fieldPath)) switch (ua.op) { case "==": case "in": ls.set(Co.fieldPath.canonicalString(), ua.value); break; case "not-in": case "!=": return ls.set(Co.fieldPath.canonicalString(), ua.value), Array.from(ls.values()) }return null }(te, j), an = function (pr, Ls) { const ls = []; let Co = !0; for (const ua of Ys(Ls)) { const Rc = 0 === ua.kind ? Pf(pr, ua.fieldPath, pr.startAt) : su(pr, ua.fieldPath, pr.startAt); ls.push(Rc.value), Co && (Co = Rc.inclusive) } return new Fl(ls, Co) }(te, j), kn = function (pr, Ls) { const ls = []; let Co = !0; for (const ua of Ys(Ls)) { const Rc = 0 === ua.kind ? su(pr, ua.fieldPath, pr.endAt) : Pf(pr, ua.fieldPath, pr.endAt); ls.push(Rc.value), Co && (Co = Rc.inclusive) } return new Fl(ls, Co) }(te, j), Yn = this.hn(j, te, an), ti = this.hn(j, te, kn), Qi = this.ln(j, te, Gt), Rr = this.fn(j.indexId, ot, Yn, an.inclusive, ti, kn.inclusive, Qi); return I.forEach(Rr, pr => s.H(pr, t.limit).next(Ls => { Ls.forEach(ls => { const Co = Bn.fromSegments(ls.documentKey); _.has(Co) || (_ = _.add(Co), R.push(Co)) }) })) }).next(() => R) } return I.resolve(null) }) } cn(e) { let t = this.un.get(e); return t || (t = 0 === e.filters.length ? [e] : gy(Yr.create(e.filters, "and")).map(s => fd(e.path, e.collectionGroup, e.orderBy, s.getFilters(), e.limit, e.startAt, e.endAt)), this.un.set(e, t), t) } fn(e, t, s, c, f, _, R) { const j = (null != t ? t.length : 1) * Math.max(s.length, f.length), te = j / (null != t ? t.length : 1), Ce = []; for (let ot = 0; ot < j; ++ot) { const Gt = t ? this.dn(t[ot / te]) : Tu, an = this.wn(e, Gt, s[ot % te], c), kn = this._n(e, Gt, f[ot % te], _), Yn = R.map(ti => this.wn(e, Gt, ti, !0)); Ce.push(...this.createRange(an, kn, Yn)) } return Ce } wn(e, t, s, c) { const f = new hc(e, Bn.empty(), t, s); return c ? f : f.Je() } _n(e, t, s, c) { const f = new hc(e, Bn.empty(), t, s); return c ? f.Je() : f } an(e, t) { const s = new py(t), c = null != t.collectionGroup ? t.collectionGroup : t.path.lastSegment(); return this.getFieldIndexes(e, c).next(f => { let _ = null; for (const R of f) s.tn(R) && (!_ || R.fields.length > _.fields.length) && (_ = R); return _ }) } getIndexType(e, t) { let s = 2; const c = this.cn(t); return I.forEach(c, f => this.an(e, f).next(_ => { _ ? 0 !== s && _.fields.length < function (R) { let j = new Zr(Hr.comparator), te = !1; for (const Ce of R.filters) for (const ot of Ce.getFlattenedFilters()) ot.field.isKeyField() || ("array-contains" === ot.op || "array-contains-any" === ot.op ? te = !0 : j = j.add(ot.field)); for (const Ce of R.orderBy) Ce.field.isKeyField() || (j = j.add(Ce.field)); return j.size + (te ? 1 : 0) }(f) && (s = 1) : s = 0 })).next(() => null !== t.limit && c.length > 1 && 2 === s ? 1 : s) } mn(e, t) { const s = new jl; for (const c of Ys(e)) { const f = t.data.field(c.fieldPath); if (null == f) return null; const _ = s.He(c.kind); Kc.Ve._e(f, _) } return s.Qe() } dn(e) { const t = new jl; return Kc.Ve._e(e, t.He(0)), t.Qe() } gn(e, t) { const s = new jl; return Kc.Ve._e(ln(this.databaseId, t), s.He(function (c) { const f = Ys(c); return 0 === f.length ? 0 : f[f.length - 1].kind }(e))), s.Qe() } ln(e, t, s) { if (null === s) return []; let c = []; c.push(new jl); let f = 0; for (const _ of Ys(e)) { const R = s[f++]; for (const j of c) if (this.yn(t, _.fieldPath) && Vn(R)) c = this.pn(c, _, R); else { const te = j.He(_.kind); Kc.Ve._e(R, te) } } return this.In(c) } hn(e, t, s) { return this.ln(e, t, s.position) } In(e) { const t = []; for (let s = 0; s < e.length; ++s)t[s] = e[s].Qe(); return t } pn(e, t, s) { const c = [...e], f = []; for (const _ of s.arrayValue.values || []) for (const R of c) { const j = new jl; j.seed(R.Qe()), Kc.Ve._e(_, j.He(t.kind)), f.push(j) } return f } yn(e, t) { return !!e.filters.find(s => s instanceof wr && s.field.isEqual(t) && ("in" === s.op || "not-in" === s.op)) } getFieldIndexes(e, t) { const s = Ih(e), c = Wo(e); return (t ? s.j("collectionGroupIndex", IDBKeyRange.bound(t, t)) : s.j()).next(f => { const _ = []; return I.forEach(f, R => c.get([R.indexId, this.uid]).next(j => { _.push(function (te, Ce) { const ot = Ce ? new ka(Ce.sequenceNumber, new ns(Gc(Ce.readTime), new Bn(Ar(Ce.documentKey)), Ce.largestBatchId)) : ka.empty(), Gt = te.fields.map(([an, kn]) => new Ba(Hr.fromServerFormat(an), kn)); return new Vs(te.indexId, te.collectionGroup, Gt, ot) }(R, j)) })).next(() => _) }) } getNextCollectionGroupToUpdate(e) { return this.getFieldIndexes(e).next(t => 0 === t.length ? null : (t.sort((s, c) => { const f = s.indexState.sequenceNumber - c.indexState.sequenceNumber; return 0 !== f ? f : Ei(s.collectionGroup, c.collectionGroup) }), t[0].collectionGroup)) } updateCollectionGroup(e, t, s) { const c = Ih(e), f = Wo(e); return this.Tn(e).next(_ => c.j("collectionGroupIndex", IDBKeyRange.bound(t, t)).next(R => I.forEach(R, j => f.put(cg(j.indexId, this.user, _, s))))) } updateIndexEntries(e, t) { const s = new Map; return I.forEach(t, (c, f) => { const _ = s.get(c.collectionGroup); return (_ ? I.resolve(_) : this.getFieldIndexes(e, c.collectionGroup)).next(R => (s.set(c.collectionGroup, R), I.forEach(R, j => this.En(e, c, j).next(te => { const Ce = this.An(f, j); return te.isEqual(Ce) ? I.resolve() : this.vn(e, f, j, te, Ce) })))) }) } Rn(e, t, s, c) { return Zc(e).put({ indexId: c.indexId, uid: this.uid, arrayValue: c.arrayValue, directionalValue: c.directionalValue, orderedDocumentKey: this.gn(s, t.key), documentKey: t.key.path.toArray() }) } Pn(e, t, s, c) { return Zc(e).delete([c.indexId, this.uid, c.arrayValue, c.directionalValue, this.gn(s, t.key), t.key.path.toArray()]) } En(e, t, s) { const c = Zc(e); let f = new Zr($l); return c.X({ index: "documentKeyIndex", range: IDBKeyRange.only([s.indexId, this.uid, this.gn(s, t)]) }, (_, R) => { f = f.add(new hc(s.indexId, t, R.arrayValue, R.directionalValue)) }).next(() => f) } An(e, t) { let s = new Zr($l); const c = this.mn(t, e); if (null == c) return s; const f = Zs(t); if (null != f) { const _ = e.data.field(f.fieldPath); if (Vn(_)) for (const R of _.arrayValue.values || []) s = s.add(new hc(t.indexId, e.key, this.dn(R), c)) } else s = s.add(new hc(t.indexId, e.key, Tu, c)); return s } vn(e, t, s, c, f) { pn("IndexedDbIndexManager", "Updating index entries for document '%s'", t.key); const _ = []; return function (R, j, te, Ce, ot) { const Gt = R.getIterator(), an = j.getIterator(); let kn = za(Gt), Yn = za(an); for (; kn || Yn;) { let ti = !1, Qi = !1; if (kn && Yn) { const Rr = te(kn, Yn); Rr < 0 ? Qi = !0 : Rr > 0 && (ti = !0) } else null != kn ? Qi = !0 : ti = !0; ti ? (Ce(Yn), Yn = za(an)) : Qi ? (ot(kn), kn = za(Gt)) : (kn = za(Gt), Yn = za(an)) } }(c, f, $l, R => { _.push(this.Rn(e, t, s, R)) }, R => { _.push(this.Pn(e, t, s, R)) }), I.waitFor(_) } Tn(e) { let t = 1; return Wo(e).X({ index: "sequenceNumberIndex", reverse: !0, range: IDBKeyRange.upperBound([this.uid, Number.MAX_SAFE_INTEGER]) }, (s, c, f) => { f.done(), t = c.sequenceNumber + 1 }).next(() => t) } createRange(e, t, s) { s = s.sort((_, R) => $l(_, R)).filter((_, R, j) => !R || 0 !== $l(_, j[R - 1])); const c = []; c.push(e); for (const _ of s) { const R = $l(_, e), j = $l(_, t); if (0 === R) c[0] = e.Je(); else if (R > 0 && j < 0) c.push(_), c.push(_.Je()); else if (j > 0) break } c.push(t); const f = []; for (let _ = 0; _ < c.length; _ += 2) { if (this.bn(c[_], c[_ + 1])) return []; f.push(IDBKeyRange.bound([c[_].indexId, this.uid, c[_].arrayValue, c[_].directionalValue, Tu, []], [c[_ + 1].indexId, this.uid, c[_ + 1].arrayValue, c[_ + 1].directionalValue, Tu, []])) } return f } bn(e, t) { return $l(e, t) > 0 } getMinOffsetFromCollectionGroup(e, t) { return this.getFieldIndexes(e, t).next(pg) } getMinOffset(e, t) { return I.mapArray(this.cn(t), s => this.an(e, s).next(c => c || Cn())).next(pg) } } function rm(r) { return or(r, "collectionParents") } function Zc(r) { return or(r, "indexEntries") } function Ih(r) { return or(r, "indexConfiguration") } function Wo(r) { return or(r, "indexState") } function pg(r) { ai(0 !== r.length); let e = r[0].indexState.offset, t = e.largestBatchId; for (let s = 1; s < r.length; s++) { const c = r[s].indexState.offset; cl(c, e) < 0 && (e = c), t < c.largestBatchId && (t = c.largestBatchId) } return new ns(e.readTime, e.documentKey, t) } const gg = { didRun: !1, sequenceNumbersCollected: 0, targetsRemoved: 0, documentsRemoved: 0 }; class Gs { constructor(e, t, s) { this.cacheSizeCollectionThreshold = e, this.percentileToCollect = t, this.maximumSequenceNumbersToCollect = s } static withCacheSize(e) { return new Gs(e, Gs.DEFAULT_COLLECTION_PERCENTILE, Gs.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT) } } function om(r, e, t) { const s = r.store("mutations"), c = r.store("documentMutations"), f = [], _ = IDBKeyRange.only(t.batchId); let R = 0; const j = s.X({ range: _ }, (Ce, ot, Gt) => (R++, Gt.delete())); f.push(j.next(() => { ai(1 === R) })); const te = []; for (const Ce of t.mutations) { const ot = Ja(e, Ce.key.path, t.batchId); f.push(c.delete(ot)), te.push(Ce.key) } return I.waitFor(f).next(() => te) } function Dh(r) { if (!r) return 0; let e; if (r.document) e = r.document; else if (r.unknownDocument) e = r.unknownDocument; else { if (!r.noDocument) throw Cn(); e = r.noDocument } return JSON.stringify(e).length } Gs.DEFAULT_COLLECTION_PERCENTILE = 10, Gs.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT = 1e3, Gs.DEFAULT = new Gs(41943040, Gs.DEFAULT_COLLECTION_PERCENTILE, Gs.DEFAULT_MAX_SEQUENCE_NUMBERS_TO_COLLECT), Gs.DISABLED = new Gs(-1, 0, 0); class Th { constructor(e, t, s, c) { this.userId = e, this.serializer = t, this.indexManager = s, this.referenceDelegate = c, this.Vn = {} } static de(e, t, s, c) { ai("" !== e.uid); const f = e.isAuthenticated() ? e.uid : ""; return new Th(f, t, s, c) } checkEmpty(e) { let t = !0; const s = IDBKeyRange.bound([this.userId, Number.NEGATIVE_INFINITY], [this.userId, Number.POSITIVE_INFINITY]); return fc(e).X({ index: "userMutationsIndex", range: s }, (c, f, _) => { t = !1, _.done() }).next(() => t) } addMutationBatch(e, t, s, c) { const f = Yc(e), _ = fc(e); return _.add({}).next(R => { ai("number" == typeof R); const j = new Vc(R, t, s, c), te = function (Gt, an, kn) { const Yn = kn.baseMutations.map(Qi => yu(Gt.fe, Qi)), ti = kn.mutations.map(Qi => yu(Gt.fe, Qi)); return { userId: an, batchId: kn.batchId, localWriteTimeMs: kn.localWriteTime.toMillis(), baseMutations: Yn, mutations: ti } }(this.serializer, this.userId, j), Ce = []; let ot = new Zr((Gt, an) => Ei(Gt.canonicalString(), an.canonicalString())); for (const Gt of c) { const an = Ja(this.userId, Gt.key.path, R); ot = ot.add(Gt.key.path.popLast()), Ce.push(_.put(te)), Ce.push(f.put(an, oa)) } return ot.forEach(Gt => { Ce.push(this.indexManager.addToCollectionParentIndex(e, Gt)) }), e.addOnCommittedListener(() => { this.Vn[R] = j.keys() }), I.waitFor(Ce).next(() => j) }) } lookupMutationBatch(e, t) { return fc(e).get(t).next(s => s ? (ai(s.userId === this.userId), Wc(this.serializer, s)) : null) } Sn(e, t) { return this.Vn[t] ? I.resolve(this.Vn[t]) : this.lookupMutationBatch(e, t).next(s => { if (s) { const c = s.keys(); return this.Vn[t] = c, c } return null }) } getNextMutationBatchAfterBatchId(e, t) { const s = t + 1, c = IDBKeyRange.lowerBound([this.userId, s]); let f = null; return fc(e).X({ index: "userMutationsIndex", range: c }, (_, R, j) => { R.userId === this.userId && (ai(R.batchId >= s), f = Wc(this.serializer, R)), j.done() }).next(() => f) } getHighestUnacknowledgedBatchId(e) { const t = IDBKeyRange.upperBound([this.userId, Number.POSITIVE_INFINITY]); let s = -1; return fc(e).X({ index: "userMutationsIndex", range: t, reverse: !0 }, (c, f, _) => { s = f.batchId, _.done() }).next(() => s) } getAllMutationBatches(e) { const t = IDBKeyRange.bound([this.userId, -1], [this.userId, Number.POSITIVE_INFINITY]); return fc(e).j("userMutationsIndex", t).next(s => s.map(c => Wc(this.serializer, c))) } getAllMutationBatchesAffectingDocumentKey(e, t) { const s = Fr(this.userId, t.path), c = IDBKeyRange.lowerBound(s), f = []; return Yc(e).X({ range: c }, (_, R, j) => { const [te, Ce, ot] = _, Gt = Ar(Ce); if (te === this.userId && t.path.isEqual(Gt)) return fc(e).get(ot).next(an => { if (!an) throw Cn(); ai(an.userId === this.userId), f.push(Wc(this.serializer, an)) }); j.done() }).next(() => f) } getAllMutationBatchesAffectingDocumentKeys(e, t) { let s = new Zr(Ei); const c = []; return t.forEach(f => { const _ = Fr(this.userId, f.path), R = IDBKeyRange.lowerBound(_), j = Yc(e).X({ range: R }, (te, Ce, ot) => { const [Gt, an, kn] = te, Yn = Ar(an); Gt === this.userId && f.path.isEqual(Yn) ? s = s.add(kn) : ot.done() }); c.push(j) }), I.waitFor(c).next(() => this.Dn(e, s)) } getAllMutationBatchesAffectingQuery(e, t) { const s = t.path, c = s.length + 1, f = Fr(this.userId, s), _ = IDBKeyRange.lowerBound(f); let R = new Zr(Ei); return Yc(e).X({ range: _ }, (j, te, Ce) => { const [ot, Gt, an] = j, kn = Ar(Gt); ot === this.userId && s.isPrefixOf(kn) ? kn.length === c && (R = R.add(an)) : Ce.done() }).next(() => this.Dn(e, R)) } Dn(e, t) { const s = [], c = []; return t.forEach(f => { c.push(fc(e).get(f).next(_ => { if (null === _) throw Cn(); ai(_.userId === this.userId), s.push(Wc(this.serializer, _)) })) }), I.waitFor(c).next(() => s) } removeMutationBatch(e, t) { return om(e.ht, this.userId, t).next(s => (e.addOnCommittedListener(() => { this.Cn(t.batchId) }), I.forEach(s, c => this.referenceDelegate.markPotentiallyOrphaned(e, c)))) } Cn(e) { delete this.Vn[e] } performConsistencyCheck(e) { return this.checkEmpty(e).next(t => { if (!t) return I.resolve(); const s = IDBKeyRange.lowerBound([this.userId]), c = []; return Yc(e).X({ range: s }, (f, _, R) => { if (f[0] === this.userId) { const j = Ar(f[1]); c.push(j) } else R.done() }).next(() => { ai(0 === c.length) }) }) } containsKey(e, t) { return _g(e, this.userId, t) } xn(e) { return bv(e).get(this.userId).next(t => t || { userId: this.userId, lastAcknowledgedBatchId: -1, lastStreamToken: "" }) } } function _g(r, e, t) { const s = Fr(e, t.path), c = s[1], f = IDBKeyRange.lowerBound(s); let _ = !1; return Yc(r).X({ range: f, Y: !0 }, (R, j, te) => { const [Ce, ot, Gt] = R; Ce === e && ot === c && (_ = !0), te.done() }).next(() => _) } function fc(r) { return or(r, "mutations") } function Yc(r) { return or(r, "documentMutations") } function bv(r) { return or(r, "mutationQueues") } class Dd { constructor(e) { this.Nn = e } next() { return this.Nn += 2, this.Nn } static kn() { return new Dd(0) } static Mn() { return new Dd(-1) } } class Mu { constructor(e, t) { this.referenceDelegate = e, this.serializer = t } allocateTargetId(e) { return this.$n(e).next(t => { const s = new Dd(t.highestTargetId); return t.highestTargetId = s.next(), this.On(e, t).next(() => t.highestTargetId) }) } getLastRemoteSnapshotVersion(e) { return this.$n(e).next(t => Jn.fromTimestamp(new Ri(t.lastRemoteSnapshotVersion.seconds, t.lastRemoteSnapshotVersion.nanoseconds))) } getHighestSequenceNumber(e) { return this.$n(e).next(t => t.highestListenSequenceNumber) } setTargetsMetadata(e, t, s) { return this.$n(e).next(c => (c.highestListenSequenceNumber = t, s && (c.lastRemoteSnapshotVersion = s.toTimestamp()), t > c.highestListenSequenceNumber && (c.highestListenSequenceNumber = t), this.On(e, c))) } addTargetData(e, t) { return this.Fn(e, t).next(() => this.$n(e).next(s => (s.targetCount += 1, this.Bn(t, s), this.On(e, s)))) } updateTargetData(e, t) { return this.Fn(e, t) } removeTargetData(e, t) { return this.removeMatchingKeysForTargetId(e, t.targetId).next(() => Cr(e).delete(t.targetId)).next(() => this.$n(e)).next(s => (ai(s.targetCount > 0), s.targetCount -= 1, this.On(e, s))) } removeTargets(e, t, s) { let c = 0; const f = []; return Cr(e).X((_, R) => { const j = Cu(R); j.sequenceNumber <= t && null === s.get(j.targetId) && (c++, f.push(this.removeTargetData(e, j))) }).next(() => I.waitFor(f)).next(() => c) } forEachTarget(e, t) { return Cr(e).X((s, c) => { const f = Cu(c); t(f) }) } $n(e) { return Td(e).get("targetGlobalKey").next(t => (ai(null !== t), t)) } On(e, t) { return Td(e).put("targetGlobalKey", t) } Fn(e, t) { return Cr(e).put(ag(this.serializer, t)) } Bn(e, t) { let s = !1; return e.targetId > t.highestTargetId && (t.highestTargetId = e.targetId, s = !0), e.sequenceNumber > t.highestListenSequenceNumber && (t.highestListenSequenceNumber = e.sequenceNumber, s = !0), s } getTargetCount(e) { return this.$n(e).next(t => t.targetCount) } getTargetData(e, t) { const s = nl(t), c = IDBKeyRange.bound([s, Number.NEGATIVE_INFINITY], [s, Number.POSITIVE_INFINITY]); let f = null; return Cr(e).X({ range: c, index: "queryTargetsIndex" }, (_, R, j) => { const te = Cu(R); $a(t, te.target) && (f = te, j.done()) }).next(() => f) } addMatchingKeys(e, t, s) { const c = [], f = Gl(e); return t.forEach(_ => { const R = ei(_.path); c.push(f.put({ targetId: s, path: R })), c.push(this.referenceDelegate.addReference(e, s, _)) }), I.waitFor(c) } removeMatchingKeys(e, t, s) { const c = Gl(e); return I.forEach(t, f => { const _ = ei(f.path); return I.waitFor([c.delete([s, _]), this.referenceDelegate.removeReference(e, s, f)]) }) } removeMatchingKeysForTargetId(e, t) { const s = Gl(e), c = IDBKeyRange.bound([t], [t + 1], !1, !0); return s.delete(c) } getMatchingKeysForTargetId(e, t) { const s = IDBKeyRange.bound([t], [t + 1], !1, !0), c = Gl(e); let f = Oi(); return c.X({ range: s, Y: !0 }, (_, R, j) => { const te = Ar(_[1]), Ce = new Bn(te); f = f.add(Ce) }).next(() => f) } containsKey(e, t) { const s = ei(t.path), c = IDBKeyRange.bound([s], [ll(s)], !1, !0); let f = 0; return Gl(e).X({ index: "documentTargetsIndex", Y: !0, range: c }, ([_, R], j, te) => { 0 !== _ && (f++, te.done()) }).next(() => f > 0) } le(e, t) { return Cr(e).get(t).next(s => s ? Cu(s) : null) } } function Cr(r) { return or(r, "targets") } function Td(r) { return or(r, "targetGlobal") } function Gl(r) { return or(r, "targetDocuments") } function sm([r, e], [t, s]) { const c = Ei(r, t); return 0 === c ? Ei(e, s) : c } class vg { constructor(e) { this.Ln = e, this.buffer = new Zr(sm), this.qn = 0 } Un() { return ++this.qn } Kn(e) { const t = [e, this.Un()]; if (this.buffer.size < this.Ln) this.buffer = this.buffer.add(t); else { const s = this.buffer.last(); sm(t, s) < 0 && (this.buffer = this.buffer.delete(s).add(t)) } } get maxValue() { return this.buffer.last()[0] } } class am { constructor(e, t, s) { this.garbageCollector = e, this.asyncQueue = t, this.localStore = s, this.Gn = null } start() { -1 !== this.garbageCollector.params.cacheSizeCollectionThreshold && this.Qn(6e4) } stop() { this.Gn && (this.Gn.cancel(), this.Gn = null) } get started() { return null !== this.Gn } Qn(e) { var t = this; pn("LruGarbageCollector", `Garbage collection scheduled in ${e}ms`), this.Gn = this.asyncQueue.enqueueAfterDelay("lru_garbage_collection", e, (0, a.Z)(function* () { t.Gn = null; try { yield t.localStore.collectGarbage(t.garbageCollector) } catch (s) { M(s) ? pn("LruGarbageCollector", "Ignoring IndexedDB error during garbage collection: ", s) : yield Ps(s) } yield t.Qn(3e5) })) } } class yv { constructor(e, t) { this.jn = e, this.params = t } calculateTargetCount(e, t) { return this.jn.zn(e).next(s => Math.floor(t / 100 * s)) } nthSequenceNumber(e, t) { if (0 === t) return I.resolve(An.ct); const s = new vg(t); return this.jn.forEachTarget(e, c => s.Kn(c.sequenceNumber)).next(() => this.jn.Wn(e, c => s.Kn(c))).next(() => s.maxValue) } removeTargets(e, t, s) { return this.jn.removeTargets(e, t, s) } removeOrphanedDocuments(e, t) { return this.jn.removeOrphanedDocuments(e, t) } collect(e, t) { return -1 === this.params.cacheSizeCollectionThreshold ? (pn("LruGarbageCollector", "Garbage collection skipped; disabled"), I.resolve(gg)) : this.getCacheSize(e).next(s => s < this.params.cacheSizeCollectionThreshold ? (pn("LruGarbageCollector", `Garbage collection skipped; Cache size ${s} is lower than threshold ${this.params.cacheSizeCollectionThreshold}`), gg) : this.Hn(e, t)) } getCacheSize(e) { return this.jn.getCacheSize(e) } Hn(e, t) { let s, c, f, _, R, j, te; const Ce = Date.now(); return this.calculateTargetCount(e, this.params.percentileToCollect).next(ot => (ot > this.params.maximumSequenceNumbersToCollect ? (pn("LruGarbageCollector", `Capping sequence numbers to collect down to the maximum of ${this.params.maximumSequenceNumbersToCollect} from ${ot}`), c = this.params.maximumSequenceNumbersToCollect) : c = ot, _ = Date.now(), this.nthSequenceNumber(e, c))).next(ot => (s = ot, R = Date.now(), this.removeTargets(e, s, t))).next(ot => (f = ot, j = Date.now(), this.removeOrphanedDocuments(e, s))).next(ot => (te = Date.now(), lr() <= Y.in.DEBUG && pn("LruGarbageCollector", `LRU Garbage Collection\n\tCounted targets in ${_ - Ce}ms\n\tDetermined least recently used ${c} in ` + (R - _) + `ms\n\tRemoved ${f} targets in ` + (j - R) + `ms\n\tRemoved ${ot} documents in ` + (te - j) + `ms\nTotal Duration: ${te - Ce}ms`), I.resolve({ didRun: !0, sequenceNumbersCollected: c, targetsRemoved: f, documentsRemoved: ot }))) } } class bg { constructor(e, t) { this.db = e, this.garbageCollector = function lm(r, e) { return new yv(r, e) }(this, t) } zn(e) { const t = this.Jn(e); return this.db.getTargetCache().getTargetCount(e).next(s => t.next(c => s + c)) } Jn(e) { let t = 0; return this.Wn(e, s => { t++ }).next(() => t) } forEachTarget(e, t) { return this.db.getTargetCache().forEachTarget(e, t) } Wn(e, t) { return this.Yn(e, (s, c) => t(c)) } addReference(e, t, s) { return Md(e, s) } removeReference(e, t, s) { return Md(e, s) } removeTargets(e, t, s) { return this.db.getTargetCache().removeTargets(e, t, s) } markPotentiallyOrphaned(e, t) { return Md(e, t) } Xn(e, t) { return function (s, c) { let f = !1; return bv(s).Z(_ => _g(s, _, c).next(R => (R && (f = !0), I.resolve(!R)))).next(() => f) }(e, t) } removeOrphanedDocuments(e, t) { const s = this.db.getRemoteDocumentCache().newChangeBuffer(), c = []; let f = 0; return this.Yn(e, (_, R) => { if (R <= t) { const j = this.Xn(e, _).next(te => { if (!te) return f++, s.getEntry(e, _).next(() => (s.removeEntry(_, Jn.min()), Gl(e).delete([0, ei(_.path)]))) }); c.push(j) } }).next(() => I.waitFor(c)).next(() => s.apply(e)).next(() => f) } removeTarget(e, t) { const s = t.withSequenceNumber(e.currentSequenceNumber); return this.db.getTargetCache().updateTargetData(e, s) } updateLimboDocument(e, t) { return Md(e, t) } Yn(e, t) { const s = Gl(e); let c, f = An.ct; return s.X({ index: "documentTargetsIndex" }, ([_, R], { path: j, sequenceNumber: te }) => { 0 === _ ? (f !== An.ct && t(new Bn(Ar(c)), f), f = te, c = j) : f = An.ct }).next(() => { f !== An.ct && t(new Bn(Ar(c)), f) }) } getCacheSize(e) { return this.db.getRemoteDocumentCache().getSize(e) } } function Md(r, e) { return Gl(r).put((s = r.currentSequenceNumber, { targetId: 0, path: ei(e.path), sequenceNumber: s })); var s } class wv { constructor() { this.changes = new Xs(e => e.toString(), (e, t) => e.isEqual(t)), this.changesApplied = !1 } addEntry(e) { this.assertNotApplied(), this.changes.set(e.key, e) } removeEntry(e, t) { this.assertNotApplied(), this.changes.set(e, So.newInvalidDocument(e).setReadTime(t)) } getEntry(e, t) { this.assertNotApplied(); const s = this.changes.get(t); return void 0 !== s ? I.resolve(s) : this.getFromCache(e, t) } getEntries(e, t) { return this.getAllFromCache(e, t) } apply(e) { return this.assertNotApplied(), this.changesApplied = !0, this.applyChanges(e) } assertNotApplied() { } } class cm { constructor(e) { this.serializer = e } setIndexManager(e) { this.indexManager = e } addEntry(e, t, s) { return mc(e).put(s) } removeEntry(e, t, s) { return mc(e).delete(function (c, f) { const _ = c.path.toArray(); return [_.slice(0, _.length - 2), _[_.length - 2], Tl(f), _[_.length - 1]] }(t, s)) } updateMetadata(e, t) { return this.getMetadata(e).next(s => (s.byteSize += t, this.Zn(e, s))) } getEntry(e, t) { let s = So.newInvalidDocument(t); return mc(e).X({ index: "documentKeyIndex", range: IDBKeyRange.only(yl(t)) }, (c, f) => { s = this.ts(t, f) }).next(() => s) } es(e, t) { let s = { size: 0, document: So.newInvalidDocument(t) }; return mc(e).X({ index: "documentKeyIndex", range: IDBKeyRange.only(yl(t)) }, (c, f) => { s = { document: this.ts(t, f), size: Dh(f) } }).next(() => s) } getEntries(e, t) { let s = ca(); return this.ns(e, t, (c, f) => { const _ = this.ts(c, f); s = s.insert(c, _) }).next(() => s) } ss(e, t) { let s = ca(), c = new ur(Bn.comparator); return this.ns(e, t, (f, _) => { const R = this.ts(f, _); s = s.insert(f, R), c = c.insert(f, Dh(_)) }).next(() => ({ documents: s, rs: c })) } ns(e, t, s) { if (t.isEmpty()) return I.resolve(); let c = new Zr(Mh); t.forEach(j => c = c.add(j)); const f = IDBKeyRange.bound(yl(c.first()), yl(c.last())), _ = c.getIterator(); let R = _.getNext(); return mc(e).X({ index: "documentKeyIndex", range: f }, (j, te, Ce) => { const ot = Bn.fromSegments([...te.prefixPath, te.collectionGroup, te.documentId]); for (; R && Mh(R, ot) < 0;)s(R, null), R = _.getNext(); R && R.isEqual(ot) && (s(R, te), R = _.hasNext() ? _.getNext() : null), R ? Ce.G(yl(R)) : Ce.done() }).next(() => { for (; R;)s(R, null), R = _.hasNext() ? _.getNext() : null }) } getDocumentsMatchingQuery(e, t, s, c) { const f = t.path, _ = [f.popLast().toArray(), f.lastSegment(), Tl(s.readTime), s.documentKey.path.isEmpty() ? "" : s.documentKey.path.lastSegment()], R = [f.popLast().toArray(), f.lastSegment(), [Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER], ""]; return mc(e).j(IDBKeyRange.bound(_, R, !0)).next(j => { let te = ca(); for (const Ce of j) { const ot = this.ts(Bn.fromSegments(Ce.prefixPath.concat(Ce.collectionGroup, Ce.documentId)), Ce); ot.isFoundDocument() && (zn(t, ot) || c.has(ot.key)) && (te = te.insert(ot.key, ot)) } return te }) } getAllFromCollectionGroup(e, t, s, c) { let f = ca(); const _ = wg(t, s), R = wg(t, ns.max()); return mc(e).X({ index: "collectionGroupIndex", range: IDBKeyRange.bound(_, R, !0) }, (j, te, Ce) => { const ot = this.ts(Bn.fromSegments(te.prefixPath.concat(te.collectionGroup, te.documentId)), te); f = f.insert(ot.key, ot), f.size === c && Ce.done() }).next(() => f) } newChangeBuffer(e) { return new dm(this, !!e && e.trackRemovals) } getSize(e) { return this.getMetadata(e).next(t => t.byteSize) } getMetadata(e) { return um(e).get("remoteDocumentGlobalKey").next(t => (ai(!!t), t)) } Zn(e, t) { return um(e).put("remoteDocumentGlobalKey", t) } ts(e, t) { if (t) { const s = function sg(r, e) { let t; if (e.document) t = Cd(r.fe, e.document, !!e.hasCommittedMutations); else if (e.noDocument) { const s = Bn.fromSegments(e.noDocument.path), c = Gc(e.noDocument.readTime); t = So.newNoDocument(s, c), e.hasCommittedMutations && t.setHasCommittedMutations() } else { if (!e.unknownDocument) return Cn(); { const s = Bn.fromSegments(e.unknownDocument.path), c = Gc(e.unknownDocument.version); t = So.newUnknownDocument(s, c) } } return e.readTime && t.setReadTime(function (s) { const c = new Ri(s[0], s[1]); return Jn.fromTimestamp(c) }(e.readTime)), t }(this.serializer, t); if (!s.isNoDocument() || !s.version.isEqual(Jn.min())) return s } return So.newInvalidDocument(e) } } function yg(r) { return new cm(r) } class dm extends wv { constructor(e, t) { super(), this.os = e, this.trackRemovals = t, this.us = new Xs(s => s.toString(), (s, c) => s.isEqual(c)) } applyChanges(e) { const t = []; let s = 0, c = new Zr((f, _) => Ei(f.canonicalString(), _.canonicalString())); return this.changes.forEach((f, _) => { const R = this.us.get(f); if (t.push(this.os.removeEntry(e, f, R.readTime)), _.isValidDocument()) { const j = tm(this.os.serializer, _); c = c.add(f.path.popLast()); const te = Dh(j); s += te - R.size, t.push(this.os.addEntry(e, f, j)) } else if (s -= R.size, this.trackRemovals) { const j = tm(this.os.serializer, _.convertToNoDocument(Jn.min())); t.push(this.os.addEntry(e, f, j)) } }), c.forEach(f => { t.push(this.os.indexManager.addToCollectionParentIndex(e, f)) }), t.push(this.os.updateMetadata(e, s)), I.waitFor(t) } getFromCache(e, t) { return this.os.es(e, t).next(s => (this.us.set(t, { size: s.size, readTime: s.document.readTime }), s.document)) } getAllFromCache(e, t) { return this.os.ss(e, t).next(({ documents: s, rs: c }) => (c.forEach((f, _) => { this.us.set(f, { size: _, readTime: s.get(f).readTime }) }), s)) } } function um(r) { return or(r, "remoteDocumentGlobal") } function mc(r) { return or(r, "remoteDocumentsV14") } function yl(r) { const e = r.path.toArray(); return [e.slice(0, e.length - 2), e[e.length - 2], e[e.length - 1]] } function wg(r, e) { const t = e.documentKey.path.toArray(); return [r, Tl(e.readTime), t.slice(0, t.length - 2), t.length > 0 ? t[t.length - 1] : ""] } function Mh(r, e) { const t = r.path.toArray(), s = e.path.toArray(); let c = 0; for (let f = 0; f < t.length - 2 && f < s.length - 2; ++f)if (c = Ei(t[f], s[f]), c) return c; return c = Ei(t.length, s.length), c || (c = Ei(t[t.length - 2], s[s.length - 2]), c || Ei(t[t.length - 1], s[s.length - 1])) } class Sh { constructor(e, t) { this.overlayedDocument = e, this.mutatedFields = t } } class xg { constructor(e, t, s, c) { this.remoteDocumentCache = e, this.mutationQueue = t, this.documentOverlayCache = s, this.indexManager = c } getDocument(e, t) { let s = null; return this.documentOverlayCache.getOverlay(e, t).next(c => (s = c, this.remoteDocumentCache.getEntry(e, t))).next(c => (null !== s && bd(s.mutation, c, Xo.empty(), Ri.now()), c)) } getDocuments(e, t) { return this.remoteDocumentCache.getEntries(e, t).next(s => this.getLocalViewOfDocuments(e, s, Oi()).next(() => s)) } getLocalViewOfDocuments(e, t, s = Oi()) { const c = Js(); return this.populateOverlays(e, c, t).next(() => this.computeViews(e, t, c, s).next(f => { let _ = Nc(); return f.forEach((R, j) => { _ = _.insert(R, j.overlayedDocument) }), _ })) } getOverlayedDocuments(e, t) { const s = Js(); return this.populateOverlays(e, s, t).next(() => this.computeViews(e, t, s, Oi())) } populateOverlays(e, t, s) { const c = []; return s.forEach(f => { t.has(f) || c.push(f) }), this.documentOverlayCache.getOverlays(e, c).next(f => { f.forEach((_, R) => { t.set(_, R) }) }) } computeViews(e, t, s, c) { let f = ca(); const _ = Hl(), R = Hl(); return t.forEach((j, te) => { const Ce = s.get(te.key); c.has(te.key) && (void 0 === Ce || Ce.mutation instanceof Dl) ? f = f.insert(te.key, te) : void 0 !== Ce ? (_.set(te.key, Ce.mutation.getFieldMask()), bd(Ce.mutation, te, Ce.mutation.getFieldMask(), Ri.now())) : _.set(te.key, Xo.empty()) }), this.recalculateAndSaveOverlays(e, f).next(j => (j.forEach((te, Ce) => _.set(te, Ce)), t.forEach((te, Ce) => { var ot; return R.set(te, new Sh(Ce, null !== (ot = _.get(te)) && void 0 !== ot ? ot : null)) }), R)) } recalculateAndSaveOverlays(e, t) { const s = Hl(); let c = new ur((_, R) => _ - R), f = Oi(); return this.mutationQueue.getAllMutationBatchesAffectingDocumentKeys(e, t).next(_ => { for (const R of _) R.keys().forEach(j => { const te = t.get(j); if (null === te) return; let Ce = s.get(j) || Xo.empty(); Ce = R.applyToLocalView(te, Ce), s.set(j, Ce); const ot = (c.get(R.batchId) || Oi()).add(j); c = c.insert(R.batchId, ot) }) }).next(() => { const _ = [], R = c.getReverseIterator(); for (; R.hasNext();) { const j = R.getNext(), te = j.key, Ce = j.value, ot = Fc(); Ce.forEach(Gt => { if (!f.has(Gt)) { const an = Uf(t.get(Gt), s.get(Gt)); null !== an && ot.set(Gt, an), f = f.add(Gt) } }), _.push(this.documentOverlayCache.saveOverlays(e, te, ot)) } return I.waitFor(_) }).next(() => s) } recalculateAndSaveOverlaysForDocumentKeys(e, t) { return this.remoteDocumentCache.getEntries(e, t).next(s => this.recalculateAndSaveOverlays(e, s)) } getDocumentsMatchingQuery(e, t, s) { return Bn.isDocumentKey((c = t).path) && null === c.collectionGroup && 0 === c.filters.length ? this.getDocumentsMatchingDocumentQuery(e, t.path) : g(t) ? this.getDocumentsMatchingCollectionGroupQuery(e, t, s) : this.getDocumentsMatchingCollectionQuery(e, t, s); var c } getNextDocuments(e, t, s, c) { return this.remoteDocumentCache.getAllFromCollectionGroup(e, t, s, c).next(f => { const _ = c - f.size > 0 ? this.documentOverlayCache.getOverlaysForCollectionGroup(e, t, s.largestBatchId, c - f.size) : I.resolve(Js()); let R = -1, j = f; return _.next(te => I.forEach(te, (Ce, ot) => (R < ot.largestBatchId && (R = ot.largestBatchId), f.get(Ce) ? I.resolve() : this.remoteDocumentCache.getEntry(e, Ce).next(Gt => { j = j.insert(Ce, Gt) }))).next(() => this.populateOverlays(e, te, f)).next(() => this.computeViews(e, j, te, Oi())).next(Ce => ({ batchId: R, changes: du(Ce) }))) }) } getDocumentsMatchingDocumentQuery(e, t) { return this.getDocument(e, new Bn(t)).next(s => { let c = Nc(); return s.isFoundDocument() && (c = c.insert(s.key, s)), c }) } getDocumentsMatchingCollectionGroupQuery(e, t, s) { const c = t.collectionGroup; let f = Nc(); return this.indexManager.getCollectionParents(e, c).next(_ => I.forEach(_, R => { const j = (te = t, Ce = R.child(c), new gl(Ce, null, te.explicitOrderBy.slice(), te.filters.slice(), te.limit, te.limitType, te.startAt, te.endAt)); var te, Ce; return this.getDocumentsMatchingCollectionQuery(e, j, s).next(te => { te.forEach((Ce, ot) => { f = f.insert(Ce, ot) }) }) }).next(() => f)) } getDocumentsMatchingCollectionQuery(e, t, s) { let c; return this.documentOverlayCache.getOverlaysForCollection(e, t.path, s.largestBatchId).next(f => (c = f, this.remoteDocumentCache.getDocumentsMatchingQuery(e, t, s, c))).next(f => { c.forEach((R, j) => { const te = j.getKey(); null === f.get(te) && (f = f.insert(te, So.newInvalidDocument(te))) }); let _ = Nc(); return f.forEach((R, j) => { const te = c.get(R); void 0 !== te && bd(te.mutation, j, Xo.empty(), Ri.now()), zn(t, j) && (_ = _.insert(R, j)) }), _ }) } } class hm { constructor(e) { this.serializer = e, this.cs = new Map, this.hs = new Map } getBundleMetadata(e, t) { return I.resolve(this.cs.get(t)) } saveBundleMetadata(e, t) { var s; return this.cs.set(t.id, { id: (s = t).id, version: s.version, createTime: ss(s.createTime) }), I.resolve() } getNamedQuery(e, t) { return I.resolve(this.hs.get(t)) } saveNamedQuery(e, t) { return this.hs.set(t.name, { name: (s = t).name, query: bl(s.bundledQuery), readTime: ss(s.readTime) }), I.resolve(); var s } } class Ah { constructor() { this.overlays = new ur(Bn.comparator), this.ls = new Map } getOverlay(e, t) { return I.resolve(this.overlays.get(t)) } getOverlays(e, t) { const s = Js(); return I.forEach(t, c => this.getOverlay(e, c).next(f => { null !== f && s.set(c, f) })).next(() => s) } saveOverlays(e, t, s) { return s.forEach((c, f) => { this.we(e, t, f) }), I.resolve() } removeOverlaysForBatchId(e, t, s) { const c = this.ls.get(s); return void 0 !== c && (c.forEach(f => this.overlays = this.overlays.remove(f)), this.ls.delete(s)), I.resolve() } getOverlaysForCollection(e, t, s) { const c = Js(), f = t.length + 1, _ = new Bn(t.child("")), R = this.overlays.getIteratorFrom(_); for (; R.hasNext();) { const j = R.getNext().value, te = j.getKey(); if (!t.isPrefixOf(te.path)) break; te.path.length === f && j.largestBatchId > s && c.set(j.getKey(), j) } return I.resolve(c) } getOverlaysForCollectionGroup(e, t, s, c) { let f = new ur((te, Ce) => te - Ce); const _ = this.overlays.getIterator(); for (; _.hasNext();) { const te = _.getNext().value; if (te.getKey().getCollectionGroup() === t && te.largestBatchId > s) { let Ce = f.get(te.largestBatchId); null === Ce && (Ce = Js(), f = f.insert(te.largestBatchId, Ce)), Ce.set(te.getKey(), te) } } const R = Js(), j = f.getIterator(); for (; j.hasNext() && (j.getNext().value.forEach((te, Ce) => R.set(te, Ce)), !(R.size() >= c));); return I.resolve(R) } we(e, t, s) { const c = this.overlays.get(s.key); if (null !== c) { const _ = this.ls.get(c.largestBatchId).delete(s.key); this.ls.set(c.largestBatchId, _) } this.overlays = this.overlays.insert(s.key, new jf(t, s)); let f = this.ls.get(t); void 0 === f && (f = Oi(), this.ls.set(t, f)), this.ls.set(t, f.add(s.key)) } } class Wl { constructor() { this.fs = new Zr(Ms.ds), this.ws = new Zr(Ms._s) } isEmpty() { return this.fs.isEmpty() } addReference(e, t) { const s = new Ms(e, t); this.fs = this.fs.add(s), this.ws = this.ws.add(s) } gs(e, t) { e.forEach(s => this.addReference(s, t)) } removeReference(e, t) { this.ys(new Ms(e, t)) } ps(e, t) { e.forEach(s => this.removeReference(s, t)) } Is(e) { const t = new Bn(new Pi([])), s = new Ms(t, e), c = new Ms(t, e + 1), f = []; return this.ws.forEachInRange([s, c], _ => { this.ys(_), f.push(_.key) }), f } Ts() { this.fs.forEach(e => this.ys(e)) } ys(e) { this.fs = this.fs.delete(e), this.ws = this.ws.delete(e) } Es(e) { const t = new Bn(new Pi([])), s = new Ms(t, e), c = new Ms(t, e + 1); let f = Oi(); return this.ws.forEachInRange([s, c], _ => { f = f.add(_.key) }), f } containsKey(e) { const t = new Ms(e, 0), s = this.fs.firstAfterOrEqual(t); return null !== s && e.isEqual(s.key) } } class Ms { constructor(e, t) { this.key = e, this.As = t } static ds(e, t) { return Bn.comparator(e.key, t.key) || Ei(e.As, t.As) } static _s(e, t) { return Ei(e.As, t.As) || Bn.comparator(e.key, t.key) } } class fm { constructor(e, t) { this.indexManager = e, this.referenceDelegate = t, this.mutationQueue = [], this.vs = 1, this.Rs = new Zr(Ms.ds) } checkEmpty(e) { return I.resolve(0 === this.mutationQueue.length) } addMutationBatch(e, t, s, c) { const f = this.vs; this.vs++; const _ = new Vc(f, t, s, c); this.mutationQueue.push(_); for (const R of c) this.Rs = this.Rs.add(new Ms(R.key, f)), this.indexManager.addToCollectionParentIndex(e, R.key.path.popLast()); return I.resolve(_) } lookupMutationBatch(e, t) { return I.resolve(this.Ps(t)) } getNextMutationBatchAfterBatchId(e, t) { const c = this.bs(t + 1), f = c < 0 ? 0 : c; return I.resolve(this.mutationQueue.length > f ? this.mutationQueue[f] : null) } getHighestUnacknowledgedBatchId() { return I.resolve(0 === this.mutationQueue.length ? -1 : this.vs - 1) } getAllMutationBatches(e) { return I.resolve(this.mutationQueue.slice()) } getAllMutationBatchesAffectingDocumentKey(e, t) { const s = new Ms(t, 0), c = new Ms(t, Number.POSITIVE_INFINITY), f = []; return this.Rs.forEachInRange([s, c], _ => { const R = this.Ps(_.As); f.push(R) }), I.resolve(f) } getAllMutationBatchesAffectingDocumentKeys(e, t) { let s = new Zr(Ei); return t.forEach(c => { const f = new Ms(c, 0), _ = new Ms(c, Number.POSITIVE_INFINITY); this.Rs.forEachInRange([f, _], R => { s = s.add(R.As) }) }), I.resolve(this.Vs(s)) } getAllMutationBatchesAffectingQuery(e, t) { const s = t.path, c = s.length + 1; let f = s; Bn.isDocumentKey(f) || (f = f.child("")); const _ = new Ms(new Bn(f), 0); let R = new Zr(Ei); return this.Rs.forEachWhile(j => { const te = j.key.path; return !!s.isPrefixOf(te) && (te.length === c && (R = R.add(j.As)), !0) }, _), I.resolve(this.Vs(R)) } Vs(e) { const t = []; return e.forEach(s => { const c = this.Ps(s); null !== c && t.push(c) }), t } removeMutationBatch(e, t) { ai(0 === this.Ss(t.batchId, "removed")), this.mutationQueue.shift(); let s = this.Rs; return I.forEach(t.mutations, c => { const f = new Ms(c.key, t.batchId); return s = s.delete(f), this.referenceDelegate.markPotentiallyOrphaned(e, c.key) }).next(() => { this.Rs = s }) } Cn(e) { } containsKey(e, t) { const s = new Ms(t, 0), c = this.Rs.firstAfterOrEqual(s); return I.resolve(t.isEqual(c && c.key)) } performConsistencyCheck(e) { return I.resolve() } Ss(e, t) { return this.bs(e) } bs(e) { return 0 === this.mutationQueue.length ? 0 : e - this.mutationQueue[0].batchId } Ps(e) { const t = this.bs(e); return t < 0 || t >= this.mutationQueue.length ? null : this.mutationQueue[t] } } class xv { constructor(e) { this.Ds = e, this.docs = new ur(Bn.comparator), this.size = 0 } setIndexManager(e) { this.indexManager = e } addEntry(e, t) { const s = t.key, c = this.docs.get(s), f = c ? c.size : 0, _ = this.Ds(t); return this.docs = this.docs.insert(s, { document: t.mutableCopy(), size: _ }), this.size += _ - f, this.indexManager.addToCollectionParentIndex(e, s.path.popLast()) } removeEntry(e) { const t = this.docs.get(e); t && (this.docs = this.docs.remove(e), this.size -= t.size) } getEntry(e, t) { const s = this.docs.get(t); return I.resolve(s ? s.document.mutableCopy() : So.newInvalidDocument(t)) } getEntries(e, t) { let s = ca(); return t.forEach(c => { const f = this.docs.get(c); s = s.insert(c, f ? f.document.mutableCopy() : So.newInvalidDocument(c)) }), I.resolve(s) } getDocumentsMatchingQuery(e, t, s, c) { let f = ca(); const _ = t.path, R = new Bn(_.child("")), j = this.docs.getIteratorFrom(R); for (; j.hasNext();) { const { key: te, value: { document: Ce } } = j.getNext(); if (!_.isPrefixOf(te.path)) break; te.path.length > _.length + 1 || cl(Xa(Ce), s) <= 0 || (c.has(Ce.key) || zn(t, Ce)) && (f = f.insert(Ce.key, Ce.mutableCopy())) } return I.resolve(f) } getAllFromCollectionGroup(e, t, s, c) { Cn() } Cs(e, t) { return I.forEach(this.docs, s => t(s)) } newChangeBuffer(e) { return new Ev(this) } getSize(e) { return I.resolve(this.size) } } class Ev extends wv { constructor(e) { super(), this.os = e } applyChanges(e) { const t = []; return this.changes.forEach((s, c) => { c.isValidDocument() ? t.push(this.os.addEntry(e, c)) : this.os.removeEntry(s) }), I.waitFor(t) } getFromCache(e, t) { return this.os.getEntry(e, t) } getAllFromCache(e, t) { return this.os.getEntries(e, t) } } class Eg { constructor(e) { this.persistence = e, this.xs = new Xs(t => nl(t), $a), this.lastRemoteSnapshotVersion = Jn.min(), this.highestTargetId = 0, this.Ns = 0, this.ks = new Wl, this.targetCount = 0, this.Ms = Dd.kn() } forEachTarget(e, t) { return this.xs.forEach((s, c) => t(c)), I.resolve() } getLastRemoteSnapshotVersion(e) { return I.resolve(this.lastRemoteSnapshotVersion) } getHighestSequenceNumber(e) { return I.resolve(this.Ns) } allocateTargetId(e) { return this.highestTargetId = this.Ms.next(), I.resolve(this.highestTargetId) } setTargetsMetadata(e, t, s) { return s && (this.lastRemoteSnapshotVersion = s), t > this.Ns && (this.Ns = t), I.resolve() } Fn(e) { this.xs.set(e.target, e); const t = e.targetId; t > this.highestTargetId && (this.Ms = new Dd(t), this.highestTargetId = t), e.sequenceNumber > this.Ns && (this.Ns = e.sequenceNumber) } addTargetData(e, t) { return this.Fn(t), this.targetCount += 1, I.resolve() } updateTargetData(e, t) { return this.Fn(t), I.resolve() } removeTargetData(e, t) { return this.xs.delete(t.target), this.ks.Is(t.targetId), this.targetCount -= 1, I.resolve() } removeTargets(e, t, s) { let c = 0; const f = []; return this.xs.forEach((_, R) => { R.sequenceNumber <= t && null === s.get(R.targetId) && (this.xs.delete(_), f.push(this.removeMatchingKeysForTargetId(e, R.targetId)), c++) }), I.waitFor(f).next(() => c) } getTargetCount(e) { return I.resolve(this.targetCount) } getTargetData(e, t) { const s = this.xs.get(t) || null; return I.resolve(s) } addMatchingKeys(e, t, s) { return this.ks.gs(t, s), I.resolve() } removeMatchingKeys(e, t, s) { this.ks.ps(t, s); const c = this.persistence.referenceDelegate, f = []; return c && t.forEach(_ => { f.push(c.markPotentiallyOrphaned(e, _)) }), I.waitFor(f) } removeMatchingKeysForTargetId(e, t) { return this.ks.Is(t), I.resolve() } getMatchingKeysForTargetId(e, t) { const s = this.ks.Es(t); return I.resolve(s) } containsKey(e, t) { return I.resolve(this.ks.containsKey(t)) } } class pc { constructor(e, t) { this.$s = {}, this.overlays = {}, this.Os = new An(0), this.Fs = !1, this.Fs = !0, this.referenceDelegate = e(this), this.Bs = new Eg(this), this.indexManager = new vv, this.remoteDocumentCache = new xv(s => this.referenceDelegate.Ls(s)), this.serializer = new em(t), this.qs = new hm(this.serializer) } start() { return Promise.resolve() } shutdown() { return this.Fs = !1, Promise.resolve() } get started() { return this.Fs } setDatabaseDeletedListener() { } setNetworkEnabled() { } getIndexManager(e) { return this.indexManager } getDocumentOverlayCache(e) { let t = this.overlays[e.toKey()]; return t || (t = new Ah, this.overlays[e.toKey()] = t), t } getMutationQueue(e, t) { let s = this.$s[e.toKey()]; return s || (s = new fm(t, this.referenceDelegate), this.$s[e.toKey()] = s), s } getTargetCache() { return this.Bs } getRemoteDocumentCache() { return this.remoteDocumentCache } getBundleCache() { return this.qs } runTransaction(e, t, s) { pn("MemoryPersistence", "Starting transaction:", e); const c = new Cv(this.Os.next()); return this.referenceDelegate.Us(), s(c).next(f => this.referenceDelegate.Ks(c).next(() => f)).toPromise().then(f => (c.raiseOnCommittedEvent(), f)) } Gs(e, t) { return I.or(Object.values(this.$s).map(s => () => s.containsKey(e, t))) } } class Cv extends ul { constructor(e) { super(), this.currentSequenceNumber = e } } class kh { constructor(e) { this.persistence = e, this.Qs = new Wl, this.js = null } static zs(e) { return new kh(e) } get Ws() { if (this.js) return this.js; throw Cn() } addReference(e, t, s) { return this.Qs.addReference(s, t), this.Ws.delete(s.toString()), I.resolve() } removeReference(e, t, s) { return this.Qs.removeReference(s, t), this.Ws.add(s.toString()), I.resolve() } markPotentiallyOrphaned(e, t) { return this.Ws.add(t.toString()), I.resolve() } removeTarget(e, t) { this.Qs.Is(t.targetId).forEach(c => this.Ws.add(c.toString())); const s = this.persistence.getTargetCache(); return s.getMatchingKeysForTargetId(e, t.targetId).next(c => { c.forEach(f => this.Ws.add(f.toString())) }).next(() => s.removeTargetData(e, t)) } Us() { this.js = new Set } Ks(e) { const t = this.persistence.getRemoteDocumentCache().newChangeBuffer(); return I.forEach(this.Ws, s => { const c = Bn.fromPath(s); return this.Hs(e, c).next(f => { f || t.removeEntry(c, Jn.min()) }) }).next(() => (this.js = null, t.apply(e))) } updateLimboDocument(e, t) { return this.Hs(e, t).next(s => { s ? this.Ws.delete(t.toString()) : this.Ws.add(t.toString()) }) } Ls(e) { return 0 } Hs(e, t) { return I.or([() => I.resolve(this.Qs.containsKey(t)), () => this.persistence.getTargetCache().containsKey(e, t), () => this.persistence.Gs(e, t)]) } } class mm { constructor(e) { this.serializer = e } O(e, t, s, c) { const f = new m("createOrUpgrade", t); var R; s < 1 && c >= 1 && (e.createObjectStore("owner"), (R = e).createObjectStore("mutationQueues", { keyPath: "userId" }), R.createObjectStore("mutations", { keyPath: "batchId", autoIncrement: !0 }).createIndex("userMutationsIndex", Mo, { unique: !0 }), R.createObjectStore("documentMutations"), pm(e), function (R) { R.createObjectStore("remoteDocuments") }(e)); let _ = I.resolve(); return s < 3 && c >= 3 && (0 !== s && (function (R) { R.deleteObjectStore("targetDocuments"), R.deleteObjectStore("targets"), R.deleteObjectStore("targetGlobal") }(e), pm(e)), _ = _.next(() => function (R) { const j = R.store("targetGlobal"), te = { highestTargetId: 0, highestListenSequenceNumber: 0, lastRemoteSnapshotVersion: Jn.min().toTimestamp(), targetCount: 0 }; return j.put("targetGlobalKey", te) }(f))), s < 4 && c >= 4 && (0 !== s && (_ = _.next(() => function (R, j) { return j.store("mutations").j().next(te => { R.deleteObjectStore("mutations"), R.createObjectStore("mutations", { keyPath: "batchId", autoIncrement: !0 }).createIndex("userMutationsIndex", Mo, { unique: !0 }); const Ce = j.store("mutations"), ot = te.map(Gt => Ce.put(Gt)); return I.waitFor(ot) }) }(e, f))), _ = _.next(() => { !function (R) { R.createObjectStore("clientMetadata", { keyPath: "clientId" }) }(e) })), s < 5 && c >= 5 && (_ = _.next(() => this.Ys(f))), s < 6 && c >= 6 && (_ = _.next(() => (function (R) { R.createObjectStore("remoteDocumentGlobal") }(e), this.Xs(f)))), s < 7 && c >= 7 && (_ = _.next(() => this.Zs(f))), s < 8 && c >= 8 && (_ = _.next(() => this.ti(e, f))), s < 9 && c >= 9 && (_ = _.next(() => { !function (R) { R.objectStoreNames.contains("remoteDocumentChanges") && R.deleteObjectStore("remoteDocumentChanges") }(e) })), s < 10 && c >= 10 && (_ = _.next(() => this.ei(f))), s < 11 && c >= 11 && (_ = _.next(() => { (function (R) { R.createObjectStore("bundles", { keyPath: "bundleId" }) })(e), function (R) { R.createObjectStore("namedQueries", { keyPath: "name" }) }(e) })), s < 12 && c >= 12 && (_ = _.next(() => { !function (R) { const j = R.createObjectStore("documentOverlays", { keyPath: bi }); j.createIndex("collectionPathOverlayIndex", vr, { unique: !1 }), j.createIndex("collectionGroupOverlayIndex", Go, { unique: !1 }) }(e) })), s < 13 && c >= 13 && (_ = _.next(() => function (R) { const j = R.createObjectStore("remoteDocumentsV14", { keyPath: Eo }); j.createIndex("documentKeyIndex", ba), j.createIndex("collectionGroupIndex", Ra) }(e)).next(() => this.ni(e, f)).next(() => e.deleteObjectStore("remoteDocuments"))), s < 14 && c >= 14 && (_ = _.next(() => this.si(e, f))), s < 15 && c >= 15 && (_ = _.next(() => function (R) { R.createObjectStore("indexConfiguration", { keyPath: "indexId", autoIncrement: !0 }).createIndex("collectionGroupIndex", "collectionGroup", { unique: !1 }), R.createObjectStore("indexState", { keyPath: el }).createIndex("sequenceNumberIndex", Pl, { unique: !1 }), R.createObjectStore("indexEntries", { keyPath: oi }).createIndex("documentKeyIndex", pi, { unique: !1 }) }(e))), _ } Xs(e) { let t = 0; return e.store("remoteDocuments").X((s, c) => { t += Dh(c) }).next(() => { const s = { byteSize: t }; return e.store("remoteDocumentGlobal").put("remoteDocumentGlobalKey", s) }) } Ys(e) { const t = e.store("mutationQueues"), s = e.store("mutations"); return t.j().next(c => I.forEach(c, f => { const _ = IDBKeyRange.bound([f.userId, -1], [f.userId, f.lastAcknowledgedBatchId]); return s.j("userMutationsIndex", _).next(R => I.forEach(R, j => { ai(j.userId === f.userId); const te = Wc(this.serializer, j); return om(e, f.userId, te).next(() => { }) })) })) } Zs(e) { const t = e.store("targetDocuments"), s = e.store("remoteDocuments"); return e.store("targetGlobal").get("targetGlobalKey").next(c => { const f = []; return s.X((_, R) => { const j = new Pi(_), te = [0, ei(j)]; f.push(t.get(te).next(Ce => Ce ? I.resolve() : t.put({ targetId: 0, path: ei(j), sequenceNumber: c.highestListenSequenceNumber }))) }).next(() => I.waitFor(f)) }) } ti(e, t) { e.createObjectStore("collectionParents", { keyPath: ya }); const s = t.store("collectionParents"), c = new im, f = _ => { if (c.add(_)) { const R = _.lastSegment(), j = _.popLast(); return s.put({ collectionId: R, parent: ei(j) }) } }; return t.store("remoteDocuments").X({ Y: !0 }, (_, R) => { const j = new Pi(_); return f(j.popLast()) }).next(() => t.store("documentMutations").X({ Y: !0 }, ([_, R, j], te) => { const Ce = Ar(R); return f(Ce.popLast()) })) } ei(e) { const t = e.store("targets"); return t.X((s, c) => { const f = Cu(c), _ = ag(this.serializer, f); return t.put(_) }) } ni(e, t) { const s = t.store("remoteDocuments"), c = []; return s.X((f, _) => { const R = t.store("remoteDocumentsV14"), j = (te = _, te.document ? new Bn(Pi.fromString(te.document.name).popFirst(5)) : te.noDocument ? Bn.fromSegments(te.noDocument.path) : te.unknownDocument ? Bn.fromSegments(te.unknownDocument.path) : Cn()).path.toArray(); var te; const Ce = { prefixPath: j.slice(0, j.length - 2), collectionGroup: j[j.length - 2], documentId: j[j.length - 1], readTime: _.readTime || [0, 0], unknownDocument: _.unknownDocument, noDocument: _.noDocument, document: _.document, hasCommittedMutations: !!_.hasCommittedMutations }; c.push(R.put(Ce)) }).next(() => I.waitFor(c)) } si(e, t) { const s = t.store("mutations"), c = yg(this.serializer), f = new pc(kh.zs, this.serializer.fe); return s.j().next(_ => { const R = new Map; return _.forEach(j => { var te; let Ce = null !== (te = R.get(j.userId)) && void 0 !== te ? te : Oi(); Wc(this.serializer, j).keys().forEach(ot => Ce = Ce.add(ot)), R.set(j.userId, Ce) }), I.forEach(R, (j, te) => { const Ce = new Di(te), ot = yh.de(this.serializer, Ce), Gt = f.getIndexManager(Ce), an = Th.de(Ce, this.serializer, Gt, f.referenceDelegate); return new xg(c, an, ot, Gt).recalculateAndSaveOverlaysForDocumentKeys(new wa(t, An.ct), j).next() }) }) } } function pm(r) { r.createObjectStore("targetDocuments", { keyPath: dd }).createIndex("documentTargetsIndex", aa, { unique: !0 }), r.createObjectStore("targets", { keyPath: "targetId" }).createIndex("queryTargetsIndex", sa, { unique: !0 }), r.createObjectStore("targetGlobal") } const gm = "Failed to obtain exclusive access to the persistence layer. To allow shared access, multi-tab synchronization has to be enabled in all tabs. If you are using `experimentalForceOwningTab:true`, make sure that only one tab has persistence enabled at any given time."; class Oh { constructor(e, t, s, c, f, _, R, j, te, Ce, ot = 15) { if (this.allowTabSynchronization = e, this.persistenceKey = t, this.clientId = s, this.ii = f, this.window = _, this.document = R, this.ri = te, this.oi = Ce, this.ui = ot, this.Os = null, this.Fs = !1, this.isPrimary = !1, this.networkEnabled = !0, this.ci = null, this.inForeground = !1, this.ai = null, this.hi = null, this.li = Number.NEGATIVE_INFINITY, this.fi = Gt => Promise.resolve(), !Oh.D()) throw new _n(Yt.UNIMPLEMENTED, "This platform is either missing IndexedDB or is known to have an incomplete implementation. Offline persistence has been disabled."); this.referenceDelegate = new bg(this, c), this.di = t + "main", this.serializer = new em(j), this.wi = new u(this.di, this.ui, new mm(this.serializer)), this.Bs = new Mu(this.referenceDelegate, this.serializer), this.remoteDocumentCache = yg(this.serializer), this.qs = new fv, this.window && this.window.localStorage ? this._i = this.window.localStorage : (this._i = null, !1 === Ce && er("IndexedDbPersistence", "LocalStorage is unavailable. As a result, persistence may not work reliably. In particular enablePersistence() could fail immediately after refreshing the page.")) } start() { return this.mi().then(() => { if (!this.isPrimary && !this.allowTabSynchronization) throw new _n(Yt.FAILED_PRECONDITION, gm); return this.gi(), this.yi(), this.pi(), this.runTransaction("getHighestListenSequenceNumber", "readonly", e => this.Bs.getHighestSequenceNumber(e)) }).then(e => { this.Os = new An(e, this.ri) }).then(() => { this.Fs = !0 }).catch(e => (this.wi && this.wi.close(), Promise.reject(e))) } Ii(e) { var t = this; return this.fi = function () { var s = (0, a.Z)(function* (c) { if (t.started) return e(c) }); return function (c) { return s.apply(this, arguments) } }(), e(this.isPrimary) } setDatabaseDeletedListener(e) { this.wi.B(function () { var t = (0, a.Z)(function* (s) { null === s.newVersion && (yield e()) }); return function (s) { return t.apply(this, arguments) } }()) } setNetworkEnabled(e) { var t = this; this.networkEnabled !== e && (this.networkEnabled = e, this.ii.enqueueAndForget((0, a.Z)(function* () { t.started && (yield t.mi()) }))) } mi() { return this.runTransaction("updateClientMetadataAndTryBecomePrimary", "readwrite", e => _m(e).put({ clientId: this.clientId, updateTimeMs: Date.now(), networkEnabled: this.networkEnabled, inForeground: this.inForeground }).next(() => { if (this.isPrimary) return this.Ti(e).next(t => { t || (this.isPrimary = !1, this.ii.enqueueRetryable(() => this.fi(!1))) }) }).next(() => this.Ei(e)).next(t => this.isPrimary && !t ? this.Ai(e).next(() => !1) : !!t && this.vi(e).next(() => !0))).catch(e => { if (M(e)) return pn("IndexedDbPersistence", "Failed to extend owner lease: ", e), this.isPrimary; if (!this.allowTabSynchronization) throw e; return pn("IndexedDbPersistence", "Releasing owner lease after error during lease refresh", e), !1 }).then(e => { this.isPrimary !== e && this.ii.enqueueRetryable(() => this.fi(e)), this.isPrimary = e }) } Ti(e) { return qc(e).get("owner").next(t => I.resolve(this.Ri(t))) } Pi(e) { return _m(e).delete(this.clientId) } bi() { var e = this; return (0, a.Z)(function* () { if (e.isPrimary && !e.Vi(e.li, 18e5)) { e.li = Date.now(); const t = yield e.runTransaction("maybeGarbageCollectMultiClientState", "readwrite-primary", s => { const c = or(s, "clientMetadata"); return c.j().next(f => { const _ = e.Si(f, 18e5), R = f.filter(j => -1 === _.indexOf(j)); return I.forEach(R, j => c.delete(j.clientId)).next(() => R) }) }).catch(() => []); if (e._i) for (const s of t) e._i.removeItem(e.Di(s.clientId)) } })() } pi() { this.hi = this.ii.enqueueAfterDelay("client_metadata_refresh", 4e3, () => this.mi().then(() => this.bi()).then(() => this.pi())) } Ri(e) { return !!e && e.ownerId === this.clientId } Ei(e) { return this.oi ? I.resolve(!0) : qc(e).get("owner").next(t => { if (null !== t && this.Vi(t.leaseTimestampMs, 5e3) && !this.Ci(t.ownerId)) { if (this.Ri(t) && this.networkEnabled) return !0; if (!this.Ri(t)) { if (!t.allowTabSynchronization) throw new _n(Yt.FAILED_PRECONDITION, gm); return !1 } } return !(!this.networkEnabled || !this.inForeground) || _m(e).j().next(s => void 0 === this.Si(s, 5e3).find(c => !(this.clientId === c.clientId || !(!this.networkEnabled && c.networkEnabled || !this.inForeground && c.inForeground && this.networkEnabled === c.networkEnabled)))) }).next(t => (this.isPrimary !== t && pn("IndexedDbPersistence", `Client ${t ? "is" : "is not"} eligible for a primary lease.`), t)) } shutdown() { var e = this; return (0, a.Z)(function* () { e.Fs = !1, e.xi(), e.hi && (e.hi.cancel(), e.hi = null), e.Ni(), e.ki(), yield e.wi.runTransaction("shutdown", "readwrite", ["owner", "clientMetadata"], t => { const s = new wa(t, An.ct); return e.Ai(s).next(() => e.Pi(s)) }), e.wi.close(), e.Mi() })() } Si(e, t) { return e.filter(s => this.Vi(s.updateTimeMs, t) && !this.Ci(s.clientId)) } $i() { return this.runTransaction("getActiveClients", "readonly", e => _m(e).j().next(t => this.Si(t, 18e5).map(s => s.clientId))) } get started() { return this.Fs } getMutationQueue(e, t) { return Th.de(e, this.serializer, t, this.referenceDelegate) } getTargetCache() { return this.Bs } getRemoteDocumentCache() { return this.remoteDocumentCache } getIndexManager(e) { return new Ch(e, this.serializer.fe.databaseId) } getDocumentOverlayCache(e) { return yh.de(this.serializer, e) } getBundleCache() { return this.qs } runTransaction(e, t, s) { pn("IndexedDbPersistence", "Starting transaction:", e); const c = "readonly" === t ? "readonly" : "readwrite", f = 15 === (_ = this.ui) ? Ua : 14 === _ ? to : 13 === _ ? No : 12 === _ ? Hs : 11 === _ ? Cs : void Cn(); var _; let R; return this.wi.runTransaction(e, c, f, j => (R = new wa(j, this.Os ? this.Os.next() : An.ct), "readwrite-primary" === t ? this.Ti(R).next(te => !!te || this.Ei(R)).next(te => { if (!te) throw er(`Failed to obtain primary lease for action '${e}'.`), this.isPrimary = !1, this.ii.enqueueRetryable(() => this.fi(!1)), new _n(Yt.FAILED_PRECONDITION, dl); return s(R) }).next(te => this.vi(R).next(() => te)) : this.Oi(R).next(() => s(R)))).then(j => (R.raiseOnCommittedEvent(), j)) } Oi(e) { return qc(e).get("owner").next(t => { if (null !== t && this.Vi(t.leaseTimestampMs, 5e3) && !this.Ci(t.ownerId) && !this.Ri(t) && !(this.oi || this.allowTabSynchronization && t.allowTabSynchronization)) throw new _n(Yt.FAILED_PRECONDITION, gm) }) } vi(e) { const t = { ownerId: this.clientId, allowTabSynchronization: this.allowTabSynchronization, leaseTimestampMs: Date.now() }; return qc(e).put("owner", t) } static D() { return u.D() } Ai(e) { const t = qc(e); return t.get("owner").next(s => this.Ri(s) ? (pn("IndexedDbPersistence", "Releasing primary lease."), t.delete("owner")) : I.resolve()) } Vi(e, t) { const s = Date.now(); return !(e < s - t || e > s && (er(`Detected an update time that is in the future: ${e} > ${s}`), 1)) } gi() { null !== this.document && "function" == typeof this.document.addEventListener && (this.ai = () => { this.ii.enqueueAndForget(() => (this.inForeground = "visible" === this.document.visibilityState, this.mi())) }, this.document.addEventListener("visibilitychange", this.ai), this.inForeground = "visible" === this.document.visibilityState) } Ni() { this.ai && (this.document.removeEventListener("visibilitychange", this.ai), this.ai = null) } yi() { var e; "function" == typeof (null === (e = this.window) || void 0 === e ? void 0 : e.addEventListener) && (this.ci = () => { this.xi(); const t = /(?:Version|Mobile)\/1[456]/; (0, he.G6)() && (navigator.appVersion.match(t) || navigator.userAgent.match(t)) && this.ii.enterRestrictedMode(!0), this.ii.enqueueAndForget(() => this.shutdown()) }, this.window.addEventListener("pagehide", this.ci)) } ki() { this.ci && (this.window.removeEventListener("pagehide", this.ci), this.ci = null) } Ci(e) { var t; try { const s = null !== (null === (t = this._i) || void 0 === t ? void 0 : t.getItem(this.Di(e))); return pn("IndexedDbPersistence", `Client '${e}' ${s ? "is" : "is not"} zombied in LocalStorage`), s } catch (s) { return er("IndexedDbPersistence", "Failed to get zombied client id.", s), !1 } } xi() { if (this._i) try { this._i.setItem(this.Di(this.clientId), String(Date.now())) } catch (e) { er("Failed to set zombie client id.", e) } } Mi() { if (this._i) try { this._i.removeItem(this.Di(this.clientId)) } catch { } } Di(e) { return `firestore_zombie_${this.persistenceKey}_${e}` } } function qc(r) { return or(r, "owner") } function _m(r) { return or(r, "clientMetadata") } function vm(r, e) { let t = r.projectId; return r.isDefaultDatabase || (t += "." + r.database), "firestore/" + e + "/" + t + "/" } class bm { constructor(e, t, s, c) { this.targetId = e, this.fromCache = t, this.Fi = s, this.Bi = c } static Li(e, t) { let s = Oi(), c = Oi(); for (const f of t.docChanges) switch (f.type) { case 0: s = s.add(f.doc.key); break; case 1: c = c.add(f.doc.key) }return new bm(e, t.fromCache, s, c) } } class Cg { constructor() { this.qi = !1 } initialize(e, t) { this.Ui = e, this.indexManager = t, this.qi = !0 } getDocumentsMatchingQuery(e, t, s, c) { return this.Ki(e, t).next(f => f || this.Gi(e, t, c, s)).next(f => f || this.Qi(e, t)) } Ki(e, t) { if (hh(t)) return I.resolve(null); let s = k(t); return this.indexManager.getIndexType(e, s).next(c => 0 === c ? null : (null !== t.limit && 1 === c && (t = De(t, null, "F"), s = k(t)), this.indexManager.getDocumentsMatchingTarget(e, s).next(f => { const _ = Oi(...f); return this.Ui.getDocuments(e, _).next(R => this.indexManager.getMinOffset(e, s).next(j => { const te = this.ji(t, R); return this.zi(t, te, _, j.readTime) ? this.Ki(e, De(t, null, "F")) : this.Wi(e, te, t, j) })) }))) } Gi(e, t, s, c) { return hh(t) || c.isEqual(Jn.min()) ? this.Qi(e, t) : this.Ui.getDocuments(e, s).next(f => { const _ = this.ji(t, f); return this.zi(t, _, s, c) ? this.Qi(e, t) : (lr() <= Y.in.DEBUG && pn("QueryEngine", "Re-using previous result from %s to execute query: %s", c.toString(), Nn(t)), this.Wi(e, _, t, va(c, -1))) }) } ji(e, t) { let s = new Zr(hr(e)); return t.forEach((c, f) => { zn(e, f) && (s = s.add(f)) }), s } zi(e, t, s, c) { if (null === e.limit) return !1; if (s.size !== t.size) return !0; const f = "F" === e.limitType ? t.last() : t.first(); return !!f && (f.hasPendingWrites || f.version.compareTo(c) > 0) } Qi(e, t) { return lr() <= Y.in.DEBUG && pn("QueryEngine", "Using full collection scan to execute query:", Nn(t)), this.Ui.getDocumentsMatchingQuery(e, t, ns.min()) } Wi(e, t, s, c) { return this.Ui.getDocumentsMatchingQuery(e, s, c).next(f => (t.forEach(_ => { f = f.insert(_.key, _) }), f)) } } class _y { constructor(e, t, s, c) { this.persistence = e, this.Hi = t, this.serializer = c, this.Ji = new ur(Ei), this.Yi = new Xs(f => nl(f), $a), this.Xi = new Map, this.Zi = e.getRemoteDocumentCache(), this.Bs = e.getTargetCache(), this.qs = e.getBundleCache(), this.tr(s) } tr(e) { this.documentOverlayCache = this.persistence.getDocumentOverlayCache(e), this.indexManager = this.persistence.getIndexManager(e), this.mutationQueue = this.persistence.getMutationQueue(e, this.indexManager), this.localDocuments = new xg(this.Zi, this.mutationQueue, this.documentOverlayCache, this.indexManager), this.Zi.setIndexManager(this.indexManager), this.Hi.initialize(this.localDocuments, this.indexManager) } collectGarbage(e) { return this.persistence.runTransaction("Collect garbage", "readwrite-primary", t => e.collect(t, this.Ji)) } } function Iv(r, e, t, s) { return new _y(r, e, t, s) } function Su(r, e) { return ym.apply(this, arguments) } function ym() { return ym = (0, a.Z)(function* (r, e) { const t = Un(r); return yield t.persistence.runTransaction("Handle user change", "readonly", s => { let c; return t.mutationQueue.getAllMutationBatches(s).next(f => (c = f, t.tr(e), t.mutationQueue.getAllMutationBatches(s))).next(f => { const _ = [], R = []; let j = Oi(); for (const te of c) { _.push(te.batchId); for (const Ce of te.mutations) j = j.add(Ce.key) } for (const te of f) { R.push(te.batchId); for (const Ce of te.mutations) j = j.add(Ce.key) } return t.localDocuments.getDocuments(s, j).next(te => ({ er: te, removedBatchIds: _, addedBatchIds: R })) }) }) }), ym.apply(this, arguments) } function Ph(r) { const e = Un(r); return e.persistence.runTransaction("Get last remote snapshot version", "readonly", t => e.Bs.getLastRemoteSnapshotVersion(t)) } function Nh(r, e, t) { let s = Oi(), c = Oi(); return t.forEach(f => s = s.add(f)), e.getEntries(r, s).next(f => { let _ = ca(); return t.forEach((R, j) => { const te = f.get(R); j.isFoundDocument() !== te.isFoundDocument() && (c = c.add(R)), j.isNoDocument() && j.version.isEqual(Jn.min()) ? (e.removeEntry(R, j.readTime), _ = _.insert(R, j)) : !te.isValidDocument() || j.version.compareTo(te.version) > 0 || 0 === j.version.compareTo(te.version) && te.hasPendingWrites ? (e.addEntry(j), _ = _.insert(R, j)) : pn("LocalStore", "Ignoring outdated watch update for ", R, ". Current version:", te.version, " Watch version:", j.version) }), { nr: _, sr: c } }) } function xm(r, e) { const t = Un(r); return t.persistence.runTransaction("Get next mutation batch", "readonly", s => (void 0 === e && (e = -1), t.mutationQueue.getNextMutationBatchAfterBatchId(s, e))) } function Ml(r, e) { const t = Un(r); return t.persistence.runTransaction("Allocate target", "readwrite", s => { let c; return t.Bs.getTargetData(s, e).next(f => f ? (c = f, I.resolve(c)) : t.Bs.allocateTargetId(s).next(_ => (c = new vl(e, _, "TargetPurposeListen", s.currentSequenceNumber), t.Bs.addTargetData(s, c).next(() => c)))) }).then(s => { const c = t.Ji.get(s.targetId); return (null === c || s.snapshotVersion.compareTo(c.snapshotVersion) > 0) && (t.Ji = t.Ji.insert(s.targetId, s), t.Yi.set(e, s.targetId)), s }) } function Kl(r, e, t) { return Qc.apply(this, arguments) } function Qc() { return Qc = (0, a.Z)(function* (r, e, t) { const s = Un(r), c = s.Ji.get(e), f = t ? "readwrite" : "readwrite-primary"; try { t || (yield s.persistence.runTransaction("Release target", f, _ => s.persistence.referenceDelegate.removeTarget(_, c))) } catch (_) { if (!M(_)) throw _; pn("LocalStore", `Failed to update sequence numbers for target ${e}: ${_}`) } s.Ji = s.Ji.remove(e), s.Yi.delete(c.target) }), Qc.apply(this, arguments) } function ku(r, e, t) { const s = Un(r); let c = Jn.min(), f = Oi(); return s.persistence.runTransaction("Execute query", "readonly", _ => function (R, j, te) { const Ce = Un(R), ot = Ce.Yi.get(te); return void 0 !== ot ? I.resolve(Ce.Ji.get(ot)) : Ce.Bs.getTargetData(j, te) }(s, _, k(e)).next(R => { if (R) return c = R.lastLimboFreeSnapshotVersion, s.Bs.getMatchingKeysForTargetId(_, R.targetId).next(j => { f = j }) }).next(() => s.Hi.getDocumentsMatchingQuery(_, e, t ? c : Jn.min(), t ? f : Oi())).next(R => (Dv(s, vi(e), R), { documents: R, ir: f }))) } function Fh(r, e) { const t = Un(r), s = Un(t.Bs), c = t.Ji.get(e); return c ? Promise.resolve(c.target) : t.persistence.runTransaction("Get target data", "readonly", f => s.le(f, e).next(_ => _ ? _.target : null)) } function Ru(r, e) { const t = Un(r), s = t.Xi.get(e) || Jn.min(); return t.persistence.runTransaction("Get new document changes", "readonly", c => t.Zi.getAllFromCollectionGroup(c, e, va(s, -1), Number.MAX_SAFE_INTEGER)).then(c => (Dv(t, e, c), c)) } function Dv(r, e, t) { let s = r.Xi.get(e) || Jn.min(); t.forEach((c, f) => { f.readTime.compareTo(s) > 0 && (s = f.readTime) }), r.Xi.set(e, s) } function Ou() { return Ou = (0, a.Z)(function* (r, e, t, s) { const c = Un(r); let f = Oi(), _ = ca(); for (const te of t) { const Ce = e.rr(te.metadata.name); te.document && (f = f.add(Ce)); const ot = e.ur(te); ot.setReadTime(e.cr(te.metadata.readTime)), _ = _.insert(Ce, ot) } const R = c.Zi.newChangeBuffer({ trackRemovals: !0 }), j = yield Ml(c, (te = s, k(Vl(Pi.fromString(`__bundle__/docs/${te}`))))); var te; return c.persistence.runTransaction("Apply bundle documents", "readwrite", te => Nh(te, R, _).next(Ce => (R.apply(te), Ce)).next(Ce => c.Bs.removeMatchingKeysForTargetId(te, j.targetId).next(() => c.Bs.addMatchingKeys(te, f, j.targetId)).next(() => c.localDocuments.getLocalViewOfDocuments(te, Ce.nr, Ce.sr)).next(() => Ce.nr))) }), Ou.apply(this, arguments) } function Ig(r, e) { return Cm.apply(this, arguments) } function Cm() { return Cm = (0, a.Z)(function* (r, e, t = Oi()) { const s = yield Ml(r, k(bl(e.bundledQuery))), c = Un(r); return c.persistence.runTransaction("Save named query", "readwrite", f => { const _ = ss(e.readTime); if (s.snapshotVersion.compareTo(_) >= 0) return c.qs.saveNamedQuery(f, e); const R = s.withResumeToken(Lo.EMPTY_BYTE_STRING, _); return c.Ji = c.Ji.insert(R.targetId, R), c.Bs.updateTargetData(f, R).next(() => c.Bs.removeMatchingKeysForTargetId(f, s.targetId)).next(() => c.Bs.addMatchingKeys(f, t, s.targetId)).next(() => c.qs.saveNamedQuery(f, e)) }) }), Cm.apply(this, arguments) } function Dg(r, e) { return `firestore_clients_${r}_${e}` } function Im(r, e, t) { let s = `firestore_mutations_${r}_${t}`; return e.isAuthenticated() && (s += `_${e.uid}`), s } function Lh(r, e) { return `firestore_targets_${r}_${e}` } class Bh { constructor(e, t, s, c) { this.user = e, this.batchId = t, this.state = s, this.error = c } static ar(e, t, s) { const c = JSON.parse(s); let f, _ = "object" == typeof c && -1 !== ["pending", "acknowledged", "rejected"].indexOf(c.state) && (void 0 === c.error || "object" == typeof c.error); return _ && c.error && (_ = "string" == typeof c.error.message && "string" == typeof c.error.code, _ && (f = new _n(c.error.code, c.error.message))), _ ? new Bh(e, t, c.state, f) : (er("SharedClientState", `Failed to parse mutation state for ID '${t}': ${s}`), null) } hr() { const e = { state: this.state, updateTimeMs: Date.now() }; return this.error && (e.error = { code: this.error.code, message: this.error.message }), JSON.stringify(e) } } class Pu { constructor(e, t, s) { this.targetId = e, this.state = t, this.error = s } static ar(e, t) { const s = JSON.parse(t); let c, f = "object" == typeof s && -1 !== ["not-current", "current", "rejected"].indexOf(s.state) && (void 0 === s.error || "object" == typeof s.error); return f && s.error && (f = "string" == typeof s.error.message && "string" == typeof s.error.code, f && (c = new _n(s.error.code, s.error.message))), f ? new Pu(e, s.state, c) : (er("SharedClientState", `Failed to parse target state for ID '${e}': ${t}`), null) } hr() { const e = { state: this.state, updateTimeMs: Date.now() }; return this.error && (e.error = { code: this.error.code, message: this.error.message }), JSON.stringify(e) } } class Dm { constructor(e, t) { this.clientId = e, this.activeTargetIds = t } static ar(e, t) { const s = JSON.parse(t); let c = "object" == typeof s && s.activeTargetIds instanceof Array, f = _d(); for (let _ = 0; c && _ < s.activeTargetIds.length; ++_)c = fi(s.activeTargetIds[_]), f = f.add(s.activeTargetIds[_]); return c ? new Dm(e, f) : (er("SharedClientState", `Failed to parse client data for instance '${e}': ${t}`), null) } } class Tm { constructor(e, t) { this.clientId = e, this.onlineState = t } static ar(e) { const t = JSON.parse(e); return "object" == typeof t && -1 !== ["Unknown", "Online", "Offline"].indexOf(t.onlineState) && "string" == typeof t.clientId ? new Tm(t.clientId, t.onlineState) : (er("SharedClientState", `Failed to parse online state: ${e}`), null) } } class Nu { constructor() { this.activeTargetIds = _d() } lr(e) { this.activeTargetIds = this.activeTargetIds.add(e) } dr(e) { this.activeTargetIds = this.activeTargetIds.delete(e) } hr() { const e = { activeTargetIds: this.activeTargetIds.toArray(), updateTimeMs: Date.now() }; return JSON.stringify(e) } } class Fu { constructor(e, t, s, c, f) { this.window = e, this.ii = t, this.persistenceKey = s, this.wr = c, this.syncEngine = null, this.onlineStateHandler = null, this.sequenceNumberHandler = null, this._r = this.mr.bind(this), this.gr = new ur(Ei), this.started = !1, this.yr = []; const _ = s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&"); this.storage = this.window.localStorage, this.currentUser = f, this.pr = Dg(this.persistenceKey, this.wr), this.Ir = `firestore_sequence_number_${this.persistenceKey}`, this.gr = this.gr.insert(this.wr, new Nu), this.Tr = new RegExp(`^firestore_clients_${_}_([^_]*)$`), this.Er = new RegExp(`^firestore_mutations_${_}_(\\d+)(?:_(.*))?$`), this.Ar = new RegExp(`^firestore_targets_${_}_(\\d+)$`), this.vr = `firestore_online_state_${this.persistenceKey}`, this.Rr = function (R) { return `firestore_bundle_loaded_v2_${R}` }(this.persistenceKey), this.window.addEventListener("storage", this._r) } static D(e) { return !(!e || !e.localStorage) } start() { var e = this; return (0, a.Z)(function* () { const t = yield e.syncEngine.$i(); for (const c of t) { if (c === e.wr) continue; const f = e.getItem(Dg(e.persistenceKey, c)); if (f) { const _ = Dm.ar(c, f); _ && (e.gr = e.gr.insert(_.clientId, _)) } } e.Pr(); const s = e.storage.getItem(e.vr); if (s) { const c = e.br(s); c && e.Vr(c) } for (const c of e.yr) e.mr(c); e.yr = [], e.window.addEventListener("pagehide", () => e.shutdown()), e.started = !0 })() } writeSequenceNumber(e) { this.setItem(this.Ir, JSON.stringify(e)) } getAllActiveQueryTargets() { return this.Sr(this.gr) } isActiveQueryTarget(e) { let t = !1; return this.gr.forEach((s, c) => { c.activeTargetIds.has(e) && (t = !0) }), t } addPendingMutation(e) { this.Dr(e, "pending") } updateMutationState(e, t, s) { this.Dr(e, t, s), this.Cr(e) } addLocalQueryTarget(e) { let t = "not-current"; if (this.isActiveQueryTarget(e)) { const s = this.storage.getItem(Lh(this.persistenceKey, e)); if (s) { const c = Pu.ar(e, s); c && (t = c.state) } } return this.Nr.lr(e), this.Pr(), t } removeLocalQueryTarget(e) { this.Nr.dr(e), this.Pr() } isLocalQueryTarget(e) { return this.Nr.activeTargetIds.has(e) } clearQueryState(e) { this.removeItem(Lh(this.persistenceKey, e)) } updateQueryState(e, t, s) { this.kr(e, t, s) } handleUserChange(e, t, s) { t.forEach(c => { this.Cr(c) }), this.currentUser = e, s.forEach(c => { this.addPendingMutation(c) }) } setOnlineState(e) { this.Mr(e) } notifyBundleLoaded(e) { this.$r(e) } shutdown() { this.started && (this.window.removeEventListener("storage", this._r), this.removeItem(this.pr), this.started = !1) } getItem(e) { const t = this.storage.getItem(e); return pn("SharedClientState", "READ", e, t), t } setItem(e, t) { pn("SharedClientState", "SET", e, t), this.storage.setItem(e, t) } removeItem(e) { pn("SharedClientState", "REMOVE", e), this.storage.removeItem(e) } mr(e) { var t = this; const s = e; if (s.storageArea === this.storage) { if (pn("SharedClientState", "EVENT", s.key, s.newValue), s.key === this.pr) return void er("Received WebStorage notification for local change. Another client might have garbage-collected our state"); this.ii.enqueueRetryable((0, a.Z)(function* () { if (t.started) { if (null !== s.key) if (t.Tr.test(s.key)) { if (null == s.newValue) { const c = t.Or(s.key); return t.Fr(c, null) } { const c = t.Br(s.key, s.newValue); if (c) return t.Fr(c.clientId, c) } } else if (t.Er.test(s.key)) { if (null !== s.newValue) { const c = t.Lr(s.key, s.newValue); if (c) return t.qr(c) } } else if (t.Ar.test(s.key)) { if (null !== s.newValue) { const c = t.Ur(s.key, s.newValue); if (c) return t.Kr(c) } } else if (s.key === t.vr) { if (null !== s.newValue) { const c = t.br(s.newValue); if (c) return t.Vr(c) } } else if (s.key === t.Ir) { const c = function (f) { let _ = An.ct; if (null != f) try { const R = JSON.parse(f); ai("number" == typeof R), _ = R } catch (R) { er("SharedClientState", "Failed to read sequence number from WebStorage", R) } return _ }(s.newValue); c !== An.ct && t.sequenceNumberHandler(c) } else if (s.key === t.Rr) { const c = t.Gr(s.newValue); yield Promise.all(c.map(f => t.syncEngine.Qr(f))) } } else t.yr.push(s) })) } } get Nr() { return this.gr.get(this.wr) } Pr() { this.setItem(this.pr, this.Nr.hr()) } Dr(e, t, s) { const c = new Bh(this.currentUser, e, t, s), f = Im(this.persistenceKey, this.currentUser, e); this.setItem(f, c.hr()) } Cr(e) { const t = Im(this.persistenceKey, this.currentUser, e); this.removeItem(t) } Mr(e) { this.storage.setItem(this.vr, JSON.stringify({ clientId: this.wr, onlineState: e })) } kr(e, t, s) { const c = Lh(this.persistenceKey, e), f = new Pu(e, t, s); this.setItem(c, f.hr()) } $r(e) { const t = JSON.stringify(Array.from(e)); this.setItem(this.Rr, t) } Or(e) { const t = this.Tr.exec(e); return t ? t[1] : null } Br(e, t) { const s = this.Or(e); return Dm.ar(s, t) } Lr(e, t) { const s = this.Er.exec(e), c = Number(s[1]); return Bh.ar(new Di(void 0 !== s[2] ? s[2] : null), c, t) } Ur(e, t) { const s = this.Ar.exec(e), c = Number(s[1]); return Pu.ar(c, t) } br(e) { return Tm.ar(e) } Gr(e) { return JSON.parse(e) } qr(e) { var t = this; return (0, a.Z)(function* () { if (e.user.uid === t.currentUser.uid) return t.syncEngine.jr(e.batchId, e.state, e.error); pn("SharedClientState", `Ignoring mutation for non-active user ${e.user.uid}`) })() } Kr(e) { return this.syncEngine.zr(e.targetId, e.state, e.error) } Fr(e, t) { const s = t ? this.gr.insert(e, t) : this.gr.remove(e), c = this.Sr(this.gr), f = this.Sr(s), _ = [], R = []; return f.forEach(j => { c.has(j) || _.push(j) }), c.forEach(j => { f.has(j) || R.push(j) }), this.syncEngine.Wr(_, R).then(() => { this.gr = s }) } Vr(e) { this.gr.get(e.clientId) && this.onlineStateHandler(e.onlineState) } Sr(e) { let t = _d(); return e.forEach((s, c) => { t = t.unionWith(c.activeTargetIds) }), t } } class Tg { constructor() { this.Hr = new Nu, this.Jr = {}, this.onlineStateHandler = null, this.sequenceNumberHandler = null } addPendingMutation(e) { } updateMutationState(e, t, s) { } addLocalQueryTarget(e) { return this.Hr.lr(e), this.Jr[e] || "not-current" } updateQueryState(e, t, s) { this.Jr[e] = t } removeLocalQueryTarget(e) { this.Hr.dr(e) } isLocalQueryTarget(e) { return this.Hr.activeTargetIds.has(e) } clearQueryState(e) { delete this.Jr[e] } getAllActiveQueryTargets() { return this.Hr.activeTargetIds } isActiveQueryTarget(e) { return this.Hr.activeTargetIds.has(e) } start() { return this.Hr = new Nu, Promise.resolve() } handleUserChange(e, t, s) { } setOnlineState(e) { } shutdown() { } writeSequenceNumber(e) { } notifyBundleLoaded(e) { } } class Mg { Yr(e) { } shutdown() { } } class Uh { constructor() { this.Xr = () => this.Zr(), this.eo = () => this.no(), this.so = [], this.io() } Yr(e) { this.so.push(e) } shutdown() { window.removeEventListener("online", this.Xr), window.removeEventListener("offline", this.eo) } io() { window.addEventListener("online", this.Xr), window.addEventListener("offline", this.eo) } Zr() { pn("ConnectivityMonitor", "Network connectivity changed: AVAILABLE"); for (const e of this.so) e(0) } no() { pn("ConnectivityMonitor", "Network connectivity changed: UNAVAILABLE"); for (const e of this.so) e(1) } static D() { return typeof window < "u" && void 0 !== window.addEventListener && void 0 !== window.removeEventListener } } let Xc = null; function Mm() { return null === Xc ? Xc = 268435456 + Math.round(2147483648 * Math.random()) : Xc++, "0x" + Xc.toString(16) } const Sg = { BatchGetDocuments: "batchGet", Commit: "commit", RunQuery: "runQuery", RunAggregationQuery: "runAggregationQuery" }; class Tv { constructor(e) { this.ro = e.ro, this.oo = e.oo } uo(e) { this.co = e } ao(e) { this.ho = e } onMessage(e) { this.lo = e } close() { this.oo() } send(e) { this.ro(e) } fo() { this.co() } wo(e) { this.ho(e) } _o(e) { this.lo(e) } } const ea = "WebChannelConnection"; class vy extends class { constructor(e) { this.databaseInfo = e, this.databaseId = e.databaseId, this.mo = (e.ssl ? "https" : "http") + "://" + e.host, this.yo = "projects/" + this.databaseId.projectId + "/databases/" + this.databaseId.database + "/documents" } get po() { return !1 } Io(e, t, s, c, f) { const _ = Mm(), R = this.To(e, t); pn("RestConnection", `Sending RPC '${e}' ${_}:`, R, s); const j = {}; return this.Eo(j, c, f), this.Ao(e, R, j, s).then(te => (pn("RestConnection", `Received RPC '${e}' ${_}: `, te), te), te => { throw wo("RestConnection", `RPC '${e}' ${_} failed with error: `, te, "url: ", R, "request:", s), te }) } vo(e, t, s, c, f, _) { return this.Io(e, t, s, c, f) } Eo(e, t, s) { e["X-Goog-Api-Client"] = "gl-js/ fire/" + qi, e["Content-Type"] = "text/plain", this.databaseInfo.appId && (e["X-Firebase-GMPID"] = this.databaseInfo.appId), t && t.headers.forEach((c, f) => e[f] = c), s && s.headers.forEach((c, f) => e[f] = c) } To(e, t) { return `${this.mo}/v1/${t}:${Sg[e]}` } }{ constructor(e) { super(e), this.forceLongPolling = e.forceLongPolling, this.autoDetectLongPolling = e.autoDetectLongPolling, this.useFetchStreams = e.useFetchStreams, this.longPollingOptions = e.longPollingOptions } Ao(e, t, s, c) { const f = Mm(); return new Promise((_, R) => { const j = new Ji; j.setWithCredentials(!0), j.listenOnce(be.COMPLETE, () => { try { switch (j.getLastErrorCode()) { case B.NO_ERROR: const Ce = j.getResponseJson(); pn(ea, `XHR for RPC '${e}' ${f} received:`, JSON.stringify(Ce)), _(Ce); break; case B.TIMEOUT: pn(ea, `RPC '${e}' ${f} timed out`), R(new _n(Yt.DEADLINE_EXCEEDED, "Request time out")); break; case B.HTTP_ERROR: const ot = j.getStatus(); if (pn(ea, `RPC '${e}' ${f} failed with status:`, ot, "response text:", j.getResponseText()), ot > 0) { let Gt = j.getResponseJson(); Array.isArray(Gt) && (Gt = Gt[0]); const an = Gt?.error; if (an && an.status && an.message) { const kn = function (Yn) { const ti = Yn.toLowerCase().replace(/_/g, "-"); return Object.values(Yt).indexOf(ti) >= 0 ? ti : Yt.UNKNOWN }(an.status); R(new _n(kn, an.message)) } else R(new _n(Yt.UNKNOWN, "Server responded with status " + j.getStatus())) } else R(new _n(Yt.UNAVAILABLE, "Connection failed.")); break; default: Cn() } } finally { pn(ea, `RPC '${e}' ${f} completed.`) } }); const te = JSON.stringify(c); pn(ea, `RPC '${e}' ${f} sending request:`, c), j.send(t, "POST", te, s, 15) }) } Ro(e, t, s) { const c = Mm(), f = [this.mo, "/", "google.firestore.v1.Firestore", "/", e, "/channel"], _ = P(), R = X(), j = { httpSessionIdParam: "gsessionid", initMessageHeaders: {}, messageUrlParams: { database: `projects/${this.databaseId.projectId}/databases/${this.databaseId.database}` }, sendRawJson: !0, supportsCrossDomainXhr: !0, internalChannelParams: { forwardChannelRequestTimeoutMs: 6e5 }, forceLongPolling: this.forceLongPolling, detectBufferingProxy: this.autoDetectLongPolling }, te = this.longPollingOptions.timeoutSeconds; void 0 !== te && (j.longPollingTimeout = Math.round(1e3 * te)), this.useFetchStreams && (j.xmlHttpFactory = new en({})), this.Eo(j.initMessageHeaders, t, s), j.encodeInitMessageHeaders = !0; const Ce = f.join(""); pn(ea, `Creating RPC '${e}' stream ${c}: ${Ce}`, j); const ot = _.createWebChannel(Ce, j); let Gt = !1, an = !1; const kn = new Tv({ ro: ti => { an ? pn(ea, `Not sending because RPC '${e}' stream ${c} is closed:`, ti) : (Gt || (pn(ea, `Opening RPC '${e}' stream ${c} transport.`), ot.open(), Gt = !0), pn(ea, `RPC '${e}' stream ${c} sending:`, ti), ot.send(ti)) }, oo: () => ot.close() }), Yn = (ti, Qi, Rr) => { ti.listen(Qi, pr => { try { Rr(pr) } catch (Ls) { setTimeout(() => { throw Ls }, 0) } }) }; return Yn(ot, Zn.EventType.OPEN, () => { an || pn(ea, `RPC '${e}' stream ${c} transport opened.`) }), Yn(ot, Zn.EventType.CLOSE, () => { an || (an = !0, pn(ea, `RPC '${e}' stream ${c} transport closed`), kn.wo()) }), Yn(ot, Zn.EventType.ERROR, ti => { an || (an = !0, wo(ea, `RPC '${e}' stream ${c} transport errored:`, ti), kn.wo(new _n(Yt.UNAVAILABLE, "The operation could not be completed"))) }), Yn(ot, Zn.EventType.MESSAGE, ti => { var Qi; if (!an) { const Rr = ti.data[0]; ai(!!Rr); const Ls = Rr.error || (null === (Qi = Rr[0]) || void 0 === Qi ? void 0 : Qi.error); if (Ls) { pn(ea, `RPC '${e}' stream ${c} received error:`, Ls); const ls = Ls.status; let Co = function (Rc) { const Op = _s[Rc]; if (void 0 !== Op) return $f(Op) }(ls), ua = Ls.message; void 0 === Co && (Co = Yt.INTERNAL, ua = "Unknown error status: " + ls + " with message " + Ls.message), an = !0, kn.wo(new _n(Co, ua)), ot.close() } else pn(ea, `RPC '${e}' stream ${c} received:`, Rr), kn._o(Rr) } }), Yn(R, Je.STAT_EVENT, ti => { ti.stat === $t.PROXY ? pn(ea, `RPC '${e}' stream ${c} detected buffering proxy`) : ti.stat === $t.NOPROXY && pn(ea, `RPC '${e}' stream ${c} detected no buffering proxy`) }), setTimeout(() => { kn.fo() }, 0), kn } } function Ag() { return typeof window < "u" ? window : null } function gc() { return typeof document < "u" ? document : null } function Lu(r) { return new fy(r, !0) } class _c { constructor(e, t, s = 1e3, c = 1.5, f = 6e4) { this.ii = e, this.timerId = t, this.Po = s, this.bo = c, this.Vo = f, this.So = 0, this.Do = null, this.Co = Date.now(), this.reset() } reset() { this.So = 0 } xo() { this.So = this.Vo } No(e) { this.cancel(); const t = Math.floor(this.So + this.ko()), s = Math.max(0, Date.now() - this.Co), c = Math.max(0, t - s); c > 0 && pn("ExponentialBackoff", `Backing off for ${c} ms (base delay: ${this.So} ms, delay with jitter: ${t} ms, last attempt: ${s} ms ago)`), this.Do = this.ii.enqueueAfterDelay(this.timerId, c, () => (this.Co = Date.now(), e())), this.So *= this.bo, this.So < this.Po && (this.So = this.Po), this.So > this.Vo && (this.So = this.Vo) } Mo() { null !== this.Do && (this.Do.skipDelay(), this.Do = null) } cancel() { null !== this.Do && (this.Do.cancel(), this.Do = null) } ko() { return (Math.random() - .5) * this.So } } class Sd { constructor(e, t, s, c, f, _, R, j) { this.ii = e, this.$o = s, this.Oo = c, this.connection = f, this.authCredentialsProvider = _, this.appCheckCredentialsProvider = R, this.listener = j, this.state = 0, this.Fo = 0, this.Bo = null, this.Lo = null, this.stream = null, this.qo = new _c(e, t) } Uo() { return 1 === this.state || 5 === this.state || this.Ko() } Ko() { return 2 === this.state || 3 === this.state } start() { 4 !== this.state ? this.auth() : this.Go() } stop() { var e = this; return (0, a.Z)(function* () { e.Uo() && (yield e.close(0)) })() } Qo() { this.state = 0, this.qo.reset() } jo() { this.Ko() && null === this.Bo && (this.Bo = this.ii.enqueueAfterDelay(this.$o, 6e4, () => this.zo())) } Wo(e) { this.Ho(), this.stream.send(e) } zo() { var e = this; return (0, a.Z)(function* () { if (e.Ko()) return e.close(0) })() } Ho() { this.Bo && (this.Bo.cancel(), this.Bo = null) } Jo() { this.Lo && (this.Lo.cancel(), this.Lo = null) } close(e, t) { var s = this; return (0, a.Z)(function* () { s.Ho(), s.Jo(), s.qo.cancel(), s.Fo++, 4 !== e ? s.qo.reset() : t && t.code === Yt.RESOURCE_EXHAUSTED ? (er(t.toString()), er("Using maximum backoff delay to prevent overloading the backend."), s.qo.xo()) : t && t.code === Yt.UNAUTHENTICATED && 3 !== s.state && (s.authCredentialsProvider.invalidateToken(), s.appCheckCredentialsProvider.invalidateToken()), null !== s.stream && (s.Yo(), s.stream.close(), s.stream = null), s.state = e, yield s.listener.ao(t) })() } Yo() { } auth() { this.state = 1; const e = this.Xo(this.Fo), t = this.Fo; Promise.all([this.authCredentialsProvider.getToken(), this.appCheckCredentialsProvider.getToken()]).then(([s, c]) => { this.Fo === t && this.Zo(s, c) }, s => { e(() => { const c = new _n(Yt.UNKNOWN, "Fetching auth token failed: " + s.message); return this.tu(c) }) }) } Zo(e, t) { const s = this.Xo(this.Fo); this.stream = this.eu(e, t), this.stream.uo(() => { s(() => (this.state = 2, this.Lo = this.ii.enqueueAfterDelay(this.Oo, 1e4, () => (this.Ko() && (this.state = 3), Promise.resolve())), this.listener.uo())) }), this.stream.ao(c => { s(() => this.tu(c)) }), this.stream.onMessage(c => { s(() => this.onMessage(c)) }) } Go() { var e = this; this.state = 5, this.qo.No((0, a.Z)(function* () { e.state = 0, e.start() })) } tu(e) { return pn("PersistentStream", `close with error: ${e}`), this.stream = null, this.close(4, e) } Xo(e) { return t => { this.ii.enqueueAndForget(() => this.Fo === e ? t() : (pn("PersistentStream", "stream callback skipped by getCloseGuardedDispatcher."), Promise.resolve())) } } } class Mv extends Sd { constructor(e, t, s, c, f, _) { super(e, "listen_stream_connection_backoff", "listen_stream_idle", "health_check_timeout", t, s, c, _), this.serializer = f } eu(e, t) { return this.connection.Ro("Listen", e, t) } onMessage(e) { this.qo.reset(); const t = function rg(r, e) { let t; if ("targetChange" in e) { const s = "NO_CHANGE" === (j = e.targetChange.targetChangeType || "NO_CHANGE") ? 0 : "ADD" === j ? 1 : "REMOVE" === j ? 2 : "CURRENT" === j ? 3 : "RESET" === j ? 4 : Cn(), c = e.targetChange.targetIds || [], f = function (j, te) { return j.useProto3Json ? (ai(void 0 === te || "string" == typeof te), Lo.fromBase64String(te || "")) : (ai(void 0 === te || te instanceof Uint8Array), Lo.fromUint8Array(te || new Uint8Array)) }(r, e.targetChange.resumeToken), _ = e.targetChange.cause, R = _ && function (j) { const te = void 0 === j.code ? Yt.UNKNOWN : $f(j.code); return new _n(te, j.message || "") }(_); t = new Jp(s, c, f, R || null) } else if ("documentChange" in e) { const s = e.documentChange, c = Na(r, s.document.name), f = ss(s.document.updateTime), _ = s.document.createTime ? ss(s.document.createTime) : Jn.min(), R = new no({ mapValue: { fields: s.document.fields } }), j = So.newFoundDocument(c, f, _, R); t = new vu(s.targetIds || [], s.removedTargetIds || [], j.key, j) } else if ("documentDelete" in e) { const s = e.documentDelete, c = Na(r, s.document), f = s.readTime ? ss(s.readTime) : Jn.min(), _ = So.newNoDocument(c, f); t = new vu([], s.removedTargetIds || [], _.key, _) } else if ("documentRemove" in e) { const s = e.documentRemove, c = Na(r, s.document); t = new vu([], s.removedTargetIds || [], c, null) } else { if (!("filter" in e)) return Cn(); { const s = e.filter, { count: c = 0, unchangedNames: f } = s, _ = new Yp(c, f); t = new ph(s.targetId, _) } } var j; return t }(this.serializer, e), s = function (c) { if (!("targetChange" in c)) return Jn.min(); const f = c.targetChange; return f.targetIds && f.targetIds.length ? Jn.min() : f.readTime ? ss(f.readTime) : Jn.min() }(e); return this.listener.nu(t, s) } su(e) { const t = {}; t.database = lc(this.serializer), t.addTarget = function (c, f) { let _; const R = f.target; if (_ = pl(R) ? { documents: Xf(c, R) } : { query: bh(c, R) }, _.targetId = f.targetId, f.resumeToken.approximateByteSize() > 0) { _.resumeToken = Zf(c, f.resumeToken); const j = xd(c, f.expectedCount); null !== j && (_.expectedCount = j) } else if (f.snapshotVersion.compareTo(Jn.min()) > 0) { _.readTime = Ed(c, f.snapshotVersion.toTimestamp()); const j = xd(c, f.expectedCount); null !== j && (_.expectedCount = j) } return _ }(this.serializer, e); const s = function Jf(r, e) { const t = function (s) { switch (s) { case "TargetPurposeListen": return null; case "TargetPurposeExistenceFilterMismatch": return "existence-filter-mismatch"; case "TargetPurposeExistenceFilterMismatchBloom": return "existence-filter-mismatch-bloom"; case "TargetPurposeLimboResolution": return "limbo-document"; default: return Cn() } }(e.purpose); return null == t ? null : { "goog-listen-tags": t } }(0, e); s && (t.labels = s), this.Wo(t) } iu(e) { const t = {}; t.database = lc(this.serializer), t.removeTarget = e, this.Wo(t) } } class kg extends Sd { constructor(e, t, s, c, f, _) { super(e, "write_stream_connection_backoff", "write_stream_idle", "health_check_timeout", t, s, c, _), this.serializer = f, this.ru = !1 } get ou() { return this.ru } start() { this.ru = !1, this.lastStreamToken = void 0, super.start() } Yo() { this.ru && this.uu([]) } eu(e, t) { return this.connection.Ro("Write", e, t) } onMessage(e) { if (ai(!!e.streamToken), this.lastStreamToken = e.streamToken, this.ru) { this.qo.reset(); const t = function dv(r, e) { return r && r.length > 0 ? (ai(void 0 !== e), r.map(t => function (s, c) { let f = ss(s.updateTime ? s.updateTime : c); return f.isEqual(Jn.min()) && (f = ss(c)), new Bf(f, s.transformResults || []) }(t, e))) : [] }(e.writeResults, e.commitTime), s = ss(e.commitTime); return this.listener.cu(s, t) } return ai(!e.writeResults || 0 === e.writeResults.length), this.ru = !0, this.listener.au() } hu() { const e = {}; e.database = lc(this.serializer), this.Wo(e) } uu(e) { const t = { streamToken: this.lastStreamToken, writes: e.map(s => yu(this.serializer, s)) }; this.Wo(t) } } class Sv extends class { }{ constructor(e, t, s, c) { super(), this.authCredentials = e, this.appCheckCredentials = t, this.connection = s, this.serializer = c, this.lu = !1 } fu() { if (this.lu) throw new _n(Yt.FAILED_PRECONDITION, "The client has already been terminated.") } Io(e, t, s) { return this.fu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([c, f]) => this.connection.Io(e, t, s, c, f)).catch(c => { throw "FirebaseError" === c.name ? (c.code === Yt.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), c) : new _n(Yt.UNKNOWN, c.toString()) }) } vo(e, t, s, c) { return this.fu(), Promise.all([this.authCredentials.getToken(), this.appCheckCredentials.getToken()]).then(([f, _]) => this.connection.vo(e, t, s, f, _, c)).catch(f => { throw "FirebaseError" === f.name ? (f.code === Yt.UNAUTHENTICATED && (this.authCredentials.invalidateToken(), this.appCheckCredentials.invalidateToken()), f) : new _n(Yt.UNKNOWN, f.toString()) }) } terminate() { this.lu = !0 } } class Rg { constructor(e, t) { this.asyncQueue = e, this.onlineStateHandler = t, this.state = "Unknown", this.wu = 0, this._u = null, this.mu = !0 } gu() { 0 === this.wu && (this.yu("Unknown"), this._u = this.asyncQueue.enqueueAfterDelay("online_state_timeout", 1e4, () => (this._u = null, this.pu("Backend didn't respond within 10 seconds."), this.yu("Offline"), Promise.resolve()))) } Iu(e) { "Online" === this.state ? this.yu("Unknown") : (this.wu++, this.wu >= 1 && (this.Tu(), this.pu(`Connection failed 1 times. Most recent error: ${e.toString()}`), this.yu("Offline"))) } set(e) { this.Tu(), this.wu = 0, "Online" === e && (this.mu = !1), this.yu(e) } yu(e) { e !== this.state && (this.state = e, this.onlineStateHandler(e)) } pu(e) { const t = `Could not reach Cloud Firestore backend. ${e}\nThis typically indicates that your device does not have a healthy Internet connection at the moment. The client will operate in offline mode until it is able to successfully connect to the backend.`; this.mu ? (er(t), this.mu = !1) : pn("OnlineStateTracker", t) } Tu() { null !== this._u && (this._u.cancel(), this._u = null) } } class Og { constructor(e, t, s, c, f) { var _ = this; this.localStore = e, this.datastore = t, this.asyncQueue = s, this.remoteSyncer = {}, this.Eu = [], this.Au = new Map, this.vu = new Set, this.Ru = [], this.Pu = f, this.Pu.Yr(R => { s.enqueueAndForget((0, a.Z)(function* () { var j; vc(_) && (pn("RemoteStore", "Restarting streams for network reachability change."), yield (j = (0, a.Z)(function* (te) { const Ce = Un(te); Ce.vu.add(4), yield td(Ce), Ce.bu.set("Unknown"), Ce.vu.delete(4), yield Jc(Ce) }), function (te) { return j.apply(this, arguments) })(_)) })) }), this.bu = new Rg(s, c) } } function Jc(r) { return ed.apply(this, arguments) } function ed() { return ed = (0, a.Z)(function* (r) { if (vc(r)) for (const e of r.Ru) yield e(!0) }), ed.apply(this, arguments) } function td(r) { return Pg.apply(this, arguments) } function Pg() { return Pg = (0, a.Z)(function* (r) { for (const e of r.Ru) yield e(!1) }), Pg.apply(this, arguments) } function Ad(r, e) { const t = Un(r); t.Au.has(e.targetId) || (t.Au.set(e.targetId, e), km(t) ? Vh(t) : nd(t).Ko() && kd(t, e)) } function Sl(r, e) { const t = Un(r), s = nd(t); t.Au.delete(e), s.Ko() && Am(t, e), 0 === t.Au.size && (s.Ko() ? s.jo() : vc(t) && t.bu.set("Unknown")) } function kd(r, e) { if (r.Vu.qt(e.targetId), e.resumeToken.approximateByteSize() > 0 || e.snapshotVersion.compareTo(Jn.min()) > 0) { const t = r.remoteSyncer.getRemoteKeysForTarget(e.targetId).size; e = e.withExpectedCount(t) } nd(r).su(e) } function Am(r, e) { r.Vu.qt(e), nd(r).iu(e) } function Vh(r) { r.Vu = new Wf({ getRemoteKeysForTarget: e => r.remoteSyncer.getRemoteKeysForTarget(e), le: e => r.Au.get(e) || null, ue: () => r.datastore.serializer.databaseId }), nd(r).start(), r.bu.gu() } function km(r) { return vc(r) && !nd(r).Uo() && r.Au.size > 0 } function vc(r) { return 0 === Un(r).vu.size } function Ng(r) { r.Vu = void 0 } function kv(r) { return Hh.apply(this, arguments) } function Hh() { return Hh = (0, a.Z)(function* (r) { r.Au.forEach((e, t) => { kd(r, e) }) }), Hh.apply(this, arguments) } function Rv(r, e) { return zh.apply(this, arguments) } function zh() { return zh = (0, a.Z)(function* (r, e) { Ng(r), km(r) ? (r.bu.Iu(e), Vh(r)) : r.bu.set("Unknown") }), zh.apply(this, arguments) } function Rd(r, e, t) { return wl.apply(this, arguments) } function wl() { return wl = (0, a.Z)(function* (r, e, t) { if (r.bu.set("Online"), e instanceof Jp && 2 === e.state && e.cause) try { yield (s = (0, a.Z)(function* (c, f) { const _ = f.cause; for (const R of f.targetIds) c.Au.has(R) && (yield c.remoteSyncer.rejectListen(R, _), c.Au.delete(R), c.Vu.removeTarget(R)) }), function (c, f) { return s.apply(this, arguments) })(r, e) } catch (s) { pn("RemoteStore", "Failed to remove targets %s: %s ", e.targetIds.join(","), s), yield Bu(r, s) } else if (e instanceof vu ? r.Vu.Ht(e) : e instanceof ph ? r.Vu.ne(e) : r.Vu.Xt(e), !t.isEqual(Jn.min())) try { const s = yield Ph(r.localStore); t.compareTo(s) >= 0 && (yield function (c, f) { const _ = c.Vu.ce(f); return _.targetChanges.forEach((R, j) => { if (R.resumeToken.approximateByteSize() > 0) { const te = c.Au.get(j); te && c.Au.set(j, te.withResumeToken(R.resumeToken, f)) } }), _.targetMismatches.forEach((R, j) => { const te = c.Au.get(R); if (!te) return; c.Au.set(R, te.withResumeToken(Lo.EMPTY_BYTE_STRING, te.snapshotVersion)), Am(c, R); const Ce = new vl(te.target, R, j, te.sequenceNumber); kd(c, Ce) }), c.remoteSyncer.applyRemoteEvent(_) }(r, t)) } catch (s) { pn("RemoteStore", "Failed to raise snapshot:", s), yield Bu(r, s) } var s }), wl.apply(this, arguments) } function Bu(r, e, t) { return Fg.apply(this, arguments) } function Fg() { return Fg = (0, a.Z)(function* (r, e, t) { if (!M(e)) throw e; r.vu.add(1), yield td(r), r.bu.set("Offline"), t || (t = () => Ph(r.localStore)), r.asyncQueue.enqueueRetryable((0, a.Z)(function* () { pn("RemoteStore", "Retrying IndexedDB access"), yield t(), r.vu.delete(1), yield Jc(r) })) }), Fg.apply(this, arguments) } function Lg(r, e) { return e().catch(t => Bu(r, t, e)) } function Uu(r) { return Bg.apply(this, arguments) } function Bg() { return Bg = (0, a.Z)(function* (r) { const e = Un(r), t = bc(e); let s = e.Eu.length > 0 ? e.Eu[e.Eu.length - 1].batchId : -1; for (; Ug(e);)try { const c = yield xm(e.localStore, s); if (null === c) { 0 === e.Eu.length && t.jo(); break } s = c.batchId, Vg(e, c) } catch (c) { yield Bu(e, c) } Ov(e) && Rm(e) }), Bg.apply(this, arguments) } function Ug(r) { return vc(r) && r.Eu.length < 10 } function Vg(r, e) { r.Eu.push(e); const t = bc(r); t.Ko() && t.ou && t.uu(e.mutations) } function Ov(r) { return vc(r) && !bc(r).Uo() && r.Eu.length > 0 } function Rm(r) { bc(r).start() } function jh(r) { return $h.apply(this, arguments) } function $h() { return $h = (0, a.Z)(function* (r) { bc(r).hu() }), $h.apply(this, arguments) } function Hg(r) { return Gh.apply(this, arguments) } function Gh() { return Gh = (0, a.Z)(function* (r) { const e = bc(r); for (const t of r.Eu) e.uu(t.mutations) }), Gh.apply(this, arguments) } function Gi(r, e, t) { return Wh.apply(this, arguments) } function Wh() { return Wh = (0, a.Z)(function* (r, e, t) { const s = r.Eu.shift(), c = zf.from(s, e, t); yield Lg(r, () => r.remoteSyncer.applySuccessfulWrite(c)), yield Uu(r) }), Wh.apply(this, arguments) } function zg(r, e) { return jg.apply(this, arguments) } function jg() { return jg = (0, a.Z)(function* (r, e) { var t; e && bc(r).ou && (yield (t = (0, a.Z)(function* (s, c) { if (pu(f = c.code) && f !== Yt.ABORTED) { const _ = s.Eu.shift(); bc(s).Qo(), yield Lg(s, () => s.remoteSyncer.rejectFailedWrite(_.batchId, c)), yield Uu(s) } var f }), function (s, c) { return t.apply(this, arguments) })(r, e)), Ov(r) && Rm(r) }), jg.apply(this, arguments) } function $g(r, e) { return Kh.apply(this, arguments) } function Kh() { return Kh = (0, a.Z)(function* (r, e) { const t = Un(r); t.asyncQueue.verifyOperationInProgress(), pn("RemoteStore", "RemoteStore received new credentials"); const s = vc(t); t.vu.add(3), yield td(t), s && t.bu.set("Unknown"), yield t.remoteSyncer.handleCredentialChange(e), t.vu.delete(3), yield Jc(t) }), Kh.apply(this, arguments) } function Om(r, e) { return Pm.apply(this, arguments) } function Pm() { return Pm = (0, a.Z)(function* (r, e) { const t = Un(r); e ? (t.vu.delete(2), yield Jc(t)) : e || (t.vu.add(2), yield td(t), t.bu.set("Unknown")) }), Pm.apply(this, arguments) } function nd(r) { return r.Su || (r.Su = function (e, t, s) { const c = Un(e); return c.fu(), new Mv(t, c.connection, c.authCredentials, c.appCheckCredentials, c.serializer, s) }(r.datastore, r.asyncQueue, { uo: kv.bind(null, r), ao: Rv.bind(null, r), nu: Rd.bind(null, r) }), r.Ru.push(function () { var e = (0, a.Z)(function* (t) { t ? (r.Su.Qo(), km(r) ? Vh(r) : r.bu.set("Unknown")) : (yield r.Su.stop(), Ng(r)) }); return function (t) { return e.apply(this, arguments) } }())), r.Su } function bc(r) { return r.Du || (r.Du = function (e, t, s) { const c = Un(e); return c.fu(), new kg(t, c.connection, c.authCredentials, c.appCheckCredentials, c.serializer, s) }(r.datastore, r.asyncQueue, { uo: jh.bind(null, r), ao: zg.bind(null, r), au: Hg.bind(null, r), cu: Gi.bind(null, r) }), r.Ru.push(function () { var e = (0, a.Z)(function* (t) { t ? (r.Du.Qo(), yield Uu(r)) : (yield r.Du.stop(), r.Eu.length > 0 && (pn("RemoteStore", `Stopping write stream with ${r.Eu.length} pending writes`), r.Eu = [])) }); return function (t) { return e.apply(this, arguments) } }())), r.Du } class Zh { constructor(e, t, s, c, f) { this.asyncQueue = e, this.timerId = t, this.targetTimeMs = s, this.op = c, this.removalCallback = f, this.deferred = new eo, this.then = this.deferred.promise.then.bind(this.deferred.promise), this.deferred.promise.catch(_ => { }) } static createAndSchedule(e, t, s, c, f) { const _ = Date.now() + s, R = new Zh(e, t, _, c, f); return R.start(s), R } start(e) { this.timerHandle = setTimeout(() => this.handleDelayElapsed(), e) } skipDelay() { return this.handleDelayElapsed() } cancel(e) { null !== this.timerHandle && (this.clearTimeout(), this.deferred.reject(new _n(Yt.CANCELLED, "Operation cancelled" + (e ? ": " + e : "")))) } handleDelayElapsed() { this.asyncQueue.enqueueAndForget(() => null !== this.timerHandle ? (this.clearTimeout(), this.op().then(e => this.deferred.resolve(e))) : Promise.resolve()) } clearTimeout() { null !== this.timerHandle && (this.removalCallback(this), clearTimeout(this.timerHandle), this.timerHandle = null) } } function Od(r, e) { if (er("AsyncQueue", `${e}: ${r}`), M(r)) return new _n(Yt.UNAVAILABLE, `${e}: ${r}`); throw r } class Pd { constructor(e) { this.comparator = e ? (t, s) => e(t, s) || Bn.comparator(t.key, s.key) : (t, s) => Bn.comparator(t.key, s.key), this.keyedMap = Nc(), this.sortedSet = new ur(this.comparator) } static emptySet(e) { return new Pd(e.comparator) } has(e) { return null != this.keyedMap.get(e) } get(e) { return this.keyedMap.get(e) } first() { return this.sortedSet.minKey() } last() { return this.sortedSet.maxKey() } isEmpty() { return this.sortedSet.isEmpty() } indexOf(e) { const t = this.keyedMap.get(e); return t ? this.sortedSet.indexOf(t) : -1 } get size() { return this.sortedSet.size } forEach(e) { this.sortedSet.inorderTraversal((t, s) => (e(t), !1)) } add(e) { const t = this.delete(e.key); return t.copy(t.keyedMap.insert(e.key, e), t.sortedSet.insert(e, null)) } delete(e) { const t = this.get(e); return t ? this.copy(this.keyedMap.remove(e), this.sortedSet.remove(t)) : this } isEqual(e) { if (!(e instanceof Pd) || this.size !== e.size) return !1; const t = this.sortedSet.getIterator(), s = e.sortedSet.getIterator(); for (; t.hasNext();) { const c = t.getNext().key, f = s.getNext().key; if (!c.isEqual(f)) return !1 } return !0 } toString() { const e = []; return this.forEach(t => { e.push(t.toString()) }), 0 === e.length ? "DocumentSet ()" : "DocumentSet (\n  " + e.join("  \n") + "\n)" } copy(e, t) { const s = new Pd; return s.comparator = this.comparator, s.keyedMap = e, s.sortedSet = t, s } } class Pv { constructor() { this.Cu = new ur(Bn.comparator) } track(e) { const t = e.doc.key, s = this.Cu.get(t); s ? 0 !== e.type && 3 === s.type ? this.Cu = this.Cu.insert(t, e) : 3 === e.type && 1 !== s.type ? this.Cu = this.Cu.insert(t, { type: s.type, doc: e.doc }) : 2 === e.type && 2 === s.type ? this.Cu = this.Cu.insert(t, { type: 2, doc: e.doc }) : 2 === e.type && 0 === s.type ? this.Cu = this.Cu.insert(t, { type: 0, doc: e.doc }) : 1 === e.type && 0 === s.type ? this.Cu = this.Cu.remove(t) : 1 === e.type && 2 === s.type ? this.Cu = this.Cu.insert(t, { type: 1, doc: s.doc }) : 0 === e.type && 1 === s.type ? this.Cu = this.Cu.insert(t, { type: 2, doc: e.doc }) : Cn() : this.Cu = this.Cu.insert(t, e) } xu() { const e = []; return this.Cu.inorderTraversal((t, s) => { e.push(s) }), e } } class id { constructor(e, t, s, c, f, _, R, j, te) { this.query = e, this.docs = t, this.oldDocs = s, this.docChanges = c, this.mutatedKeys = f, this.fromCache = _, this.syncStateChanged = R, this.excludesMetadataChanges = j, this.hasCachedResults = te } static fromInitialDocuments(e, t, s, c, f) { const _ = []; return t.forEach(R => { _.push({ type: 0, doc: R }) }), new id(e, t, Pd.emptySet(t), _, s, c, !0, !1, f) } get hasPendingWrites() { return !this.mutatedKeys.isEmpty() } isEqual(e) { if (!(this.fromCache === e.fromCache && this.hasCachedResults === e.hasCachedResults && this.syncStateChanged === e.syncStateChanged && this.mutatedKeys.isEqual(e.mutatedKeys) && Tt(this.query, e.query) && this.docs.isEqual(e.docs) && this.oldDocs.isEqual(e.oldDocs))) return !1; const t = this.docChanges, s = e.docChanges; if (t.length !== s.length) return !1; for (let c = 0; c < t.length; c++)if (t[c].type !== s[c].type || !t[c].doc.isEqual(s[c].doc)) return !1; return !0 } } class Gg { constructor() { this.Nu = void 0, this.listeners = [] } } class yc { constructor() { this.queries = new Xs(e => Xt(e), Tt), this.onlineState = "Unknown", this.ku = new Set } } function wc(r, e) { return Yh.apply(this, arguments) } function Yh() { return Yh = (0, a.Z)(function* (r, e) { const t = Un(r), s = e.query; let c = !1, f = t.queries.get(s); if (f || (c = !0, f = new Gg), c) try { f.Nu = yield t.onListen(s) } catch (_) { const R = Od(_, `Initialization of query '${Nn(e.query)}' failed`); return void e.onError(R) } t.queries.set(s, f), f.listeners.push(e), e.Mu(t.onlineState), f.Nu && e.$u(f.Nu) && rd(t) }), Yh.apply(this, arguments) } function Nm(r, e) { return Nd.apply(this, arguments) } function Nd() { return Nd = (0, a.Z)(function* (r, e) { const t = Un(r), s = e.query; let c = !1; const f = t.queries.get(s); if (f) { const _ = f.listeners.indexOf(e); _ >= 0 && (f.listeners.splice(_, 1), c = 0 === f.listeners.length) } if (c) return t.queries.delete(s), t.onUnlisten(s) }), Nd.apply(this, arguments) } function Fd(r, e) { const t = Un(r); let s = !1; for (const c of e) { const _ = t.queries.get(c.query); if (_) { for (const R of _.listeners) R.$u(c) && (s = !0); _.Nu = c } } s && rd(t) } function Fm(r, e, t) { const s = Un(r), c = s.queries.get(e); if (c) for (const f of c.listeners) f.onError(t); s.queries.delete(e) } function rd(r) { r.ku.forEach(e => { e.next() }) } class qh { constructor(e, t, s) { this.query = e, this.Ou = t, this.Fu = !1, this.Bu = null, this.onlineState = "Unknown", this.options = s || {} } $u(e) { if (!this.options.includeMetadataChanges) { const s = []; for (const c of e.docChanges) 3 !== c.type && s.push(c); e = new id(e.query, e.docs, e.oldDocs, s, e.mutatedKeys, e.fromCache, e.syncStateChanged, !0, e.hasCachedResults) } let t = !1; return this.Fu ? this.Lu(e) && (this.Ou.next(e), t = !0) : this.qu(e, this.onlineState) && (this.Uu(e), t = !0), this.Bu = e, t } onError(e) { this.Ou.error(e) } Mu(e) { this.onlineState = e; let t = !1; return this.Bu && !this.Fu && this.qu(this.Bu, e) && (this.Uu(this.Bu), t = !0), t } qu(e, t) { return !e.fromCache || (!this.options.Ku || !("Offline" !== t)) && (!e.docs.isEmpty() || e.hasCachedResults || "Offline" === t) } Lu(e) { return e.docChanges.length > 0 || !!(e.syncStateChanged || this.Bu && this.Bu.hasPendingWrites !== e.hasPendingWrites) && !0 === this.options.includeMetadataChanges } Uu(e) { e = id.fromInitialDocuments(e.query, e.docs, e.mutatedKeys, e.fromCache, e.hasCachedResults), this.Fu = !0, this.Ou.next(e) } } class Lm { constructor(e, t) { this.Gu = e, this.byteLength = t } Qu() { return "metadata" in this.Gu } } class Qh { constructor(e) { this.serializer = e } rr(e) { return Na(this.serializer, e) } ur(e) { return e.metadata.exists ? Cd(this.serializer, e.document, !1) : So.newNoDocument(this.rr(e.metadata.name), this.cr(e.metadata.readTime)) } cr(e) { return ss(e) } } class Bm { constructor(e, t, s) { this.ju = e, this.localStore = t, this.serializer = s, this.queries = [], this.documents = [], this.collectionGroups = new Set, this.progress = Um(e) } zu(e) { this.progress.bytesLoaded += e.byteLength; let t = this.progress.documentsLoaded; if (e.Gu.namedQuery) this.queries.push(e.Gu.namedQuery); else if (e.Gu.documentMetadata) { this.documents.push({ metadata: e.Gu.documentMetadata }), e.Gu.documentMetadata.exists || ++t; const s = Pi.fromString(e.Gu.documentMetadata.name); this.collectionGroups.add(s.get(s.length - 2)) } else e.Gu.document && (this.documents[this.documents.length - 1].document = e.Gu.document, ++t); return t !== this.progress.documentsLoaded ? (this.progress.documentsLoaded = t, Object.assign({}, this.progress)) : null } Wu(e) { const t = new Map, s = new Qh(this.serializer); for (const c of e) if (c.metadata.queries) { const f = s.rr(c.metadata.name); for (const _ of c.metadata.queries) { const R = (t.get(_) || Oi()).add(f); t.set(_, R) } } return t } complete() { var e = this; return (0, a.Z)(function* () { const t = yield function Em(r, e, t, s) { return Ou.apply(this, arguments) }(e.localStore, new Qh(e.serializer), e.documents, e.ju.id), s = e.Wu(e.documents); for (const c of e.queries) yield Ig(e.localStore, c, s.get(c.name)); return e.progress.taskState = "Success", { progress: e.progress, Hu: e.collectionGroups, Ju: t } })() } } function Um(r) { return { taskState: "Running", documentsLoaded: 0, bytesLoaded: 0, totalDocuments: r.totalDocuments, totalBytes: r.totalBytes } } class Xh { constructor(e) { this.key = e } } class Wg { constructor(e) { this.key = e } } class Kg { constructor(e, t) { this.query = e, this.Yu = t, this.Xu = null, this.hasCachedResults = !1, this.current = !1, this.Zu = Oi(), this.mutatedKeys = Oi(), this.tc = hr(e), this.ec = new Pd(this.tc) } get nc() { return this.Yu } sc(e, t) { const s = t ? t.ic : new Pv, c = t ? t.ec : this.ec; let f = t ? t.mutatedKeys : this.mutatedKeys, _ = c, R = !1; const j = "F" === this.query.limitType && c.size === this.query.limit ? c.last() : null, te = "L" === this.query.limitType && c.size === this.query.limit ? c.first() : null; if (e.inorderTraversal((Ce, ot) => { const Gt = c.get(Ce), an = zn(this.query, ot) ? ot : null, kn = !!Gt && this.mutatedKeys.has(Gt.key), Yn = !!an && (an.hasLocalMutations || this.mutatedKeys.has(an.key) && an.hasCommittedMutations); let ti = !1; Gt && an ? Gt.data.isEqual(an.data) ? kn !== Yn && (s.track({ type: 3, doc: an }), ti = !0) : this.rc(Gt, an) || (s.track({ type: 2, doc: an }), ti = !0, (j && this.tc(an, j) > 0 || te && this.tc(an, te) < 0) && (R = !0)) : !Gt && an ? (s.track({ type: 0, doc: an }), ti = !0) : Gt && !an && (s.track({ type: 1, doc: Gt }), ti = !0, (j || te) && (R = !0)), ti && (an ? (_ = _.add(an), f = Yn ? f.add(Ce) : f.delete(Ce)) : (_ = _.delete(Ce), f = f.delete(Ce))) }), null !== this.query.limit) for (; _.size > this.query.limit;) { const Ce = "F" === this.query.limitType ? _.last() : _.first(); _ = _.delete(Ce.key), f = f.delete(Ce.key), s.track({ type: 1, doc: Ce }) } return { ec: _, ic: s, zi: R, mutatedKeys: f } } rc(e, t) { return e.hasLocalMutations && t.hasCommittedMutations && !t.hasLocalMutations } applyChanges(e, t, s) { const c = this.ec; this.ec = e.ec, this.mutatedKeys = e.mutatedKeys; const f = e.ic.xu(); f.sort((te, Ce) => function (ot, Gt) { const an = kn => { switch (kn) { case 0: return 1; case 2: case 3: return 2; case 1: return 0; default: return Cn() } }; return an(ot) - an(Gt) }(te.type, Ce.type) || this.tc(te.doc, Ce.doc)), this.oc(s); const _ = t ? this.uc() : [], R = 0 === this.Zu.size && this.current ? 1 : 0, j = R !== this.Xu; return this.Xu = R, 0 !== f.length || j ? { snapshot: new id(this.query, e.ec, c, f, e.mutatedKeys, 0 === R, j, !1, !!s && s.resumeToken.approximateByteSize() > 0), cc: _ } : { cc: _ } } Mu(e) { return this.current && "Offline" === e ? (this.current = !1, this.applyChanges({ ec: this.ec, ic: new Pv, mutatedKeys: this.mutatedKeys, zi: !1 }, !1)) : { cc: [] } } ac(e) { return !this.Yu.has(e) && !!this.ec.has(e) && !this.ec.get(e).hasLocalMutations } oc(e) { e && (e.addedDocuments.forEach(t => this.Yu = this.Yu.add(t)), e.modifiedDocuments.forEach(t => { }), e.removedDocuments.forEach(t => this.Yu = this.Yu.delete(t)), this.current = e.current) } uc() { if (!this.current) return []; const e = this.Zu; this.Zu = Oi(), this.ec.forEach(s => { this.ac(s.key) && (this.Zu = this.Zu.add(s.key)) }); const t = []; return e.forEach(s => { this.Zu.has(s) || t.push(new Wg(s)) }), this.Zu.forEach(s => { e.has(s) || t.push(new Xh(s)) }), t } hc(e) { this.Yu = e.ir, this.Zu = Oi(); const t = this.sc(e.documents); return this.applyChanges(t, !0) } lc() { return id.fromInitialDocuments(this.query, this.ec, this.mutatedKeys, 0 === this.Xu, this.hasCachedResults) } } class Nv { constructor(e, t, s) { this.query = e, this.targetId = t, this.view = s } } class Zg { constructor(e) { this.key = e, this.fc = !1 } } class Fv { constructor(e, t, s, c, f, _) { this.localStore = e, this.remoteStore = t, this.eventManager = s, this.sharedClientState = c, this.currentUser = f, this.maxConcurrentLimboResolutions = _, this.dc = {}, this.wc = new Xs(R => Xt(R), Tt), this._c = new Map, this.mc = new Set, this.gc = new ur(Bn.comparator), this.yc = new Map, this.Ic = new Wl, this.Tc = {}, this.Ec = new Map, this.Ac = Dd.Mn(), this.onlineState = "Unknown", this.vc = void 0 } get isPrimaryClient() { return !0 === this.vc } } function Lv(r, e) { return Vm.apply(this, arguments) } function Vm() { return Vm = (0, a.Z)(function* (r, e) { const t = o_(r); let s, c; const f = t.wc.get(e); if (f) s = f.targetId, t.sharedClientState.addLocalQueryTarget(s), c = f.view.lc(); else { const _ = yield Ml(t.localStore, k(e)), R = t.sharedClientState.addLocalQueryTarget(_.targetId); s = _.targetId, c = yield Hm(t, e, s, "current" === R, _.resumeToken), t.isPrimaryClient && Ad(t.remoteStore, _) } return c }), Vm.apply(this, arguments) } function Hm(r, e, t, s, c) { return Jh.apply(this, arguments) } function Jh() { return Jh = (0, a.Z)(function* (r, e, t, s, c) { r.Rc = (ot, Gt, an) => { return (kn = (0, a.Z)(function* (Yn, ti, Qi, Rr) { let pr = ti.view.sc(Qi); pr.zi && (pr = yield ku(Yn.localStore, ti.query, !1).then(({ documents: Co }) => ti.view.sc(Co, pr))); const Ls = Rr && Rr.targetChanges.get(ti.targetId), ls = ti.view.applyChanges(pr, Yn.isPrimaryClient, Ls); return Zm(Yn, ti.targetId, ls.cc), ls.snapshot }), function (Yn, ti, Qi, Rr) { return kn.apply(this, arguments) })(r, ot, Gt, an); var kn }; const f = yield ku(r.localStore, e, !0), _ = new Kg(e, f.ir), R = _.sc(f.documents), j = zc.createSynthesizedTargetChangeForCurrentChange(t, s && "Offline" !== r.onlineState, c), te = _.applyChanges(R, r.isPrimaryClient, j); Zm(r, t, te.cc); const Ce = new Nv(e, t, _); return r.wc.set(e, Ce), r._c.has(t) ? r._c.get(t).push(e) : r._c.set(t, [e]), te.snapshot }), Jh.apply(this, arguments) } function Yg(r, e) { return zm.apply(this, arguments) } function zm() { return zm = (0, a.Z)(function* (r, e) { const t = Un(r), s = t.wc.get(e), c = t._c.get(s.targetId); if (c.length > 1) return t._c.set(s.targetId, c.filter(f => !Tt(f, e))), void t.wc.delete(e); t.isPrimaryClient ? (t.sharedClientState.removeLocalQueryTarget(s.targetId), t.sharedClientState.isActiveQueryTarget(s.targetId) || (yield Kl(t.localStore, s.targetId, !1).then(() => { t.sharedClientState.clearQueryState(s.targetId), Sl(t.remoteStore, s.targetId), Ld(t, s.targetId) }).catch(Ps))) : (Ld(t, s.targetId), yield Kl(t.localStore, s.targetId, !0)) }), zm.apply(this, arguments) } function Ia() { return Ia = (0, a.Z)(function* (r, e, t) { const s = af(r); try { const c = yield function (f, _) { const R = Un(f), j = Ri.now(), te = _.reduce((Gt, an) => Gt.add(an.key), Oi()); let Ce, ot; return R.persistence.runTransaction("Locally write mutations", "readwrite", Gt => { let an = ca(), kn = Oi(); return R.Zi.getEntries(Gt, te).next(Yn => { an = Yn, an.forEach((ti, Qi) => { Qi.isValidDocument() || (kn = kn.add(ti)) }) }).next(() => R.localDocuments.getOverlayedDocuments(Gt, an)).next(Yn => { Ce = Yn; const ti = []; for (const Qi of _) { const Rr = sv(Qi, Ce.get(Qi.key).overlayedDocument); null != Rr && ti.push(new Dl(Qi.key, Rr, ml(Rr.value.mapValue), fr.exists(!0))) } return R.mutationQueue.addMutationBatch(Gt, j, ti, _) }).next(Yn => { ot = Yn; const ti = Yn.applyToLocalDocumentSet(Ce, kn); return R.documentOverlayCache.saveOverlays(Gt, Yn.batchId, ti) }) }).then(() => ({ batchId: ot.batchId, changes: du(Ce) })) }(s.localStore, e); s.sharedClientState.addPendingMutation(c.batchId), function (f, _, R) { let j = f.Tc[f.currentUser.toKey()]; j || (j = new ur(Ei)), j = j.insert(_, R), f.Tc[f.currentUser.toKey()] = j }(s, c.batchId, t), yield xl(s, c.changes), yield Uu(s.remoteStore) } catch (c) { const f = Od(c, "Failed to persist write"); t.reject(f) } }), Ia.apply(this, arguments) } function qg(r, e) { return jm.apply(this, arguments) } function jm() { return jm = (0, a.Z)(function* (r, e) { const t = Un(r); try { const s = yield function Au(r, e) { const t = Un(r), s = e.snapshotVersion; let c = t.Ji; return t.persistence.runTransaction("Apply remote event", "readwrite-primary", f => { const _ = t.Zi.newChangeBuffer({ trackRemovals: !0 }); c = t.Ji; const R = []; e.targetChanges.forEach((Ce, ot) => { const Gt = c.get(ot); if (!Gt) return; R.push(t.Bs.removeMatchingKeys(f, Ce.removedDocuments, ot).next(() => t.Bs.addMatchingKeys(f, Ce.addedDocuments, ot))); let an = Gt.withSequenceNumber(f.currentSequenceNumber); var kn, Yn, ti; null !== e.targetMismatches.get(ot) ? an = an.withResumeToken(Lo.EMPTY_BYTE_STRING, Jn.min()).withLastLimboFreeSnapshotVersion(Jn.min()) : Ce.resumeToken.approximateByteSize() > 0 && (an = an.withResumeToken(Ce.resumeToken, s)), c = c.insert(ot, an), Yn = an, ti = Ce, (0 === (kn = Gt).resumeToken.approximateByteSize() || Yn.snapshotVersion.toMicroseconds() - kn.snapshotVersion.toMicroseconds() >= 3e8 || ti.addedDocuments.size + ti.modifiedDocuments.size + ti.removedDocuments.size > 0) && R.push(t.Bs.updateTargetData(f, an)) }); let j = ca(), te = Oi(); if (e.documentUpdates.forEach(Ce => { e.resolvedLimboDocuments.has(Ce) && R.push(t.persistence.referenceDelegate.updateLimboDocument(f, Ce)) }), R.push(Nh(f, _, e.documentUpdates).next(Ce => { j = Ce.nr, te = Ce.sr })), !s.isEqual(Jn.min())) { const Ce = t.Bs.getLastRemoteSnapshotVersion(f).next(ot => t.Bs.setTargetsMetadata(f, f.currentSequenceNumber, s)); R.push(Ce) } return I.waitFor(R).next(() => _.apply(f)).next(() => t.localDocuments.getLocalViewOfDocuments(f, j, te)).next(() => j) }).then(f => (t.Ji = c, f)) }(t.localStore, e); e.targetChanges.forEach((c, f) => { const _ = t.yc.get(f); _ && (ai(c.addedDocuments.size + c.modifiedDocuments.size + c.removedDocuments.size <= 1), c.addedDocuments.size > 0 ? _.fc = !0 : c.modifiedDocuments.size > 0 ? ai(_.fc) : c.removedDocuments.size > 0 && (ai(_.fc), _.fc = !1)) }), yield xl(t, s, e) } catch (s) { yield Ps(s) } }), jm.apply(this, arguments) } function Uv(r, e, t) { const s = Un(r); if (s.isPrimaryClient && 0 === t || !s.isPrimaryClient && 1 === t) { const c = []; s.wc.forEach((f, _) => { const R = _.view.Mu(e); R.snapshot && c.push(R.snapshot) }), function (f, _) { const R = Un(f); R.onlineState = _; let j = !1; R.queries.forEach((te, Ce) => { for (const ot of Ce.listeners) ot.Mu(_) && (j = !0) }), j && rd(R) }(s.eventManager, e), c.length && s.dc.nu(c), s.onlineState = e, s.isPrimaryClient && s.sharedClientState.setOnlineState(e) } } function $m(r, e, t) { return ef.apply(this, arguments) } function ef() { return ef = (0, a.Z)(function* (r, e, t) { const s = Un(r); s.sharedClientState.updateQueryState(e, "rejected", t); const c = s.yc.get(e), f = c && c.key; if (f) { let _ = new ur(Bn.comparator); _ = _.insert(f, So.newNoDocument(f, Jn.min())); const R = Oi().add(f), j = new wd(Jn.min(), new Map, new ur(Ei), _, R); yield qg(s, j), s.gc = s.gc.remove(f), s.yc.delete(e), il(s) } else yield Kl(s.localStore, e, !1).then(() => Ld(s, e, t)).catch(Ps) }), ef.apply(this, arguments) } function Vv(r, e) { return Gm.apply(this, arguments) } function Gm() { return Gm = (0, a.Z)(function* (r, e) { const t = Un(r), s = e.batch.batchId; try { const c = yield function wm(r, e) { const t = Un(r); return t.persistence.runTransaction("Acknowledge batch", "readwrite-primary", s => { const c = e.batch.keys(), f = t.Zi.newChangeBuffer({ trackRemovals: !0 }); return function (_, R, j, te) { const Ce = j.batch, ot = Ce.keys(); let Gt = I.resolve(); return ot.forEach(an => { Gt = Gt.next(() => te.getEntry(R, an)).next(kn => { const Yn = j.docVersions.get(an); ai(null !== Yn), kn.version.compareTo(Yn) < 0 && (Ce.applyToRemoteDocument(kn, j), kn.isValidDocument() && (kn.setReadTime(j.commitVersion), te.addEntry(kn))) }) }), Gt.next(() => _.mutationQueue.removeMutationBatch(R, Ce)) }(t, s, e, f).next(() => f.apply(s)).next(() => t.mutationQueue.performConsistencyCheck(s)).next(() => t.documentOverlayCache.removeOverlaysForBatchId(s, c, e.batch.batchId)).next(() => t.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(s, function (_) { let R = Oi(); for (let j = 0; j < _.mutationResults.length; ++j)_.mutationResults[j].transformResults.length > 0 && (R = R.add(_.batch.mutations[j].key)); return R }(e))).next(() => t.localDocuments.getDocuments(s, c)) }) }(t.localStore, e); Km(t, s, null), Vu(t, s), t.sharedClientState.updateMutationState(s, "acknowledged"), yield xl(t, c) } catch (c) { yield Ps(c) } }), Gm.apply(this, arguments) } function Hv(r, e, t) { return tf.apply(this, arguments) } function tf() { return tf = (0, a.Z)(function* (r, e, t) { const s = Un(r); try { const c = yield function (f, _) { const R = Un(f); return R.persistence.runTransaction("Reject batch", "readwrite-primary", j => { let te; return R.mutationQueue.lookupMutationBatch(j, _).next(Ce => (ai(null !== Ce), te = Ce.keys(), R.mutationQueue.removeMutationBatch(j, Ce))).next(() => R.mutationQueue.performConsistencyCheck(j)).next(() => R.documentOverlayCache.removeOverlaysForBatchId(j, te, _)).next(() => R.localDocuments.recalculateAndSaveOverlaysForDocumentKeys(j, te)).next(() => R.localDocuments.getDocuments(j, te)) }) }(s.localStore, e); Km(s, e, t), Vu(s, e), s.sharedClientState.updateMutationState(e, "rejected", t), yield xl(s, c) } catch (c) { yield Ps(c) } }), tf.apply(this, arguments) } function Wm() { return Wm = (0, a.Z)(function* (r, e) { const t = Un(r); vc(t.remoteStore) || pn("SyncEngine", "The network is disabled. The task returned by 'awaitPendingWrites()' will not complete until the network is enabled."); try { const s = yield function (f) { const _ = Un(f); return _.persistence.runTransaction("Get highest unacknowledged batch id", "readonly", R => _.mutationQueue.getHighestUnacknowledgedBatchId(R)) }(t.localStore); if (-1 === s) return void e.resolve(); const c = t.Ec.get(s) || []; c.push(e), t.Ec.set(s, c) } catch (s) { const c = Od(s, "Initialization of waitForPendingWrites() operation failed"); e.reject(c) } }), Wm.apply(this, arguments) } function Vu(r, e) { (r.Ec.get(e) || []).forEach(t => { t.resolve() }), r.Ec.delete(e) } function Km(r, e, t) { const s = Un(r); let c = s.Tc[s.currentUser.toKey()]; if (c) { const f = c.get(e); f && (t ? f.reject(t) : f.resolve(), c = c.remove(e)), s.Tc[s.currentUser.toKey()] = c } } function Ld(r, e, t = null) { r.sharedClientState.removeLocalQueryTarget(e); for (const s of r._c.get(e)) r.wc.delete(s), t && r.dc.Pc(s, t); r._c.delete(e), r.isPrimaryClient && r.Ic.Is(e).forEach(s => { r.Ic.containsKey(s) || Qg(r, s) }) } function Qg(r, e) { r.mc.delete(e.path.canonicalString()); const t = r.gc.get(e); null !== t && (Sl(r.remoteStore, t), r.gc = r.gc.remove(e), r.yc.delete(t), il(r)) } function Zm(r, e, t) { for (const s of t) s instanceof Xh ? (r.Ic.addReference(s.key, e), jv(r, s)) : s instanceof Wg ? (pn("SyncEngine", "Document no longer in limbo: " + s.key), r.Ic.removeReference(s.key, e), r.Ic.containsKey(s.key) || Qg(r, s.key)) : Cn() } function jv(r, e) { const t = e.key, s = t.path.canonicalString(); r.gc.get(t) || r.mc.has(s) || (pn("SyncEngine", "New document in limbo: " + t), r.mc.add(s), il(r)) } function il(r) { for (; r.mc.size > 0 && r.gc.size < r.maxConcurrentLimboResolutions;) { const e = r.mc.values().next().value; r.mc.delete(e); const t = new Bn(Pi.fromString(e)), s = r.Ac.next(); r.yc.set(s, new Zg(t)), r.gc = r.gc.insert(t, s), Ad(r.remoteStore, new vl(k(Vl(t.path)), s, "TargetPurposeLimboResolution", An.ct)) } } function xl(r, e, t) { return Ym.apply(this, arguments) } function Ym() { return Ym = (0, a.Z)(function* (r, e, t) { const s = Un(r), c = [], f = [], _ = []; var R; s.wc.isEmpty() || (s.wc.forEach((R, j) => { _.push(s.Rc(j, e, t).then(te => { if ((te || t) && s.isPrimaryClient && s.sharedClientState.updateQueryState(j.targetId, te?.fromCache ? "not-current" : "current"), te) { c.push(te); const Ce = bm.Li(j.targetId, te); f.push(Ce) } })) }), yield Promise.all(_), s.dc.nu(c), yield (R = (0, a.Z)(function* (j, te) { const Ce = Un(j); try { yield Ce.persistence.runTransaction("notifyLocalViewChanges", "readwrite", ot => I.forEach(te, Gt => I.forEach(Gt.Fi, an => Ce.persistence.referenceDelegate.addReference(ot, Gt.targetId, an)).next(() => I.forEach(Gt.Bi, an => Ce.persistence.referenceDelegate.removeReference(ot, Gt.targetId, an))))) } catch (ot) { if (!M(ot)) throw ot; pn("LocalStore", "Failed to update sequence numbers: " + ot) } for (const ot of te) { const Gt = ot.targetId; if (!ot.fromCache) { const an = Ce.Ji.get(Gt), Yn = an.withLastLimboFreeSnapshotVersion(an.snapshotVersion); Ce.Ji = Ce.Ji.insert(Gt, Yn) } } }), function (j, te) { return R.apply(this, arguments) })(s.localStore, f)) }), Ym.apply(this, arguments) } function Xg(r, e) { return qm.apply(this, arguments) } function qm() { return qm = (0, a.Z)(function* (r, e) { const t = Un(r); if (!t.currentUser.isEqual(e)) { pn("SyncEngine", "User change. New user:", e.toKey()); const s = yield Su(t.localStore, e); t.currentUser = e, (c = t).Ec.forEach(_ => { _.forEach(R => { R.reject(new _n(Yt.CANCELLED, "'waitForPendingWrites' promise is rejected due to a user change.")) }) }), c.Ec.clear(), t.sharedClientState.handleUserChange(e, s.removedBatchIds, s.addedBatchIds), yield xl(t, s.er) } var c }), qm.apply(this, arguments) } function Jg(r, e) { const t = Un(r), s = t.yc.get(e); if (s && s.fc) return Oi().add(s.key); { let c = Oi(); const f = t._c.get(e); if (!f) return c; for (const _ of f) { const R = t.wc.get(_); c = c.unionWith(R.view.nc) } return c } } function e_(r, e) { return Bd.apply(this, arguments) } function Bd() { return Bd = (0, a.Z)(function* (r, e) { const t = Un(r), s = yield ku(t.localStore, e.query, !0), c = e.view.hc(s); return t.isPrimaryClient && Zm(t, e.targetId, c.cc), c }), Bd.apply(this, arguments) } function Qm(r, e) { return t_.apply(this, arguments) } function t_() { return t_ = (0, a.Z)(function* (r, e) { const t = Un(r); return Ru(t.localStore, e).then(s => xl(t, s)) }), t_.apply(this, arguments) } function n_(r, e, t, s) { return nf.apply(this, arguments) } function nf() { return nf = (0, a.Z)(function* (r, e, t, s) { const c = Un(r), f = yield function (_, R) { const j = Un(_), te = Un(j.mutationQueue); return j.persistence.runTransaction("Lookup mutation documents", "readonly", Ce => te.Sn(Ce, R).next(ot => ot ? j.localDocuments.getDocuments(Ce, ot) : I.resolve(null))) }(c.localStore, e); var R; null !== f ? ("pending" === t ? yield Uu(c.remoteStore) : "acknowledged" === t || "rejected" === t ? (Km(c, e, s || null), Vu(c, e), R = e, Un(Un(c.localStore).mutationQueue).Cn(R)) : Cn(), yield xl(c, f)) : pn("SyncEngine", "Cannot apply mutation batch with id: " + e) }), nf.apply(this, arguments) } function rf() { return rf = (0, a.Z)(function* (r, e) { const t = Un(r); if (o_(t), af(t), !0 === e && !0 !== t.vc) { const s = t.sharedClientState.getAllActiveQueryTargets(), c = yield sf(t, s.toArray()); t.vc = !0, yield Om(t.remoteStore, !0); for (const f of c) Ad(t.remoteStore, f) } else if (!1 === e && !1 !== t.vc) { const s = []; let c = Promise.resolve(); t._c.forEach((f, _) => { t.sharedClientState.isLocalQueryTarget(_) ? s.push(_) : c = c.then(() => (Ld(t, _), Kl(t.localStore, _, !0))), Sl(t.remoteStore, _) }), yield c, yield sf(t, s), function (f) { const _ = Un(f); _.yc.forEach((R, j) => { Sl(_.remoteStore, j) }), _.Ic.Ts(), _.yc = new Map, _.gc = new ur(Bn.comparator) }(t), t.vc = !1, yield Om(t.remoteStore, !1) } }), rf.apply(this, arguments) } function sf(r, e, t) { return El.apply(this, arguments) } function El() { return El = (0, a.Z)(function* (r, e, t) { const s = Un(r), c = [], f = []; for (const _ of e) { let R; const j = s._c.get(_); if (j && 0 !== j.length) { R = yield Ml(s.localStore, k(j[0])); for (const te of j) { const Ce = s.wc.get(te), ot = yield e_(s, Ce); ot.snapshot && f.push(ot.snapshot) } } else { const te = yield Fh(s.localStore, _); R = yield Ml(s.localStore, te), yield Hm(s, r_(te), _, !1, R.resumeToken) } c.push(R) } return s.dc.nu(f), c }), El.apply(this, arguments) } function r_(r) { return Nf(r.path, r.collectionGroup, r.orderBy, r.filters, r.limit, "F", r.startAt, r.endAt) } function $v(r) { const e = Un(r); return Un(Un(e.localStore).persistence).$i() } function Xm(r, e, t, s) { return Jm.apply(this, arguments) } function Jm() { return Jm = (0, a.Z)(function* (r, e, t, s) { const c = Un(r); if (c.vc) return void pn("SyncEngine", "Ignoring unexpected query state notification."); const f = c._c.get(e); if (f && f.length > 0) switch (t) { case "current": case "not-current": { const _ = yield Ru(c.localStore, vi(f[0])), R = wd.createSynthesizedRemoteEventForCurrentChange(e, "current" === t, Lo.EMPTY_BYTE_STRING); yield xl(c, _, R); break } case "rejected": yield Kl(c.localStore, e, !0), Ld(c, e, s); break; default: Cn() } }), Jm.apply(this, arguments) } function Gv(r, e, t) { return ep.apply(this, arguments) } function ep() { return ep = (0, a.Z)(function* (r, e, t) { const s = o_(r); if (s.vc) { for (const c of e) { if (s._c.has(c)) { pn("SyncEngine", "Adding an already active target " + c); continue } const f = yield Fh(s.localStore, c), _ = yield Ml(s.localStore, f); yield Hm(s, r_(f), _.targetId, !1, _.resumeToken), Ad(s.remoteStore, _) } for (const c of t) s._c.has(c) && (yield Kl(s.localStore, c, !1).then(() => { Sl(s.remoteStore, c), Ld(s, c) }).catch(Ps)) } }), ep.apply(this, arguments) } function o_(r) { const e = Un(r); return e.remoteStore.remoteSyncer.applyRemoteEvent = qg.bind(null, e), e.remoteStore.remoteSyncer.getRemoteKeysForTarget = Jg.bind(null, e), e.remoteStore.remoteSyncer.rejectListen = $m.bind(null, e), e.dc.nu = Fd.bind(null, e.eventManager), e.dc.Pc = Fm.bind(null, e.eventManager), e } function af(r) { const e = Un(r); return e.remoteStore.remoteSyncer.applySuccessfulWrite = Vv.bind(null, e), e.remoteStore.remoteSyncer.rejectFailedWrite = Hv.bind(null, e), e } class xc { constructor() { this.synchronizeTabs = !1 } initialize(e) { var t = this; return (0, a.Z)(function* () { t.serializer = Lu(e.databaseInfo.databaseId), t.sharedClientState = t.createSharedClientState(e), t.persistence = t.createPersistence(e), yield t.persistence.start(), t.localStore = t.createLocalStore(e), t.gcScheduler = t.createGarbageCollectionScheduler(e, t.localStore), t.indexBackfillerScheduler = t.createIndexBackfillerScheduler(e, t.localStore) })() } createGarbageCollectionScheduler(e, t) { return null } createIndexBackfillerScheduler(e, t) { return null } createLocalStore(e) { return Iv(this.persistence, new Cg, e.initialUser, this.serializer) } createPersistence(e) { return new pc(kh.zs, this.serializer) } createSharedClientState(e) { return new Tg } terminate() { var e = this; return (0, a.Z)(function* () { e.gcScheduler && e.gcScheduler.stop(), yield e.sharedClientState.shutdown(), yield e.persistence.shutdown() })() } } class Ud extends xc { constructor(e, t, s) { super(), this.Vc = e, this.cacheSizeBytes = t, this.forceOwnership = s, this.synchronizeTabs = !1 } initialize(e) { var t = () => super.initialize, s = this; return (0, a.Z)(function* () { yield t().call(s, e), yield s.Vc.initialize(s, e), yield af(s.Vc.syncEngine), yield Uu(s.Vc.remoteStore), yield s.persistence.Ii(() => (s.gcScheduler && !s.gcScheduler.started && s.gcScheduler.start(), s.indexBackfillerScheduler && !s.indexBackfillerScheduler.started && s.indexBackfillerScheduler.start(), Promise.resolve())) })() } createLocalStore(e) { return Iv(this.persistence, new Cg, e.initialUser, this.serializer) } createGarbageCollectionScheduler(e, t) { return new am(this.persistence.referenceDelegate.garbageCollector, e.asyncQueue, t) } createIndexBackfillerScheduler(e, t) { const s = new xn(t, this.persistence); return new zt(e.asyncQueue, s) } createPersistence(e) { const t = vm(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey), s = void 0 !== this.cacheSizeBytes ? Gs.withCacheSize(this.cacheSizeBytes) : Gs.DEFAULT; return new Oh(this.synchronizeTabs, t, e.clientId, s, e.asyncQueue, Ag(), gc(), this.serializer, this.sharedClientState, !!this.forceOwnership) } createSharedClientState(e) { return new Tg } } class Kv extends Ud { constructor(e, t) { super(e, t, !1), this.Vc = e, this.cacheSizeBytes = t, this.synchronizeTabs = !0 } initialize(e) { var t = () => super.initialize, s = this; return (0, a.Z)(function* () { yield t().call(s, e); const c = s.Vc.syncEngine; s.sharedClientState instanceof Fu && (s.sharedClientState.syncEngine = { jr: n_.bind(null, c), zr: Xm.bind(null, c), Wr: Gv.bind(null, c), $i: $v.bind(null, c), Qr: Qm.bind(null, c) }, yield s.sharedClientState.start()), yield s.persistence.Ii(function () { var f = (0, a.Z)(function* (_) { yield function i_(r, e) { return rf.apply(this, arguments) }(s.Vc.syncEngine, _), s.gcScheduler && (_ && !s.gcScheduler.started ? s.gcScheduler.start() : _ || s.gcScheduler.stop()), s.indexBackfillerScheduler && (_ && !s.indexBackfillerScheduler.started ? s.indexBackfillerScheduler.start() : _ || s.indexBackfillerScheduler.stop()) }); return function (_) { return f.apply(this, arguments) } }()) })() } createSharedClientState(e) { const t = Ag(); if (!Fu.D(t)) throw new _n(Yt.UNIMPLEMENTED, "IndexedDB persistence is only available on platforms that support LocalStorage."); const s = vm(e.databaseInfo.databaseId, e.databaseInfo.persistenceKey); return new Fu(t, e.asyncQueue, s, e.clientId, e.initialUser) } } class Vd { initialize(e, t) { var s = this; return (0, a.Z)(function* () { s.localStore || (s.localStore = e.localStore, s.sharedClientState = e.sharedClientState, s.datastore = s.createDatastore(t), s.remoteStore = s.createRemoteStore(t), s.eventManager = s.createEventManager(t), s.syncEngine = s.createSyncEngine(t, !e.synchronizeTabs), s.sharedClientState.onlineStateHandler = c => Uv(s.syncEngine, c, 1), s.remoteStore.remoteSyncer.handleCredentialChange = Xg.bind(null, s.syncEngine), yield Om(s.remoteStore, s.syncEngine.isPrimaryClient)) })() } createEventManager(e) { return new yc } createDatastore(e) { const t = Lu(e.databaseInfo.databaseId), s = new vy(e.databaseInfo); return new Sv(e.authCredentials, e.appCheckCredentials, s, t) } createRemoteStore(e) { return t = this.localStore, s = this.datastore, c = e.asyncQueue, f = R => Uv(this.syncEngine, R, 0), _ = Uh.D() ? new Uh : new Mg, new Og(t, s, c, f, _); var t, s, c, f, _ } createSyncEngine(e, t) { return function (s, c, f, _, R, j, te) { const Ce = new Fv(s, c, f, _, R, j); return te && (Ce.vc = !0), Ce }(this.localStore, this.remoteStore, this.eventManager, this.sharedClientState, e.initialUser, e.maxConcurrentLimboResolutions, t) } terminate() { return (e = (0, a.Z)(function* (t) { const s = Un(t); pn("RemoteStore", "RemoteStore shutting down."), s.vu.add(5), yield td(s), s.Pu.shutdown(), s.bu.set("Unknown") }), function (t) { return e.apply(this, arguments) })(this.remoteStore); var e } } function tp(r, e = 10240) { let t = 0; return { read: () => (0, a.Z)(function* () { if (t < r.byteLength) { const s = { value: r.slice(t, t + e), done: !1 }; return t += e, s } return { done: !0 } })(), cancel: () => (0, a.Z)(function* () { })(), releaseLock() { }, closed: Promise.resolve() } } class zu { constructor(e) { this.observer = e, this.muted = !1 } next(e) { this.observer.next && this.Sc(this.observer.next, e) } error(e) { this.observer.error ? this.Sc(this.observer.error, e) : er("Uncaught Error in snapshot listener:", e.toString()) } Dc() { this.muted = !0 } Sc(e, t) { this.muted || setTimeout(() => { this.muted || e(t) }, 0) } } class Zv { constructor(e, t) { this.Cc = e, this.serializer = t, this.metadata = new eo, this.buffer = new Uint8Array, this.xc = new TextDecoder("utf-8"), this.Nc().then(s => { s && s.Qu() ? this.metadata.resolve(s.Gu.metadata) : this.metadata.reject(new Error(`The first element of the bundle is not a metadata, it is\n             ${JSON.stringify(s?.Gu)}`)) }, s => this.metadata.reject(s)) } close() { return this.Cc.cancel() } getMetadata() { var e = this; return (0, a.Z)(function* () { return e.metadata.promise })() } bc() { var e = this; return (0, a.Z)(function* () { return yield e.getMetadata(), e.Nc() })() } Nc() { var e = this; return (0, a.Z)(function* () { const t = yield e.kc(); if (null === t) return null; const s = e.xc.decode(t), c = Number(s); isNaN(c) && e.Mc(`length string (${s}) is not valid number`); const f = yield e.$c(c); return new Lm(JSON.parse(f), t.length + c) })() } Oc() { return this.buffer.findIndex(e => e === "{".charCodeAt(0)) } kc() { var e = this; return (0, a.Z)(function* () { for (; e.Oc() < 0 && !(yield e.Fc());); if (0 === e.buffer.length) return null; const t = e.Oc(); t < 0 && e.Mc("Reached the end of bundle when a length string is expected."); const s = e.buffer.slice(0, t); return e.buffer = e.buffer.slice(t), s })() } $c(e) { var t = this; return (0, a.Z)(function* () { for (; t.buffer.length < e;)(yield t.Fc()) && t.Mc("Reached the end of bundle when more is expected."); const s = t.xc.decode(t.buffer.slice(0, e)); return t.buffer = t.buffer.slice(e), s })() } Mc(e) { throw this.Cc.cancel(), new Error(`Invalid bundle format: ${e}`) } Fc() { var e = this; return (0, a.Z)(function* () { const t = yield e.Cc.read(); if (!t.done) { const s = new Uint8Array(e.buffer.length + t.value.length); s.set(e.buffer), s.set(t.value, e.buffer.length), e.buffer = s } return t.done })() } } class Yv { constructor(e) { this.datastore = e, this.readVersions = new Map, this.mutations = [], this.committed = !1, this.lastWriteError = null, this.writtenDocs = new Set } lookup(e) { var t = this; return (0, a.Z)(function* () { if (t.ensureCommitNotCalled(), t.mutations.length > 0) throw new _n(Yt.INVALID_ARGUMENT, "Firestore transactions require all reads to be executed before all writes."); const s = yield (c = (0, a.Z)(function* (f, _) { const R = Un(f), j = lc(R.serializer) + "/documents", te = { documents: _.map(an => ac(R.serializer, an)) }, Ce = yield R.vo("BatchGetDocuments", j, te, _.length), ot = new Map; Ce.forEach(an => { const kn = function cv(r, e) { return "found" in e ? function (t, s) { ai(!!s.found); const c = Na(t, s.found.name), f = ss(s.found.updateTime), _ = s.found.createTime ? ss(s.found.createTime) : Jn.min(), R = new no({ mapValue: { fields: s.found.fields } }); return So.newFoundDocument(c, f, _, R) }(r, e) : "missing" in e ? function (t, s) { ai(!!s.missing), ai(!!s.readTime); const c = Na(t, s.missing), f = ss(s.readTime); return So.newNoDocument(c, f) }(r, e) : Cn() }(R.serializer, an); ot.set(kn.key.toString(), kn) }); const Gt = []; return _.forEach(an => { const kn = ot.get(an.toString()); ai(!!kn), Gt.push(kn) }), Gt }), function (f, _) { return c.apply(this, arguments) })(t.datastore, e); var c; return s.forEach(c => t.recordVersion(c)), s })() } set(e, t) { this.write(t.toMutation(e, this.precondition(e))), this.writtenDocs.add(e.toString()) } update(e, t) { try { this.write(t.toMutation(e, this.preconditionForUpdate(e))) } catch (s) { this.lastWriteError = s } this.writtenDocs.add(e.toString()) } delete(e) { this.write(new oc(e, this.precondition(e))), this.writtenDocs.add(e.toString()) } commit() { var e = this; return (0, a.Z)(function* () { if (e.ensureCommitNotCalled(), e.lastWriteError) throw e.lastWriteError; const t = e.readVersions; var s; e.mutations.forEach(s => { t.delete(s.key.toString()) }), t.forEach((s, c) => { const f = Bn.fromPath(c); e.mutations.push(new Hf(f, e.precondition(f))) }), yield (s = (0, a.Z)(function* (c, f) { const _ = Un(c), R = lc(_.serializer) + "/documents", j = { writes: f.map(te => yu(_.serializer, te)) }; yield _.Io("Commit", R, j) }), function (c, f) { return s.apply(this, arguments) })(e.datastore, e.mutations), e.committed = !0 })() } recordVersion(e) { let t; if (e.isFoundDocument()) t = e.version; else { if (!e.isNoDocument()) throw Cn(); t = Jn.min() } const s = this.readVersions.get(e.key.toString()); if (s) { if (!t.isEqual(s)) throw new _n(Yt.ABORTED, "Document version changed between two reads.") } else this.readVersions.set(e.key.toString(), t) } precondition(e) { const t = this.readVersions.get(e.toString()); return !this.writtenDocs.has(e.toString()) && t ? t.isEqual(Jn.min()) ? fr.exists(!1) : fr.updateTime(t) : fr.none() } preconditionForUpdate(e) { const t = this.readVersions.get(e.toString()); if (!this.writtenDocs.has(e.toString()) && t) { if (t.isEqual(Jn.min())) throw new _n(Yt.INVALID_ARGUMENT, "Can't update a document that doesn't exist."); return fr.updateTime(t) } return fr.exists(!0) } write(e) { this.ensureCommitNotCalled(), this.mutations.push(e) } ensureCommitNotCalled() { } } class s_ { constructor(e, t, s, c, f) { this.asyncQueue = e, this.datastore = t, this.options = s, this.updateFunction = c, this.deferred = f, this.Bc = s.maxAttempts, this.qo = new _c(this.asyncQueue, "transaction_retry") } run() { this.Bc -= 1, this.Lc() } Lc() { var e = this; this.qo.No((0, a.Z)(function* () { const t = new Yv(e.datastore), s = e.qc(t); s && s.then(c => { e.asyncQueue.enqueueAndForget(() => t.commit().then(() => { e.deferred.resolve(c) }).catch(f => { e.Uc(f) })) }).catch(c => { e.Uc(c) }) })) } qc(e) { try { const t = this.updateFunction(e); return !ri(t) && t.catch && t.then ? t : (this.deferred.reject(Error("Transaction callback must return a Promise")), null) } catch (t) { return this.deferred.reject(t), null } } Uc(e) { this.Bc > 0 && this.Kc(e) ? (this.Bc -= 1, this.asyncQueue.enqueueAndForget(() => (this.Lc(), Promise.resolve()))) : this.deferred.reject(e) } Kc(e) { if ("FirebaseError" === e.name) { const t = e.code; return "aborted" === t || "failed-precondition" === t || "already-exists" === t || !pu(t) } return !1 } } class a_ { constructor(e, t, s, c) { var f = this; this.authCredentials = e, this.appCheckCredentials = t, this.asyncQueue = s, this.databaseInfo = c, this.user = Di.UNAUTHENTICATED, this.clientId = Vr.A(), this.authCredentialListener = () => Promise.resolve(), this.appCheckCredentialListener = () => Promise.resolve(), this.authCredentials.start(s, function () { var _ = (0, a.Z)(function* (R) { pn("FirestoreClient", "Received user=", R.uid), yield f.authCredentialListener(R), f.user = R }); return function (R) { return _.apply(this, arguments) } }()), this.appCheckCredentials.start(s, _ => (pn("FirestoreClient", "Received new app check token=", _), this.appCheckCredentialListener(_, this.user))) } getConfiguration() { var e = this; return (0, a.Z)(function* () { return { asyncQueue: e.asyncQueue, databaseInfo: e.databaseInfo, clientId: e.clientId, authCredentials: e.authCredentials, appCheckCredentials: e.appCheckCredentials, initialUser: e.user, maxConcurrentLimboResolutions: 100 } })() } setCredentialChangeListener(e) { this.authCredentialListener = e } setAppCheckTokenChangeListener(e) { this.appCheckCredentialListener = e } verifyNotTerminated() { if (this.asyncQueue.isShuttingDown) throw new _n(Yt.FAILED_PRECONDITION, "The client has already been terminated.") } terminate() { var e = this; this.asyncQueue.enterRestrictedMode(); const t = new eo; return this.asyncQueue.enqueueAndForgetEvenWhileRestricted((0, a.Z)(function* () { try { e._onlineComponents && (yield e._onlineComponents.terminate()), e._offlineComponents && (yield e._offlineComponents.terminate()), e.authCredentials.shutdown(), e.appCheckCredentials.shutdown(), t.resolve() } catch (s) { const c = Od(s, "Failed to shutdown persistence"); t.reject(c) } })), t.promise } } function Ec(r, e) { return np.apply(this, arguments) } function np() { return np = (0, a.Z)(function* (r, e) { r.asyncQueue.verifyOperationInProgress(), pn("FirestoreClient", "Initializing OfflineComponentProvider"); const t = yield r.getConfiguration(); yield e.initialize(t); let s = t.initialUser; r.setCredentialChangeListener(function () { var c = (0, a.Z)(function* (f) { s.isEqual(f) || (yield Su(e.localStore, f), s = f) }); return function (f) { return c.apply(this, arguments) } }()), e.persistence.setDatabaseDeletedListener(() => r.terminate()), r._offlineComponents = e }), np.apply(this, arguments) } function lf(r, e) { return cf.apply(this, arguments) } function cf() { return cf = (0, a.Z)(function* (r, e) { r.asyncQueue.verifyOperationInProgress(); const t = yield ip(r); pn("FirestoreClient", "Initializing OnlineComponentProvider"); const s = yield r.getConfiguration(); yield e.initialize(t, s), r.setCredentialChangeListener(c => $g(e.remoteStore, c)), r.setAppCheckTokenChangeListener((c, f) => $g(e.remoteStore, f)), r._onlineComponents = e }), cf.apply(this, arguments) } function l_(r) { return "FirebaseError" === r.name ? r.code === Yt.FAILED_PRECONDITION || r.code === Yt.UNIMPLEMENTED : !(typeof DOMException < "u" && r instanceof DOMException) || 22 === r.code || 20 === r.code || 11 === r.code } function ip(r) { return od.apply(this, arguments) } function od() { return od = (0, a.Z)(function* (r) { if (!r._offlineComponents) if (r._uninitializedComponentsProvider) { pn("FirestoreClient", "Using user provided OfflineComponentProvider"); try { yield Ec(r, r._uninitializedComponentsProvider._offline) } catch (e) { const t = e; if (!l_(t)) throw t; wo("Error using user provided cache. Falling back to memory cache: " + t), yield Ec(r, new xc) } } else pn("FirestoreClient", "Using default OfflineComponentProvider"), yield Ec(r, new xc); return r._offlineComponents }), od.apply(this, arguments) } function df(r) { return c_.apply(this, arguments) } function c_() { return c_ = (0, a.Z)(function* (r) { return r._onlineComponents || (r._uninitializedComponentsProvider ? (pn("FirestoreClient", "Using user provided OnlineComponentProvider"), yield lf(r, r._uninitializedComponentsProvider._online)) : (pn("FirestoreClient", "Using default OnlineComponentProvider"), yield lf(r, new Vd))), r._onlineComponents }), c_.apply(this, arguments) } function d_(r) { return ip(r).then(e => e.persistence) } function uf(r) { return ip(r).then(e => e.localStore) } function u_(r) { return df(r).then(e => e.remoteStore) } function rp(r) { return df(r).then(e => e.syncEngine) } function Hd(r) { return op.apply(this, arguments) } function op() { return op = (0, a.Z)(function* (r) { const e = yield df(r), t = e.eventManager; return t.onListen = Lv.bind(null, e.syncEngine), t.onUnlisten = Yg.bind(null, e.syncEngine), t }), op.apply(this, arguments) } function ju(r, e, t = {}) { const s = new eo; return r.asyncQueue.enqueueAndForget((0, a.Z)(function* () { return function (c, f, _, R, j) { const te = new zu({ next: ot => { f.enqueueAndForget(() => Nm(c, Ce)); const Gt = ot.docs.has(_); !Gt && ot.fromCache ? j.reject(new _n(Yt.UNAVAILABLE, "Failed to get document because the client is offline.")) : Gt && ot.fromCache && R && "server" === R.source ? j.reject(new _n(Yt.UNAVAILABLE, 'Failed to get document from server. (However, this document does exist in the local cache. Run again without setting source to "server" to retrieve the cached document.)')) : j.resolve(ot) }, error: ot => j.reject(ot) }), Ce = new qh(Vl(_.path), te, { includeMetadataChanges: !0, Ku: !0 }); return wc(c, Ce) }(yield Hd(r), r.asyncQueue, e, t, s) })), s.promise } function m_(r, e, t = {}) { const s = new eo; return r.asyncQueue.enqueueAndForget((0, a.Z)(function* () { return function (c, f, _, R, j) { const te = new zu({ next: ot => { f.enqueueAndForget(() => Nm(c, Ce)), ot.fromCache && "server" === R.source ? j.reject(new _n(Yt.UNAVAILABLE, 'Failed to get documents from server. (However, these documents may exist in the local cache. Run again without setting source to "server" to retrieve the cached documents.)')) : j.resolve(ot) }, error: ot => j.reject(ot) }), Ce = new qh(_, te, { includeMetadataChanges: !0, Ku: !0 }); return wc(c, Ce) }(yield Hd(r), r.asyncQueue, e, t, s) })), s.promise } function p_(r) { const e = {}; return void 0 !== r.timeoutSeconds && (e.timeoutSeconds = r.timeoutSeconds), e } const ap = new Map; function hf(r, e, t) { if (!t) throw new _n(Yt.INVALID_ARGUMENT, `Function ${r}() cannot be called with an empty ${e}.`) } function g_(r, e, t, s) { if (!0 === e && !0 === s) throw new _n(Yt.INVALID_ARGUMENT, `${r} and ${t} cannot be used together.`) } function nb(r) { if (!Bn.isDocumentKey(r)) throw new _n(Yt.INVALID_ARGUMENT, `Invalid document reference. Document references must have an even number of segments, but ${r} has ${r.length}.`) } function lp(r) { if (Bn.isDocumentKey(r)) throw new _n(Yt.INVALID_ARGUMENT, `Invalid collection reference. Collection references must have an odd number of segments, but ${r} has ${r.length}.`) } function $u(r) { if (void 0 === r) return "undefined"; if (null === r) return "null"; if ("string" == typeof r) return r.length > 20 && (r = `${r.substring(0, 20)}...`), JSON.stringify(r); if ("number" == typeof r || "boolean" == typeof r) return "" + r; if ("object" == typeof r) { if (r instanceof Array) return "an array"; { const e = (t = r).constructor ? t.constructor.name : null; return e ? `a custom ${e} object` : "an object" } } var t; return "function" == typeof r ? "a function" : Cn() } function kr(r, e) { if ("_delegate" in r && (r = r._delegate), !(r instanceof e)) { if (e.name === r.constructor.name) throw new _n(Yt.INVALID_ARGUMENT, "Type does not match the expected instance. Did you pass a reference from a different Firestore SDK?"); { const t = $u(r); throw new _n(Yt.INVALID_ARGUMENT, `Expected type '${e.name}', but it was: ${t}`) } } return r } function Gu(r, e) { if (e <= 0) throw new _n(Yt.INVALID_ARGUMENT, `Function ${r}() requires a positive number, but it was: ${e}.`) } class __ { constructor(e) { var t, s; if (void 0 === e.host) { if (void 0 !== e.ssl) throw new _n(Yt.INVALID_ARGUMENT, "Can't provide ssl option if host option is not set"); this.host = "firestore.googleapis.com", this.ssl = !0 } else this.host = e.host, this.ssl = null === (t = e.ssl) || void 0 === t || t; if (this.credentials = e.credentials, this.ignoreUndefinedProperties = !!e.ignoreUndefinedProperties, this.cache = e.localCache, void 0 === e.cacheSizeBytes) this.cacheSizeBytes = 41943040; else { if (-1 !== e.cacheSizeBytes && e.cacheSizeBytes < 1048576) throw new _n(Yt.INVALID_ARGUMENT, "cacheSizeBytes must be at least 1048576"); this.cacheSizeBytes = e.cacheSizeBytes } g_("experimentalForceLongPolling", e.experimentalForceLongPolling, "experimentalAutoDetectLongPolling", e.experimentalAutoDetectLongPolling), this.experimentalForceLongPolling = !!e.experimentalForceLongPolling, this.experimentalAutoDetectLongPolling = !(this.experimentalForceLongPolling || void 0 !== e.experimentalAutoDetectLongPolling && !e.experimentalAutoDetectLongPolling), this.experimentalLongPollingOptions = p_(null !== (s = e.experimentalLongPollingOptions) && void 0 !== s ? s : {}), function (c) { if (void 0 !== c.timeoutSeconds) { if (isNaN(c.timeoutSeconds)) throw new _n(Yt.INVALID_ARGUMENT, `invalid long polling timeout: ${c.timeoutSeconds} (must not be NaN)`); if (c.timeoutSeconds < 5) throw new _n(Yt.INVALID_ARGUMENT, `invalid long polling timeout: ${c.timeoutSeconds} (minimum allowed value is 5)`); if (c.timeoutSeconds > 30) throw new _n(Yt.INVALID_ARGUMENT, `invalid long polling timeout: ${c.timeoutSeconds} (maximum allowed value is 30)`) } }(this.experimentalLongPollingOptions), this.useFetchStreams = !!e.useFetchStreams } isEqual(e) { return this.host === e.host && this.ssl === e.ssl && this.credentials === e.credentials && this.cacheSizeBytes === e.cacheSizeBytes && this.experimentalForceLongPolling === e.experimentalForceLongPolling && this.experimentalAutoDetectLongPolling === e.experimentalAutoDetectLongPolling && this.experimentalLongPollingOptions.timeoutSeconds === e.experimentalLongPollingOptions.timeoutSeconds && this.ignoreUndefinedProperties === e.ignoreUndefinedProperties && this.useFetchStreams === e.useFetchStreams } } class Wu { constructor(e, t, s, c) { this._authCredentials = e, this._appCheckCredentials = t, this._databaseId = s, this._app = c, this.type = "firestore-lite", this._persistenceKey = "(lite)", this._settings = new __({}), this._settingsFrozen = !1 } get app() { if (!this._app) throw new _n(Yt.FAILED_PRECONDITION, "Firestore was not initialized using the Firebase SDK. 'app' is not available"); return this._app } get _initialized() { return this._settingsFrozen } get _terminated() { return void 0 !== this._terminateTask } _setSettings(e) { if (this._settingsFrozen) throw new _n(Yt.FAILED_PRECONDITION, "Firestore has already been started and its settings can no longer be changed. You can only modify settings before calling any other methods on a Firestore object."); this._settings = new __(e), void 0 !== e.credentials && (this._authCredentials = function (t) { if (!t) return new vn; switch (t.type) { case "firstParty": return new xo(t.sessionIndex || "0", t.iamToken || null, t.authTokenFactory || null); case "provider": return t.client; default: throw new _n(Yt.INVALID_ARGUMENT, "makeAuthCredentialsProvider failed due to invalid credential type") } }(e.credentials)) } _getSettings() { return this._settings } _freezeSettings() { return this._settingsFrozen = !0, this._settings } _delete() { return this._terminateTask || (this._terminateTask = this._terminate()), this._terminateTask } toJSON() { return { app: this._app, databaseId: this._databaseId, settings: this._settings } } _terminate() { return function (e) { const t = ap.get(e); t && (pn("ComponentProvider", "Removing Datastore"), ap.delete(e), t.terminate()) }(this), Promise.resolve() } } function ff(r, e, t, s = {}) { var c; const f = (r = kr(r, Wu))._getSettings(), _ = `${e}:${t}`; if ("firestore.googleapis.com" !== f.host && f.host !== _ && wo("Host has been set in both settings() and connectFirestoreEmulator(), emulator host will be used."), r._setSettings(Object.assign(Object.assign({}, f), { host: _, ssl: !1 })), s.mockUserToken) { let R, j; if ("string" == typeof s.mockUserToken) R = s.mockUserToken, j = Di.MOCK_USER; else { R = (0, he.Sg)(s.mockUserToken, null === (c = r._app) || void 0 === c ? void 0 : c.options.projectId); const te = s.mockUserToken.sub || s.mockUserToken.user_id; if (!te) throw new _n(Yt.INVALID_ARGUMENT, "mockUserToken must contain 'sub' or 'user_id' field!"); j = new Di(te) } r._authCredentials = new $i(new Us(R, j)) } } class as { constructor(e, t, s) { this.converter = t, this._key = s, this.type = "document", this.firestore = e } get _path() { return this._key.path } get id() { return this._key.path.lastSegment() } get path() { return this._key.path.canonicalString() } get parent() { return new Fa(this.firestore, this.converter, this._key.path.popLast()) } withConverter(e) { return new as(this.firestore, e, this._key) } } class Uo { constructor(e, t, s) { this.converter = t, this._query = s, this.type = "query", this.firestore = e } withConverter(e) { return new Uo(this.firestore, e, this._query) } } class Fa extends Uo { constructor(e, t, s) { super(e, t, Vl(s)), this._path = s, this.type = "collection" } get id() { return this._query.path.lastSegment() } get path() { return this._query.path.canonicalString() } get parent() { const e = this._path.popLast(); return e.isEmpty() ? null : new as(this.firestore, null, new Bn(e)) } withConverter(e) { return new Fa(this.firestore, e, this._path) } } function da(r, e, ...t) { if (r = (0, he.m9)(r), hf("collection", "path", e), r instanceof Wu) { const s = Pi.fromString(e, ...t); return lp(s), new Fa(r, null, s) } { if (!(r instanceof as || r instanceof Fa)) throw new _n(Yt.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore"); const s = r._path.child(Pi.fromString(e, ...t)); return lp(s), new Fa(r.firestore, null, s) } } function sd(r, e) { if (r = kr(r, Wu), hf("collectionGroup", "collection id", e), e.indexOf("/") >= 0) throw new _n(Yt.INVALID_ARGUMENT, `Invalid collection ID '${e}' passed to function collectionGroup(). Collection IDs must not contain '/'.`); return new Uo(r, null, (t = e, new gl(Pi.emptyPath(), t))); var t } function Ku(r, e, ...t) { if (r = (0, he.m9)(r), 1 === arguments.length && (e = Vr.A()), hf("doc", "path", e), r instanceof Wu) { const s = Pi.fromString(e, ...t); return nb(s), new as(r, null, new Bn(s)) } { if (!(r instanceof as || r instanceof Fa)) throw new _n(Yt.INVALID_ARGUMENT, "Expected first argument to collection() to be a CollectionReference, a DocumentReference or FirebaseFirestore"); const s = r._path.child(Pi.fromString(e, ...t)); return nb(s), new as(r.firestore, r instanceof Fa ? r.converter : null, new Bn(s)) } } function rl(r, e) { return r = (0, he.m9)(r), e = (0, he.m9)(e), (r instanceof as || r instanceof Fa) && (e instanceof as || e instanceof Fa) && r.firestore === e.firestore && r.path === e.path && r.converter === e.converter } function Zu(r, e) { return r = (0, he.m9)(r), e = (0, he.m9)(e), r instanceof Uo && e instanceof Uo && r.firestore === e.firestore && Tt(r._query, e._query) && r.converter === e.converter } class zd { constructor() { this.Gc = Promise.resolve(), this.Qc = [], this.jc = !1, this.zc = [], this.Wc = null, this.Hc = !1, this.Jc = !1, this.Yc = [], this.qo = new _c(this, "async_queue_retry"), this.Xc = () => { const t = gc(); t && pn("AsyncQueue", "Visibility state changed to " + t.visibilityState), this.qo.Mo() }; const e = gc(); e && "function" == typeof e.addEventListener && e.addEventListener("visibilitychange", this.Xc) } get isShuttingDown() { return this.jc } enqueueAndForget(e) { this.enqueue(e) } enqueueAndForgetEvenWhileRestricted(e) { this.Zc(), this.ta(e) } enterRestrictedMode(e) { if (!this.jc) { this.jc = !0, this.Jc = e || !1; const t = gc(); t && "function" == typeof t.removeEventListener && t.removeEventListener("visibilitychange", this.Xc) } } enqueue(e) { if (this.Zc(), this.jc) return new Promise(() => { }); const t = new eo; return this.ta(() => this.jc && this.Jc ? Promise.resolve() : (e().then(t.resolve, t.reject), t.promise)).then(() => t.promise) } enqueueRetryable(e) { this.enqueueAndForget(() => (this.Qc.push(e), this.ea())) } ea() { var e = this; return (0, a.Z)(function* () { if (0 !== e.Qc.length) { try { yield e.Qc[0](), e.Qc.shift(), e.qo.reset() } catch (t) { if (!M(t)) throw t; pn("AsyncQueue", "Operation failed with retryable error: " + t) } e.Qc.length > 0 && e.qo.No(() => e.ea()) } })() } ta(e) { const t = this.Gc.then(() => (this.Hc = !0, e().catch(s => { throw this.Wc = s, this.Hc = !1, er("INTERNAL UNHANDLED ERROR: ", function (f) { let _ = f.message || ""; return f.stack && (_ = f.stack.includes(f.message) ? f.stack : f.message + "\n" + f.stack), _ }(s)), s }).then(s => (this.Hc = !1, s)))); return this.Gc = t, t } enqueueAfterDelay(e, t, s) { this.Zc(), this.Yc.indexOf(e) > -1 && (t = 0); const c = Zh.createAndSchedule(this, e, t, s, f => this.na(f)); return this.zc.push(c), c } Zc() { this.Wc && Cn() } verifyOperationInProgress() { } sa() { var e = this; return (0, a.Z)(function* () { let t; do { t = e.Gc, yield t } while (t !== e.Gc) })() } ia(e) { for (const t of this.zc) if (t.timerId === e) return !0; return !1 } ra(e) { return this.sa().then(() => { this.zc.sort((t, s) => t.targetTimeMs - s.targetTimeMs); for (const t of this.zc) if (t.skipDelay(), "all" !== e && t.timerId === e) break; return this.sa() }) } oa(e) { this.Yc.push(e) } na(e) { const t = this.zc.indexOf(e); this.zc.splice(t, 1) } } function Cc(r) { return function (e, t) { if ("object" != typeof e || null === e) return !1; const s = e; for (const c of ["next", "error", "complete"]) if (c in s && "function" == typeof s[c]) return !0; return !1 }(r) } class jd { constructor() { this._progressObserver = {}, this._taskCompletionResolver = new eo, this._lastProgress = { taskState: "Running", totalBytes: 0, totalDocuments: 0, bytesLoaded: 0, documentsLoaded: 0 } } onProgress(e, t, s) { this._progressObserver = { next: e, error: t, complete: s } } catch(e) { return this._taskCompletionResolver.promise.catch(e) } then(e, t) { return this._taskCompletionResolver.promise.then(e, t) } _completeWith(e) { this._updateProgress(e), this._progressObserver.complete && this._progressObserver.complete(), this._taskCompletionResolver.resolve(e) } _failWith(e) { this._lastProgress.taskState = "Error", this._progressObserver.next && this._progressObserver.next(this._lastProgress), this._progressObserver.error && this._progressObserver.error(e), this._taskCompletionResolver.reject(e) } _updateProgress(e) { this._lastProgress = e, this._progressObserver.next && this._progressObserver.next(e) } } const $d = -1; class uo extends Wu { constructor(e, t, s, c) { super(e, t, s, c), this.type = "firestore", this._queue = new zd, this._persistenceKey = c?.name || "[DEFAULT]" } _terminate() { return this._firestoreClient || ad(this), this._firestoreClient.terminate() } } function Gd(r, e) { const t = "object" == typeof r ? r : (0, y.getApp)(), s = "string" == typeof r ? r : e || "(default)", c = (0, y._getProvider)(t, "firestore").getImmediate({ identifier: s }); if (!c._initialized) { const f = (0, he.P0)("firestore"); f && ff(c, ...f) } return c } function Vo(r) { return r._firestoreClient || ad(r), r._firestoreClient.verifyNotTerminated(), r._firestoreClient } function ad(r) { var e, t, s; const c = r._freezeSettings(), f = (R = (null === (e = r._app) || void 0 === e ? void 0 : e.options.appId) || "", new tl(r._databaseId, R, r._persistenceKey, (te = c).host, te.ssl, te.experimentalForceLongPolling, te.experimentalAutoDetectLongPolling, p_(te.experimentalLongPollingOptions), te.useFetchStreams)); var R, te; r._firestoreClient = new a_(r._authCredentials, r._appCheckCredentials, r._queue, f), null !== (t = c.cache) && void 0 !== t && t._offlineComponentProvider && null !== (s = c.cache) && void 0 !== s && s._onlineComponentProvider && (r._firestoreClient._uninitializedComponentsProvider = { _offlineKind: c.cache.kind, _offline: c.cache._offlineComponentProvider, _online: c.cache._onlineComponentProvider }) } function v_(r, e) { I_(r = kr(r, uo)); const t = Vo(r); if (t._uninitializedComponentsProvider) throw new _n(Yt.FAILED_PRECONDITION, "SDK cache is already specified."); wo("enableIndexedDbPersistence() will be deprecated in the future, you can use `FirestoreSettings.cache` instead."); const s = r._freezeSettings(), c = new Vd; return cp(t, c, new Ud(c, s.cacheSizeBytes, e?.forceOwnership)) } function b_(r) { I_(r = kr(r, uo)); const e = Vo(r); if (e._uninitializedComponentsProvider) throw new _n(Yt.FAILED_PRECONDITION, "SDK cache is already specified."); wo("enableMultiTabIndexedDbPersistence() will be deprecated in the future, you can use `FirestoreSettings.cache` instead."); const t = r._freezeSettings(), s = new Vd; return cp(e, s, new Kv(s, t.cacheSizeBytes)) } function cp(r, e, t) { const s = new eo; return r.asyncQueue.enqueue((0, a.Z)(function* () { try { yield Ec(r, t), yield lf(r, e), s.resolve() } catch (c) { const f = c; if (!l_(f)) throw f; wo("Error enabling indexeddb cache. Falling back to memory cache: " + f), s.reject(f) } })).then(() => s.promise) } function y_(r) { if (r._initialized && !r._terminated) throw new _n(Yt.FAILED_PRECONDITION, "Persistence can only be cleared before a Firestore instance is initialized or after it is terminated."); const e = new eo; return r._queue.enqueueAndForgetEvenWhileRestricted((0, a.Z)(function* () { try { yield (t = (0, a.Z)(function* (s) { if (!u.D()) return Promise.resolve(); const c = s + "main"; yield u.delete(c) }), function (s) { return t.apply(this, arguments) })(vm(r._databaseId, r._persistenceKey)), e.resolve() } catch (t) { e.reject(t) } var t })), e.promise } function w_(r) { return function (e) { const t = new eo; return e.asyncQueue.enqueueAndForget((0, a.Z)(function* () { return function zv(r, e) { return Wm.apply(this, arguments) }(yield rp(e), t) })), t.promise }(Vo(r = kr(r, uo))) } function x_(r) { return function f_(r) { return r.asyncQueue.enqueue((0, a.Z)(function* () { const e = yield d_(r), t = yield u_(r); return e.setNetworkEnabled(!0), function (s) { const c = Un(s); return c.vu.delete(0), Jc(c) }(t) })) }(Vo(r = kr(r, uo))) } function E_(r) { return function sp(r) { return r.asyncQueue.enqueue((0, a.Z)(function* () { const e = yield d_(r), t = yield u_(r); return e.setNetworkEnabled(!1), (s = (0, a.Z)(function* (c) { const f = Un(c); f.vu.add(0), yield td(f), f.bu.set("Offline") }), function (c) { return s.apply(this, arguments) })(t); var s })) }(Vo(r = kr(r, uo))) } function C_(r, e) { const t = Vo(r = kr(r, uo)), s = new jd; return function Jv(r, e, t, s) { const c = function (f, _) { let R; return R = "string" == typeof f ? qp().encode(f) : f, j = function (j, te) { if (j instanceof Uint8Array) return tp(j, void 0); if (j instanceof ArrayBuffer) return tp(new Uint8Array(j), void 0); if (j instanceof ReadableStream) return j.getReader(); throw new Error("Source of `toByteStreamReader` has to be a ArrayBuffer or ReadableStream") }(R), new Zv(j, _); var j }(t, Lu(e)); r.asyncQueue.enqueueAndForget((0, a.Z)(function* () { !function Wv(r, e, t) { const s = Un(r); var c; (c = (0, a.Z)(function* (f, _, R) { try { const j = yield _.getMetadata(); if (yield function (Gt, an) { const kn = Un(Gt), Yn = ss(an.createTime); return kn.persistence.runTransaction("hasNewerBundle", "readonly", ti => kn.qs.getBundleMetadata(ti, an.id)).then(ti => !!ti && ti.createTime.compareTo(Yn) >= 0) }(f.localStore, j)) return yield _.close(), R._completeWith({ taskState: "Success", documentsLoaded: (Gt = j).totalDocuments, bytesLoaded: Gt.totalBytes, totalDocuments: Gt.totalDocuments, totalBytes: Gt.totalBytes }), Promise.resolve(new Set); R._updateProgress(Um(j)); const te = new Bm(j, f.localStore, _.serializer); let Ce = yield _.bc(); for (; Ce;) { const Gt = yield te.zu(Ce); Gt && R._updateProgress(Gt), Ce = yield _.bc() } const ot = yield te.complete(); return yield xl(f, ot.Ju, void 0), yield function (Gt, an) { const kn = Un(Gt); return kn.persistence.runTransaction("Save bundle", "readwrite", Yn => kn.qs.saveBundleMetadata(Yn, an)) }(f.localStore, j), R._completeWith(ot.progress), Promise.resolve(ot.Hu) } catch (j) { return wo("SyncEngine", `Loading bundle failed with ${j}`), R._failWith(j), Promise.resolve(new Set) } var Gt }), function (f, _, R) { return c.apply(this, arguments) })(s, e, t).then(c => { s.sharedClientState.notifyBundleLoaded(c) }) }(yield rp(r), c, s) })) }(t, r._databaseId, e, s), s } function dp(r, e) { return function eb(r, e) { return r.asyncQueue.enqueue((0, a.Z)(function* () { return function (t, s) { const c = Un(t); return c.persistence.runTransaction("Get named query", "readonly", f => c.qs.getNamedQuery(f, s)) }(yield uf(r), e) })) }(Vo(r = kr(r, uo)), e).then(t => t ? new Uo(r, null, t.query) : null) } function I_(r) { if (r._initialized || r._terminated) throw new _n(Yt.FAILED_PRECONDITION, "Firestore has already been started and persistence can no longer be enabled. You can only enable persistence before calling any other methods on a Firestore object.") } class Ic { constructor(e) { this._byteString = e } static fromBase64String(e) { try { return new Ic(Lo.fromBase64String(e)) } catch (t) { throw new _n(Yt.INVALID_ARGUMENT, "Failed to construct data from Base64 string: " + t) } } static fromUint8Array(e) { return new Ic(Lo.fromUint8Array(e)) } toBase64() { return this._byteString.toBase64() } toUint8Array() { return this._byteString.toUint8Array() } toString() { return "Bytes(base64: " + this.toBase64() + ")" } isEqual(e) { return this._byteString.isEqual(e._byteString) } } class Dc { constructor(...e) { for (let t = 0; t < e.length; ++t)if (0 === e[t].length) throw new _n(Yt.INVALID_ARGUMENT, "Invalid field name at argument $(i + 1). Field names must not be empty."); this._internalPath = new Hr(e) } isEqual(e) { return this._internalPath.isEqual(e._internalPath) } } class ld { constructor(e) { this._methodName = e } } class up { constructor(e, t) { if (!isFinite(e) || e < -90 || e > 90) throw new _n(Yt.INVALID_ARGUMENT, "Latitude must be a number between -90 and 90, but was: " + e); if (!isFinite(t) || t < -180 || t > 180) throw new _n(Yt.INVALID_ARGUMENT, "Longitude must be a number between -180 and 180, but was: " + t); this._lat = e, this._long = t } get latitude() { return this._lat } get longitude() { return this._long } isEqual(e) { return this._lat === e._lat && this._long === e._long } toJSON() { return { latitude: this._lat, longitude: this._long } } _compareTo(e) { return Ei(this._lat, e._lat) || Ei(this._long, e._long) } } const rb = /^__.*__$/; class ob { constructor(e, t, s) { this.data = e, this.fieldMask = t, this.fieldTransforms = s } toMutation(e, t) { return null !== this.fieldMask ? new Dl(e, this.data, this.fieldMask, t, this.fieldTransforms) : new yd(e, this.data, t, this.fieldTransforms) } } class D_ { constructor(e, t, s) { this.data = e, this.fieldMask = t, this.fieldTransforms = s } toMutation(e, t) { return new Dl(e, this.data, this.fieldMask, t, this.fieldTransforms) } } function pf(r) { switch (r) { case 0: case 2: case 1: return !0; case 3: case 4: return !1; default: throw Cn() } } class Tc { constructor(e, t, s, c, f, _) { this.settings = e, this.databaseId = t, this.serializer = s, this.ignoreUndefinedProperties = c, void 0 === f && this.ua(), this.fieldTransforms = f || [], this.fieldMask = _ || [] } get path() { return this.settings.path } get ca() { return this.settings.ca } aa(e) { return new Tc(Object.assign(Object.assign({}, this.settings), e), this.databaseId, this.serializer, this.ignoreUndefinedProperties, this.fieldTransforms, this.fieldMask) } ha(e) { var t; const s = null === (t = this.path) || void 0 === t ? void 0 : t.child(e), c = this.aa({ path: s, la: !1 }); return c.fa(e), c } da(e) { var t; const s = null === (t = this.path) || void 0 === t ? void 0 : t.child(e), c = this.aa({ path: s, la: !1 }); return c.ua(), c } wa(e) { return this.aa({ path: void 0, la: !0 }) } _a(e) { return eh(e, this.settings.methodName, this.settings.ma || !1, this.path, this.settings.ga) } contains(e) { return void 0 !== this.fieldMask.find(t => e.isPrefixOf(t)) || void 0 !== this.fieldTransforms.find(t => e.isPrefixOf(t.field)) } ua() { if (this.path) for (let e = 0; e < this.path.length; e++)this.fa(this.path.get(e)) } fa(e) { if (0 === e.length) throw this._a("Document fields must not be empty"); if (pf(this.ca) && rb.test(e)) throw this._a('Document fields cannot begin and end with "__"') } } class hp { constructor(e, t, s) { this.databaseId = e, this.ignoreUndefinedProperties = t, this.serializer = s || Lu(e) } ya(e, t, s, c = !1) { return new Tc({ ca: e, methodName: t, ga: s, path: Hr.emptyPath(), la: !1, ma: c }, this.databaseId, this.serializer, this.ignoreUndefinedProperties) } } function Al(r) { const e = r._freezeSettings(), t = Lu(r._databaseId); return new hp(r._databaseId, !!e.ignoreUndefinedProperties, t) } function qu(r, e, t, s, c, f = {}) { const _ = r.ya(f.merge || f.mergeFields ? 2 : 0, e, t, c); _p("Data must be an object, but it was:", _, s); const R = Xu(s, _); let j, te; if (f.merge) j = new Xo(_.fieldMask), te = _.fieldTransforms; else if (f.mergeFields) { const Ce = []; for (const ot of f.mergeFields) { const Gt = Ju(e, ot, t); if (!_.contains(Gt)) throw new _n(Yt.INVALID_ARGUMENT, `Field '${Gt}' is specified in your field mask but missing from your input data.`); T_(Ce, Gt) || Ce.push(Gt) } j = new Xo(Ce), te = _.fieldTransforms.filter(ot => j.covers(ot.field)) } else j = null, te = _.fieldTransforms; return new ob(new no(R), j, te) } class Zl extends ld { _toFieldTransform(e) { if (2 !== e.ca) throw e._a(1 === e.ca ? `${this._methodName}() can only appear at the top level of your update data` : `${this._methodName}() cannot be used with set() unless you pass {merge:true}`); return e.fieldMask.push(e.path), null } isEqual(e) { return e instanceof Zl } } function fp(r, e, t) { return new Tc({ ca: 3, ga: e.settings.ga, methodName: r._methodName, la: t }, e.databaseId, e.serializer, e.ignoreUndefinedProperties) } class mp extends ld { _toFieldTransform(e) { return new Uc(e.path, new ic) } isEqual(e) { return e instanceof mp } } class Qu extends ld { constructor(e, t) { super(e), this.pa = t } _toFieldTransform(e) { const t = fp(this, e, !0), s = this.pa.map(f => kl(f, t)), c = new Lc(s); return new Uc(e.path, c) } isEqual(e) { return this === e } } class sb extends ld { constructor(e, t) { super(e), this.pa = t } _toFieldTransform(e) { const t = fp(this, e, !0), s = this.pa.map(f => kl(f, t)), c = new Bc(s); return new Uc(e.path, c) } isEqual(e) { return this === e } } class ab extends ld { constructor(e, t) { super(e), this.Ia = t } _toFieldTransform(e) { const t = new vd(e.serializer, _l(e.serializer, this.Ia)); return new Uc(e.path, t) } isEqual(e) { return this === e } } function pp(r, e, t, s) { const c = r.ya(1, e, t); _p("Data must be an object, but it was:", c, s); const f = [], _ = no.empty(); _o(s, (j, te) => { const Ce = _f(e, j, t); te = (0, he.m9)(te); const ot = c.da(Ce); if (te instanceof Zl) f.push(Ce); else { const Gt = kl(te, ot); null != Gt && (f.push(Ce), _.set(Ce, Gt)) } }); const R = new Xo(f); return new D_(_, R, c.fieldTransforms) } function gp(r, e, t, s, c, f) { const _ = r.ya(1, e, t), R = [Ju(e, s, t)], j = [c]; if (f.length % 2 != 0) throw new _n(Yt.INVALID_ARGUMENT, `Function ${e}() needs to be called with an even number of arguments that alternate between field names and values.`); for (let Gt = 0; Gt < f.length; Gt += 2)R.push(Ju(e, f[Gt])), j.push(f[Gt + 1]); const te = [], Ce = no.empty(); for (let Gt = R.length - 1; Gt >= 0; --Gt)if (!T_(te, R[Gt])) { const an = R[Gt]; let kn = j[Gt]; kn = (0, he.m9)(kn); const Yn = _.da(an); if (kn instanceof Zl) te.push(an); else { const ti = kl(kn, Yn); null != ti && (te.push(an), Ce.set(an, ti)) } } const ot = new Xo(te); return new D_(Ce, ot, _.fieldTransforms) } function gf(r, e, t, s = !1) { return kl(t, r.ya(s ? 4 : 3, e)) } function kl(r, e) { if (lb(r = (0, he.m9)(r))) return _p("Unsupported field value:", e, r), Xu(r, e); if (r instanceof ld) return function (t, s) { if (!pf(s.ca)) throw s._a(`${t._methodName}() can only be used with update() and set()`); if (!s.path) throw s._a(`${t._methodName}() is not currently supported inside arrays`); const c = t._toFieldTransform(s); c && s.fieldTransforms.push(c) }(r, e), null; if (void 0 === r && e.ignoreUndefinedProperties) return null; if (e.path && e.fieldMask.push(e.path), r instanceof Array) { if (e.settings.la && 4 !== e.ca) throw e._a("Nested arrays are not supported"); return function (t, s) { const c = []; let f = 0; for (const _ of t) { let R = kl(_, s.wa(f)); null == R && (R = { nullValue: "NULL_VALUE" }), c.push(R), f++ } return { arrayValue: { values: c } } }(r, e) } return function (t, s) { if (null === (t = (0, he.m9)(t))) return { nullValue: "NULL_VALUE" }; if ("number" == typeof t) return _l(s.serializer, t); if ("boolean" == typeof t) return { booleanValue: t }; if ("string" == typeof t) return { stringValue: t }; if (t instanceof Date) { const c = Ri.fromDate(t); return { timestampValue: Ed(s.serializer, c) } } if (t instanceof Ri) { const c = new Ri(t.seconds, 1e3 * Math.floor(t.nanoseconds / 1e3)); return { timestampValue: Ed(s.serializer, c) } } if (t instanceof up) return { geoPointValue: { latitude: t.latitude, longitude: t.longitude } }; if (t instanceof Ic) return { bytesValue: Zf(s.serializer, t._byteString) }; if (t instanceof as) { const c = s.databaseId, f = t.firestore._databaseId; if (!f.isEqual(c)) throw s._a(`Document reference is for database ${f.projectId}/${f.database} but should be for database ${c.projectId}/${c.database}`); return { referenceValue: bu(t.firestore._databaseId || s.databaseId, t._key.path) } } throw s._a(`Unsupported field value: ${$u(t)}`) }(r, e) } function Xu(r, e) { const t = {}; return Va(r) ? e.path && e.path.length > 0 && e.fieldMask.push(e.path) : _o(r, (s, c) => { const f = kl(c, e.ha(s)); null != f && (t[s] = f) }), { mapValue: { fields: t } } } function lb(r) { return !("object" != typeof r || null === r || r instanceof Array || r instanceof Date || r instanceof Ri || r instanceof up || r instanceof Ic || r instanceof as || r instanceof ld) } function _p(r, e, t) { if (!lb(t) || "object" != typeof (s = t) || null === s || Object.getPrototypeOf(s) !== Object.prototype && null !== Object.getPrototypeOf(s)) { const s = $u(t); throw e._a("an object" === s ? r + " a custom object" : r + " " + s) } var s } function Ju(r, e, t) { if ((e = (0, he.m9)(e)) instanceof Dc) return e._internalPath; if ("string" == typeof e) return _f(r, e); throw eh("Field path arguments must be of type string or ", r, !1, void 0, t) } const vp = new RegExp("[~\\*/\\[\\]]"); function _f(r, e, t) { if (e.search(vp) >= 0) throw eh(`Invalid field path (${e}). Paths must not contain '~', '*', '/', '[', or ']'`, r, !1, void 0, t); try { return new Dc(...e.split("."))._internalPath } catch { throw eh(`Invalid field path (${e}). Paths must not be empty, begin with '.', end with '.', or contain '..'`, r, !1, void 0, t) } } function eh(r, e, t, s, c) { const f = s && !s.isEmpty(), _ = void 0 !== c; let R = `Function ${e}() called with invalid data`; t && (R += " (via `toFirestore()`)"), R += ". "; let j = ""; return (f || _) && (j += " (found", f && (j += ` in field ${s}`), _ && (j += ` in document ${c}`), j += ")"), new _n(Yt.INVALID_ARGUMENT, R + r + j) } function T_(r, e) { return r.some(t => t.isEqual(e)) } class th { constructor(e, t, s, c, f) { this._firestore = e, this._userDataWriter = t, this._key = s, this._document = c, this._converter = f } get id() { return this._key.path.lastSegment() } get ref() { return new as(this._firestore, this._converter, this._key) } exists() { return null !== this._document } data() { if (this._document) { if (this._converter) { const e = new M_(this._firestore, this._userDataWriter, this._key, this._document, null); return this._converter.fromFirestore(e) } return this._userDataWriter.convertValue(this._document.data.value) } } get(e) { if (this._document) { const t = this._document.data.field(nh("DocumentSnapshot.get", e)); if (null !== t) return this._userDataWriter.convertValue(t) } } } class M_ extends th { data() { return super.data() } } function nh(r, e) { return "string" == typeof e ? _f(r, e) : e instanceof Dc ? e._internalPath : e._delegate._internalPath } function bp(r) { if ("L" === r.limitType && 0 === r.explicitOrderBy.length) throw new _n(Yt.UNIMPLEMENTED, "limitToLast() queries require specifying at least one orderBy() clause") } class yp { } class ih extends yp { } function cb(r, e, ...t) { let s = []; e instanceof yp && s.push(e), s = s.concat(t), function (c) { const f = c.filter(R => R instanceof Mc).length, _ = c.filter(R => R instanceof Wd).length; if (f > 1 || f > 0 && _ > 0) throw new _n(Yt.INVALID_ARGUMENT, "InvalidQuery. When using composite filters, you cannot use more than one filter at the top level. Consider nesting the multiple filters within an `and(...)` statement. For example: change `query(query, where(...), or(...))` to `query(query, and(where(...), or(...)))`.") }(s); for (const c of s) r = c._apply(r); return r } class Wd extends ih { constructor(e, t, s) { super(), this._field = e, this._op = t, this._value = s, this.type = "where" } static _create(e, t, s) { return new Wd(e, t, s) } _apply(e) { const t = this._parse(e); return Ip(e._query, t), new Uo(e.firestore, e.converter, oe(e._query, t)) } _parse(e) { const t = Al(e.firestore); return function (c, f, _, R, j, te, Ce) { let ot; if (j.isKeyField()) { if ("array-contains" === te || "array-contains-any" === te) throw new _n(Yt.INVALID_ARGUMENT, `Invalid Query. You can't perform '${te}' queries on documentId().`); if ("in" === te || "not-in" === te) { wf(Ce, te); const Gt = []; for (const an of Ce) Gt.push(Cp(R, c, an)); ot = { arrayValue: { values: Gt } } } else ot = Cp(R, c, Ce) } else "in" !== te && "not-in" !== te && "array-contains-any" !== te || wf(Ce, te), ot = gf(_, "where", Ce, "in" === te || "not-in" === te); return wr.create(j, te, ot) }(e._query, 0, t, e.firestore._databaseId, this._field, this._op, this._value) } } function wp(r, e, t) { const s = e, c = nh("where", r); return Wd._create(c, s, t) } class Mc extends yp { constructor(e, t) { super(), this.type = e, this._queryConstraints = t } static _create(e, t) { return new Mc(e, t) } _parse(e) { const t = this._queryConstraints.map(s => s._parse(e)).filter(s => s.getFilters().length > 0); return 1 === t.length ? t[0] : Yr.create(t, this._getOperator()) } _apply(e) { const t = this._parse(e); return 0 === t.getFilters().length ? e : (function (s, c) { let f = s; const _ = c.getFlattenedFilters(); for (const R of _) Ip(f, R), f = oe(f, R) }(e._query, t), new Uo(e.firestore, e.converter, oe(e._query, t))) } _getQueryConstraints() { return this._queryConstraints } _getOperator() { return "and" === this.type ? "and" : "or" } } class Kd extends ih { constructor(e, t) { super(), this._field = e, this._direction = t, this.type = "orderBy" } static _create(e, t) { return new Kd(e, t) } _apply(e) { const t = function (s, c, f) { if (null !== s.startAt) throw new _n(Yt.INVALID_ARGUMENT, "Invalid query. You must not call startAt() or startAfter() before calling orderBy()."); if (null !== s.endAt) throw new _n(Yt.INVALID_ARGUMENT, "Invalid query. You must not call endAt() or endBefore() before calling orderBy()."); const _ = new Ts(c, f); return function (R, j) { if (null === au(R)) { const te = T(R); null !== te && xf(0, te, j.field) } }(s, _), _ }(e._query, this._field, this._direction); return new Uo(e.firestore, e.converter, function (s, c) { const f = s.explicitOrderBy.concat([c]); return new gl(s.path, s.collectionGroup, f, s.filters.slice(), s.limit, s.limitType, s.startAt, s.endAt) }(e._query, t)) } } function Ep(r, e = "asc") { const t = e, s = nh("orderBy", r); return Kd._create(s, t) } class rh extends ih { constructor(e, t, s) { super(), this.type = e, this._limit = t, this._limitType = s } static _create(e, t, s) { return new rh(e, t, s) } _apply(e) { return new Uo(e.firestore, e.converter, De(e._query, this._limit, this._limitType)) } } function db(r) { return Gu("limit", r), rh._create("limit", r, "F") } function ub(r) { return Gu("limitToLast", r), rh._create("limitToLast", r, "L") } class vf extends ih { constructor(e, t, s) { super(), this.type = e, this._docOrFields = t, this._inclusive = s } static _create(e, t, s) { return new vf(e, t, s) } _apply(e) { const t = A_(e, this.type, this._docOrFields, this._inclusive); return new Uo(e.firestore, e.converter, (c = t, new gl((s = e._query).path, s.collectionGroup, s.explicitOrderBy.slice(), s.filters.slice(), s.limit, s.limitType, c, s.endAt))); var s, c } } function bf(...r) { return vf._create("startAt", r, !0) } function yf(...r) { return vf._create("startAfter", r, !1) } class Zd extends ih { constructor(e, t, s) { super(), this.type = e, this._docOrFields = t, this._inclusive = s } static _create(e, t, s) { return new Zd(e, t, s) } _apply(e) { const t = A_(e, this.type, this._docOrFields, this._inclusive); return new Uo(e.firestore, e.converter, (c = t, new gl((s = e._query).path, s.collectionGroup, s.explicitOrderBy.slice(), s.filters.slice(), s.limit, s.limitType, s.startAt, c))); var s, c } } function S_(...r) { return Zd._create("endBefore", r, !1) } function hb(...r) { return Zd._create("endAt", r, !0) } function A_(r, e, t, s) { if (t[0] = (0, he.m9)(t[0]), t[0] instanceof th) return function (c, f, _, R, j) { if (!R) throw new _n(Yt.NOT_FOUND, `Can't use a DocumentSnapshot that doesn't exist for ${_}().`); const te = []; for (const Ce of b(c)) if (Ce.field.isKeyField()) te.push(ln(f, R.key)); else { const ot = R.data.field(Ce.field); if (Oa(ot)) throw new _n(Yt.INVALID_ARGUMENT, 'Invalid query. You are trying to start or end a query using a document for which the field "' + Ce.field + '" is an uncommitted server timestamp. (Since the value of this field is unknown, you cannot start/end a query with it.)'); if (null === ot) { const Gt = Ce.field.canonicalString(); throw new _n(Yt.INVALID_ARGUMENT, `Invalid query. You are trying to start or end a query using a document for which the field '${Gt}' (used as the orderBy) does not exist.`) } te.push(ot) } return new Fl(te, j) }(r._query, r.firestore._databaseId, e, t[0]._document, s); { const c = Al(r.firestore); return function (f, _, R, j, te, Ce) { const ot = f.explicitOrderBy; if (te.length > ot.length) throw new _n(Yt.INVALID_ARGUMENT, `Too many arguments provided to ${j}(). The number of arguments must be less than or equal to the number of orderBy() clauses`); const Gt = []; for (let an = 0; an < te.length; an++) { const kn = te[an]; if (ot[an].field.isKeyField()) { if ("string" != typeof kn) throw new _n(Yt.INVALID_ARGUMENT, `Invalid query. Expected a string for document ID in ${j}(), but got a ${typeof kn}`); if (!g(f) && -1 !== kn.indexOf("/")) throw new _n(Yt.INVALID_ARGUMENT, `Invalid query. When querying a collection and ordering by documentId(), the value passed to ${j}() must be a plain document ID, but '${kn}' contains a slash.`); const Yn = f.path.child(Pi.fromString(kn)); if (!Bn.isDocumentKey(Yn)) throw new _n(Yt.INVALID_ARGUMENT, `Invalid query. When querying a collection group and ordering by documentId(), the value passed to ${j}() must result in a valid document path, but '${Yn}' is not because it contains an odd number of segments.`); const ti = new Bn(Yn); Gt.push(ln(_, ti)) } else { const Yn = gf(R, j, kn); Gt.push(Yn) } } return new Fl(Gt, Ce) }(r._query, r.firestore._databaseId, c, e, t, s) } } function Cp(r, e, t) { if ("string" == typeof (t = (0, he.m9)(t))) { if ("" === t) throw new _n(Yt.INVALID_ARGUMENT, "Invalid query. When querying with documentId(), you must provide a valid document ID, but it was an empty string."); if (!g(e) && -1 !== t.indexOf("/")) throw new _n(Yt.INVALID_ARGUMENT, `Invalid query. When querying a collection by documentId(), you must provide a plain document ID, but '${t}' contains a '/' character.`); const s = e.path.child(Pi.fromString(t)); if (!Bn.isDocumentKey(s)) throw new _n(Yt.INVALID_ARGUMENT, `Invalid query. When querying a collection group by documentId(), the value provided must result in a valid document path, but '${s}' is not because it has an odd number of segments (${s.length}).`); return ln(r, new Bn(s)) } if (t instanceof as) return ln(r, t._key); throw new _n(Yt.INVALID_ARGUMENT, `Invalid query. When querying with documentId(), you must provide a valid string or a DocumentReference, but it was: ${$u(t)}.`) } function wf(r, e) { if (!Array.isArray(r) || 0 === r.length) throw new _n(Yt.INVALID_ARGUMENT, `Invalid Query. A non-empty array is required for '${e.toString()}' filters.`) } function Ip(r, e) { if (e.isInequality()) { const s = T(r), c = e.field; if (null !== s && !s.isEqual(c)) throw new _n(Yt.INVALID_ARGUMENT, `Invalid query. All where filters with an inequality (<, <=, !=, not-in, >, or >=) must be on the same field. But you have inequality filters on '${s.toString()}' and '${c.toString()}'`); const f = au(r); null !== f && xf(0, c, f) } const t = function (s, c) { for (const f of s) for (const _ of f.getFlattenedFilters()) if (c.indexOf(_.op) >= 0) return _.op; return null }(r.filters, function (s) { switch (s) { case "!=": return ["!=", "not-in"]; case "array-contains-any": case "in": return ["not-in"]; case "not-in": return ["array-contains-any", "in", "not-in", "!="]; default: return [] } }(e.op)); if (null !== t) throw new _n(Yt.INVALID_ARGUMENT, t === e.op ? `Invalid query. You cannot use more than one '${e.op.toString()}' filter.` : `Invalid query. You cannot use '${e.op.toString()}' filters with '${t.toString()}' filters.`) } function xf(r, e, t) { if (!t.isEqual(e)) throw new _n(Yt.INVALID_ARGUMENT, `Invalid query. You have a where filter with an inequality (<, <=, !=, not-in, >, or >=) on field '${e.toString()}' and so you must also use '${e.toString()}' as your first argument to orderBy(), but your first orderBy() is on field '${t.toString()}' instead.`) } class Dp { convertValue(e, t = "none") { switch (la(e)) { case 0: return null; case 1: return e.booleanValue; case 2: return vo(e.integerValue || e.doubleValue); case 3: return this.convertTimestamp(e.timestampValue); case 4: return this.convertServerTimestamp(e, t); case 5: return e.stringValue; case 6: return this.convertBytes(Ea(e.bytesValue)); case 7: return this.convertReference(e.referenceValue); case 8: return this.convertGeoPoint(e.geoPointValue); case 9: return this.convertArray(e.arrayValue, t); case 10: return this.convertObject(e.mapValue, t); default: throw Cn() } } convertObject(e, t) { return this.convertObjectMap(e.fields, t) } convertObjectMap(e, t = "none") { const s = {}; return _o(e, (c, f) => { s[c] = this.convertValue(f, t) }), s } convertGeoPoint(e) { return new up(vo(e.latitude), vo(e.longitude)) } convertArray(e, t) { return (e.values || []).map(s => this.convertValue(s, t)) } convertServerTimestamp(e, t) { switch (t) { case "previous": const s = hl(e); return null == s ? null : this.convertValue(s, t); case "estimate": return this.convertTimestamp(qs(e)); default: return null } } convertTimestamp(e) { const t = ja(e); return new Ri(t.seconds, t.nanos) } convertDocumentKey(e, t) { const s = Pi.fromString(e); ai(Eu(s)); const c = new zs(s.get(1), s.get(3)), f = new Bn(s.popFirst(5)); return c.isEqual(t) || er(`Document ${f} contains a document reference within a different database (${c.projectId}/${c.database}) which is not supported. It will be treated as a reference in the current database (${t.projectId}/${t.database}) instead.`), f } } function oh(r, e, t) { let s; return s = r ? t && (t.merge || t.mergeFields) ? r.toFirestore(e, t) : r.toFirestore(e) : e, s } class k_ extends Dp { constructor(e) { super(), this.firestore = e } convertBytes(e) { return new Ic(e) } convertReference(e) { const t = this.convertDocumentKey(e, this.firestore._databaseId); return new as(this.firestore, null, t) } } class Yl { constructor(e, t) { this.hasPendingWrites = e, this.fromCache = t } isEqual(e) { return this.hasPendingWrites === e.hasPendingWrites && this.fromCache === e.fromCache } } class ql extends th { constructor(e, t, s, c, f, _) { super(e, t, s, c, _), this._firestore = e, this._firestoreImpl = e, this.metadata = f } exists() { return super.exists() } data(e = {}) { if (this._document) { if (this._converter) { const t = new Yd(this._firestore, this._userDataWriter, this._key, this._document, this.metadata, null); return this._converter.fromFirestore(t, e) } return this._userDataWriter.convertValue(this._document.data.value, e.serverTimestamps) } } get(e, t = {}) { if (this._document) { const s = this._document.data.field(nh("DocumentSnapshot.get", e)); if (null !== s) return this._userDataWriter.convertValue(s, t.serverTimestamps) } } } class Yd extends ql { data(e = {}) { return super.data(e) } } class Sc { constructor(e, t, s, c) { this._firestore = e, this._userDataWriter = t, this._snapshot = c, this.metadata = new Yl(c.hasPendingWrites, c.fromCache), this.query = s } get docs() { const e = []; return this.forEach(t => e.push(t)), e } get size() { return this._snapshot.docs.size } get empty() { return 0 === this.size } forEach(e, t) { this._snapshot.docs.forEach(s => { e.call(t, new Yd(this._firestore, this._userDataWriter, s.key, s, new Yl(this._snapshot.mutatedKeys.has(s.key), this._snapshot.fromCache), this.query.converter)) }) } docChanges(e = {}) { const t = !!e.includeMetadataChanges; if (t && this._snapshot.excludesMetadataChanges) throw new _n(Yt.INVALID_ARGUMENT, "To include metadata changes with your document changes, you must also pass { includeMetadataChanges:true } to onSnapshot()."); return this._cachedChanges && this._cachedChangesIncludeMetadataChanges === t || (this._cachedChanges = function (s, c) { if (s._snapshot.oldDocs.isEmpty()) { let f = 0; return s._snapshot.docChanges.map(_ => ({ type: "added", doc: new Yd(s._firestore, s._userDataWriter, _.doc.key, _.doc, new Yl(s._snapshot.mutatedKeys.has(_.doc.key), s._snapshot.fromCache), s.query.converter), oldIndex: -1, newIndex: f++ })) } { let f = s._snapshot.oldDocs; return s._snapshot.docChanges.filter(_ => c || 3 !== _.type).map(_ => { const R = new Yd(s._firestore, s._userDataWriter, _.doc.key, _.doc, new Yl(s._snapshot.mutatedKeys.has(_.doc.key), s._snapshot.fromCache), s.query.converter); let j = -1, te = -1; return 0 !== _.type && (j = f.indexOf(_.doc.key), f = f.delete(_.doc.key)), 1 !== _.type && (f = f.add(_.doc), te = f.indexOf(_.doc.key)), { type: R_(_.type), doc: R, oldIndex: j, newIndex: te } }) } }(this, t), this._cachedChangesIncludeMetadataChanges = t), this._cachedChanges } } function R_(r) { switch (r) { case 0: return "added"; case 2: case 3: return "modified"; case 1: return "removed"; default: return Cn() } } function O_(r, e) { return r instanceof ql && e instanceof ql ? r._firestore === e._firestore && r._key.isEqual(e._key) && (null === r._document ? null === e._document : r._document.isEqual(e._document)) && r._converter === e._converter : r instanceof Sc && e instanceof Sc && r._firestore === e._firestore && Zu(r.query, e.query) && r.metadata.isEqual(e.metadata) && r._snapshot.isEqual(e._snapshot) } function P_(r) { r = kr(r, as); const e = kr(r.firestore, uo); return ju(Vo(e), r._key).then(t => L_(e, r, t)) } class Ql extends Dp { constructor(e) { super(), this.firestore = e } convertBytes(e) { return new Ic(e) } convertReference(e) { const t = this.convertDocumentKey(e, this.firestore._databaseId); return new as(this.firestore, null, t) } } function N_(r) { r = kr(r, as); const e = kr(r.firestore, uo), t = Vo(e), s = new Ql(e); return function qv(r, e) { const t = new eo; return r.asyncQueue.enqueueAndForget((0, a.Z)(function* () { return (s = (0, a.Z)(function* (c, f, _) { try { const R = yield function (j, te) { const Ce = Un(j); return Ce.persistence.runTransaction("read document", "readonly", ot => Ce.localDocuments.getDocument(ot, te)) }(c, f); R.isFoundDocument() ? _.resolve(R) : R.isNoDocument() ? _.resolve(null) : _.reject(new _n(Yt.UNAVAILABLE, "Failed to get document from cache. (However, this document may exist on the server. Run again without setting 'source' in the GetOptions to attempt to retrieve the document from the server.)")) } catch (R) { const j = Od(R, `Failed to get document '${f} from cache`); _.reject(j) } }), function (c, f, _) { return s.apply(this, arguments) })(yield uf(r), e, t); var s })), t.promise }(t, r._key).then(c => new ql(e, s, r._key, c, new Yl(null !== c && c.hasLocalMutations, !0), r.converter)) } function F_(r) { r = kr(r, as); const e = kr(r.firestore, uo); return ju(Vo(e), r._key, { source: "server" }).then(t => L_(e, r, t)) } function Cf(r) { r = kr(r, Uo); const e = kr(r.firestore, uo), t = Vo(e), s = new Ql(e); return bp(r._query), m_(t, r._query).then(c => new Sc(e, s, r, c)) } function Ac(r) { r = kr(r, Uo); const e = kr(r.firestore, uo), t = Vo(e), s = new Ql(e); return function Qv(r, e) { const t = new eo; return r.asyncQueue.enqueueAndForget((0, a.Z)(function* () { return (s = (0, a.Z)(function* (c, f, _) { try { const R = yield ku(c, f, !0), j = new Kg(f, R.ir), te = j.sc(R.documents), Ce = j.applyChanges(te, !1); _.resolve(Ce.snapshot) } catch (R) { const j = Od(R, `Failed to execute query '${f} against cache`); _.reject(j) } }), function (c, f, _) { return s.apply(this, arguments) })(yield uf(r), e, t); var s })), t.promise }(t, r._query).then(c => new Sc(e, s, r, c)) } function vb(r) { r = kr(r, Uo); const e = kr(r.firestore, uo), t = Vo(e), s = new Ql(e); return m_(t, r._query, { source: "server" }).then(c => new Sc(e, s, r, c)) } function bb(r, e, t) { r = kr(r, as); const s = kr(r.firestore, uo), c = oh(r.converter, e, t); return sh(s, [qu(Al(s), "setDoc", r._key, c, null !== r.converter, t).toMutation(r._key, fr.none())]) } function Tp(r, e, t, ...s) { r = kr(r, as); const c = kr(r.firestore, uo), f = Al(c); let _; return _ = "string" == typeof (e = (0, he.m9)(e)) || e instanceof Dc ? gp(f, "updateDoc", r._key, e, t, s) : pp(f, "updateDoc", r._key, e), sh(c, [_.toMutation(r._key, fr.exists(!0))]) } function cd(r) { return sh(kr(r.firestore, uo), [new oc(r._key, fr.none())]) } function Mp(r, e) { const t = kr(r.firestore, uo), s = Ku(r), c = oh(r.converter, e); return sh(t, [qu(Al(r.firestore), "addDoc", s._key, c, null !== r.converter, {}).toMutation(s._key, fr.exists(!1))]).then(() => s) } function yb(r, ...e) { var t, s, c; r = (0, he.m9)(r); let f = { includeMetadataChanges: !1 }, _ = 0; "object" != typeof e[_] || Cc(e[_]) || (f = e[_], _++); const R = { includeMetadataChanges: f.includeMetadataChanges }; if (Cc(e[_])) { const ot = e[_]; e[_] = null === (t = ot.next) || void 0 === t ? void 0 : t.bind(ot), e[_ + 1] = null === (s = ot.error) || void 0 === s ? void 0 : s.bind(ot), e[_ + 2] = null === (c = ot.complete) || void 0 === c ? void 0 : c.bind(ot) } let j, te, Ce; if (r instanceof as) te = kr(r.firestore, uo), Ce = Vl(r._key.path), j = { next: ot => { e[_] && e[_](L_(te, r, ot)) }, error: e[_ + 1], complete: e[_ + 2] }; else { const ot = kr(r, Uo); te = kr(ot.firestore, uo), Ce = ot._query; const Gt = new Ql(te); j = { next: an => { e[_] && e[_](new Sc(te, Gt, ot, an)) }, error: e[_ + 1], complete: e[_ + 2] }, bp(r._query) } return function (ot, Gt, an, kn) { const Yn = new zu(kn), ti = new qh(Gt, Yn, an); return ot.asyncQueue.enqueueAndForget((0, a.Z)(function* () { return wc(yield Hd(ot), ti) })), () => { Yn.Dc(), ot.asyncQueue.enqueueAndForget((0, a.Z)(function* () { return Nm(yield Hd(ot), ti) })) } }(Vo(te), Ce, R, j) } function Sp(r, e) { return function Xv(r, e) { const t = new zu(e); return r.asyncQueue.enqueueAndForget((0, a.Z)(function* () { return s = yield Hd(r), c = t, Un(s).ku.add(c), void c.next(); var s, c })), () => { t.Dc(), r.asyncQueue.enqueueAndForget((0, a.Z)(function* () { return s = yield Hd(r), c = t, void Un(s).ku.delete(c); var s, c })) } }(Vo(r = kr(r, uo)), Cc(e) ? e : { next: e }) } function sh(r, e) { return function (t, s) { const c = new eo; return t.asyncQueue.enqueueAndForget((0, a.Z)(function* () { return function Bv(r, e, t) { return Ia.apply(this, arguments) }(yield rp(t), s, c) })), c.promise }(Vo(r), e) } function L_(r, e, t) { const s = t.docs.get(e._key), c = new Ql(r); return new ql(r, c, e._key, s, new Yl(t.hasPendingWrites, t.fromCache), e.converter) } const Cb = { maxAttempts: 5 }; class Ap { constructor(e, t) { this._firestore = e, this._commitHandler = t, this._mutations = [], this._committed = !1, this._dataReader = Al(e) } set(e, t, s) { this._verifyNotCommitted(); const c = kc(e, this._firestore), f = oh(c.converter, t, s), _ = qu(this._dataReader, "WriteBatch.set", c._key, f, null !== c.converter, s); return this._mutations.push(_.toMutation(c._key, fr.none())), this } update(e, t, s, ...c) { this._verifyNotCommitted(); const f = kc(e, this._firestore); let _; return _ = "string" == typeof (t = (0, he.m9)(t)) || t instanceof Dc ? gp(this._dataReader, "WriteBatch.update", f._key, t, s, c) : pp(this._dataReader, "WriteBatch.update", f._key, t), this._mutations.push(_.toMutation(f._key, fr.exists(!0))), this } delete(e) { this._verifyNotCommitted(); const t = kc(e, this._firestore); return this._mutations = this._mutations.concat(new oc(t._key, fr.none())), this } commit() { return this._verifyNotCommitted(), this._committed = !0, this._mutations.length > 0 ? this._commitHandler(this._mutations) : Promise.resolve() } _verifyNotCommitted() { if (this._committed) throw new _n(Yt.FAILED_PRECONDITION, "A write batch can no longer be used after commit() has been called.") } } function kc(r, e) { if ((r = (0, he.m9)(r)).firestore !== e) throw new _n(Yt.INVALID_ARGUMENT, "Provided document reference is from a different Firestore instance."); return r } class z_ extends class { constructor(e, t) { this._firestore = e, this._transaction = t, this._dataReader = Al(e) } get(e) { const t = kc(e, this._firestore), s = new k_(this._firestore); return this._transaction.lookup([t._key]).then(c => { if (!c || 1 !== c.length) return Cn(); const f = c[0]; if (f.isFoundDocument()) return new th(this._firestore, s, f.key, f, t.converter); if (f.isNoDocument()) return new th(this._firestore, s, t._key, null, t.converter); throw Cn() }) } set(e, t, s) { const c = kc(e, this._firestore), f = oh(c.converter, t, s), _ = qu(this._dataReader, "Transaction.set", c._key, f, null !== c.converter, s); return this._transaction.set(c._key, _), this } update(e, t, s, ...c) { const f = kc(e, this._firestore); let _; return _ = "string" == typeof (t = (0, he.m9)(t)) || t instanceof Dc ? gp(this._dataReader, "Transaction.update", f._key, t, s, c) : pp(this._dataReader, "Transaction.update", f._key, t), this._transaction.update(f._key, _), this } delete(e) { const t = kc(e, this._firestore); return this._transaction.delete(t._key), this } }{ constructor(e, t) { super(e, t), this._firestore = e } get(e) { const t = kc(e, this._firestore), s = new Ql(this._firestore); return super.get(e).then(c => new ql(this._firestore, s, t._key, c._document, new Yl(!1, !1), t.converter)) } } function Dy(r, e, t) { r = kr(r, uo); const s = Object.assign(Object.assign({}, Cb), t); return function (c) { if (c.maxAttempts < 1) throw new _n(Yt.INVALID_ARGUMENT, "Max attempts must be at least 1") }(s), function (c, f, _) { const R = new eo; return c.asyncQueue.enqueueAndForget((0, a.Z)(function* () { const j = yield function h_(r) { return df(r).then(e => e.datastore) }(c); new s_(c.asyncQueue, j, _, f, R).run() })), R.promise }(Vo(r), c => e(new z_(r, c)), s) } function kp() { return new Zl("deleteField") } function Rp() { return new mp("serverTimestamp") } function Rl(...r) { return new Qu("arrayUnion", r) } function Ib(...r) { return new sb("arrayRemove", r) } function Db(r) { return new ab("increment", r) } !function (r, e = !0) { qi = y.SDK_VERSION, (0, y._registerComponent)(new v.wA("firestore", (t, { instanceIdentifier: s, options: c }) => { const f = t.getProvider("app").getImmediate(), _ = new uo(new Cl(t.getProvider("auth-internal")), new ga(t.getProvider("app-check-internal")), function (R, j) { if (!Object.prototype.hasOwnProperty.apply(R.options, ["projectId"])) throw new _n(Yt.INVALID_ARGUMENT, '"projectId" not provided in firebase.initializeApp.'); return new zs(R.options.projectId, j) }(f, s), f); return c = Object.assign({ useFetchStreams: e }, c), _._setSettings(c), _ }, "PUBLIC").setMultipleInstances(!0)), (0, y.registerVersion)(Fi, "3.13.0", r), (0, y.registerVersion)(Fi, "3.13.0", "esm2017") }() }, 9058: (nn, Qe, C) => { C.d(Qe, { $s: () => me, BH: () => le, G6: () => Hn, L: () => Ie, LL: () => Wt, P0: () => ut, Pz: () => Le, Sg: () => ge, UG: () => $e, US: () => Se, ZB: () => xe, ZR: () => Ft, aH: () => ie, b$: () => bn, eu: () => vt, hl: () => at, jU: () => rt, m9: () => Lt, ne: () => Xe, pd: () => se, q4: () => Ye, r3: () => Pt, ru: () => Kt, tV: () => Q, uI: () => ee, vZ: () => Zt, w1: () => Mn, xO: () => Fn, xb: () => Nt, z$: () => ue, zI: () => xt, zd: () => Ke }); const Y = function (He) { const ae = []; let z = 0; for (let L = 0; L < He.length; L++) { let H = He.charCodeAt(L); H < 128 ? ae[z++] = H : H < 2048 ? (ae[z++] = H >> 6 | 192, ae[z++] = 63 & H | 128) : 55296 == (64512 & H) && L + 1 < He.length && 56320 == (64512 & He.charCodeAt(L + 1)) ? (H = 65536 + ((1023 & H) << 10) + (1023 & He.charCodeAt(++L)), ae[z++] = H >> 18 | 240, ae[z++] = H >> 12 & 63 | 128, ae[z++] = H >> 6 & 63 | 128, ae[z++] = 63 & H | 128) : (ae[z++] = H >> 12 | 224, ae[z++] = H >> 6 & 63 | 128, ae[z++] = 63 & H | 128) } return ae }, Se = { byteToCharMap_: null, charToByteMap_: null, byteToCharMapWebSafe_: null, charToByteMapWebSafe_: null, ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", get ENCODED_VALS() { return this.ENCODED_VALS_BASE + "+/=" }, get ENCODED_VALS_WEBSAFE() { return this.ENCODED_VALS_BASE + "-_." }, HAS_NATIVE_SUPPORT: "function" == typeof atob, encodeByteArray(He, ae) { if (!Array.isArray(He)) throw Error("encodeByteArray takes an array as a parameter"); this.init_(); const z = ae ? this.byteToCharMapWebSafe_ : this.byteToCharMap_, L = []; for (let H = 0; H < He.length; H += 3) { const Ne = He[H], pt = H + 1 < He.length, pe = pt ? He[H + 1] : 0, fe = H + 2 < He.length, F = fe ? He[H + 2] : 0; let lt = (15 & pe) << 2 | F >> 6, gt = 63 & F; fe || (gt = 64, pt || (lt = 64)), L.push(z[Ne >> 2], z[(3 & Ne) << 4 | pe >> 4], z[lt], z[gt]) } return L.join("") }, encodeString(He, ae) { return this.HAS_NATIVE_SUPPORT && !ae ? btoa(He) : this.encodeByteArray(Y(He), ae) }, decodeString(He, ae) { return this.HAS_NATIVE_SUPPORT && !ae ? atob(He) : function (He) { const ae = []; let z = 0, L = 0; for (; z < He.length;) { const H = He[z++]; if (H < 128) ae[L++] = String.fromCharCode(H); else if (H > 191 && H < 224) { const Ne = He[z++]; ae[L++] = String.fromCharCode((31 & H) << 6 | 63 & Ne) } else if (H > 239 && H < 365) { const fe = ((7 & H) << 18 | (63 & He[z++]) << 12 | (63 & He[z++]) << 6 | 63 & He[z++]) - 65536; ae[L++] = String.fromCharCode(55296 + (fe >> 10)), ae[L++] = String.fromCharCode(56320 + (1023 & fe)) } else { const Ne = He[z++], pt = He[z++]; ae[L++] = String.fromCharCode((15 & H) << 12 | (63 & Ne) << 6 | 63 & pt) } } return ae.join("") }(this.decodeStringToByteArray(He, ae)) }, decodeStringToByteArray(He, ae) { this.init_(); const z = ae ? this.charToByteMapWebSafe_ : this.charToByteMap_, L = []; for (let H = 0; H < He.length;) { const Ne = z[He.charAt(H++)], pe = H < He.length ? z[He.charAt(H)] : 0; ++H; const F = H < He.length ? z[He.charAt(H)] : 64; ++H; const Te = H < He.length ? z[He.charAt(H)] : 64; if (++H, null == Ne || null == pe || null == F || null == Te) throw new ke; L.push(Ne << 2 | pe >> 4), 64 !== F && (L.push(pe << 4 & 240 | F >> 2), 64 !== Te && L.push(F << 6 & 192 | Te)) } return L }, init_() { if (!this.byteToCharMap_) { this.byteToCharMap_ = {}, this.charToByteMap_ = {}, this.byteToCharMapWebSafe_ = {}, this.charToByteMapWebSafe_ = {}; for (let He = 0; He < this.ENCODED_VALS.length; He++)this.byteToCharMap_[He] = this.ENCODED_VALS.charAt(He), this.charToByteMap_[this.byteToCharMap_[He]] = He, this.byteToCharMapWebSafe_[He] = this.ENCODED_VALS_WEBSAFE.charAt(He), this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[He]] = He, He >= this.ENCODED_VALS_BASE.length && (this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(He)] = He, this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(He)] = He) } } }; class ke extends Error { constructor() { super(...arguments), this.name = "DecodeBase64StringError" } } const Ie = function (He) { return function (He) { const ae = Y(He); return Se.encodeByteArray(ae, !0) }(He).replace(/\./g, "") }, Q = function (He) { try { return Se.decodeString(He, !0) } catch (ae) { console.error("base64Decode failed: ", ae) } return null }; function xe(He, ae) { if (!(ae instanceof Object)) return ae; switch (ae.constructor) { case Date: return new Date(ae.getTime()); case Object: void 0 === He && (He = {}); break; case Array: He = []; break; default: return ae }for (const z in ae) !ae.hasOwnProperty(z) || !ze(z) || (He[z] = xe(He[z], ae[z])); return He } function ze(He) { return "__proto__" !== He } const tt = () => { try { return function Oe() { if (typeof self < "u") return self; if (typeof window < "u") return window; if (typeof global < "u") return global; throw new Error("Unable to locate global object.") }().__FIREBASE_DEFAULTS__ || (() => { if (typeof process > "u" || typeof process.env > "u") return; const He = process.env.__FIREBASE_DEFAULTS__; return He ? JSON.parse(He) : void 0 })() || (() => { if (typeof document > "u") return; let He; try { He = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/) } catch { return } const ae = He && Q(He[1]); return ae && JSON.parse(ae) })() } catch (He) { return void console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${He}`) } }, Ye = He => { var ae, z; return null === (z = null === (ae = tt()) || void 0 === ae ? void 0 : ae.emulatorHosts) || void 0 === z ? void 0 : z[He] }, ut = He => { const ae = Ye(He); if (!ae) return; const z = ae.lastIndexOf(":"); if (z <= 0 || z + 1 === ae.length) throw new Error(`Invalid host ${ae} with no separate hostname and port!`); const L = parseInt(ae.substring(z + 1), 10); return "[" === ae[0] ? [ae.substring(1, z - 1), L] : [ae.substring(0, z), L] }, ie = () => { var He; return null === (He = tt()) || void 0 === He ? void 0 : He.config }, Le = He => { var ae; return null === (ae = tt()) || void 0 === ae ? void 0 : ae[`_${He}`] }; class le { constructor() { this.reject = () => { }, this.resolve = () => { }, this.promise = new Promise((ae, z) => { this.resolve = ae, this.reject = z }) } wrapCallback(ae) { return (z, L) => { z ? this.reject(z) : this.resolve(L), "function" == typeof ae && (this.promise.catch(() => { }), 1 === ae.length ? ae(z) : ae(z, L)) } } } function ge(He, ae) { if (He.uid) throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.'); const L = ae || "demo-project", H = He.iat || 0, Ne = He.sub || He.user_id; if (!Ne) throw new Error("mockUserToken must contain 'sub' or 'user_id' field!"); const pt = Object.assign({ iss: `https://securetoken.google.com/${L}`, aud: L, iat: H, exp: H + 3600, auth_time: H, sub: Ne, user_id: Ne, firebase: { sign_in_provider: "custom", identities: {} } }, He); return [Ie(JSON.stringify({ alg: "none", type: "JWT" })), Ie(JSON.stringify(pt)), ""].join(".") } function ue() { return typeof navigator < "u" && "string" == typeof navigator.userAgent ? navigator.userAgent : "" } function ee() { return typeof window < "u" && !!(window.cordova || window.phonegap || window.PhoneGap) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(ue()) } function $e() { var He; const ae = null === (He = tt()) || void 0 === He ? void 0 : He.forceEnvironment; if ("node" === ae) return !0; if ("browser" === ae) return !1; try { return "[object process]" === Object.prototype.toString.call(global.process) } catch { return !1 } } function rt() { return "object" == typeof self && self.self === self } function Kt() { const He = "object" == typeof chrome ? chrome.runtime : "object" == typeof browser ? browser.runtime : void 0; return "object" == typeof He && void 0 !== He.id } function bn() { return "object" == typeof navigator && "ReactNative" === navigator.product } function Mn() { const He = ue(); return He.indexOf("MSIE ") >= 0 || He.indexOf("Trident/") >= 0 } function Hn() { return !$e() && navigator.userAgent.includes("Safari") && !navigator.userAgent.includes("Chrome") } function at() { try { return "object" == typeof indexedDB } catch { return !1 } } function vt() { return new Promise((He, ae) => { try { let z = !0; const L = "validate-browser-context-for-indexeddb-analytics-module", H = self.indexedDB.open(L); H.onsuccess = () => { H.result.close(), z || self.indexedDB.deleteDatabase(L), He(!0) }, H.onupgradeneeded = () => { z = !1 }, H.onerror = () => { var Ne; ae((null === (Ne = H.error) || void 0 === Ne ? void 0 : Ne.message) || "") } } catch (z) { ae(z) } }) } function xt() { return !(typeof navigator > "u" || !navigator.cookieEnabled) } class Ft extends Error { constructor(ae, z, L) { super(z), this.code = ae, this.customData = L, this.name = "FirebaseError", Object.setPrototypeOf(this, Ft.prototype), Error.captureStackTrace && Error.captureStackTrace(this, Wt.prototype.create) } } class Wt { constructor(ae, z, L) { this.service = ae, this.serviceName = z, this.errors = L } create(ae, ...z) { const L = z[0] || {}, H = `${this.service}/${ae}`, Ne = this.errors[ae], pt = Ne ? function rn(He, ae) { return He.replace(Jt, (z, L) => { const H = ae[L]; return null != H ? String(H) : `<${L}?>` }) }(Ne, L) : "Error"; return new Ft(H, `${this.serviceName}: ${pt} (${H}).`, L) } } const Jt = /\{\$([^}]+)}/g; function Pt(He, ae) { return Object.prototype.hasOwnProperty.call(He, ae) } function Nt(He) { for (const ae in He) if (Object.prototype.hasOwnProperty.call(He, ae)) return !1; return !0 } function Zt(He, ae) { if (He === ae) return !0; const z = Object.keys(He), L = Object.keys(ae); for (const H of z) { if (!L.includes(H)) return !1; const Ne = He[H], pt = ae[H]; if (gn(Ne) && gn(pt)) { if (!Zt(Ne, pt)) return !1 } else if (Ne !== pt) return !1 } for (const H of L) if (!z.includes(H)) return !1; return !0 } function gn(He) { return null !== He && "object" == typeof He } function Fn(He) { const ae = []; for (const [z, L] of Object.entries(He)) Array.isArray(L) ? L.forEach(H => { ae.push(encodeURIComponent(z) + "=" + encodeURIComponent(H)) }) : ae.push(encodeURIComponent(z) + "=" + encodeURIComponent(L)); return ae.length ? "&" + ae.join("&") : "" } function Ke(He) { const ae = {}; return He.replace(/^\?/, "").split("&").forEach(L => { if (L) { const [H, Ne] = L.split("="); ae[decodeURIComponent(H)] = decodeURIComponent(Ne) } }), ae } function se(He) { const ae = He.indexOf("?"); if (!ae) return ""; const z = He.indexOf("#", ae); return He.substring(ae, z > 0 ? z : void 0) } function Xe(He, ae) { const z = new Ot(He, ae); return z.subscribe.bind(z) } class Ot { constructor(ae, z) { this.observers = [], this.unsubscribes = [], this.observerCount = 0, this.task = Promise.resolve(), this.finalized = !1, this.onNoObservers = z, this.task.then(() => { ae(this) }).catch(L => { this.error(L) }) } next(ae) { this.forEachObserver(z => { z.next(ae) }) } error(ae) { this.forEachObserver(z => { z.error(ae) }), this.close(ae) } complete() { this.forEachObserver(ae => { ae.complete() }), this.close() } subscribe(ae, z, L) { let H; if (void 0 === ae && void 0 === z && void 0 === L) throw new Error("Missing Observer."); H = function Ue(He, ae) { if ("object" != typeof He || null === He) return !1; for (const z of ae) if (z in He && "function" == typeof He[z]) return !0; return !1 }(ae, ["next", "error", "complete"]) ? ae : { next: ae, error: z, complete: L }, void 0 === H.next && (H.next = Z), void 0 === H.error && (H.error = Z), void 0 === H.complete && (H.complete = Z); const Ne = this.unsubscribeOne.bind(this, this.observers.length); return this.finalized && this.task.then(() => { try { this.finalError ? H.error(this.finalError) : H.complete() } catch { } }), this.observers.push(H), Ne } unsubscribeOne(ae) { void 0 === this.observers || void 0 === this.observers[ae] || (delete this.observers[ae], this.observerCount -= 1, 0 === this.observerCount && void 0 !== this.onNoObservers && this.onNoObservers(this)) } forEachObserver(ae) { if (!this.finalized) for (let z = 0; z < this.observers.length; z++)this.sendOne(z, ae) } sendOne(ae, z) { this.task.then(() => { if (void 0 !== this.observers && void 0 !== this.observers[ae]) try { z(this.observers[ae]) } catch (L) { typeof console < "u" && console.error && console.error(L) } }) } close(ae) { this.finalized || (this.finalized = !0, void 0 !== ae && (this.finalError = ae), this.task.then(() => { this.observers = void 0, this.onNoObservers = void 0 })) } } function Z() { } const Et = 1e3, _t = 2, G = 144e5, W = .5; function me(He, ae = Et, z = _t) { const L = ae * Math.pow(z, He), H = Math.round(W * L * (Math.random() - .5) * 2); return Math.min(G, L + H) } function Lt(He) { return He && He._delegate ? He._delegate : He } }, 6009: (nn, Qe, C) => { C.d(Qe, { g: () => ge }); var a = C(4190), y = C(5879); let v = (() => { class ue { } return ue.\u0275fac = function ($e) { return new ($e || ue) }, ue.\u0275cmp = y.Xpm({ type: ue, selectors: [["app-user"]], decls: 1, vars: 0, template: function ($e, rt) { 1 & $e && y._UZ(0, "router-outlet") }, dependencies: [a.lC] }), ue })(); var Y = C(6223), he = C(304), Se = C(6814), ke = C(1175), re = C(2032), Ie = C(4170), Q = C(2296); function _e(ue, ee) { 1 & ue && (y.TgZ(0, "mat-error"), y._uU(1, "Email Invalid"), y.qZA()) } let xe = (() => { class ue { constructor($e, rt) { this.authService = $e, this.router = rt, this.hide = !0, this.users = [], this.email = "", this.password = "", this.error = { message: "" }, this.loginForm = new Y.cw({ email: new Y.NI("", [Y.kI.required, Y.kI.pattern("^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$")]), password: new Y.NI("", { validators: Y.kI.required }) }) } onLogin() { this.authService.signIn(this.loginForm.controls.email.value, this.loginForm.controls.password.value).then(() => this.authService.getCurrentUserUid().then(Kt => { this.authService.getUserRole(Kt).subscribe(bn => { "patient" === bn && this.router.navigate(["patient/dashboard/current"]), "doctor" === bn && this.router.navigate(["doctor/dashboard/current"]), "admin" === bn && this.router.navigate(["admin"]) }) })).catch(Kt => { this.error.message = "auth/user-not-found" === Kt.code ? "User-ul nu a fost g\u0103sit." : "auth/invalid-email" === Kt.code ? "Email obligatoriu" : "auth/invalid-password" === Kt.code ? "Parol\u0103 obligatorie" : "auth/wrong-password" === Kt.code || "auth/invalid-email" === Kt.code ? "Email sau parol\u0103 incorecte. Te rog s\u0103 \xeencerci din nou" : "auth/missing-password" === Kt.code ? "Parol\u0103 obligatorie" : "auth/too-many-requests" === Kt.code ? "Cont blocat, num\u0103rul de cereri dep\u0103\u0219ite" : "Eroare intern\u0103, te rog s\u0103 \xeencerci mai t\xe2rziu" }) } onLoginWithGoogle() { this.authService.patientGoogleSignIn().then(() => { this.router.navigate(["patient/dashboard/current"]) }) } onRouterSignUp() { this.router.navigate(["sign-up"]) } } return ue.\u0275fac = function ($e) { return new ($e || ue)(y.Y36(he.e), y.Y36(a.F0)) }, ue.\u0275cmp = y.Xpm({ type: ue, selectors: [["app-user-login"]], decls: 34, vars: 7, consts: [[1, "page-container"], [1, "form-login-container"], ["id", "googleLogin", "mat-raised-button", "", "color", "warn", 3, "click"], [1, "divider", "sign-in"], [1, "example-form", 3, "formGroup"], ["id", "error"], [1, "login-full-width"], ["type", "email", "matInput", "", "placeholder", "nume@mail.com", "required", "", "formControlName", "email"], ["matSuffix", ""], [4, "ngIf"], ["matInput", "", "formControlName", "password", 3, "type"], ["type", "button", "mat-icon-button", "", "matSuffix", "", 3, "click"], [1, "forgotPassword"], ["routerLink", "/forgot-password"], ["mat-raised-button", "", "id", "loginBtn", "color", "primary", 3, "click"], ["id", "signUpLink"], ["routerLink", "/sign-up"]], template: function ($e, rt) { if (1 & $e && (y.TgZ(0, "section", 0)(1, "h1"), y._uU(2, "Conecteaz\u0103-te in contul t\u0103u"), y.qZA(), y.TgZ(3, "div", 1)(4, "button", 2), y.NdJ("click", function () { return rt.onLoginWithGoogle() }), y._uU(5, "Google Login"), y.qZA(), y._UZ(6, "hr", 3), y.TgZ(7, "form", 4)(8, "p", 5), y._uU(9), y.qZA(), y.TgZ(10, "mat-form-field", 6)(11, "mat-label"), y._uU(12, "Email"), y.qZA(), y._UZ(13, "input", 7), y.TgZ(14, "mat-icon", 8), y._uU(15, "alternate_email"), y.qZA(), y.YNc(16, _e, 2, 0, "mat-error", 9), y.qZA(), y.TgZ(17, "mat-form-field", 6)(18, "mat-label"), y._uU(19, "Parola"), y.qZA(), y._UZ(20, "input", 10), y.TgZ(21, "button", 11), y.NdJ("click", function () { return rt.hide = !rt.hide }), y.TgZ(22, "mat-icon"), y._uU(23), y.qZA()()(), y.TgZ(24, "div", 12)(25, "a", 13), y._uU(26, "Ai uitat parola?"), y.qZA()(), y.TgZ(27, "button", 14), y.NdJ("click", function () { return rt.onLogin() }), y._uU(28, "Login"), y.qZA(), y.TgZ(29, "span", 15), y._uU(30, "Nu ai un cont? "), y.TgZ(31, "a", 16), y._uU(32, "Signup"), y.qZA()()()()(), y._UZ(33, "router-outlet")), 2 & $e) { let Kt; y.xp6(7), y.Q6J("formGroup", rt.loginForm), y.xp6(2), y.Oqu(rt.error.message), y.xp6(7), y.Q6J("ngIf", null == (Kt = rt.loginForm.get("email")) ? null : Kt.hasError("pattern")), y.xp6(4), y.Q6J("type", rt.hide ? "password" : "text"), y.xp6(1), y.uIk("aria-label", "Hide password")("aria-pressed", rt.hide), y.xp6(2), y.Oqu(rt.hide ? "visibility_off" : "visibility") } }, dependencies: [Se.O5, ke.Hw, Y._Y, Y.Fj, Y.JJ, Y.JL, Y.Q7, Y.sg, Y.u, re.Nt, Ie.KE, Ie.hX, Ie.TO, Ie.R9, Q.lW, Q.RK, a.lC, a.rH], styles: ['#error[_ngcontent-%COMP%]{text-align:center;color:red}.page-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;justify-content:center;align-items:center;padding:2rem}h1[_ngcontent-%COMP%]{text-align:center;margin:80px 0 40px}hr.divider.sign-in[_ngcontent-%COMP%]:after{position:relative;top:-10px;padding-right:8px;padding-left:8px;background-color:#fff;content:"sau login cu email-ul"}hr.divider[_ngcontent-%COMP%]{height:1px;margin:30px 0;overflow:visible;border:none;background-color:#000;color:#6e6d7a;text-align:center;width:100%}.form-login-container[_ngcontent-%COMP%]{display:flex;flex-direction:column;align-items:center;justify-content:center;max-width:30rem}.login-full-width[_ngcontent-%COMP%]{width:100%;margin-bottom:0}#googleLogin[_ngcontent-%COMP%]{width:100%}.forgotPassword[_ngcontent-%COMP%]{text-align:right}#loginBtn[_ngcontent-%COMP%]{width:100%;margin-top:10px;margin-bottom:10px}'] }), ue })(); var ze = C(498), Oe = C(7466); function We(ue, ee) { if (1 & ue && y._UZ(0, "img", 24), 2 & ue) { const $e = y.oxw(); y.Q6J("src", $e.patientImage, y.LSH) } } function Pe(ue, ee) { if (1 & ue && (y.TgZ(0, "div", 25), y._uU(1), y.qZA()), 2 & ue) { const $e = y.oxw(); y.xp6(1), y.hij(" ", $e.error.message, " ") } } function Ve(ue, ee) { 1 & ue && (y.TgZ(0, "mat-error"), y._uU(1, "Num\u0103r de telefon invalid"), y.qZA()) } function tt(ue, ee) { 1 & ue && (y.TgZ(0, "mat-error"), y._uU(1, "Adres\u0103 de email invalid\u0103"), y.qZA()) } function Ye(ue, ee) { 1 & ue && (y.TgZ(0, "mat-error"), y._uU(1, "Email invalid"), y.qZA()) } const le = [{ path: "", component: v }, { path: "login", component: xe }, { path: "sign-up", component: (() => { class ue { constructor($e, rt, Kt) { this.authService = $e, this.imageUploadService = rt, this.router = Kt, this.patientImage = "", this.hide = !0, this.error = { message: "" }, this.signUpForm = new Y.cw({ lastName: new Y.NI("", { nonNullable: !0, validators: Y.kI.required }), firstName: new Y.NI("", { nonNullable: !0, validators: Y.kI.required }), gender: new Y.NI("", { nonNullable: !0, validators: Y.kI.required }), phone: new Y.NI("", { nonNullable: !0, validators: [Y.kI.required, Y.kI.pattern("^((\\+91-?)|0)?[0-9]{3}( ?)[0-9]{3}( ?)[0-9]{4}$")] }), email: new Y.NI("", { nonNullable: !0, validators: [Y.kI.required, Y.kI.email, Y.kI.pattern("^[a-z0-9._%+-]+@[a-z0-9.-]+\\.[a-z]{2,4}$")] }), password: new Y.NI("", { nonNullable: !0, validators: Y.kI.required }), imageUrl: new Y.NI("", { nonNullable: !0 }) }) } onSignUp() { this.authService.pacientSignUp(this.signUpForm.controls.password.value, { ...this.signUpForm.getRawValue(), imageUrl: this.patientImage }).then(() => { this.router.navigate(["patient/dashboard/details"]), this.signUpForm.reset() }).catch($e => { this.error.message = "auth/email-already-in-use" === $e.code ? "Adres\u0103 de email deja \xeenregistrat\u0103 \xeen baza noastra de date. Te rog \xeencearc\u0103 cu alta." : "auth/invalid-email" === $e.code ? "Adres\u0103 de email invalid\u0103." : "auth/weak-password" === $e.code ? "Parol\u0103 prea scurt\u0103. Parola trebuie s\u0103 aib\u0103 minim 6 caractere." : "auth/invalid-photo-url" === $e.code ? "URL-ul pozei este invalid. \xcencearc\u0103 alta te rog." : "auth/invalid-phone-number" === $e.code ? "Numarul de telefon intrudus este invalid. Formatul trebuie sa fie 07xx xxx xxx" : "auth/phone-number-already-exists" === $e.code ? "Num\u0103rul de telefon este deja \xeenregistrat. Te rog \xeencearc\u0103 cu altul." : "Eroare intern\u0103, te rog sa \xeencerci mai t\xe2rziu" }) } uploadImage($e) { const rt = ($e?.target).files?.[0]; rt && this.imageUploadService.uploadImage(rt, "doctors").subscribe(Kt => { this.patientImage = Kt }) } } return ue.\u0275fac = function ($e) { return new ($e || ue)(y.Y36(he.e), y.Y36(ze.K), y.Y36(a.F0)) }, ue.\u0275cmp = y.Xpm({ type: ue, selectors: [["app-user-sign-up"]], decls: 55, vars: 11, consts: [[1, "form-container"], [1, "example-form", 3, "formGroup", "ngSubmit"], [1, "imageContainer"], ["alt", "Imagine Doctor Neincarcata", "width", "50%", "height", "50%", 3, "src", 4, "ngIf"], ["for", "fileInput", 1, "fileLabel"], ["type", "file", "accept", ".png,.jpg", "formControlName", "imageUrl", "id", "fileInput", 3, "change"], ["class", "error-message", 4, "ngIf"], [1, "example-full-width"], ["matInput", "", "formControlName", "lastName", "placeholder", "Nume"], ["matSuffix", ""], ["matInput", "", "formControlName", "firstName", "placeholder", "Prenume"], ["formControlName", "gender"], ["value", "Masculin"], ["value", "Feminin"], ["value", "Altul"], ["type", "tel", "formControlName", "phone", "matInput", "", "placeholder", "0712 345 678"], [4, "ngIf"], ["type", "email", "formControlName", "email", "matInput", "", "placeholder", "nume@mail.com", "required", ""], ["email", ""], ["matInput", "", "formControlName", "password", 3, "type"], ["password", ""], ["type", "button", "mat-icon-button", "", "matSuffix", "", 3, "click"], [1, "actions"], ["id", "signUpBtn", "mat-raised-button", "", "color", "primary", "type", "submit", 3, "disabled"], ["alt", "Imagine Doctor Neincarcata", "width", "50%", "height", "50%", 3, "src"], [1, "error-message"]], template: function ($e, rt) { if (1 & $e && (y.TgZ(0, "div", 0)(1, "form", 1), y.NdJ("ngSubmit", function () { return rt.onSignUp() }), y.TgZ(2, "div", 2), y.YNc(3, We, 1, 1, "img", 3), y.TgZ(4, "label", 4), y._uU(5, " Incarca o imagine "), y.qZA(), y.TgZ(6, "input", 5), y.NdJ("change", function (bn) { return rt.uploadImage(bn) }), y.qZA()(), y.YNc(7, Pe, 2, 1, "div", 6), y.TgZ(8, "mat-form-field", 7)(9, "mat-label"), y._uU(10, "Nume"), y.qZA(), y._UZ(11, "input", 8), y.TgZ(12, "mat-icon", 9), y._uU(13, "person"), y.qZA()(), y.TgZ(14, "mat-form-field", 7)(15, "mat-label"), y._uU(16, "Prenume"), y.qZA(), y._UZ(17, "input", 10), y.TgZ(18, "mat-icon", 9), y._uU(19, "person"), y.qZA()(), y.TgZ(20, "mat-radio-group", 11)(21, "mat-radio-button", 12), y._uU(22, "Masculin"), y.qZA(), y.TgZ(23, "mat-radio-button", 13), y._uU(24, "Feminin"), y.qZA(), y.TgZ(25, "mat-radio-button", 14), y._uU(26, "Altul"), y.qZA()(), y.TgZ(27, "mat-form-field", 7)(28, "mat-label"), y._uU(29, "Telefon"), y.qZA(), y._UZ(30, "input", 15), y.TgZ(31, "mat-icon", 9), y._uU(32, "mode_edit"), y.qZA(), y.YNc(33, Ve, 2, 0, "mat-error", 16), y.qZA(), y.TgZ(34, "mat-form-field", 7)(35, "mat-label"), y._uU(36, "Email"), y.qZA(), y._UZ(37, "input", 17, 18), y.YNc(39, tt, 2, 0, "mat-error", 16), y.TgZ(40, "mat-icon", 9), y._uU(41, "alternate_email"), y.qZA(), y.YNc(42, Ye, 2, 0, "mat-error", 16), y.qZA(), y.TgZ(43, "mat-form-field", 7)(44, "mat-label"), y._uU(45, "Parol\u0103"), y.qZA(), y._UZ(46, "input", 19, 20), y.TgZ(48, "button", 21), y.NdJ("click", function () { return rt.hide = !rt.hide }), y.TgZ(49, "mat-icon"), y._uU(50), y.qZA()()(), y.TgZ(51, "div", 22)(52, "button", 23), y._uU(53, " Sign-up "), y.qZA()()()(), y._UZ(54, "router-outlet")), 2 & $e) { let Kt, bn, Dn; y.xp6(1), y.Q6J("formGroup", rt.signUpForm), y.xp6(2), y.Q6J("ngIf", rt.patientImage), y.xp6(4), y.Q6J("ngIf", rt.error.message), y.xp6(26), y.Q6J("ngIf", null == (Kt = rt.signUpForm.get("phone")) ? null : Kt.hasError("pattern")), y.xp6(6), y.Q6J("ngIf", null == (bn = rt.signUpForm.get("email")) ? null : bn.hasError("pattern")), y.xp6(3), y.Q6J("ngIf", null == (Dn = rt.signUpForm.get("email")) ? null : Dn.hasError("pattern")), y.xp6(4), y.Q6J("type", rt.hide ? "password" : "text"), y.xp6(2), y.uIk("aria-label", "Hide password")("aria-pressed", rt.hide), y.xp6(2), y.Oqu(rt.hide ? "visibility_off" : "visibility"), y.xp6(2), y.Q6J("disabled", !rt.signUpForm.valid) } }, dependencies: [Se.O5, ke.Hw, Y._Y, Y.Fj, Y.JJ, Y.JL, Y.Q7, Y.sg, Y.u, re.Nt, Ie.KE, Ie.hX, Ie.TO, Ie.R9, Q.lW, Q.RK, a.lC, Oe.VQ, Oe.U0], styles: [".error-message[_ngcontent-%COMP%]{text-align:center;color:red;padding-bottom:15px}#signUpBtn[_ngcontent-%COMP%]{width:100%;margin-top:10px;margin-bottom:10px}"] }), ue })() }, { path: "forgot-password", component: (() => { class ue { constructor($e) { this.authService = $e, this.email = "" } resetPassword() { this.authService.sendPasswordResetEmail(this.email).then(() => { console.log("Password reset email sent.") }).catch($e => { console.error("Error sending password reset email:", $e) }) } } return ue.\u0275fac = function ($e) { return new ($e || ue)(y.Y36(he.e)) }, ue.\u0275cmp = y.Xpm({ type: ue, selectors: [["app-user-forgot-password"]], decls: 17, vars: 2, consts: [[1, "container"], [1, "authBlock"], [1, "text-center"], [3, "ngSubmit"], ["resetForm", "ngForm"], ["for", "email"], ["type", "email", "id", "email", "name", "email", "matInput", "", "required", "", "required", "", 3, "ngModel", "ngModelChange"], ["type", "submit", "mat-raised-button", "", "color", "warn", 3, "disabled"]], template: function ($e, rt) { if (1 & $e && (y.TgZ(0, "div", 0)(1, "div", 1)(2, "h2"), y._uU(3, "Ai uitat parola?"), y.qZA(), y.TgZ(4, "p", 2), y._uU(5, " Introdu adresa de e-mail pe care ai folosit-o c\xe2nd te-ai \xeenregistrat \u0219i \xee\u021bi vom trimite instruc\u021biuni pentru a-\u021bi reseta parola. "), y.qZA(), y.TgZ(6, "p"), y._uU(7, " Din motive de securitate, NU v\u0103 vom stoca parola. Prin urmare, fi\u021bi siguri c\u0103 nu v\u0103 vom trimite niciodat\u0103 parola prin e-mail. "), y.qZA(), y.TgZ(8, "form", 3, 4), y.NdJ("ngSubmit", function () { return rt.resetPassword() }), y.TgZ(10, "label", 5), y._uU(11, "Adresa de email"), y.qZA(), y._UZ(12, "br"), y.TgZ(13, "input", 6), y.NdJ("ngModelChange", function (bn) { return rt.email = bn }), y.qZA(), y._UZ(14, "br"), y.TgZ(15, "button", 7), y._uU(16, "Reseteaz\u0103"), y.qZA()()()()), 2 & $e) { const Kt = y.MAs(9); y.xp6(13), y.Q6J("ngModel", rt.email), y.xp6(2), y.Q6J("disabled", !Kt.valid) } }, dependencies: [Y._Y, Y.Fj, Y.JJ, Y.JL, Y.Q7, re.Nt, Q.lW, Y.On, Y.F], styles: [".authBlock[_ngcontent-%COMP%]{text-align:left;width:36%}.container[_ngcontent-%COMP%]{display:flex;align-items:center;justify-content:center;height:80%}label[_ngcontent-%COMP%]{font-size:16px;font-weight:500}#email[_ngcontent-%COMP%]{margin:20px 0}p[_ngcontent-%COMP%]{line-height:24px}input[_ngcontent-%COMP%]{width:98%;height:30px;border-radius:7x;border:none;background-color:#eeededdd}"] }), ue })() }, { path: "verify-email", component: (() => { class ue { constructor($e) { this.router = $e } onRouteLogin() { this.router.navigate(["login"]) } } return ue.\u0275fac = function ($e) { return new ($e || ue)(y.Y36(a.F0)) }, ue.\u0275cmp = y.Xpm({ type: ue, selectors: [["app-user-verify-email"]], decls: 14, vars: 0, consts: [[1, "displayTable"], [1, "displayTableCell"], [1, "authBlock"], [1, "formGroup"], [1, "text-center"], [1, "redirectToLogin"], ["mat-raised-button", "", "color", "primary", 3, "click"]], template: function ($e, rt) { 1 & $e && (y.TgZ(0, "div", 0)(1, "div", 1)(2, "div", 2)(3, "h3"), y._uU(4, "\xce\u021bi mul\u021bumim!"), y.qZA(), y.TgZ(5, "div", 3)(6, "p", 4), y._uU(7, " Cerere \xeeregistrata cu succes."), y._UZ(8, "br"), y._uU(9, "V\u0103 rug\u0103m s\u0103 v\u0103 verifica\u021bi e-mailul pentru a v\u0103 reseta parola. "), y.qZA()()(), y.TgZ(10, "div", 5)(11, "button", 6), y.NdJ("click", function () { return rt.onRouteLogin() }), y._uU(12, "\xcenapoi la Login"), y.qZA()()()(), y._UZ(13, "router-outlet")) }, dependencies: [Q.lW, a.lC], styles: [".displayTable[_ngcontent-%COMP%]{display:flex;justify-content:center;align-items:center;height:80%}.text-center[_ngcontent-%COMP%]{line-height:25px}"] }), ue })() }]; let ge = (() => { class ue { } return ue.\u0275fac = function ($e) { return new ($e || ue) }, ue.\u0275mod = y.oAB({ type: ue }), ue.\u0275inj = y.cJS({ imports: [a.Bz.forChild(le), a.Bz] }), ue })() }, 304: (nn, Qe, C) => { C.d(Qe, { e: () => ze }); var a = C(8429), y = C(752), v = C(2572), Y = C(2096), he = C(4664), Se = C(7398), ke = C(8726), re = C(553), Ie = C(5879), Q = C(7046), _e = C(1457), xe = C(4190); let ze = (() => { class Oe { constructor(Pe, Ve, tt) { this.afAuth = Pe, this.afs = Ve, this.router = tt, this.secondaryApp = (0, ke.ZF)(re.N.firebase, "SecondaryApp"), this.secondaryAppAuth = (0, a.v0)(this.secondaryApp), this.user$ = this.afAuth.authState.pipe((0, he.w)(Ye => { if (Ye) { const ut = this.afs.doc(`patients/${Ye.uid}`).valueChanges(), ie = this.afs.doc(`doctors/${Ye.uid}`).valueChanges(), Le = this.afs.doc(`admin/${Ye.uid}`).valueChanges(); return (0, v.a)([ut, ie, Le]).pipe((0, Se.U)(([le, ge, ue]) => le || ge || ue || null)) } return (0, Y.of)(null) })) } getUserRole(Pe) { const Ve = this.afs.doc(`patients/${Pe}`).valueChanges(), tt = this.afs.doc(`doctors/${Pe}`).valueChanges(), Ye = this.afs.doc(`admin/${Pe}`).valueChanges(); return (0, v.a)([Ve, tt, Ye]).pipe((0, Se.U)(([ut, ie, Le]) => ut && "patient" === ut.role ? "patient" : ie && "doctor" === ie.role ? "doctor" : Le && "admin" === Le.role ? "admin" : null)) } getCurrentUserUid() { return this.afAuth.currentUser.then(Pe => Pe ? Pe.uid : null).catch(() => null) } pacientSignUp(Pe, Ve) { return this.afAuth.createUserWithEmailAndPassword(Ve.email, Pe).then(tt => { if (tt.user) return this.afs.doc(`patients/${tt.user.uid}`).set({ uid: tt.user.uid, email: Ve.email, imageUrl: Ve.imageUrl, displayName: Ve.lastName + " " + Ve.firstName, gender: Ve.gender, phone: Ve.phone, role: "patient" }, { merge: !0 }) }).catch(tt => Promise.reject(tt)) } doctorSignUp(Pe, Ve) { return (0, a.Xb)(this.secondaryAppAuth, Ve.email, Pe).then(tt => { if (tt.user) return this.afs.doc(`doctors/${tt.user.uid}`).set({ uid: tt.user.uid, email: Ve.email, password: Ve.password, imageUrl: Ve.imageUrl, lastName: Ve.lastName, firstName: Ve.firstName, displayName: Ve.firstName + " " + Ve.lastName, phone: Ve.phone, adress: Ve.adress, gender: Ve.gender, description: Ve.description, specialtyIds: Ve.specialtyIds, role: "doctor" }, { merge: !0 }) }).catch(tt => Promise.reject(tt)).finally(() => { this.secondaryAppAuth.signOut() }) } signIn(Pe, Ve) { return this.afAuth.signInWithEmailAndPassword(Pe, Ve).catch(tt => Promise.reject(tt)) } patientGoogleSignIn() { return this.afAuth.signInWithPopup(new y.hJ).then(Pe => { if (Pe.user) return this.afs.doc(`patients/${Pe.user.uid}`).set({ uid: Pe.user.uid, email: Pe.user.email, imageUrl: Pe.user.photoURL, displayName: Pe.user.displayName, gender: null, phone: Pe.user.phoneNumber, role: "patient" }, { merge: !0 }) }).catch(Pe => Promise.reject(Pe)) } signOut() { return this.afAuth.signOut() } sendPasswordResetEmail(Pe) { return this.afAuth.sendPasswordResetEmail(Pe).then(() => { this.router.navigate(["verify-email"]) }).catch(Ve => { console.error("Error sending password reset email:", Ve) }) } } return Oe.\u0275fac = function (Pe) { return new (Pe || Oe)(Ie.LFG(Q.zQ), Ie.LFG(_e.ST), Ie.LFG(xe.F0)) }, Oe.\u0275prov = Ie.Yz7({ token: Oe, factory: Oe.\u0275fac, providedIn: "root" }), Oe })() }, 2365: (nn, Qe, C) => { C.d(Qe, { O: () => he }); var a = C(3828), y = C(2459), v = C(5879), Y = C(304); let he = (() => { class Se { constructor(re, Ie) { this.firestore = re, this.authService = Ie } addDoctor(re, Ie) { this.authService.doctorSignUp(re, Ie) } queryDoctors(re) { const Ie = (0, a.hJ)(this.firestore, "doctors"), Q = (0, a.IO)(Ie, (0, a.ar)("specialtyIds", "array-contains", re)); return (0, a.BS)(Q, { idField: "id" }) } getDoctors() { const re = (0, a.hJ)(this.firestore, "doctors"); return (0, a.BS)(re, { idField: "id" }) } getDoctor(re) { const Ie = (0, a.JU)(this.firestore, "doctors", re); return (0, y.D)((0, a.QT)(Ie)) } updateDoctor(re, Ie) { const Q = (0, a.JU)(this.firestore, "doctors", re); return Ie.imageUrl || delete Ie.imageUrl, (0, y.D)((0, a.r7)(Q, Ie)) } deleteDoctor(re) { const Ie = (0, a.JU)(this.firestore, "doctors", re); return (0, y.D)((0, a.oe)(Ie)) } updateImage(re, Ie) { if (!Ie) return void console.error("Image URL is undefined or empty"); const Q = (0, a.JU)(this.firestore, "doctors", re); (0, a.r7)(Q, { imageUrl: Ie }) } } return Se.\u0275fac = function (re) { return new (re || Se)(v.LFG(a.gg), v.LFG(Y.e)) }, Se.\u0275prov = v.Yz7({ token: Se, factory: Se.\u0275fac, providedIn: "root" }), Se })() }, 498: (nn, Qe, C) => { C.d(Qe, { K: () => he }); var a = C(2459), y = C(4664), v = C(5879), Y = C(7793); let he = (() => { class Se { constructor(re) { this.afStorage = re } uploadImage(re, Ie) { const Q = `${Ie}/` + re.name, _e = this.afStorage.ref(Q), xe = this.afStorage.upload(Q, re); return (0, a.D)(xe).pipe((0, y.w)(() => _e.getDownloadURL())) } } return Se.\u0275fac = function (re) { return new (re || Se)(v.LFG(Y.Q1)) }, Se.\u0275prov = v.Yz7({ token: Se, factory: Se.\u0275fac, providedIn: "root" }), Se })() }, 553: (nn, Qe, C) => { C.d(Qe, { N: () => a }); const a = { firebase: { projectId: "int-clinic", appId: "1:981743238567:web:4d762ad80a0a1aef760a82", storageBucket: "int-clinic.appspot.com", apiKey: "AIzaSyDT6naFYtKTQupxrzWdb315TvM00aOpZvE", authDomain: "int-clinic.firebaseapp.com", messagingSenderId: "981743238567" } } }, 1326: (nn, Qe, C) => { var a = C(6593), y = C(4190), v = C(5879), Y = C(304), he = C(6814), Se = C(2296); function ke(m, u) { if (1 & m) { const h = v.EpF(); v.TgZ(0, "div")(1, "button", 10), v.NdJ("click", function () { v.CHM(h); const M = v.oxw(2); return v.KtG(M.onClickManageSite()) }), v._uU(2, "Intr\u0103 in cont"), v.qZA()() } } function re(m, u) { if (1 & m) { const h = v.EpF(); v.TgZ(0, "div", 7)(1, "div")(2, "button", 8), v.NdJ("click", function () { v.CHM(h); const M = v.oxw(); return v.KtG(M.onClickGetAppoinment()) }), v._uU(3, " F\u0103-\u021bi o programare | + "), v.qZA()(), v.YNc(4, ke, 3, 0, "div", 9), v.qZA() } if (2 & m) { const h = v.oxw(); v.xp6(4), v.Q6J("ngIf", !h.loggedUser || h.isDoctor) } } let Ie = (() => { class m { constructor(h, x) { this.router = h, this.authService = x } ngOnInit() { this.authService.user$.subscribe(h => { this.loggedUser = h, this.isAdmin = "admin" === this.loggedUser?.role, this.isPatient = "patient" === this.loggedUser?.role, this.isDoctor = "doctor" === this.loggedUser?.role }) } onClickGetAppoinment() { this.router.navigate(["patient/appointment"]) } onClickManageSite() { this.router.navigate(["doctor"]) } } return m.\u0275fac = function (h) { return new (h || m)(v.Y36(y.F0), v.Y36(Y.e)) }, m.\u0275cmp = v.Xpm({ type: m, selectors: [["app-home-page"]], decls: 13, vars: 1, consts: [[1, "sections-container"], [1, "first-section"], [1, "title-homepage"], [1, "lorem-homepage"], ["class", "btns", 4, "ngIf"], [1, "second-section"], ["src", "assets/Doctors-bro.png", "alt", "", "width", "500px", "height", "500px"], [1, "btns"], ["id", "firstBtn", "mat-flat-button", "", "color", "primary", 3, "click"], [4, "ngIf"], ["id", "secondBtn", "mat-flat-button", "", "color", "warn", 3, "click"]], template: function (h, x) { 1 & h && (v.TgZ(0, "div", 0)(1, "section", 1)(2, "h1", 2), v._uU(3, " \xcendrum\u0103m spre s\u0103n\u0103tate, "), v._UZ(4, "br"), v._uU(5, " \xcendrum\u0103m spre via\u021b\u0103 "), v.qZA(), v.TgZ(6, "p", 3), v._uU(7, " \xcenfiin\u021bate cu grij\u0103 \u0219i dedicare, clinicile noastre se angajeaz\u0103 s\u0103 va ofere \xeengrijire medical\u0103 de calitate superioar\u0103 \xeentr-un mediu prietenos \u0219i modern. Profesioni\u0219ti medicali cu experien\u021b\u0103 combin\u0103 cuno\u0219tin\u021bele avansate cu compasiunea pentru a asigura s\u0103n\u0103tatea \u0219i binele pacien\u021bilor lor. "), v.qZA(), v.TgZ(8, "p"), v._uU(9, "test"), v.qZA(), v.YNc(10, re, 5, 1, "div", 4), v.qZA(), v.TgZ(11, "section", 5), v._UZ(12, "img", 6), v.qZA()()), 2 & h && (v.xp6(10), v.Q6J("ngIf", !x.loggedUser || x.isPatient)) }, dependencies: [he.O5, Se.lW], styles: [".title-homepage[_ngcontent-%COMP%]{font-size:35px;line-height:45px;color:gray}.sections-container[_ngcontent-%COMP%]{display:flex;align-items:center;padding:5rem}.lorem-homepage[_ngcontent-%COMP%]{width:70%;line-height:25px}#firstBtn[_ngcontent-%COMP%], #secondBtn[_ngcontent-%COMP%]{margin-right:50px;border-radius:0}.btns[_ngcontent-%COMP%]{display:flex}"] }), m })(); var Q = C(8180), _e = C(7398); const ze = (m, u) => (() => { const m = (0, v.f3M)(Y.e), u = (0, v.f3M)(y.F0); return m.user$.pipe((0, Q.q)(1), (0, _e.U)(h => (h || u.navigate(["login"]), "doctor" === h?.role && u.navigate([""]), "patient" === h?.role || "admin" === h?.role))) })(), We = (m, u) => (() => { const m = (0, v.f3M)(Y.e), u = (0, v.f3M)(y.F0); return m.user$.pipe((0, Q.q)(1), (0, _e.U)(h => (h || u.navigate(["login"]), "patient" === h?.role && u.navigate(["homepage"]), "doctor" === h?.role || "admin" === h?.role))) })(), tt = [{ path: "homepage", component: Ie }, { path: "admin", canActivateChild: [(m, u) => (() => { const m = (0, v.f3M)(Y.e), u = (0, v.f3M)(y.F0); return m.user$.pipe((0, Q.q)(1), (0, _e.U)(h => (h || u.navigate(["login"]), ("doctor" === h?.role || "patient" === h?.role) && u.navigate(["homepage"]), "admin" === h?.role))) })(), ze, We], loadChildren: () => Promise.all([C.e(226), C.e(592), C.e(357)]).then(C.bind(C, 2357)).then(m => m.AdminModule) }, { path: "patient", canActivateChild: [ze], loadChildren: () => Promise.all([C.e(170), C.e(592), C.e(393)]).then(C.bind(C, 9393)).then(m => m.PatientModule) }, { path: "doctor", canActivateChild: [We], loadChildren: () => Promise.all([C.e(226), C.e(170), C.e(455)]).then(C.bind(C, 4455)).then(m => m.DoctorModule) }, { path: "user", loadChildren: () => C.e(825).then(C.bind(C, 9825)).then(m => m.UserModule) }, { path: "", component: Ie }]; let Ye = (() => { class m { } return m.\u0275fac = function (h) { return new (h || m) }, m.\u0275mod = v.oAB({ type: m }), m.\u0275inj = v.cJS({ imports: [y.Bz.forRoot(tt), y.Bz] }), m })(); var ut = C(1274), ie = C(1175), Le = C(4191), le = C(2495), ge = C(6028), ue = C(8645), ee = C(3019), $e = C(7394), rt = C(2096), Kt = C(6410), bn = C(7921), Dn = C(4664), Mn = C(9773), On = C(2181), Wn = C(6321), Hn = C(5211), at = C(9360), vt = C(8251), xt = C(2420), Ft = C(975), Wt = C(1631), rn = C(4829); function Jt(m, u) { return u ? h => (0, Hn.z)(u.pipe((0, Q.q)(1), function it() { return (0, at.e)((m, u) => { m.subscribe((0, vt.x)(u, xt.Z)) }) }()), h.pipe(Jt(m))) : (0, Wt.z)((h, x) => (0, rn.Xf)(m(h, x)).pipe((0, Q.q)(1), (0, Ft.h)(h))) } var tn = C(4825); function St(m, u = Wn.z) { const h = (0, tn.H)(m, u); return Jt(() => h) } var ht = C(3680), Ae = C(8484), nt = C(6825), qt = C(9388), jt = C(3651), Pt = C(2831), qe = C(9829); const Nt = ["mat-menu-item", ""]; function on(m, u) { 1 & m && (v.O4$(), v.TgZ(0, "svg", 3), v._UZ(1, "polygon", 4), v.qZA()) } const Zt = [[["mat-icon"], ["", "matMenuItemIcon", ""]], "*"], gn = ["mat-icon, [matMenuItemIcon]", "*"]; function $n(m, u) { if (1 & m) { const h = v.EpF(); v.TgZ(0, "div", 0), v.NdJ("keydown", function (M) { v.CHM(h); const $ = v.oxw(); return v.KtG($._handleKeydown(M)) })("click", function () { v.CHM(h); const M = v.oxw(); return v.KtG(M.closed.emit("click")) })("@transformMenu.start", function (M) { v.CHM(h); const $ = v.oxw(); return v.KtG($._onAnimationStart(M)) })("@transformMenu.done", function (M) { v.CHM(h); const $ = v.oxw(); return v.KtG($._onAnimationDone(M)) }), v.TgZ(1, "div", 1), v.Hsn(2), v.qZA()() } if (2 & m) { const h = v.oxw(); v.Q6J("id", h.panelId)("ngClass", h._classList)("@transformMenu", h._panelAnimationState), v.uIk("aria-label", h.ariaLabel || null)("aria-labelledby", h.ariaLabelledby || null)("aria-describedby", h.ariaDescribedby || null) } } const Fn = ["*"], Ke = new v.OlP("MAT_MENU_PANEL"), se = (0, ht.Kr)((0, ht.Id)(class { })); let Me = (() => { class m extends se { constructor(h, x, M, $, Ee) { super(), this._elementRef = h, this._document = x, this._focusMonitor = M, this._parentMenu = $, this._changeDetectorRef = Ee, this.role = "menuitem", this._hovered = new ue.x, this._focused = new ue.x, this._highlighted = !1, this._triggersSubmenu = !1, $?.addItem?.(this) } focus(h, x) { this._focusMonitor && h ? this._focusMonitor.focusVia(this._getHostElement(), h, x) : this._getHostElement().focus(x), this._focused.next(this) } ngAfterViewInit() { this._focusMonitor && this._focusMonitor.monitor(this._elementRef, !1) } ngOnDestroy() { this._focusMonitor && this._focusMonitor.stopMonitoring(this._elementRef), this._parentMenu && this._parentMenu.removeItem && this._parentMenu.removeItem(this), this._hovered.complete(), this._focused.complete() } _getTabIndex() { return this.disabled ? "-1" : "0" } _getHostElement() { return this._elementRef.nativeElement } _checkDisabled(h) { this.disabled && (h.preventDefault(), h.stopPropagation()) } _handleMouseEnter() { this._hovered.next(this) } getLabel() { const h = this._elementRef.nativeElement.cloneNode(!0), x = h.querySelectorAll("mat-icon, .material-icons"); for (let M = 0; M < x.length; M++)x[M].remove(); return h.textContent?.trim() || "" } _setHighlighted(h) { this._highlighted = h, this._changeDetectorRef?.markForCheck() } _setTriggersSubmenu(h) { this._triggersSubmenu = h, this._changeDetectorRef?.markForCheck() } _hasFocus() { return this._document && this._document.activeElement === this._getHostElement() } } return m.\u0275fac = function (h) { return new (h || m)(v.Y36(v.SBq), v.Y36(he.K0), v.Y36(Le.tE), v.Y36(Ke, 8), v.Y36(v.sBO)) }, m.\u0275cmp = v.Xpm({ type: m, selectors: [["", "mat-menu-item", ""]], hostAttrs: [1, "mat-mdc-menu-item", "mat-mdc-focus-indicator", "mdc-list-item"], hostVars: 8, hostBindings: function (h, x) { 1 & h && v.NdJ("click", function ($) { return x._checkDisabled($) })("mouseenter", function () { return x._handleMouseEnter() }), 2 & h && (v.uIk("role", x.role)("tabindex", x._getTabIndex())("aria-disabled", x.disabled)("disabled", x.disabled || null), v.ekj("mat-mdc-menu-item-highlighted", x._highlighted)("mat-mdc-menu-item-submenu-trigger", x._triggersSubmenu)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", role: "role" }, exportAs: ["matMenuItem"], features: [v.qOj], attrs: Nt, ngContentSelectors: gn, decls: 5, vars: 3, consts: [[1, "mdc-list-item__primary-text"], ["matRipple", "", 1, "mat-mdc-menu-ripple", 3, "matRippleDisabled", "matRippleTrigger"], ["class", "mat-mdc-menu-submenu-icon", "viewBox", "0 0 5 10", "focusable", "false", "aria-hidden", "true", 4, "ngIf"], ["viewBox", "0 0 5 10", "focusable", "false", "aria-hidden", "true", 1, "mat-mdc-menu-submenu-icon"], ["points", "0,0 5,5 0,10"]], template: function (h, x) { 1 & h && (v.F$t(Zt), v.Hsn(0), v.TgZ(1, "span", 0), v.Hsn(2, 1), v.qZA(), v._UZ(3, "div", 1), v.YNc(4, on, 2, 0, "svg", 2)), 2 & h && (v.xp6(3), v.Q6J("matRippleDisabled", x.disableRipple || x.disabled)("matRippleTrigger", x._getHostElement()), v.xp6(1), v.Q6J("ngIf", x._triggersSubmenu)) }, dependencies: [he.O5, ht.wG], encapsulation: 2, changeDetection: 0 }), m })(); const Ue = new v.OlP("MatMenuContent"), ct = { transformMenu: (0, nt.X$)("transformMenu", [(0, nt.SB)("void", (0, nt.oB)({ opacity: 0, transform: "scale(0.8)" })), (0, nt.eR)("void => enter", (0, nt.jt)("120ms cubic-bezier(0, 0, 0.2, 1)", (0, nt.oB)({ opacity: 1, transform: "scale(1)" }))), (0, nt.eR)("* => void", (0, nt.jt)("100ms 25ms linear", (0, nt.oB)({ opacity: 0 })))]), fadeInItems: (0, nt.X$)("fadeInItems", [(0, nt.SB)("showing", (0, nt.oB)({ opacity: 1 })), (0, nt.eR)("void => *", [(0, nt.oB)({ opacity: 0 }), (0, nt.jt)("400ms 100ms cubic-bezier(0.55, 0, 0.55, 0.2)")])]) }; let fn = 0; const En = new v.OlP("mat-menu-default-options", { providedIn: "root", factory: function Ln() { return { overlapTrigger: !1, xPosition: "after", yPosition: "below", backdropClass: "cdk-overlay-transparent-backdrop" } } }); let In = (() => { class m { get xPosition() { return this._xPosition } set xPosition(h) { this._xPosition = h, this.setPositionClasses() } get yPosition() { return this._yPosition } set yPosition(h) { this._yPosition = h, this.setPositionClasses() } get overlapTrigger() { return this._overlapTrigger } set overlapTrigger(h) { this._overlapTrigger = (0, le.Ig)(h) } get hasBackdrop() { return this._hasBackdrop } set hasBackdrop(h) { this._hasBackdrop = (0, le.Ig)(h) } set panelClass(h) { const x = this._previousPanelClass; x && x.length && x.split(" ").forEach(M => { this._classList[M] = !1 }), this._previousPanelClass = h, h && h.length && (h.split(" ").forEach(M => { this._classList[M] = !0 }), this._elementRef.nativeElement.className = "") } get classList() { return this.panelClass } set classList(h) { this.panelClass = h } constructor(h, x, M, $) { this._elementRef = h, this._ngZone = x, this._changeDetectorRef = $, this._directDescendantItems = new v.n_E, this._classList = {}, this._panelAnimationState = "void", this._animationDone = new ue.x, this.closed = new v.vpe, this.close = this.closed, this.panelId = "mat-menu-panel-" + fn++, this.overlayPanelClass = M.overlayPanelClass || "", this._xPosition = M.xPosition, this._yPosition = M.yPosition, this.backdropClass = M.backdropClass, this._overlapTrigger = M.overlapTrigger, this._hasBackdrop = M.hasBackdrop } ngOnInit() { this.setPositionClasses() } ngAfterContentInit() { this._updateDirectDescendants(), this._keyManager = new Le.Em(this._directDescendantItems).withWrap().withTypeAhead().withHomeAndEnd(), this._keyManager.tabOut.subscribe(() => this.closed.emit("tab")), this._directDescendantItems.changes.pipe((0, bn.O)(this._directDescendantItems), (0, Dn.w)(h => (0, ee.T)(...h.map(x => x._focused)))).subscribe(h => this._keyManager.updateActiveItem(h)), this._directDescendantItems.changes.subscribe(h => { const x = this._keyManager; if ("enter" === this._panelAnimationState && x.activeItem?._hasFocus()) { const M = h.toArray(), $ = Math.max(0, Math.min(M.length - 1, x.activeItemIndex || 0)); M[$] && !M[$].disabled ? x.setActiveItem($) : x.setNextItemActive() } }) } ngOnDestroy() { this._keyManager?.destroy(), this._directDescendantItems.destroy(), this.closed.complete(), this._firstItemFocusSubscription?.unsubscribe() } _hovered() { return this._directDescendantItems.changes.pipe((0, bn.O)(this._directDescendantItems), (0, Dn.w)(x => (0, ee.T)(...x.map(M => M._hovered)))) } addItem(h) { } removeItem(h) { } _handleKeydown(h) { const x = h.keyCode, M = this._keyManager; switch (x) { case ge.hY: (0, ge.Vb)(h) || (h.preventDefault(), this.closed.emit("keydown")); break; case ge.oh: this.parentMenu && "ltr" === this.direction && this.closed.emit("keydown"); break; case ge.SV: this.parentMenu && "rtl" === this.direction && this.closed.emit("keydown"); break; default: return (x === ge.LH || x === ge.JH) && M.setFocusOrigin("keyboard"), void M.onKeydown(h) }h.stopPropagation() } focusFirstItem(h = "program") { this._firstItemFocusSubscription?.unsubscribe(), this._firstItemFocusSubscription = this._ngZone.onStable.pipe((0, Q.q)(1)).subscribe(() => { let x = null; if (this._directDescendantItems.length && (x = this._directDescendantItems.first._getHostElement().closest('[role="menu"]')), !x || !x.contains(document.activeElement)) { const M = this._keyManager; M.setFocusOrigin(h).setFirstItemActive(), !M.activeItem && x && x.focus() } }) } resetActiveItem() { this._keyManager.setActiveItem(-1) } setElevation(h) { const x = Math.min(this._baseElevation + h, 24), M = `${this._elevationPrefix}${x}`, $ = Object.keys(this._classList).find(Ee => Ee.startsWith(this._elevationPrefix)); (!$ || $ === this._previousElevation) && (this._previousElevation && (this._classList[this._previousElevation] = !1), this._classList[M] = !0, this._previousElevation = M) } setPositionClasses(h = this.xPosition, x = this.yPosition) { const M = this._classList; M["mat-menu-before"] = "before" === h, M["mat-menu-after"] = "after" === h, M["mat-menu-above"] = "above" === x, M["mat-menu-below"] = "below" === x, this._changeDetectorRef?.markForCheck() } _startAnimation() { this._panelAnimationState = "enter" } _resetAnimation() { this._panelAnimationState = "void" } _onAnimationDone(h) { this._animationDone.next(h), this._isAnimating = !1 } _onAnimationStart(h) { this._isAnimating = !0, "enter" === h.toState && 0 === this._keyManager.activeItemIndex && (h.element.scrollTop = 0) } _updateDirectDescendants() { this._allItems.changes.pipe((0, bn.O)(this._allItems)).subscribe(h => { this._directDescendantItems.reset(h.filter(x => x._parentMenu === this)), this._directDescendantItems.notifyOnChanges() }) } } return m.\u0275fac = function (h) { return new (h || m)(v.Y36(v.SBq), v.Y36(v.R0b), v.Y36(En), v.Y36(v.sBO)) }, m.\u0275dir = v.lG2({ type: m, contentQueries: function (h, x, M) { if (1 & h && (v.Suo(M, Ue, 5), v.Suo(M, Me, 5), v.Suo(M, Me, 4)), 2 & h) { let $; v.iGM($ = v.CRH()) && (x.lazyContent = $.first), v.iGM($ = v.CRH()) && (x._allItems = $), v.iGM($ = v.CRH()) && (x.items = $) } }, viewQuery: function (h, x) { if (1 & h && v.Gf(v.Rgc, 5), 2 & h) { let M; v.iGM(M = v.CRH()) && (x.templateRef = M.first) } }, inputs: { backdropClass: "backdropClass", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedby: ["aria-describedby", "ariaDescribedby"], xPosition: "xPosition", yPosition: "yPosition", overlapTrigger: "overlapTrigger", hasBackdrop: "hasBackdrop", panelClass: ["class", "panelClass"], classList: "classList" }, outputs: { closed: "closed", close: "close" } }), m })(), Et = (() => { class m extends In { constructor(h, x, M, $) { super(h, x, M, $), this._elevationPrefix = "mat-elevation-z", this._baseElevation = 8 } } return m.\u0275fac = function (h) { return new (h || m)(v.Y36(v.SBq), v.Y36(v.R0b), v.Y36(En), v.Y36(v.sBO)) }, m.\u0275cmp = v.Xpm({ type: m, selectors: [["mat-menu"]], hostAttrs: ["ngSkipHydration", ""], hostVars: 3, hostBindings: function (h, x) { 2 & h && v.uIk("aria-label", null)("aria-labelledby", null)("aria-describedby", null) }, exportAs: ["matMenu"], features: [v._Bn([{ provide: Ke, useExisting: m }]), v.qOj], ngContentSelectors: Fn, decls: 1, vars: 0, consts: [["tabindex", "-1", "role", "menu", 1, "mat-mdc-menu-panel", "mdc-menu-surface", "mdc-menu-surface--open", "mat-mdc-elevation-specific", 3, "id", "ngClass", "keydown", "click"], [1, "mat-mdc-menu-content", "mdc-list"]], template: function (h, x) { 1 & h && (v.F$t(), v.YNc(0, $n, 3, 6, "ng-template")) }, dependencies: [he.mk], styles: ['mat-menu{display:none}.mat-mdc-menu-content{margin:0;padding:8px 0;list-style-type:none}.mat-mdc-menu-content:focus{outline:none}.mat-mdc-menu-content,.mat-mdc-menu-content .mat-mdc-menu-item .mdc-list-item__primary-text{-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;font-family:var(--mat-menu-item-label-text-font);line-height:var(--mat-menu-item-label-text-line-height);font-size:var(--mat-menu-item-label-text-size);letter-spacing:var(--mat-menu-item-label-text-tracking);font-weight:var(--mat-menu-item-label-text-weight)}.mat-mdc-menu-panel{--mat-menu-container-shape:4px;box-sizing:border-box;outline:0;border-radius:var(--mat-menu-container-shape);background-color:var(--mat-menu-container-color);will-change:transform,opacity}.mat-mdc-menu-panel.ng-animating{pointer-events:none}.cdk-high-contrast-active .mat-mdc-menu-panel{outline:solid 1px}.mat-mdc-menu-panel.mat-mdc-menu-panel{min-width:112px;max-width:280px;overflow:auto;-webkit-overflow-scrolling:touch;position:relative}.mat-mdc-menu-item{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;-webkit-user-select:none;user-select:none;cursor:pointer;outline:none;border:none;-webkit-tap-highlight-color:rgba(0,0,0,0);cursor:pointer;width:100%;text-align:left;box-sizing:border-box;color:inherit;font-size:inherit;background:none;text-decoration:none;margin:0;min-height:48px}.mat-mdc-menu-item:focus{outline:none}[dir=rtl] .mat-mdc-menu-item,.mat-mdc-menu-item[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-menu-item::-moz-focus-inner{border:0}.mat-mdc-menu-item,.mat-mdc-menu-item:visited,.mat-mdc-menu-item:link{color:var(--mat-menu-item-label-text-color)}.mat-mdc-menu-item .mat-icon-no-color,.mat-mdc-menu-item .mat-mdc-menu-submenu-icon{color:var(--mat-menu-item-icon-color)}.mat-mdc-menu-item.mdc-list-item{align-items:center}.mat-mdc-menu-item[disabled]{cursor:default;opacity:.38}.mat-mdc-menu-item[disabled]::after{display:block;position:absolute;content:"";top:0;left:0;bottom:0;right:0}.mat-mdc-menu-item .mat-icon{margin-right:16px}[dir=rtl] .mat-mdc-menu-item{text-align:right}[dir=rtl] .mat-mdc-menu-item .mat-icon{margin-right:0;margin-left:16px}.mat-mdc-menu-item .mdc-list-item__primary-text{white-space:normal}.mat-mdc-menu-item.mat-mdc-menu-item-submenu-trigger{padding-right:32px}[dir=rtl] .mat-mdc-menu-item.mat-mdc-menu-item-submenu-trigger{padding-right:16px;padding-left:32px}.mat-mdc-menu-item:not([disabled]):hover{background-color:var(--mat-menu-item-hover-state-layer-color)}.mat-mdc-menu-item:not([disabled]).cdk-program-focused,.mat-mdc-menu-item:not([disabled]).cdk-keyboard-focused,.mat-mdc-menu-item:not([disabled]).mat-mdc-menu-item-highlighted{background-color:var(--mat-menu-item-focus-state-layer-color)}.cdk-high-contrast-active .mat-mdc-menu-item{margin-top:1px}.mat-mdc-menu-submenu-icon{position:absolute;top:50%;right:16px;transform:translateY(-50%);width:5px;height:10px;fill:currentColor}[dir=rtl] .mat-mdc-menu-submenu-icon{right:auto;left:16px;transform:translateY(-50%) scaleX(-1)}.cdk-high-contrast-active .mat-mdc-menu-submenu-icon{fill:CanvasText}.mat-mdc-menu-item .mat-mdc-menu-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}'], encapsulation: 2, data: { animation: [ct.transformMenu, ct.fadeInItems] }, changeDetection: 0 }), m })(); const _t = new v.OlP("mat-menu-scroll-strategy"), W = { provide: _t, deps: [jt.aV], useFactory: function G(m) { return () => m.scrollStrategies.reposition() } }, me = (0, Pt.i$)({ passive: !0 }); let st = (() => { class m { get _deprecatedMatMenuTriggerFor() { return this.menu } set _deprecatedMatMenuTriggerFor(h) { this.menu = h } get menu() { return this._menu } set menu(h) { h !== this._menu && (this._menu = h, this._menuCloseSubscription.unsubscribe(), h && (this._menuCloseSubscription = h.close.subscribe(x => { this._destroyMenu(x), ("click" === x || "tab" === x) && this._parentMaterialMenu && this._parentMaterialMenu.closed.emit(x) })), this._menuItemInstance?._setTriggersSubmenu(this.triggersSubmenu())) } constructor(h, x, M, $, Ee, je, ft, zt, xn) { this._overlay = h, this._element = x, this._viewContainerRef = M, this._menuItemInstance = je, this._dir = ft, this._focusMonitor = zt, this._ngZone = xn, this._overlayRef = null, this._menuOpen = !1, this._closingActionsSubscription = $e.w0.EMPTY, this._hoverSubscription = $e.w0.EMPTY, this._menuCloseSubscription = $e.w0.EMPTY, this._changeDetectorRef = (0, v.f3M)(v.sBO), this._handleTouchStart = An => { (0, Le.yG)(An) || (this._openedBy = "touch") }, this._openedBy = void 0, this.restoreFocus = !0, this.menuOpened = new v.vpe, this.onMenuOpen = this.menuOpened, this.menuClosed = new v.vpe, this.onMenuClose = this.menuClosed, this._scrollStrategy = $, this._parentMaterialMenu = Ee instanceof In ? Ee : void 0, x.nativeElement.addEventListener("touchstart", this._handleTouchStart, me) } ngAfterContentInit() { this._handleHover() } ngOnDestroy() { this._overlayRef && (this._overlayRef.dispose(), this._overlayRef = null), this._element.nativeElement.removeEventListener("touchstart", this._handleTouchStart, me), this._menuCloseSubscription.unsubscribe(), this._closingActionsSubscription.unsubscribe(), this._hoverSubscription.unsubscribe() } get menuOpen() { return this._menuOpen } get dir() { return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr" } triggersSubmenu() { return !!(this._menuItemInstance && this._parentMaterialMenu && this.menu) } toggleMenu() { return this._menuOpen ? this.closeMenu() : this.openMenu() } openMenu() { const h = this.menu; if (this._menuOpen || !h) return; const x = this._createOverlay(h), M = x.getConfig(), $ = M.positionStrategy; this._setPosition(h, $), M.hasBackdrop = null == h.hasBackdrop ? !this.triggersSubmenu() : h.hasBackdrop, x.attach(this._getPortal(h)), h.lazyContent && h.lazyContent.attach(this.menuData), this._closingActionsSubscription = this._menuClosingActions().subscribe(() => this.closeMenu()), this._initMenu(h), h instanceof In && (h._startAnimation(), h._directDescendantItems.changes.pipe((0, Mn.R)(h.close)).subscribe(() => { $.withLockedPosition(!1).reapplyLastPosition(), $.withLockedPosition(!0) })) } closeMenu() { this.menu?.close.emit() } focus(h, x) { this._focusMonitor && h ? this._focusMonitor.focusVia(this._element, h, x) : this._element.nativeElement.focus(x) } updatePosition() { this._overlayRef?.updatePosition() } _destroyMenu(h) { if (!this._overlayRef || !this.menuOpen) return; const x = this.menu; this._closingActionsSubscription.unsubscribe(), this._overlayRef.detach(), this.restoreFocus && ("keydown" === h || !this._openedBy || !this.triggersSubmenu()) && this.focus(this._openedBy), this._openedBy = void 0, x instanceof In ? (x._resetAnimation(), x.lazyContent ? x._animationDone.pipe((0, On.h)(M => "void" === M.toState), (0, Q.q)(1), (0, Mn.R)(x.lazyContent._attached)).subscribe({ next: () => x.lazyContent.detach(), complete: () => this._setIsMenuOpen(!1) }) : this._setIsMenuOpen(!1)) : (this._setIsMenuOpen(!1), x?.lazyContent?.detach()) } _initMenu(h) { h.parentMenu = this.triggersSubmenu() ? this._parentMaterialMenu : void 0, h.direction = this.dir, this._setMenuElevation(h), h.focusFirstItem(this._openedBy || "program"), this._setIsMenuOpen(!0) } _setMenuElevation(h) { if (h.setElevation) { let x = 0, M = h.parentMenu; for (; M;)x++, M = M.parentMenu; h.setElevation(x) } } _setIsMenuOpen(h) { h !== this._menuOpen && (this._menuOpen = h, this._menuOpen ? this.menuOpened.emit() : this.menuClosed.emit(), this.triggersSubmenu() && this._menuItemInstance._setHighlighted(h), this._changeDetectorRef.markForCheck()) } _createOverlay(h) { if (!this._overlayRef) { const x = this._getOverlayConfig(h); this._subscribeToPositions(h, x.positionStrategy), this._overlayRef = this._overlay.create(x), this._overlayRef.keydownEvents().subscribe() } return this._overlayRef } _getOverlayConfig(h) { return new jt.X_({ positionStrategy: this._overlay.position().flexibleConnectedTo(this._element).withLockedPosition().withGrowAfterOpen().withTransformOriginOn(".mat-menu-panel, .mat-mdc-menu-panel"), backdropClass: h.backdropClass || "cdk-overlay-transparent-backdrop", panelClass: h.overlayPanelClass, scrollStrategy: this._scrollStrategy(), direction: this._dir }) } _subscribeToPositions(h, x) { h.setPositionClasses && x.positionChanges.subscribe(M => { const $ = "start" === M.connectionPair.overlayX ? "after" : "before", Ee = "top" === M.connectionPair.overlayY ? "below" : "above"; this._ngZone ? this._ngZone.run(() => h.setPositionClasses($, Ee)) : h.setPositionClasses($, Ee) }) } _setPosition(h, x) { let [M, $] = "before" === h.xPosition ? ["end", "start"] : ["start", "end"], [Ee, je] = "above" === h.yPosition ? ["bottom", "top"] : ["top", "bottom"], [ft, zt] = [Ee, je], [xn, An] = [M, $], ri = 0; if (this.triggersSubmenu()) { if (An = M = "before" === h.xPosition ? "start" : "end", $ = xn = "end" === M ? "start" : "end", this._parentMaterialMenu) { if (null == this._parentInnerPadding) { const hi = this._parentMaterialMenu.items.first; this._parentInnerPadding = hi ? hi._getHostElement().offsetTop : 0 } ri = "bottom" === Ee ? this._parentInnerPadding : -this._parentInnerPadding } } else h.overlapTrigger || (ft = "top" === Ee ? "bottom" : "top", zt = "top" === je ? "bottom" : "top"); x.withPositions([{ originX: M, originY: ft, overlayX: xn, overlayY: Ee, offsetY: ri }, { originX: $, originY: ft, overlayX: An, overlayY: Ee, offsetY: ri }, { originX: M, originY: zt, overlayX: xn, overlayY: je, offsetY: -ri }, { originX: $, originY: zt, overlayX: An, overlayY: je, offsetY: -ri }]) } _menuClosingActions() { const h = this._overlayRef.backdropClick(), x = this._overlayRef.detachments(), M = this._parentMaterialMenu ? this._parentMaterialMenu.closed : (0, rt.of)(), $ = this._parentMaterialMenu ? this._parentMaterialMenu._hovered().pipe((0, On.h)(Ee => Ee !== this._menuItemInstance), (0, On.h)(() => this._menuOpen)) : (0, rt.of)(); return (0, ee.T)(h, M, $, x) } _handleMousedown(h) { (0, Le.X6)(h) || (this._openedBy = 0 === h.button ? "mouse" : void 0, this.triggersSubmenu() && h.preventDefault()) } _handleKeydown(h) { const x = h.keyCode; (x === ge.K5 || x === ge.L_) && (this._openedBy = "keyboard"), this.triggersSubmenu() && (x === ge.SV && "ltr" === this.dir || x === ge.oh && "rtl" === this.dir) && (this._openedBy = "keyboard", this.openMenu()) } _handleClick(h) { this.triggersSubmenu() ? (h.stopPropagation(), this.openMenu()) : this.toggleMenu() } _handleHover() { !this.triggersSubmenu() || !this._parentMaterialMenu || (this._hoverSubscription = this._parentMaterialMenu._hovered().pipe((0, On.h)(h => h === this._menuItemInstance && !h.disabled), St(0, Kt.E)).subscribe(() => { this._openedBy = "mouse", this.menu instanceof In && this.menu._isAnimating ? this.menu._animationDone.pipe((0, Q.q)(1), St(0, Kt.E), (0, Mn.R)(this._parentMaterialMenu._hovered())).subscribe(() => this.openMenu()) : this.openMenu() })) } _getPortal(h) { return (!this._portal || this._portal.templateRef !== h.templateRef) && (this._portal = new Ae.UE(h.templateRef, this._viewContainerRef)), this._portal } } return m.\u0275fac = function (h) { return new (h || m)(v.Y36(jt.aV), v.Y36(v.SBq), v.Y36(v.s_b), v.Y36(_t), v.Y36(Ke, 8), v.Y36(Me, 10), v.Y36(qt.Is, 8), v.Y36(Le.tE), v.Y36(v.R0b)) }, m.\u0275dir = v.lG2({ type: m, hostVars: 3, hostBindings: function (h, x) { 1 & h && v.NdJ("click", function ($) { return x._handleClick($) })("mousedown", function ($) { return x._handleMousedown($) })("keydown", function ($) { return x._handleKeydown($) }), 2 & h && v.uIk("aria-haspopup", x.menu ? "menu" : null)("aria-expanded", x.menuOpen)("aria-controls", x.menuOpen ? x.menu.panelId : null) }, inputs: { _deprecatedMatMenuTriggerFor: ["mat-menu-trigger-for", "_deprecatedMatMenuTriggerFor"], menu: ["matMenuTriggerFor", "menu"], menuData: ["matMenuTriggerData", "menuData"], restoreFocus: ["matMenuTriggerRestoreFocus", "restoreFocus"] }, outputs: { menuOpened: "menuOpened", onMenuOpen: "onMenuOpen", menuClosed: "menuClosed", onMenuClose: "onMenuClose" } }), m })(), Lt = (() => { class m extends st { } return m.\u0275fac = function () { let u; return function (x) { return (u || (u = v.n5z(m)))(x || m) } }(), m.\u0275dir = v.lG2({ type: m, selectors: [["", "mat-menu-trigger-for", ""], ["", "matMenuTriggerFor", ""]], hostAttrs: [1, "mat-mdc-menu-trigger"], exportAs: ["matMenuTrigger"], features: [v.qOj] }), m })(), He = (() => { class m { } return m.\u0275fac = function (h) { return new (h || m) }, m.\u0275mod = v.oAB({ type: m }), m.\u0275inj = v.cJS({ providers: [W], imports: [he.ez, ht.si, ht.BQ, jt.U8, qe.ZD, ht.BQ] }), m })(); function ae(m, u) { 1 & m && (v.TgZ(0, "li")(1, "a", 4), v._uU(2, "Admin"), v.qZA()()) } function z(m, u) { 1 & m && (v.TgZ(0, "li")(1, "a", 5), v._uU(2, "Pacient"), v.qZA()()) } function L(m, u) { 1 & m && (v.TgZ(0, "li")(1, "a", 6), v._uU(2, "Doctor"), v.qZA()()) } function H(m, u) { if (1 & m && (v.TgZ(0, "div")(1, "button", 7)(2, "mat-icon", 8), v._uU(3, "account_circle "), v.qZA()(), v.TgZ(4, "mat-menu", null, 9)(6, "button", 10)(7, "mat-icon", 8), v._uU(8, "account_circle "), v.qZA(), v._uU(9, " Login "), v.qZA(), v.TgZ(10, "button", 11)(11, "mat-icon", 12), v._uU(12, "account_circle "), v.qZA(), v._uU(13, " SignUp "), v.qZA()()()), 2 & m) { const h = v.MAs(5); v.xp6(1), v.Q6J("matMenuTriggerFor", h) } } function Ne(m, u) { if (1 & m) { const h = v.EpF(); v.TgZ(0, "div", 13), v._UZ(1, "span", 14), v.TgZ(2, "button", 7), v._uU(3), v.TgZ(4, "mat-icon", 12), v._uU(5, "account_circle "), v.qZA()(), v.TgZ(6, "mat-menu", null, 15)(8, "a", 16)(9, "mat-icon", 12), v._uU(10, "account_circle "), v.qZA(), v._uU(11, " Contul meu "), v.qZA(), v.TgZ(12, "button", 17), v.NdJ("click", function () { v.CHM(h); const M = v.oxw(); return v.KtG(M.onLogOut()) }), v.TgZ(13, "mat-icon", 12), v._uU(14, "account_circle "), v.qZA(), v._uU(15, " LogOut "), v.qZA()()() } if (2 & m) { const h = v.MAs(7), x = v.oxw(); v.xp6(2), v.Q6J("matMenuTriggerFor", h), v.xp6(1), v.hij(" Bine ai venit, ", x.loggedUser.displayName, " "), v.xp6(5), v.Q6J("routerLink", x.isPatient ? "patient/dashboard/current" : x.isDoctor ? "doctor/dashboard/current" : "admin") } } const pt = function () { return { exact: !0 } }; let pe = (() => { class m { constructor(h, x) { this.authService = h, this.router = x } ngOnInit() { this.authService.user$.subscribe(h => { this.loggedUser = h, this.isAdmin = "admin" === this.loggedUser?.role, this.isPatient = "patient" === this.loggedUser?.role, this.isDoctor = "doctor" === this.loggedUser?.role }) } onLogOut() { this.authService.signOut(), this.router.navigate(["login"]) } } return m.\u0275fac = function (h) { return new (h || m)(v.Y36(Y.e), v.Y36(y.F0)) }, m.\u0275cmp = v.Xpm({ type: m, selectors: [["app-navigation-bar"]], decls: 11, vars: 7, consts: [["routerLink", "", "routerLinkActive", "activeNav", 3, "routerLinkActiveOptions"], [4, "ngIf"], [1, "right-menu"], ["class", "user-profile", 4, "ngIf"], ["routerLink", "admin", "routerLinkActive", "activeNav"], ["routerLink", "patient/dashboard/current", "routerLinkActive", "activeNav"], ["routerLink", "doctor/dashboard/current", "routerLinkActive", "activeNav"], ["mat-button", "", 3, "matMenuTriggerFor"], ["clasa", "login-icon"], ["menu1", "matMenu"], ["mat-menu-item", "", "routerLink", "login"], ["mat-menu-item", "", "routerLink", "sign-up"], [1, "login-icon"], [1, "user-profile"], [1, "username"], ["menu2", "matMenu"], ["mat-menu-item", "", 3, "routerLink"], ["mat-menu-item", "", 3, "click"]], template: function (h, x) { 1 & h && (v.TgZ(0, "mat-toolbar")(1, "ul")(2, "li")(3, "a", 0), v._uU(4, "Acas\u0103"), v.qZA()(), v.YNc(5, ae, 3, 0, "li", 1), v.YNc(6, z, 3, 0, "li", 1), v.YNc(7, L, 3, 0, "li", 1), v.qZA(), v.TgZ(8, "div", 2), v.YNc(9, H, 14, 1, "div", 1), v.YNc(10, Ne, 16, 3, "div", 3), v.qZA()()), 2 & h && (v.xp6(3), v.Q6J("routerLinkActiveOptions", v.DdM(6, pt)), v.xp6(2), v.Q6J("ngIf", x.isAdmin), v.xp6(1), v.Q6J("ngIf", !x.loggedUser || x.isPatient), v.xp6(1), v.Q6J("ngIf", !x.loggedUser || x.isDoctor), v.xp6(2), v.Q6J("ngIf", !x.loggedUser), v.xp6(1), v.Q6J("ngIf", x.loggedUser)) }, dependencies: [he.O5, y.rH, y.Od, Se.lW, ut.Ye, ie.Hw, Et, Me, Lt], styles: [".mat-mdc-button[_ngcontent-%COMP%] > .mat-icon[_ngcontent-%COMP%]{font-size:2.125rem;height:2.125rem;width:2.125rem}"] }), m })(), fe = (() => { class m { } return m.\u0275fac = function (h) { return new (h || m) }, m.\u0275cmp = v.Xpm({ type: m, selectors: [["app-root"]], decls: 2, vars: 0, template: function (h, x) { 1 & h && v._UZ(0, "app-navigation-bar")(1, "router-outlet") }, dependencies: [y.lC, pe] }), m })(); var F = C(8726), J = C(553), Te = C(8429), lt = C(7046), gt = C(3828), Ht = C(6223), un = C(6304); function It(m) { return new v.vHH(3e3, !1) } function Xi(m) { switch (m.length) { case 0: return new nt.ZN; case 1: return m[0]; default: return new nt.ZE(m) } } function Dr(m, u, h = new Map, x = new Map) { const M = [], $ = []; let Ee = -1, je = null; if (u.forEach(ft => { const zt = ft.get("offset"), xn = zt == Ee, An = xn && je || new Map; ft.forEach((ri, hi) => { let fi = hi, ei = ri; if ("offset" !== hi) switch (fi = m.normalizePropertyName(fi, M), ei) { case nt.k1: ei = h.get(hi); break; case nt.l3: ei = x.get(hi); break; default: ei = m.normalizeStyleValue(hi, fi, ei, M) }An.set(fi, ei) }), xn || $.push(An), je = An, Ee = zt }), M.length) throw function Rt(m) { return new v.vHH(3502, !1) }(); return $ } function xr(m, u, h, x) { switch (u) { case "start": m.onStart(() => x(h && Ko(h, "start", m))); break; case "done": m.onDone(() => x(h && Ko(h, "done", m))); break; case "destroy": m.onDestroy(() => x(h && Ko(h, "destroy", m))) } } function Ko(m, u, h) { const $ = mo(m.element, m.triggerName, m.fromState, m.toState, u || m.phaseName, h.totalTime ?? m.totalTime, !!h.disabled), Ee = m._data; return null != Ee && ($._data = Ee), $ } function mo(m, u, h, x, M = "", $ = 0, Ee) { return { element: m, triggerName: u, fromState: h, toState: x, phaseName: M, totalTime: $, disabled: !!Ee } } function _i(m, u, h) { let x = m.get(u); return x || m.set(u, x = h), x } function Sn(m) { const u = m.indexOf(":"); return [m.substring(1, u), m.slice(u + 1)] } const ci = (() => typeof document > "u" ? null : document.documentElement)(); function ki(m) { const u = m.parentNode || m.host || null; return u === ci ? null : u } let Lr = null, nr = !1; function ro(m, u) { for (; u;) { if (u === m) return !0; u = ki(u) } return !1 } function Xn(m, u, h) { if (h) return Array.from(m.querySelectorAll(u)); const x = m.querySelector(u); return x ? [x] : [] } let Ao = (() => { class m { validateStyleProperty(h) { return function io(m) { Lr || (Lr = function qr() { return typeof document < "u" ? document.body : null }() || {}, nr = !!Lr.style && "WebkitAppearance" in Lr.style); let u = !0; return Lr.style && !function tr(m) { return "ebkit" == m.substring(1, 6) }(m) && (u = m in Lr.style, !u && nr && (u = "Webkit" + m.charAt(0).toUpperCase() + m.slice(1) in Lr.style)), u }(h) } matchesElement(h, x) { return !1 } containsElement(h, x) { return ro(h, x) } getParentElement(h) { return ki(h) } query(h, x, M) { return Xn(h, x, M) } computeStyle(h, x, M) { return M || "" } animate(h, x, M, $, Ee, je = [], ft) { return new nt.ZN(M, $) } } return m.\u0275fac = function (h) { return new (h || m) }, m.\u0275prov = v.Yz7({ token: m, factory: m.\u0275fac }), m })(), ko = (() => { class m { } return m.NOOP = new Ao, m })(); const cr = 1e3, oo = "ng-enter", Qr = "ng-leave", es = "ng-trigger", Tr = ".ng-trigger", Br = "ng-animating", Yo = ".ng-animating"; function so(m) { if ("number" == typeof m) return m; const u = m.match(/^(-?[\.\d]+)(m?s)/); return !u || u.length < 2 ? 0 : Mi(parseFloat(u[1]), u[2]) } function Mi(m, u) { return "s" === u ? m * cr : m } function qo(m, u, h) { return m.hasOwnProperty("duration") ? m : function Ho(m, u, h) { let M, $ = 0, Ee = ""; if ("string" == typeof m) { const je = m.match(/^(-?[\.\d]+)(m?s)(?:\s+(-?[\.\d]+)(m?s))?(?:\s+([-a-z]+(?:\(.+?\))?))?$/i); if (null === je) return u.push(It()), { duration: 0, delay: 0, easing: "" }; M = Mi(parseFloat(je[1]), je[2]); const ft = je[3]; null != ft && ($ = Mi(parseFloat(ft), je[4])); const zt = je[5]; zt && (Ee = zt) } else M = m; if (!h) { let je = !1, ft = u.length; M < 0 && (u.push(function dn() { return new v.vHH(3100, !1) }()), je = !0), $ < 0 && (u.push(function Pn() { return new v.vHH(3101, !1) }()), je = !0), je && u.splice(ft, 0, It()) } return { duration: M, delay: $, easing: Ee } }(m, u, h) } function Ro(m, u = {}) { return Object.keys(m).forEach(h => { u[h] = m[h] }), u } function yo(m) { const u = new Map; return Object.keys(m).forEach(h => { u.set(h, m[h]) }), u } function br(m, u = new Map, h) { if (h) for (let [x, M] of h) u.set(x, M); for (let [x, M] of m) u.set(x, M); return u } function Ki(m, u, h) { u.forEach((x, M) => { const $ = ao(M); h && !h.has(M) && h.set(M, m.style[$]), m.style[$] = x }) } function po(m, u) { u.forEach((h, x) => { const M = ao(x); m.style[M] = "" }) } function Er(m) { return Array.isArray(m) ? 1 == m.length ? m[0] : (0, nt.vP)(m) : m } const us = new RegExp("{{\\s*(.+?)\\s*}}", "g"); function dr(m) { let u = []; if ("string" == typeof m) { let h; for (; h = us.exec(m);)u.push(h[1]); us.lastIndex = 0 } return u } function Wr(m, u, h) { const x = m.toString(), M = x.replace(us, ($, Ee) => { let je = u[Ee]; return null == je && (h.push(function ni(m) { return new v.vHH(3003, !1) }()), je = ""), je.toString() }); return M == x ? m : M } function Ni(m) { const u = []; let h = m.next(); for (; !h.done;)u.push(h.value), h = m.next(); return u } const As = /-+([a-z0-9])/g; function ao(m) { return m.replace(As, (...u) => u[1].toUpperCase()) } function Ci(m, u, h) { switch (u.type) { case 7: return m.visitTrigger(u, h); case 0: return m.visitState(u, h); case 1: return m.visitTransition(u, h); case 2: return m.visitSequence(u, h); case 3: return m.visitGroup(u, h); case 4: return m.visitAnimate(u, h); case 5: return m.visitKeyframes(u, h); case 6: return m.visitStyle(u, h); case 8: return m.visitReference(u, h); case 9: return m.visitAnimateChild(u, h); case 10: return m.visitAnimateRef(u, h); case 11: return m.visitQuery(u, h); case 12: return m.visitStagger(u, h); default: throw function si(m) { return new v.vHH(3004, !1) }() } } function ys(m, u) { return window.getComputedStyle(m)[u] } const is = "*"; function Ks(m, u) { const h = []; return "string" == typeof m ? m.split(/\s*,\s*/).forEach(x => function jo(m, u, h) { if (":" == m[0]) { const ft = function K(m, u) { switch (m) { case ":enter": return "void => *"; case ":leave": return "* => void"; case ":increment": return (h, x) => parseFloat(x) > parseFloat(h); case ":decrement": return (h, x) => parseFloat(x) < parseFloat(h); default: return u.push(function Jo(m) { return new v.vHH(3016, !1) }()), "* => *" } }(m, h); if ("function" == typeof ft) return void u.push(ft); m = ft } const x = m.match(/^(\*|[-\w]+)\s*(<?[=-]>)\s*(\*|[-\w]+)$/); if (null == x || x.length < 4) return h.push(function fo(m) { return new v.vHH(3015, !1) }()), u; const M = x[1], $ = x[2], Ee = x[3]; u.push(D(M, Ee)); "<" == $[0] && !(M == is && Ee == is) && u.push(D(Ee, M)) }(x, h, u)) : h.push(m), h } const V = new Set(["true", "1"]), w = new Set(["false", "0"]); function D(m, u) { const h = V.has(m) || w.has(m), x = V.has(u) || w.has(u); return (M, $) => { let Ee = m == is || m == M, je = u == is || u == $; return !Ee && h && "boolean" == typeof M && (Ee = M ? V.has(m) : w.has(m)), !je && x && "boolean" == typeof $ && (je = $ ? V.has(u) : w.has(u)), Ee && je } } const Re = new RegExp("s*:selfs*,?", "g"); function mt(m, u, h, x) { return new mn(m).build(u, h, x) } class mn { constructor(u) { this._driver = u } build(u, h, x) { const M = new gi(h); return this._resetContextStyleTimingState(M), Ci(this, Er(u), M) } _resetContextStyleTimingState(u) { u.currentQuerySelector = "", u.collectedStyles = new Map, u.collectedStyles.set("", new Map), u.currentTime = 0 } visitTrigger(u, h) { let x = h.queryCount = 0, M = h.depCount = 0; const $ = [], Ee = []; return "@" == u.name.charAt(0) && h.errors.push(function Li() { return new v.vHH(3006, !1) }()), u.definitions.forEach(je => { if (this._resetContextStyleTimingState(h), 0 == je.type) { const ft = je, zt = ft.name; zt.toString().split(/\s*,\s*/).forEach(xn => { ft.name = xn, $.push(this.visitState(ft, h)) }), ft.name = zt } else if (1 == je.type) { const ft = this.visitTransition(je, h); x += ft.queryCount, M += ft.depCount, Ee.push(ft) } else h.errors.push(function ho() { return new v.vHH(3007, !1) }()) }), { type: 7, name: u.name, states: $, transitions: Ee, queryCount: x, depCount: M, options: null } } visitState(u, h) { const x = this.visitStyle(u.styles, h), M = u.options && u.options.params || null; if (x.containsDynamicStyles) { const $ = new Set, Ee = M || {}; x.styles.forEach(je => { je instanceof Map && je.forEach(ft => { dr(ft).forEach(zt => { Ee.hasOwnProperty(zt) || $.add(zt) }) }) }), $.size && (Ni($.values()), h.errors.push(function $r(m, u) { return new v.vHH(3008, !1) }())) } return { type: 0, name: u.name, style: x, options: M ? { params: M } : null } } visitTransition(u, h) { h.queryCount = 0, h.depCount = 0; const x = Ci(this, Er(u.animation), h); return { type: 1, matchers: Ks(u.expr, h.errors), animation: x, queryCount: h.queryCount, depCount: h.depCount, options: ji(u.options) } } visitSequence(u, h) { return { type: 2, steps: u.steps.map(x => Ci(this, x, h)), options: ji(u.options) } } visitGroup(u, h) { const x = h.currentTime; let M = 0; const $ = u.steps.map(Ee => { h.currentTime = x; const je = Ci(this, Ee, h); return M = Math.max(M, h.currentTime), je }); return h.currentTime = M, { type: 3, steps: $, options: ji(u.options) } } visitAnimate(u, h) { const x = function Zi(m, u) { if (m.hasOwnProperty("duration")) return m; if ("number" == typeof m) return Bi(qo(m, u).duration, 0, ""); const h = m; if (h.split(/\s+/).some($ => "{" == $.charAt(0) && "{" == $.charAt(1))) { const $ = Bi(0, 0, ""); return $.dynamic = !0, $.strValue = h, $ } const M = qo(h, u); return Bi(M.duration, M.delay, M.easing) }(u.timings, h.errors); h.currentAnimateTimings = x; let M, $ = u.styles ? u.styles : (0, nt.oB)({}); if (5 == $.type) M = this.visitKeyframes($, h); else { let Ee = u.styles, je = !1; if (!Ee) { je = !0; const zt = {}; x.easing && (zt.easing = x.easing), Ee = (0, nt.oB)(zt) } h.currentTime += x.duration + x.delay; const ft = this.visitStyle(Ee, h); ft.isEmptyStep = je, M = ft } return h.currentAnimateTimings = null, { type: 4, timings: x, style: M, options: null } } visitStyle(u, h) { const x = this._makeStyleAst(u, h); return this._validateStyleAst(x, h), x } _makeStyleAst(u, h) { const x = [], M = Array.isArray(u.styles) ? u.styles : [u.styles]; for (let je of M) "string" == typeof je ? je === nt.l3 ? x.push(je) : h.errors.push(new v.vHH(3002, !1)) : x.push(yo(je)); let $ = !1, Ee = null; return x.forEach(je => { if (je instanceof Map && (je.has("easing") && (Ee = je.get("easing"), je.delete("easing")), !$)) for (let ft of je.values()) if (ft.toString().indexOf("{{") >= 0) { $ = !0; break } }), { type: 6, styles: x, easing: Ee, offset: u.offset, containsDynamicStyles: $, options: null } } _validateStyleAst(u, h) { const x = h.currentAnimateTimings; let M = h.currentTime, $ = h.currentTime; x && $ > 0 && ($ -= x.duration + x.delay), u.styles.forEach(Ee => { "string" != typeof Ee && Ee.forEach((je, ft) => { const zt = h.collectedStyles.get(h.currentQuerySelector), xn = zt.get(ft); let An = !0; xn && ($ != M && $ >= xn.startTime && M <= xn.endTime && (h.errors.push(function Ti(m, u, h, x, M) { return new v.vHH(3010, !1) }()), An = !1), $ = xn.startTime), An && zt.set(ft, { startTime: $, endTime: M }), h.options && function Gr(m, u, h) { const x = u.params || {}, M = dr(m); M.length && M.forEach($ => { x.hasOwnProperty($) || h.push(function qn(m) { return new v.vHH(3001, !1) }()) }) }(je, h.options, h.errors) }) }) } visitKeyframes(u, h) { const x = { type: 5, styles: [], options: null }; if (!h.currentAnimateTimings) return h.errors.push(function Pr() { return new v.vHH(3011, !1) }()), x; let $ = 0; const Ee = []; let je = !1, ft = !1, zt = 0; const xn = u.steps.map(Po => { const Ar = this._makeStyleAst(Po, h); let Mo = null != Ar.offset ? Ar.offset : function Ii(m) { if ("string" == typeof m) return null; let u = null; if (Array.isArray(m)) m.forEach(h => { if (h instanceof Map && h.has("offset")) { const x = h; u = parseFloat(x.get("offset")), x.delete("offset") } }); else if (m instanceof Map && m.has("offset")) { const h = m; u = parseFloat(h.get("offset")), h.delete("offset") } return u }(Ar.styles), Fr = 0; return null != Mo && ($++, Fr = Ar.offset = Mo), ft = ft || Fr < 0 || Fr > 1, je = je || Fr < zt, zt = Fr, Ee.push(Fr), Ar }); ft && h.errors.push(function Ir() { return new v.vHH(3012, !1) }()), je && h.errors.push(function bo() { return new v.vHH(3200, !1) }()); const An = u.steps.length; let ri = 0; $ > 0 && $ < An ? h.errors.push(function Nr() { return new v.vHH(3202, !1) }()) : 0 == $ && (ri = 1 / (An - 1)); const hi = An - 1, fi = h.currentTime, ei = h.currentAnimateTimings, zr = ei.duration; return xn.forEach((Po, Ar) => { const Mo = ri > 0 ? Ar == hi ? 1 : ri * Ar : Ee[Ar], Fr = Mo * zr; h.currentTime = fi + ei.delay + Fr, ei.duration = Fr, this._validateStyleAst(Po, h), Po.offset = Mo, x.styles.push(Po) }), x } visitReference(u, h) { return { type: 8, animation: Ci(this, Er(u.animation), h), options: ji(u.options) } } visitAnimateChild(u, h) { return h.depCount++, { type: 9, options: ji(u.options) } } visitAnimateRef(u, h) { return { type: 10, animation: this.visitReference(u.animation, h), options: ji(u.options) } } visitQuery(u, h) { const x = h.currentQuerySelector, M = u.options || {}; h.queryCount++, h.currentQuery = u; const [$, Ee] = function Gn(m) { const u = !!m.split(/\s*,\s*/).find(h => ":self" == h); return u && (m = m.replace(Re, "")), m = m.replace(/@\*/g, Tr).replace(/@\w+/g, h => Tr + "-" + h.slice(1)).replace(/:animating/g, Yo), [m, u] }(u.selector); h.currentQuerySelector = x.length ? x + " " + $ : $, _i(h.collectedStyles, h.currentQuerySelector, new Map); const je = Ci(this, Er(u.animation), h); return h.currentQuery = null, h.currentQuerySelector = x, { type: 11, selector: $, limit: M.limit || 0, optional: !!M.optional, includeSelf: Ee, animation: je, originalSelector: u.selector, options: ji(u.options) } } visitStagger(u, h) { h.currentQuery || h.errors.push(function Vi() { return new v.vHH(3013, !1) }()); const x = "full" === u.timings ? { duration: 0, delay: 0, easing: "full" } : qo(u.timings, h.errors, !0); return { type: 12, animation: Ci(this, Er(u.animation), h), timings: x, options: null } } } class gi { constructor(u) { this.errors = u, this.queryCount = 0, this.depCount = 0, this.currentTransition = null, this.currentQuery = null, this.currentQuerySelector = null, this.currentAnimateTimings = null, this.currentTime = 0, this.collectedStyles = new Map, this.options = null, this.unsupportedCSSPropertiesFound = new Set } } function ji(m) { return m ? (m = Ro(m)).params && (m.params = function jn(m) { return m ? Ro(m) : null }(m.params)) : m = {}, m } function Bi(m, u, h) { return { duration: m, delay: u, easing: h } } function ir(m, u, h, x, M, $, Ee = null, je = !1) { return { type: 1, element: m, keyframes: u, preStyleProps: h, postStyleProps: x, duration: M, delay: $, totalTime: M + $, easing: Ee, subTimeline: je } } class ar { constructor() { this._map = new Map } get(u) { return this._map.get(u) || [] } append(u, h) { let x = this._map.get(u); x || this._map.set(u, x = []), x.push(...h) } has(u) { return this._map.has(u) } clear() { this._map.clear() } } const Kr = new RegExp(":enter", "g"), Sr = new RegExp(":leave", "g"); function Do(m, u, h, x, M, $ = new Map, Ee = new Map, je, ft, zt = []) { return (new $o).buildKeyframes(m, u, h, x, M, $, Ee, je, ft, zt) } class $o { buildKeyframes(u, h, x, M, $, Ee, je, ft, zt, xn = []) { zt = zt || new ar; const An = new rs(u, h, zt, M, $, xn, []); An.options = ft; const ri = ft.delay ? so(ft.delay) : 0; An.currentTimeline.delayNextStep(ri), An.currentTimeline.setStyles([Ee], null, An.errors, ft), Ci(this, x, An); const hi = An.timelines.filter(fi => fi.containsAnimation()); if (hi.length && je.size) { let fi; for (let ei = hi.length - 1; ei >= 0; ei--) { const zr = hi[ei]; if (zr.element === h) { fi = zr; break } } fi && !fi.allowOnlyTimelineStyles() && fi.setStyles([je], null, An.errors, ft) } return hi.length ? hi.map(fi => fi.buildKeyframes()) : [ir(h, [], [], [], 0, ri, "", !1)] } visitTrigger(u, h) { } visitState(u, h) { } visitTransition(u, h) { } visitAnimateChild(u, h) { const x = h.subInstructions.get(h.element); if (x) { const M = h.createSubContext(u.options), $ = h.currentTimeline.currentTime, Ee = this._visitSubInstructions(x, M, M.options); $ != Ee && h.transformIntoNewTimeline(Ee) } h.previousNode = u } visitAnimateRef(u, h) { const x = h.createSubContext(u.options); x.transformIntoNewTimeline(), this._applyAnimationRefDelays([u.options, u.animation.options], h, x), this.visitReference(u.animation, x), h.transformIntoNewTimeline(x.currentTimeline.currentTime), h.previousNode = u } _applyAnimationRefDelays(u, h, x) { for (const M of u) { const $ = M?.delay; if ($) { const Ee = "number" == typeof $ ? $ : so(Wr($, M?.params ?? {}, h.errors)); x.delayNextStep(Ee) } } } _visitSubInstructions(u, h, x) { let $ = h.currentTimeline.currentTime; const Ee = null != x.duration ? so(x.duration) : null, je = null != x.delay ? so(x.delay) : null; return 0 !== Ee && u.forEach(ft => { const zt = h.appendInstructionToTimeline(ft, Ee, je); $ = Math.max($, zt.duration + zt.delay) }), $ } visitReference(u, h) { h.updateOptions(u.options, !0), Ci(this, u.animation, h), h.previousNode = u } visitSequence(u, h) { const x = h.subContextCount; let M = h; const $ = u.options; if ($ && ($.params || $.delay) && (M = h.createSubContext($), M.transformIntoNewTimeline(), null != $.delay)) { 6 == M.previousNode.type && (M.currentTimeline.snapshotCurrentStyles(), M.previousNode = hs); const Ee = so($.delay); M.delayNextStep(Ee) } u.steps.length && (u.steps.forEach(Ee => Ci(this, Ee, M)), M.currentTimeline.applyStylesToKeyframe(), M.subContextCount > x && M.transformIntoNewTimeline()), h.previousNode = u } visitGroup(u, h) { const x = []; let M = h.currentTimeline.currentTime; const $ = u.options && u.options.delay ? so(u.options.delay) : 0; u.steps.forEach(Ee => { const je = h.createSubContext(u.options); $ && je.delayNextStep($), Ci(this, Ee, je), M = Math.max(M, je.currentTimeline.currentTime), x.push(je.currentTimeline) }), x.forEach(Ee => h.currentTimeline.mergeTimelineCollectedStyles(Ee)), h.transformIntoNewTimeline(M), h.previousNode = u } _visitTiming(u, h) { if (u.dynamic) { const x = u.strValue; return qo(h.params ? Wr(x, h.params, h.errors) : x, h.errors) } return { duration: u.duration, delay: u.delay, easing: u.easing } } visitAnimate(u, h) { const x = h.currentAnimateTimings = this._visitTiming(u.timings, h), M = h.currentTimeline; x.delay && (h.incrementTime(x.delay), M.snapshotCurrentStyles()); const $ = u.style; 5 == $.type ? this.visitKeyframes($, h) : (h.incrementTime(x.duration), this.visitStyle($, h), M.applyStylesToKeyframe()), h.currentAnimateTimings = null, h.previousNode = u } visitStyle(u, h) { const x = h.currentTimeline, M = h.currentAnimateTimings; !M && x.hasCurrentStyleProperties() && x.forwardFrame(); const $ = M && M.easing || u.easing; u.isEmptyStep ? x.applyEmptyStep($) : x.setStyles(u.styles, $, h.errors, h.options), h.previousNode = u } visitKeyframes(u, h) { const x = h.currentAnimateTimings, M = h.currentTimeline.duration, $ = x.duration, je = h.createSubContext().currentTimeline; je.easing = x.easing, u.styles.forEach(ft => { je.forwardTime((ft.offset || 0) * $), je.setStyles(ft.styles, ft.easing, h.errors, h.options), je.applyStylesToKeyframe() }), h.currentTimeline.mergeTimelineCollectedStyles(je), h.transformIntoNewTimeline(M + $), h.previousNode = u } visitQuery(u, h) { const x = h.currentTimeline.currentTime, M = u.options || {}, $ = M.delay ? so(M.delay) : 0; $ && (6 === h.previousNode.type || 0 == x && h.currentTimeline.hasCurrentStyleProperties()) && (h.currentTimeline.snapshotCurrentStyles(), h.previousNode = hs); let Ee = x; const je = h.invokeQuery(u.selector, u.originalSelector, u.limit, u.includeSelf, !!M.optional, h.errors); h.currentQueryTotal = je.length; let ft = null; je.forEach((zt, xn) => { h.currentQueryIndex = xn; const An = h.createSubContext(u.options, zt); $ && An.delayNextStep($), zt === h.element && (ft = An.currentTimeline), Ci(this, u.animation, An), An.currentTimeline.applyStylesToKeyframe(), Ee = Math.max(Ee, An.currentTimeline.currentTime) }), h.currentQueryIndex = 0, h.currentQueryTotal = 0, h.transformIntoNewTimeline(Ee), ft && (h.currentTimeline.mergeTimelineCollectedStyles(ft), h.currentTimeline.snapshotCurrentStyles()), h.previousNode = u } visitStagger(u, h) { const x = h.parentContext, M = h.currentTimeline, $ = u.timings, Ee = Math.abs($.duration), je = Ee * (h.currentQueryTotal - 1); let ft = Ee * h.currentQueryIndex; switch ($.duration < 0 ? "reverse" : $.easing) { case "reverse": ft = je - ft; break; case "full": ft = x.currentStaggerTime }const xn = h.currentTimeline; ft && xn.delayNextStep(ft); const An = xn.currentTime; Ci(this, u.animation, h), h.previousNode = u, x.currentStaggerTime = M.currentTime - An + (M.startTime - x.currentTimeline.startTime) } } const hs = {}; class rs { constructor(u, h, x, M, $, Ee, je, ft) { this._driver = u, this.element = h, this.subInstructions = x, this._enterClassName = M, this._leaveClassName = $, this.errors = Ee, this.timelines = je, this.parentContext = null, this.currentAnimateTimings = null, this.previousNode = hs, this.subContextCount = 0, this.options = {}, this.currentQueryIndex = 0, this.currentQueryTotal = 0, this.currentStaggerTime = 0, this.currentTimeline = ft || new Jr(this._driver, h, 0), je.push(this.currentTimeline) } get params() { return this.options.params } updateOptions(u, h) { if (!u) return; const x = u; let M = this.options; null != x.duration && (M.duration = so(x.duration)), null != x.delay && (M.delay = so(x.delay)); const $ = x.params; if ($) { let Ee = M.params; Ee || (Ee = this.options.params = {}), Object.keys($).forEach(je => { (!h || !Ee.hasOwnProperty(je)) && (Ee[je] = Wr($[je], Ee, this.errors)) }) } } _copyOptions() { const u = {}; if (this.options) { const h = this.options.params; if (h) { const x = u.params = {}; Object.keys(h).forEach(M => { x[M] = h[M] }) } } return u } createSubContext(u = null, h, x) { const M = h || this.element, $ = new rs(this._driver, M, this.subInstructions, this._enterClassName, this._leaveClassName, this.errors, this.timelines, this.currentTimeline.fork(M, x || 0)); return $.previousNode = this.previousNode, $.currentAnimateTimings = this.currentAnimateTimings, $.options = this._copyOptions(), $.updateOptions(u), $.currentQueryIndex = this.currentQueryIndex, $.currentQueryTotal = this.currentQueryTotal, $.parentContext = this, this.subContextCount++, $ } transformIntoNewTimeline(u) { return this.previousNode = hs, this.currentTimeline = this.currentTimeline.fork(this.element, u), this.timelines.push(this.currentTimeline), this.currentTimeline } appendInstructionToTimeline(u, h, x) { const M = { duration: h ?? u.duration, delay: this.currentTimeline.currentTime + (x ?? 0) + u.delay, easing: "" }, $ = new os(this._driver, u.element, u.keyframes, u.preStyleProps, u.postStyleProps, M, u.stretchStartingKeyframe); return this.timelines.push($), M } incrementTime(u) { this.currentTimeline.forwardTime(this.currentTimeline.duration + u) } delayNextStep(u) { u > 0 && this.currentTimeline.delayNextStep(u) } invokeQuery(u, h, x, M, $, Ee) { let je = []; if (M && je.push(this.element), u.length > 0) { u = (u = u.replace(Kr, "." + this._enterClassName)).replace(Sr, "." + this._leaveClassName); let zt = this._driver.query(this.element, u, 1 != x); 0 !== x && (zt = x < 0 ? zt.slice(zt.length + x, zt.length) : zt.slice(0, x)), je.push(...zt) } return !$ && 0 == je.length && Ee.push(function cs(m) { return new v.vHH(3014, !1) }()), je } } class Jr { constructor(u, h, x, M) { this._driver = u, this.element = h, this.startTime = x, this._elementTimelineStylesLookup = M, this.duration = 0, this.easing = null, this._previousKeyframe = new Map, this._currentKeyframe = new Map, this._keyframes = new Map, this._styleSummary = new Map, this._localTimelineStyles = new Map, this._pendingStyles = new Map, this._backFill = new Map, this._currentEmptyStepKeyframe = null, this._elementTimelineStylesLookup || (this._elementTimelineStylesLookup = new Map), this._globalTimelineStyles = this._elementTimelineStylesLookup.get(h), this._globalTimelineStyles || (this._globalTimelineStyles = this._localTimelineStyles, this._elementTimelineStylesLookup.set(h, this._localTimelineStyles)), this._loadKeyframe() } containsAnimation() { switch (this._keyframes.size) { case 0: return !1; case 1: return this.hasCurrentStyleProperties(); default: return !0 } } hasCurrentStyleProperties() { return this._currentKeyframe.size > 0 } get currentTime() { return this.startTime + this.duration } delayNextStep(u) { const h = 1 === this._keyframes.size && this._pendingStyles.size; this.duration || h ? (this.forwardTime(this.currentTime + u), h && this.snapshotCurrentStyles()) : this.startTime += u } fork(u, h) { return this.applyStylesToKeyframe(), new Jr(this._driver, u, h || this.currentTime, this._elementTimelineStylesLookup) } _loadKeyframe() { this._currentKeyframe && (this._previousKeyframe = this._currentKeyframe), this._currentKeyframe = this._keyframes.get(this.duration), this._currentKeyframe || (this._currentKeyframe = new Map, this._keyframes.set(this.duration, this._currentKeyframe)) } forwardFrame() { this.duration += 1, this._loadKeyframe() } forwardTime(u) { this.applyStylesToKeyframe(), this.duration = u, this._loadKeyframe() } _updateStyle(u, h) { this._localTimelineStyles.set(u, h), this._globalTimelineStyles.set(u, h), this._styleSummary.set(u, { time: this.currentTime, value: h }) } allowOnlyTimelineStyles() { return this._currentEmptyStepKeyframe !== this._currentKeyframe } applyEmptyStep(u) { u && this._previousKeyframe.set("easing", u); for (let [h, x] of this._globalTimelineStyles) this._backFill.set(h, x || nt.l3), this._currentKeyframe.set(h, nt.l3); this._currentEmptyStepKeyframe = this._currentKeyframe } setStyles(u, h, x, M) { h && this._previousKeyframe.set("easing", h); const $ = M && M.params || {}, Ee = function ks(m, u) { const h = new Map; let x; return m.forEach(M => { if ("*" === M) { x = x || u.keys(); for (let $ of x) h.set($, nt.l3) } else br(M, h) }), h }(u, this._globalTimelineStyles); for (let [je, ft] of Ee) { const zt = Wr(ft, $, x); this._pendingStyles.set(je, zt), this._localTimelineStyles.has(je) || this._backFill.set(je, this._globalTimelineStyles.get(je) ?? nt.l3), this._updateStyle(je, zt) } } applyStylesToKeyframe() { 0 != this._pendingStyles.size && (this._pendingStyles.forEach((u, h) => { this._currentKeyframe.set(h, u) }), this._pendingStyles.clear(), this._localTimelineStyles.forEach((u, h) => { this._currentKeyframe.has(h) || this._currentKeyframe.set(h, u) })) } snapshotCurrentStyles() { for (let [u, h] of this._localTimelineStyles) this._pendingStyles.set(u, h), this._updateStyle(u, h) } getFinalKeyframe() { return this._keyframes.get(this.duration) } get properties() { const u = []; for (let h in this._currentKeyframe) u.push(h); return u } mergeTimelineCollectedStyles(u) { u._styleSummary.forEach((h, x) => { const M = this._styleSummary.get(x); (!M || h.time > M.time) && this._updateStyle(x, h.value) }) } buildKeyframes() { this.applyStylesToKeyframe(); const u = new Set, h = new Set, x = 1 === this._keyframes.size && 0 === this.duration; let M = []; this._keyframes.forEach((je, ft) => { const zt = br(je, new Map, this._backFill); zt.forEach((xn, An) => { xn === nt.k1 ? u.add(An) : xn === nt.l3 && h.add(An) }), x || zt.set("offset", ft / this.duration), M.push(zt) }); const $ = u.size ? Ni(u.values()) : [], Ee = h.size ? Ni(h.values()) : []; if (x) { const je = M[0], ft = new Map(je); je.set("offset", 0), ft.set("offset", 1), M = [je, ft] } return ir(this.element, M, $, Ee, this.duration, this.startTime, this.easing, !1) } } class os extends Jr { constructor(u, h, x, M, $, Ee, je = !1) { super(u, h, Ee.delay), this.keyframes = x, this.preStyleProps = M, this.postStyleProps = $, this._stretchStartingKeyframe = je, this.timings = { duration: Ee.duration, delay: Ee.delay, easing: Ee.easing } } containsAnimation() { return this.keyframes.length > 1 } buildKeyframes() { let u = this.keyframes, { delay: h, duration: x, easing: M } = this.timings; if (this._stretchStartingKeyframe && h) { const $ = [], Ee = x + h, je = h / Ee, ft = br(u[0]); ft.set("offset", 0), $.push(ft); const zt = br(u[0]); zt.set("offset", Ka(je)), $.push(zt); const xn = u.length - 1; for (let An = 1; An <= xn; An++) { let ri = br(u[An]); const hi = ri.get("offset"); ri.set("offset", Ka((h + hi * x) / Ee)), $.push(ri) } x = Ee, h = 0, M = "", u = $ } return ir(this.element, u, this.preStyleProps, this.postStyleProps, x, h, M, !0) } } function Ka(m, u = 3) { const h = Math.pow(10, u - 1); return Math.round(m * h) / h } class fs { } const _r = new Set(["width", "height", "minWidth", "minHeight", "maxWidth", "maxHeight", "left", "top", "bottom", "right", "fontSize", "outlineWidth", "outlineOffset", "paddingTop", "paddingLeft", "paddingBottom", "paddingRight", "marginTop", "marginLeft", "marginBottom", "marginRight", "borderRadius", "borderWidth", "borderTopWidth", "borderLeftWidth", "borderRightWidth", "borderBottomWidth", "textIndent", "perspective"]); class ma extends fs { normalizePropertyName(u, h) { return ao(u) } normalizeStyleValue(u, h, x, M) { let $ = ""; const Ee = x.toString().trim(); if (_r.has(h) && 0 !== x && "0" !== x) if ("number" == typeof x) $ = "px"; else { const je = x.match(/^[+-]?[\d\.]+([a-z]*)$/); je && 0 == je[1].length && M.push(function Ai(m, u) { return new v.vHH(3005, !1) }()) } return Ee + $ } } function Ya(m, u, h, x, M, $, Ee, je, ft, zt, xn, An, ri) { return { type: 0, element: m, triggerName: u, isRemovalTransition: M, fromState: h, fromStyles: $, toState: x, toStyles: Ee, timelines: je, queriedElements: ft, preStyleProps: zt, postStyleProps: xn, totalTime: An, errors: ri } } const To = {}; class pa { constructor(u, h, x) { this._triggerName = u, this.ast = h, this._stateStyles = x } match(u, h, x, M) { return function Bs(m, u, h, x, M) { return m.some($ => $(u, h, x, M)) }(this.ast.matchers, u, h, x, M) } buildStyles(u, h, x) { let M = this._stateStyles.get("*"); return void 0 !== u && (M = this._stateStyles.get(u?.toString()) || M), M ? M.buildStyles(h, x) : new Map } build(u, h, x, M, $, Ee, je, ft, zt, xn) { const An = [], ri = this.ast.options && this.ast.options.params || To, fi = this.buildStyles(x, je && je.params || To, An), ei = ft && ft.params || To, zr = this.buildStyles(M, ei, An), Po = new Set, Ar = new Map, Mo = new Map, Fr = "void" === M, Ja = { params: Ta(ei, ri), delay: this.ast.options?.delay }, oa = xn ? [] : Do(u, h, this.ast.animation, $, Ee, fi, zr, Ja, zt, An); let Eo = 0; if (oa.forEach(Ra => { Eo = Math.max(Ra.duration + Ra.delay, Eo) }), An.length) return Ya(h, this._triggerName, x, M, Fr, fi, zr, [], [], Ar, Mo, Eo, An); oa.forEach(Ra => { const sa = Ra.element, dd = _i(Ar, sa, new Set); Ra.preStyleProps.forEach(ya => dd.add(ya)); const aa = _i(Mo, sa, new Set); Ra.postStyleProps.forEach(ya => aa.add(ya)), sa !== h && Po.add(sa) }); const ba = Ni(Po.values()); return Ya(h, this._triggerName, x, M, Fr, fi, zr, oa, ba, Ar, Mo, Eo) } } function Ta(m, u) { const h = Ro(u); for (const x in m) m.hasOwnProperty(x) && null != m[x] && (h[x] = m[x]); return h } class Ma { constructor(u, h, x) { this.styles = u, this.defaultParams = h, this.normalizer = x } buildStyles(u, h) { const x = new Map, M = Ro(this.defaultParams); return Object.keys(u).forEach($ => { const Ee = u[$]; null !== Ee && (M[$] = Ee) }), this.styles.styles.forEach($ => { "string" != typeof $ && $.forEach((Ee, je) => { Ee && (Ee = Wr(Ee, M, h)); const ft = this.normalizer.normalizePropertyName(je, h); Ee = this.normalizer.normalizeStyleValue(je, ft, Ee, h), x.set(je, Ee) }) }), x } } class ts { constructor(u, h, x) { this.name = u, this.ast = h, this._normalizer = x, this.transitionFactories = [], this.states = new Map, h.states.forEach(M => { this.states.set(M.name, new Ma(M.style, M.options && M.options.params || {}, x)) }), Rs(this.states, "true", "1"), Rs(this.states, "false", "0"), h.transitions.forEach(M => { this.transitionFactories.push(new pa(u, M, this.states)) }), this.fallbackTransition = function lo(m, u, h) { return new pa(m, { type: 1, animation: { type: 2, steps: [], options: null }, matchers: [(Ee, je) => !0], options: null, queryCount: 0, depCount: 0 }, u) }(u, this.states) } get containsQueries() { return this.ast.queryCount > 0 } matchTransition(u, h, x, M) { return this.transitionFactories.find(Ee => Ee.match(u, h, x, M)) || null } matchStyles(u, h, x) { return this.fallbackTransition.buildStyles(u, h, x) } } function Rs(m, u, h) { m.has(u) ? m.has(h) || m.set(h, m.get(u)) : m.has(h) && m.set(u, m.get(h)) } const go = new ar; class Os { constructor(u, h, x) { this.bodyNode = u, this._driver = h, this._normalizer = x, this._animations = new Map, this._playersById = new Map, this.players = [] } register(u, h) { const x = [], $ = mt(this._driver, h, x, []); if (x.length) throw function sn(m) { return new v.vHH(3503, !1) }(); this._animations.set(u, $) } _buildPlayer(u, h, x) { const M = u.element, $ = Dr(this._normalizer, u.keyframes, h, x); return this._driver.animate(M, $, u.duration, u.delay, u.easing, [], !0) } create(u, h, x = {}) { const M = [], $ = this._animations.get(u); let Ee; const je = new Map; if ($ ? (Ee = Do(this._driver, h, $, oo, Qr, new Map, new Map, x, go, M), Ee.forEach(xn => { const An = _i(je, xn.element, new Map); xn.postStyleProps.forEach(ri => An.set(ri, null)) })) : (M.push(function wn() { return new v.vHH(3300, !1) }()), Ee = []), M.length) throw function dt(m) { return new v.vHH(3504, !1) }(); je.forEach((xn, An) => { xn.forEach((ri, hi) => { xn.set(hi, this._driver.computeStyle(An, hi, nt.l3)) }) }); const zt = Xi(Ee.map(xn => { const An = je.get(xn.element); return this._buildPlayer(xn, new Map, An) })); return this._playersById.set(u, zt), zt.onDestroy(() => this.destroy(u)), this.players.push(zt), zt } destroy(u) { const h = this._getPlayer(u); h.destroy(), this._playersById.delete(u); const x = this.players.indexOf(h); x >= 0 && this.players.splice(x, 1) } _getPlayer(u) { const h = this._playersById.get(u); if (!h) throw function Be(m) { return new v.vHH(3301, !1) }(); return h } listen(u, h, x, M) { const $ = mo(h, "", "", ""); return xr(this._getPlayer(u), x, $, M), () => { } } command(u, h, x, M) { if ("register" == x) return void this.register(u, M[0]); if ("create" == x) return void this.create(u, h, M[0] || {}); const $ = this._getPlayer(u); switch (x) { case "play": $.play(); break; case "pause": $.pause(); break; case "reset": $.reset(); break; case "restart": $.restart(); break; case "finish": $.finish(); break; case "init": $.init(); break; case "setPosition": $.setPosition(parseFloat(M[0])); break; case "destroy": this.destroy(u) } } } const xs = "ng-animate-queued", Oo = "ng-animate-disabled", be = [], Je = { namespaceId: "", setForRemoval: !1, setForMove: !1, hasAnimation: !1, removedBeforeQueried: !1 }, $t = { namespaceId: "", setForMove: !1, setForRemoval: !1, hasAnimation: !1, removedBeforeQueried: !0 }, en = "__ng_removed"; class Zn { get params() { return this.options.params } constructor(u, h = "") { this.namespaceId = h; const x = u && u.hasOwnProperty("value"); if (this.value = function rr(m) { return m ?? null }(x ? u.value : u), x) { const $ = Ro(u); delete $.value, this.options = $ } else this.options = {}; this.options.params || (this.options.params = {}) } absorbOptions(u) { const h = u.params; if (h) { const x = this.options.params; Object.keys(h).forEach(M => { null == x[M] && (x[M] = h[M]) }) } } } const Ji = "void", xi = new Zn(Ji); class Hi { constructor(u, h, x) { this.id = u, this.hostElement = h, this._engine = x, this.players = [], this._triggers = new Map, this._queue = [], this._elementListeners = new Map, this._hostClassName = "ng-tns-" + u, Ur(h, this._hostClassName) } listen(u, h, x, M) { if (!this._triggers.has(h)) throw function ye(m, u) { return new v.vHH(3302, !1) }(); if (null == x || 0 == x.length) throw function et(m) { return new v.vHH(3303, !1) }(); if (!function ui(m) { return "start" == m || "done" == m }(x)) throw function Vt(m, u) { return new v.vHH(3400, !1) }(); const $ = _i(this._elementListeners, u, []), Ee = { name: h, phase: x, callback: M }; $.push(Ee); const je = _i(this._engine.statesByElement, u, new Map); return je.has(h) || (Ur(u, es), Ur(u, es + "-" + h), je.set(h, xi)), () => { this._engine.afterFlush(() => { const ft = $.indexOf(Ee); ft >= 0 && $.splice(ft, 1), this._triggers.has(h) || je.delete(h) }) } } register(u, h) { return !this._triggers.has(u) && (this._triggers.set(u, h), !0) } _getTrigger(u) { const h = this._triggers.get(u); if (!h) throw function At(m) { return new v.vHH(3401, !1) }(); return h } trigger(u, h, x, M = !0) { const $ = this._getTrigger(h), Ee = new Di(this.id, h, u); let je = this._engine.statesByElement.get(u); je || (Ur(u, es), Ur(u, es + "-" + h), this._engine.statesByElement.set(u, je = new Map)); let ft = je.get(h); const zt = new Zn(x, this.id); if (!(x && x.hasOwnProperty("value")) && ft && zt.absorbOptions(ft.options), je.set(h, zt), ft || (ft = xi), zt.value !== Ji && ft.value === zt.value) { if (!function Yt(m, u) { const h = Object.keys(m), x = Object.keys(u); if (h.length != x.length) return !1; for (let M = 0; M < h.length; M++) { const $ = h[M]; if (!u.hasOwnProperty($) || m[$] !== u[$]) return !1 } return !0 }(ft.params, zt.params)) { const ei = [], zr = $.matchStyles(ft.value, ft.params, ei), Po = $.matchStyles(zt.value, zt.params, ei); ei.length ? this._engine.reportError(ei) : this._engine.afterFlush(() => { po(u, zr), Ki(u, Po) }) } return } const ri = _i(this._engine.playersByElement, u, []); ri.forEach(ei => { ei.namespaceId == this.id && ei.triggerName == h && ei.queued && ei.destroy() }); let hi = $.matchTransition(ft.value, zt.value, u, zt.params), fi = !1; if (!hi) { if (!M) return; hi = $.fallbackTransition, fi = !0 } return this._engine.totalQueuedPlayers++, this._queue.push({ element: u, triggerName: h, transition: hi, fromState: ft, toState: zt, player: Ee, isFallbackTransition: fi }), fi || (Ur(u, xs), Ee.onStart(() => { Cn(u, xs) })), Ee.onDone(() => { let ei = this.players.indexOf(Ee); ei >= 0 && this.players.splice(ei, 1); const zr = this._engine.playersByElement.get(u); if (zr) { let Po = zr.indexOf(Ee); Po >= 0 && zr.splice(Po, 1) } }), this.players.push(Ee), ri.push(Ee), Ee } deregister(u) { this._triggers.delete(u), this._engine.statesByElement.forEach(h => h.delete(u)), this._elementListeners.forEach((h, x) => { this._elementListeners.set(x, h.filter(M => M.name != u)) }) } clearElementCache(u) { this._engine.statesByElement.delete(u), this._elementListeners.delete(u); const h = this._engine.playersByElement.get(u); h && (h.forEach(x => x.destroy()), this._engine.playersByElement.delete(u)) } _signalRemovalForInnerTriggers(u, h) { const x = this._engine.driver.query(u, Tr, !0); x.forEach(M => { if (M[en]) return; const $ = this._engine.fetchNamespacesByElement(M); $.size ? $.forEach(Ee => Ee.triggerLeaveAnimation(M, h, !1, !0)) : this.clearElementCache(M) }), this._engine.afterFlushAnimationsDone(() => x.forEach(M => this.clearElementCache(M))) } triggerLeaveAnimation(u, h, x, M) { const $ = this._engine.statesByElement.get(u), Ee = new Map; if ($) { const je = []; if ($.forEach((ft, zt) => { if (Ee.set(zt, ft.value), this._triggers.has(zt)) { const xn = this.trigger(u, zt, Ji, M); xn && je.push(xn) } }), je.length) return this._engine.markElementAsRemoved(this.id, u, !0, h, Ee), x && Xi(je).onDone(() => this._engine.processLeaveNode(u)), !0 } return !1 } prepareLeaveAnimationListeners(u) { const h = this._elementListeners.get(u), x = this._engine.statesByElement.get(u); if (h && x) { const M = new Set; h.forEach($ => { const Ee = $.name; if (M.has(Ee)) return; M.add(Ee); const ft = this._triggers.get(Ee).fallbackTransition, zt = x.get(Ee) || xi, xn = new Zn(Ji), An = new Di(this.id, Ee, u); this._engine.totalQueuedPlayers++, this._queue.push({ element: u, triggerName: Ee, transition: ft, fromState: zt, toState: xn, player: An, isFallbackTransition: !0 }) }) } } removeNode(u, h) { const x = this._engine; if (u.childElementCount && this._signalRemovalForInnerTriggers(u, h), this.triggerLeaveAnimation(u, h, !0)) return; let M = !1; if (x.totalAnimations) { const $ = x.players.length ? x.playersByQueriedElement.get(u) : []; if ($ && $.length) M = !0; else { let Ee = u; for (; Ee = Ee.parentNode;)if (x.statesByElement.get(Ee)) { M = !0; break } } } if (this.prepareLeaveAnimationListeners(u), M) x.markElementAsRemoved(this.id, u, !1, h); else { const $ = u[en]; (!$ || $ === Je) && (x.afterFlush(() => this.clearElementCache(u)), x.destroyInnerAnimations(u), x._onRemovalComplete(u, h)) } } insertNode(u, h) { Ur(u, this._hostClassName) } drainQueuedTransitions(u) { const h = []; return this._queue.forEach(x => { const M = x.player; if (M.destroyed) return; const $ = x.element, Ee = this._elementListeners.get($); Ee && Ee.forEach(je => { if (je.name == x.triggerName) { const ft = mo($, x.triggerName, x.fromState.value, x.toState.value); ft._data = u, xr(x.player, je.phase, ft, je.callback) } }), M.markedForDestroy ? this._engine.afterFlush(() => { M.destroy() }) : h.push(x) }), this._queue = [], h.sort((x, M) => { const $ = x.transition.ast.depCount, Ee = M.transition.ast.depCount; return 0 == $ || 0 == Ee ? $ - Ee : this._engine.driver.containsElement(x.element, M.element) ? 1 : -1 }) } destroy(u) { this.players.forEach(h => h.destroy()), this._signalRemovalForInnerTriggers(this.hostElement, u) } elementContainsData(u) { let h = !1; return this._elementListeners.has(u) && (h = !0), h = !!this._queue.find(x => x.element === u) || h, h } } class Fi { _onRemovalComplete(u, h) { this.onRemovalComplete(u, h) } constructor(u, h, x) { this.bodyNode = u, this.driver = h, this._normalizer = x, this.players = [], this.newHostElements = new Map, this.playersByElement = new Map, this.playersByQueriedElement = new Map, this.statesByElement = new Map, this.disabledNodes = new Set, this.totalAnimations = 0, this.totalQueuedPlayers = 0, this._namespaceLookup = {}, this._namespaceList = [], this._flushFns = [], this._whenQuietFns = [], this.namespacesByHostElement = new Map, this.collectedEnterElements = [], this.collectedLeaveElements = [], this.onRemovalComplete = (M, $) => { } } get queuedPlayers() { const u = []; return this._namespaceList.forEach(h => { h.players.forEach(x => { x.queued && u.push(x) }) }), u } createNamespace(u, h) { const x = new Hi(u, h, this); return this.bodyNode && this.driver.containsElement(this.bodyNode, h) ? this._balanceNamespaceList(x, h) : (this.newHostElements.set(h, x), this.collectEnterElement(h)), this._namespaceLookup[u] = x } _balanceNamespaceList(u, h) { const x = this._namespaceList, M = this.namespacesByHostElement; if (x.length - 1 >= 0) { let Ee = !1, je = this.driver.getParentElement(h); for (; je;) { const ft = M.get(je); if (ft) { const zt = x.indexOf(ft); x.splice(zt + 1, 0, u), Ee = !0; break } je = this.driver.getParentElement(je) } Ee || x.unshift(u) } else x.push(u); return M.set(h, u), u } register(u, h) { let x = this._namespaceLookup[u]; return x || (x = this.createNamespace(u, h)), x } registerTrigger(u, h, x) { let M = this._namespaceLookup[u]; M && M.register(h, x) && this.totalAnimations++ } destroy(u, h) { if (!u) return; const x = this._fetchNamespace(u); this.afterFlush(() => { this.namespacesByHostElement.delete(x.hostElement), delete this._namespaceLookup[u]; const M = this._namespaceList.indexOf(x); M >= 0 && this._namespaceList.splice(M, 1) }), this.afterFlushAnimationsDone(() => x.destroy(h)) } _fetchNamespace(u) { return this._namespaceLookup[u] } fetchNamespacesByElement(u) { const h = new Set, x = this.statesByElement.get(u); if (x) for (let M of x.values()) if (M.namespaceId) { const $ = this._fetchNamespace(M.namespaceId); $ && h.add($) } return h } trigger(u, h, x, M) { if (lr(h)) { const $ = this._fetchNamespace(u); if ($) return $.trigger(h, x, M), !0 } return !1 } insertNode(u, h, x, M) { if (!lr(h)) return; const $ = h[en]; if ($ && $.setForRemoval) { $.setForRemoval = !1, $.setForMove = !0; const Ee = this.collectedLeaveElements.indexOf(h); Ee >= 0 && this.collectedLeaveElements.splice(Ee, 1) } if (u) { const Ee = this._fetchNamespace(u); Ee && Ee.insertNode(h, x) } M && this.collectEnterElement(h) } collectEnterElement(u) { this.collectedEnterElements.push(u) } markElementAsDisabled(u, h) { h ? this.disabledNodes.has(u) || (this.disabledNodes.add(u), Ur(u, Oo)) : this.disabledNodes.has(u) && (this.disabledNodes.delete(u), Cn(u, Oo)) } removeNode(u, h, x) { if (lr(h)) { const M = u ? this._fetchNamespace(u) : null; M ? M.removeNode(h, x) : this.markElementAsRemoved(u, h, !1, x); const $ = this.namespacesByHostElement.get(h); $ && $.id !== u && $.removeNode(h, x) } else this._onRemovalComplete(h, x) } markElementAsRemoved(u, h, x, M, $) { this.collectedLeaveElements.push(h), h[en] = { namespaceId: u, setForRemoval: M, hasAnimation: x, removedBeforeQueried: !1, previousTriggersValues: $ } } listen(u, h, x, M, $) { return lr(h) ? this._fetchNamespace(u).listen(h, x, M, $) : () => { } } _buildInstruction(u, h, x, M, $) { return u.transition.build(this.driver, u.element, u.fromState.value, u.toState.value, x, M, u.fromState.options, u.toState.options, h, $) } destroyInnerAnimations(u) { let h = this.driver.query(u, Tr, !0); h.forEach(x => this.destroyActiveAnimationsForElement(x)), 0 != this.playersByQueriedElement.size && (h = this.driver.query(u, Yo, !0), h.forEach(x => this.finishActiveQueriedAnimationOnElement(x))) } destroyActiveAnimationsForElement(u) { const h = this.playersByElement.get(u); h && h.forEach(x => { x.queued ? x.markedForDestroy = !0 : x.destroy() }) } finishActiveQueriedAnimationOnElement(u) { const h = this.playersByQueriedElement.get(u); h && h.forEach(x => x.finish()) } whenRenderingDone() { return new Promise(u => { if (this.players.length) return Xi(this.players).onDone(() => u()); u() }) } processLeaveNode(u) { const h = u[en]; if (h && h.setForRemoval) { if (u[en] = Je, h.namespaceId) { this.destroyInnerAnimations(u); const x = this._fetchNamespace(h.namespaceId); x && x.clearElementCache(u) } this._onRemovalComplete(u, h.setForRemoval) } u.classList?.contains(Oo) && this.markElementAsDisabled(u, !1), this.driver.query(u, ".ng-animate-disabled", !0).forEach(x => { this.markElementAsDisabled(x, !1) }) } flush(u = -1) { let h = []; if (this.newHostElements.size && (this.newHostElements.forEach((x, M) => this._balanceNamespaceList(x, M)), this.newHostElements.clear()), this.totalAnimations && this.collectedEnterElements.length) for (let x = 0; x < this.collectedEnterElements.length; x++)Ur(this.collectedEnterElements[x], "ng-star-inserted"); if (this._namespaceList.length && (this.totalQueuedPlayers || this.collectedLeaveElements.length)) { const x = []; try { h = this._flushAnimations(x, u) } finally { for (let M = 0; M < x.length; M++)x[M]() } } else for (let x = 0; x < this.collectedLeaveElements.length; x++)this.processLeaveNode(this.collectedLeaveElements[x]); if (this.totalQueuedPlayers = 0, this.collectedEnterElements.length = 0, this.collectedLeaveElements.length = 0, this._flushFns.forEach(x => x()), this._flushFns = [], this._whenQuietFns.length) { const x = this._whenQuietFns; this._whenQuietFns = [], h.length ? Xi(h).onDone(() => { x.forEach(M => M()) }) : x.forEach(M => M()) } } reportError(u) { throw function cn(m) { return new v.vHH(3402, !1) }() } _flushAnimations(u, h) { const x = new ar, M = [], $ = new Map, Ee = [], je = new Map, ft = new Map, zt = new Map, xn = new Set; this.disabledNodes.forEach(oi => { xn.add(oi); const pi = this.driver.query(oi, ".ng-animate-queued", !0); for (let bi = 0; bi < pi.length; bi++)xn.add(pi[bi]) }); const An = this.bodyNode, ri = Array.from(this.statesByElement.keys()), hi = wo(ri, this.collectedEnterElements), fi = new Map; let ei = 0; hi.forEach((oi, pi) => { const bi = oo + ei++; fi.set(pi, bi), oi.forEach(vr => Ur(vr, bi)) }); const zr = [], Po = new Set, Ar = new Set; for (let oi = 0; oi < this.collectedLeaveElements.length; oi++) { const pi = this.collectedLeaveElements[oi], bi = pi[en]; bi && bi.setForRemoval && (zr.push(pi), Po.add(pi), bi.hasAnimation ? this.driver.query(pi, ".ng-star-inserted", !0).forEach(vr => Po.add(vr)) : Ar.add(pi)) } const Mo = new Map, Fr = wo(ri, Array.from(Po)); Fr.forEach((oi, pi) => { const bi = Qr + ei++; Mo.set(pi, bi), oi.forEach(vr => Ur(vr, bi)) }), u.push(() => { hi.forEach((oi, pi) => { const bi = fi.get(pi); oi.forEach(vr => Cn(vr, bi)) }), Fr.forEach((oi, pi) => { const bi = Mo.get(pi); oi.forEach(vr => Cn(vr, bi)) }), zr.forEach(oi => { this.processLeaveNode(oi) }) }); const Ja = [], oa = []; for (let oi = this._namespaceList.length - 1; oi >= 0; oi--)this._namespaceList[oi].drainQueuedTransitions(h).forEach(bi => { const vr = bi.player, Go = bi.element; if (Ja.push(vr), this.collectedEnterElements.length) { const or = Go[en]; if (or && or.setForMove) { if (or.previousTriggersValues && or.previousTriggersValues.has(bi.triggerName)) { const Is = or.previousTriggersValues.get(bi.triggerName), _o = this.statesByElement.get(bi.element); if (_o && _o.has(bi.triggerName)) { const Va = _o.get(bi.triggerName); Va.value = Is, _o.set(bi.triggerName, Va) } } return void vr.destroy() } } const Cs = !An || !this.driver.containsElement(An, Go), Hs = Mo.get(Go), No = fi.get(Go), to = this._buildInstruction(bi, x, No, Hs, Cs); if (to.errors && to.errors.length) return void oa.push(to); if (Cs) return vr.onStart(() => po(Go, to.fromStyles)), vr.onDestroy(() => Ki(Go, to.toStyles)), void M.push(vr); if (bi.isFallbackTransition) return vr.onStart(() => po(Go, to.fromStyles)), vr.onDestroy(() => Ki(Go, to.toStyles)), void M.push(vr); const Ua = []; to.timelines.forEach(or => { or.stretchStartingKeyframe = !0, this.disabledNodes.has(or.element) || Ua.push(or) }), to.timelines = Ua, x.append(Go, to.timelines), Ee.push({ instruction: to, player: vr, element: Go }), to.queriedElements.forEach(or => _i(je, or, []).push(vr)), to.preStyleProps.forEach((or, Is) => { if (or.size) { let _o = ft.get(Is); _o || ft.set(Is, _o = new Set), or.forEach((Va, ur) => _o.add(ur)) } }), to.postStyleProps.forEach((or, Is) => { let _o = zt.get(Is); _o || zt.set(Is, _o = new Set), or.forEach((Va, ur) => _o.add(ur)) }) }); if (oa.length) { const oi = []; oa.forEach(pi => { oi.push(function ii(m, u) { return new v.vHH(3505, !1) }()) }), Ja.forEach(pi => pi.destroy()), this.reportError(oi) } const Eo = new Map, ba = new Map; Ee.forEach(oi => { const pi = oi.element; x.has(pi) && (ba.set(pi, pi), this._beforeAnimationBuild(oi.player.namespaceId, oi.instruction, Eo)) }), M.forEach(oi => { const pi = oi.element; this._getPreviousPlayers(pi, !1, oi.namespaceId, oi.triggerName, null).forEach(vr => { _i(Eo, pi, []).push(vr), vr.destroy() }) }); const Ra = zr.filter(oi => _n(oi, ft, zt)), sa = new Map; er(sa, this.driver, Ar, zt, nt.l3).forEach(oi => { _n(oi, ft, zt) && Ra.push(oi) }); const aa = new Map; hi.forEach((oi, pi) => { er(aa, this.driver, new Set(oi), ft, nt.k1) }), Ra.forEach(oi => { const pi = sa.get(oi), bi = aa.get(oi); sa.set(oi, new Map([...pi?.entries() ?? [], ...bi?.entries() ?? []])) }); const ya = [], el = [], Pl = {}; Ee.forEach(oi => { const { element: pi, player: bi, instruction: vr } = oi; if (x.has(pi)) { if (xn.has(pi)) return bi.onDestroy(() => Ki(pi, vr.toStyles)), bi.disabled = !0, bi.overrideTotalTime(vr.totalTime), void M.push(bi); let Go = Pl; if (ba.size > 1) { let Hs = pi; const No = []; for (; Hs = Hs.parentNode;) { const to = ba.get(Hs); if (to) { Go = to; break } No.push(Hs) } No.forEach(to => ba.set(to, Go)) } const Cs = this._buildAnimation(bi.namespaceId, vr, Eo, $, aa, sa); if (bi.setRealPlayer(Cs), Go === Pl) ya.push(bi); else { const Hs = this.playersByElement.get(Go); Hs && Hs.length && (bi.parentPlayer = Xi(Hs)), M.push(bi) } } else po(pi, vr.fromStyles), bi.onDestroy(() => Ki(pi, vr.toStyles)), el.push(bi), xn.has(pi) && M.push(bi) }), el.forEach(oi => { const pi = $.get(oi.element); if (pi && pi.length) { const bi = Xi(pi); oi.setRealPlayer(bi) } }), M.forEach(oi => { oi.parentPlayer ? oi.syncPlayerEvents(oi.parentPlayer) : oi.destroy() }); for (let oi = 0; oi < zr.length; oi++) { const pi = zr[oi], bi = pi[en]; if (Cn(pi, Qr), bi && bi.hasAnimation) continue; let vr = []; if (je.size) { let Cs = je.get(pi); Cs && Cs.length && vr.push(...Cs); let Hs = this.driver.query(pi, Yo, !0); for (let No = 0; No < Hs.length; No++) { let to = je.get(Hs[No]); to && to.length && vr.push(...to) } } const Go = vr.filter(Cs => !Cs.destroyed); Go.length ? ai(this, pi, Go) : this.processLeaveNode(pi) } return zr.length = 0, ya.forEach(oi => { this.players.push(oi), oi.onDone(() => { oi.destroy(); const pi = this.players.indexOf(oi); this.players.splice(pi, 1) }), oi.play() }), ya } elementContainsData(u, h) { let x = !1; const M = h[en]; return M && M.setForRemoval && (x = !0), this.playersByElement.has(h) && (x = !0), this.playersByQueriedElement.has(h) && (x = !0), this.statesByElement.has(h) && (x = !0), this._fetchNamespace(u).elementContainsData(h) || x } afterFlush(u) { this._flushFns.push(u) } afterFlushAnimationsDone(u) { this._whenQuietFns.push(u) } _getPreviousPlayers(u, h, x, M, $) { let Ee = []; if (h) { const je = this.playersByQueriedElement.get(u); je && (Ee = je) } else { const je = this.playersByElement.get(u); if (je) { const ft = !$ || $ == Ji; je.forEach(zt => { zt.queued || !ft && zt.triggerName != M || Ee.push(zt) }) } } return (x || M) && (Ee = Ee.filter(je => !(x && x != je.namespaceId || M && M != je.triggerName))), Ee } _beforeAnimationBuild(u, h, x) { const $ = h.element, Ee = h.isRemovalTransition ? void 0 : u, je = h.isRemovalTransition ? void 0 : h.triggerName; for (const ft of h.timelines) { const zt = ft.element, xn = zt !== $, An = _i(x, zt, []); this._getPreviousPlayers(zt, xn, Ee, je, h.toState).forEach(hi => { const fi = hi.getRealPlayer(); fi.beforeDestroy && fi.beforeDestroy(), hi.destroy(), An.push(hi) }) } po($, h.fromStyles) } _buildAnimation(u, h, x, M, $, Ee) { const je = h.triggerName, ft = h.element, zt = [], xn = new Set, An = new Set, ri = h.timelines.map(fi => { const ei = fi.element; xn.add(ei); const zr = ei[en]; if (zr && zr.removedBeforeQueried) return new nt.ZN(fi.duration, fi.delay); const Po = ei !== ft, Ar = function co(m) { const u = []; return Un(m, u), u }((x.get(ei) || be).map(Eo => Eo.getRealPlayer())).filter(Eo => !!Eo.element && Eo.element === ei), Mo = $.get(ei), Fr = Ee.get(ei), Ja = Dr(this._normalizer, fi.keyframes, Mo, Fr), oa = this._buildPlayer(fi, Ja, Ar); if (fi.subTimeline && M && An.add(ei), Po) { const Eo = new Di(u, je, ei); Eo.setRealPlayer(oa), zt.push(Eo) } return oa }); zt.forEach(fi => { _i(this.playersByQueriedElement, fi.element, []).push(fi), fi.onDone(() => function qi(m, u, h) { let x = m.get(u); if (x) { if (x.length) { const M = x.indexOf(h); x.splice(M, 1) } 0 == x.length && m.delete(u) } return x }(this.playersByQueriedElement, fi.element, fi)) }), xn.forEach(fi => Ur(fi, Br)); const hi = Xi(ri); return hi.onDestroy(() => { xn.forEach(fi => Cn(fi, Br)), Ki(ft, h.toStyles) }), An.forEach(fi => { _i(M, fi, []).push(hi) }), hi } _buildPlayer(u, h, x) { return h.length > 0 ? this.driver.animate(u.element, h, u.duration, u.delay, u.easing, x) : new nt.ZN(u.duration, u.delay) } } class Di { constructor(u, h, x) { this.namespaceId = u, this.triggerName = h, this.element = x, this._player = new nt.ZN, this._containsRealPlayer = !1, this._queuedCallbacks = new Map, this.destroyed = !1, this.parentPlayer = null, this.markedForDestroy = !1, this.disabled = !1, this.queued = !0, this.totalTime = 0 } setRealPlayer(u) { this._containsRealPlayer || (this._player = u, this._queuedCallbacks.forEach((h, x) => { h.forEach(M => xr(u, x, void 0, M)) }), this._queuedCallbacks.clear(), this._containsRealPlayer = !0, this.overrideTotalTime(u.totalTime), this.queued = !1) } getRealPlayer() { return this._player } overrideTotalTime(u) { this.totalTime = u } syncPlayerEvents(u) { const h = this._player; h.triggerCallback && u.onStart(() => h.triggerCallback("start")), u.onDone(() => this.finish()), u.onDestroy(() => this.destroy()) } _queueEvent(u, h) { _i(this._queuedCallbacks, u, []).push(h) } onDone(u) { this.queued && this._queueEvent("done", u), this._player.onDone(u) } onStart(u) { this.queued && this._queueEvent("start", u), this._player.onStart(u) } onDestroy(u) { this.queued && this._queueEvent("destroy", u), this._player.onDestroy(u) } init() { this._player.init() } hasStarted() { return !this.queued && this._player.hasStarted() } play() { !this.queued && this._player.play() } pause() { !this.queued && this._player.pause() } restart() { !this.queued && this._player.restart() } finish() { this._player.finish() } destroy() { this.destroyed = !0, this._player.destroy() } reset() { !this.queued && this._player.reset() } setPosition(u) { this.queued || this._player.setPosition(u) } getPosition() { return this.queued ? 0 : this._player.getPosition() } triggerCallback(u) { const h = this._player; h.triggerCallback && h.triggerCallback(u) } } function lr(m) { return m && 1 === m.nodeType } function pn(m, u) { const h = m.style.display; return m.style.display = u ?? "none", h } function er(m, u, h, x, M) { const $ = []; h.forEach(ft => $.push(pn(ft))); const Ee = []; x.forEach((ft, zt) => { const xn = new Map; ft.forEach(An => { const ri = u.computeStyle(zt, An, M); xn.set(An, ri), (!ri || 0 == ri.length) && (zt[en] = $t, Ee.push(zt)) }), m.set(zt, xn) }); let je = 0; return h.forEach(ft => pn(ft, $[je++])), Ee } function wo(m, u) { const h = new Map; if (m.forEach(je => h.set(je, [])), 0 == u.length) return h; const M = new Set(u), $ = new Map; function Ee(je) { if (!je) return 1; let ft = $.get(je); if (ft) return ft; const zt = je.parentNode; return ft = h.has(zt) ? zt : M.has(zt) ? 1 : Ee(zt), $.set(je, ft), ft } return u.forEach(je => { const ft = Ee(je); 1 !== ft && h.get(ft).push(je) }), h } function Ur(m, u) { m.classList?.add(u) } function Cn(m, u) { m.classList?.remove(u) } function ai(m, u, h) { Xi(h).onDone(() => m.processLeaveNode(u)) } function Un(m, u) { for (let h = 0; h < m.length; h++) { const x = m[h]; x instanceof nt.ZE ? Un(x.players, u) : u.push(x) } } function _n(m, u, h) { const x = h.get(m); if (!x) return !1; let M = u.get(m); return M ? x.forEach($ => M.add($)) : u.set(m, x), h.delete(m), !0 } class eo { constructor(u, h, x) { this.bodyNode = u, this._driver = h, this._normalizer = x, this._triggerCache = {}, this.onRemovalComplete = (M, $) => { }, this._transitionEngine = new Fi(u, h, x), this._timelineEngine = new Os(u, h, x), this._transitionEngine.onRemovalComplete = (M, $) => this.onRemovalComplete(M, $) } registerTrigger(u, h, x, M, $) { const Ee = u + "-" + M; let je = this._triggerCache[Ee]; if (!je) { const ft = [], xn = mt(this._driver, $, ft, []); if (ft.length) throw function bt(m, u) { return new v.vHH(3404, !1) }(); je = function ms(m, u, h) { return new ts(m, u, h) }(M, xn, this._normalizer), this._triggerCache[Ee] = je } this._transitionEngine.registerTrigger(h, M, je) } register(u, h) { this._transitionEngine.register(u, h) } destroy(u, h) { this._transitionEngine.destroy(u, h) } onInsert(u, h, x, M) { this._transitionEngine.insertNode(u, h, x, M) } onRemove(u, h, x) { this._transitionEngine.removeNode(u, h, x) } disableAnimations(u, h) { this._transitionEngine.markElementAsDisabled(u, h) } process(u, h, x, M) { if ("@" == x.charAt(0)) { const [$, Ee] = Sn(x); this._timelineEngine.command($, h, Ee, M) } else this._transitionEngine.trigger(u, h, x, M) } listen(u, h, x, M, $) { if ("@" == x.charAt(0)) { const [Ee, je] = Sn(x); return this._timelineEngine.listen(Ee, h, je, $) } return this._transitionEngine.listen(u, h, x, M, $) } flush(u = -1) { this._transitionEngine.flush(u) } get players() { return [...this._transitionEngine.players, ...this._timelineEngine.players] } whenRenderingDone() { return this._transitionEngine.whenRenderingDone() } afterFlushAnimationsDone(u) { this._transitionEngine.afterFlushAnimationsDone(u) } } let vn = (() => { class m { constructor(h, x, M) { this._element = h, this._startStyles = x, this._endStyles = M, this._state = 0; let $ = m.initialStylesByElement.get(h); $ || m.initialStylesByElement.set(h, $ = new Map), this._initialStyles = $ } start() { this._state < 1 && (this._startStyles && Ki(this._element, this._startStyles, this._initialStyles), this._state = 1) } finish() { this.start(), this._state < 2 && (Ki(this._element, this._initialStyles), this._endStyles && (Ki(this._element, this._endStyles), this._endStyles = null), this._state = 1) } destroy() { this.finish(), this._state < 3 && (m.initialStylesByElement.delete(this._element), this._startStyles && (po(this._element, this._startStyles), this._endStyles = null), this._endStyles && (po(this._element, this._endStyles), this._endStyles = null), Ki(this._element, this._initialStyles), this._state = 3) } } return m.initialStylesByElement = new WeakMap, m })(); function $i(m) { let u = null; return m.forEach((h, x) => { (function Cl(m) { return "display" === m || "position" === m })(x) && (u = u || new Map, u.set(x, h)) }), u } class al { constructor(u, h, x, M) { this.element = u, this.keyframes = h, this.options = x, this._specialStyles = M, this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._initialized = !1, this._finished = !1, this._started = !1, this._destroyed = !1, this._originalOnDoneFns = [], this._originalOnStartFns = [], this.time = 0, this.parentPlayer = null, this.currentSnapshot = new Map, this._duration = x.duration, this._delay = x.delay || 0, this.time = this._duration + this._delay } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(u => u()), this._onDoneFns = []) } init() { this._buildPlayer(), this._preparePlayerBeforeStart() } _buildPlayer() { if (this._initialized) return; this._initialized = !0; const u = this.keyframes; this.domPlayer = this._triggerWebAnimation(this.element, u, this.options), this._finalKeyframe = u.length ? u[u.length - 1] : new Map, this.domPlayer.addEventListener("finish", () => this._onFinish()) } _preparePlayerBeforeStart() { this._delay ? this._resetDomPlayerState() : this.domPlayer.pause() } _convertKeyframesToObject(u) { const h = []; return u.forEach(x => { h.push(Object.fromEntries(x)) }), h } _triggerWebAnimation(u, h, x) { return u.animate(this._convertKeyframesToObject(h), x) } onStart(u) { this._originalOnStartFns.push(u), this._onStartFns.push(u) } onDone(u) { this._originalOnDoneFns.push(u), this._onDoneFns.push(u) } onDestroy(u) { this._onDestroyFns.push(u) } play() { this._buildPlayer(), this.hasStarted() || (this._onStartFns.forEach(u => u()), this._onStartFns = [], this._started = !0, this._specialStyles && this._specialStyles.start()), this.domPlayer.play() } pause() { this.init(), this.domPlayer.pause() } finish() { this.init(), this._specialStyles && this._specialStyles.finish(), this._onFinish(), this.domPlayer.finish() } reset() { this._resetDomPlayerState(), this._destroyed = !1, this._finished = !1, this._started = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns } _resetDomPlayerState() { this.domPlayer && this.domPlayer.cancel() } restart() { this.reset(), this.play() } hasStarted() { return this._started } destroy() { this._destroyed || (this._destroyed = !0, this._resetDomPlayerState(), this._onFinish(), this._specialStyles && this._specialStyles.destroy(), this._onDestroyFns.forEach(u => u()), this._onDestroyFns = []) } setPosition(u) { void 0 === this.domPlayer && this.init(), this.domPlayer.currentTime = u * this.time } getPosition() { return this.domPlayer.currentTime / this.time } get totalTime() { return this._delay + this._duration } beforeDestroy() { const u = new Map; this.hasStarted() && this._finalKeyframe.forEach((x, M) => { "offset" !== M && u.set(M, this._finished ? x : ys(this.element, M)) }), this.currentSnapshot = u } triggerCallback(u) { const h = "start" === u ? this._onStartFns : this._onDoneFns; h.forEach(x => x()), h.length = 0 } } class xo { validateStyleProperty(u) { return !0 } validateAnimatableStyleProperty(u) { return !0 } matchesElement(u, h) { return !1 } containsElement(u, h) { return ro(u, h) } getParentElement(u) { return ki(u) } query(u, h, x) { return Xn(u, h, x) } computeStyle(u, h, x) { return window.getComputedStyle(u)[h] } animate(u, h, x, M, $, Ee = []) { const ft = { duration: x, delay: M, fill: 0 == M ? "both" : "forwards" }; $ && (ft.easing = $); const zt = new Map, xn = Ee.filter(hi => hi instanceof al); (function bs(m, u) { return 0 === m || 0 === u })(x, M) && xn.forEach(hi => { hi.currentSnapshot.forEach((fi, ei) => zt.set(ei, fi)) }); let An = function zo(m) { return m.length ? m[0] instanceof Map ? m : m.map(u => yo(u)) : [] }(h).map(hi => br(hi)); An = function ta(m, u, h) { if (h.size && u.length) { let x = u[0], M = []; if (h.forEach(($, Ee) => { x.has(Ee) || M.push(Ee), x.set(Ee, $) }), M.length) for (let $ = 1; $ < u.length; $++) { let Ee = u[$]; M.forEach(je => Ee.set(je, ys(m, je))) } } return u }(u, An, zt); const ri = function Us(m, u) { let h = null, x = null; return Array.isArray(u) && u.length ? (h = $i(u[0]), u.length > 1 && (x = $i(u[u.length - 1]))) : u instanceof Map && (h = $i(u)), h || x ? new vn(m, h, x) : null }(u, An); return new al(u, An, ft, ri) } } let qa = (() => { class m extends nt._j { constructor(h, x) { super(), this._nextAnimationId = 0, this._renderer = h.createRenderer(x.body, { id: "0", encapsulation: v.ifc.None, styles: [], data: { animation: [] } }) } build(h) { const x = this._nextAnimationId.toString(); this._nextAnimationId++; const M = Array.isArray(h) ? (0, nt.vP)(h) : h; return Qa(this._renderer, null, x, "register", [M]), new ga(x, this._renderer) } } return m.\u0275fac = function (h) { return new (h || m)(v.LFG(v.FYo), v.LFG(he.K0)) }, m.\u0275prov = v.Yz7({ token: m, factory: m.\u0275fac }), m })(); class ga extends nt.LC { constructor(u, h) { super(), this._id = u, this._renderer = h } create(u, h) { return new ps(this._id, u, h || {}, this._renderer) } } class ps { constructor(u, h, x, M) { this.id = u, this.element = h, this._renderer = M, this.parentPlayer = null, this._started = !1, this.totalTime = 0, this._command("create", x) } _listen(u, h) { return this._renderer.listen(this.element, `@@${this.id}:${u}`, h) } _command(u, ...h) { return Qa(this._renderer, this.element, this.id, u, h) } onDone(u) { this._listen("done", u) } onStart(u) { this._listen("start", u) } onDestroy(u) { this._listen("destroy", u) } init() { this._command("init") } hasStarted() { return this._started } play() { this._command("play"), this._started = !0 } pause() { this._command("pause") } restart() { this._command("restart") } finish() { this._command("finish") } destroy() { this._command("destroy") } reset() { this._command("reset"), this._started = !1 } setPosition(u) { this._command("setPosition", u) } getPosition() { return this._renderer.engine.players[+this.id]?.getPosition() ?? 0 } } function Qa(m, u, h, x, M) { return m.setProperty(u, `@@${h}:${x}`, M) } const Ei = "@.disabled"; let _a = (() => { class m { constructor(h, x, M) { this.delegate = h, this.engine = x, this._zone = M, this._currentId = 0, this._microtaskId = 1, this._animationCallbacksBuffer = [], this._rendererCache = new Map, this._cdRecurDepth = 0, x.onRemovalComplete = ($, Ee) => { const je = Ee?.parentNode($); je && Ee.removeChild(je, $) } } createRenderer(h, x) { const $ = this.delegate.createRenderer(h, x); if (!(h && x && x.data && x.data.animation)) { let xn = this._rendererCache.get($); return xn || (xn = new ll("", $, this.engine, () => this._rendererCache.delete($)), this._rendererCache.set($, xn)), xn } const Ee = x.id, je = x.id + "-" + this._currentId; this._currentId++, this.engine.register(je, h); const ft = xn => { Array.isArray(xn) ? xn.forEach(ft) : this.engine.registerTrigger(Ee, je, h, xn.name, xn) }; return x.data.animation.forEach(ft), new Ri(this, je, $, this.engine) } begin() { this._cdRecurDepth++, this.delegate.begin && this.delegate.begin() } _scheduleCountTask() { queueMicrotask(() => { this._microtaskId++ }) } scheduleListenerCallback(h, x, M) { h >= 0 && h < this._microtaskId ? this._zone.run(() => x(M)) : (0 == this._animationCallbacksBuffer.length && queueMicrotask(() => { this._zone.run(() => { this._animationCallbacksBuffer.forEach($ => { const [Ee, je] = $; Ee(je) }), this._animationCallbacksBuffer = [] }) }), this._animationCallbacksBuffer.push([x, M])) } end() { this._cdRecurDepth--, 0 == this._cdRecurDepth && this._zone.runOutsideAngular(() => { this._scheduleCountTask(), this.engine.flush(this._microtaskId) }), this.delegate.end && this.delegate.end() } whenRenderingDone() { return this.engine.whenRenderingDone() } } return m.\u0275fac = function (h) { return new (h || m)(v.LFG(v.FYo), v.LFG(eo), v.LFG(v.R0b)) }, m.\u0275prov = v.Yz7({ token: m, factory: m.\u0275fac }), m })(); class ll { constructor(u, h, x, M) { this.namespaceId = u, this.delegate = h, this.engine = x, this._onDestroy = M } get data() { return this.delegate.data } destroyNode(u) { this.delegate.destroyNode?.(u) } destroy() { this.engine.destroy(this.namespaceId, this.delegate), this.engine.afterFlushAnimationsDone(() => { queueMicrotask(() => { this.delegate.destroy() }) }), this._onDestroy?.() } createElement(u, h) { return this.delegate.createElement(u, h) } createComment(u) { return this.delegate.createComment(u) } createText(u) { return this.delegate.createText(u) } appendChild(u, h) { this.delegate.appendChild(u, h), this.engine.onInsert(this.namespaceId, h, u, !1) } insertBefore(u, h, x, M = !0) { this.delegate.insertBefore(u, h, x), this.engine.onInsert(this.namespaceId, h, u, M) } removeChild(u, h, x) { this.engine.onRemove(this.namespaceId, h, this.delegate) } selectRootElement(u, h) { return this.delegate.selectRootElement(u, h) } parentNode(u) { return this.delegate.parentNode(u) } nextSibling(u) { return this.delegate.nextSibling(u) } setAttribute(u, h, x, M) { this.delegate.setAttribute(u, h, x, M) } removeAttribute(u, h, x) { this.delegate.removeAttribute(u, h, x) } addClass(u, h) { this.delegate.addClass(u, h) } removeClass(u, h) { this.delegate.removeClass(u, h) } setStyle(u, h, x, M) { this.delegate.setStyle(u, h, x, M) } removeStyle(u, h, x) { this.delegate.removeStyle(u, h, x) } setProperty(u, h, x) { "@" == h.charAt(0) && h == Ei ? this.disableAnimations(u, !!x) : this.delegate.setProperty(u, h, x) } setValue(u, h) { this.delegate.setValue(u, h) } listen(u, h, x) { return this.delegate.listen(u, h, x) } disableAnimations(u, h) { this.engine.disableAnimations(u, h) } } class Ri extends ll { constructor(u, h, x, M, $) { super(h, x, M, $), this.factory = u, this.namespaceId = h } setProperty(u, h, x) { "@" == h.charAt(0) ? "." == h.charAt(1) && h == Ei ? this.disableAnimations(u, x = void 0 === x || !!x) : this.engine.process(this.namespaceId, u, h.slice(1), x) : this.delegate.setProperty(u, h, x) } listen(u, h, x) { if ("@" == h.charAt(0)) { const M = function Jn(m) { switch (m) { case "body": return document.body; case "document": return document; case "window": return window; default: return m } }(u); let $ = h.slice(1), Ee = ""; return "@" != $.charAt(0) && ([$, Ee] = function ra(m) { const u = m.indexOf("."); return [m.substring(0, u), m.slice(u + 1)] }($)), this.engine.listen(this.namespaceId, M, $, Ee, je => { this.factory.scheduleListenerCallback(je._data || -1, x, je) }) } return this.delegate.listen(u, h, x) } } const Bn = [{ provide: nt._j, useClass: qa }, { provide: fs, useFactory: function Es() { return new ma } }, { provide: eo, useClass: (() => { class m extends eo { constructor(h, x, M, $) { super(h.body, x, M) } ngOnDestroy() { this.flush() } } return m.\u0275fac = function (h) { return new (h || m)(v.LFG(he.K0), v.LFG(ko), v.LFG(fs), v.LFG(v.z2F)) }, m.\u0275prov = v.Yz7({ token: m, factory: m.\u0275fac }), m })() }, { provide: v.FYo, useFactory: function Hr(m, u, h) { return new _a(m, u, h) }, deps: [a.se, eo, v.R0b] }], Vs = [{ provide: ko, useFactory: () => new xo }, { provide: v.QbO, useValue: "BrowserAnimations" }, ...Bn], Zs = [{ provide: ko, useClass: Ao }, { provide: v.QbO, useValue: "NoopAnimations" }, ...Bn]; let Ys = (() => { class m { static withConfig(h) { return { ngModule: m, providers: h.disableAnimations ? Zs : Vs } } } return m.\u0275fac = function (h) { return new (h || m) }, m.\u0275mod = v.oAB({ type: m }), m.\u0275inj = v.cJS({ providers: Vs, imports: [a.b2] }), m })(); var ka = C(2032), va = C(4170), Xa = C(2365), ns = C(7700), cl = C(4104), dl = C(5195), ul = C(2651), Ps = C(1919), S = C(6009); let I = (() => { class m { } return m.\u0275fac = function (h) { return new (h || m) }, m.\u0275mod = v.oAB({ type: m, bootstrap: [fe] }), m.\u0275inj = v.cJS({ providers: [Y.e, Xa.O, { provide: un.Dh, useValue: J.N.firebase }], imports: [a.b2, Ye, (0, F.hX)(() => (0, F.ZF)(J.N.firebase)), (0, Te.AR)(() => (0, Te.v0)()), (0, gt.Cm)(() => (0, gt.ad)()), Ht.u5, Ht.UX, ka.c, va.lN, Ys, lt.ww, ns.Is, Se.ot, cl.Nh, dl.QW, ul.SJ, ut.g0, ie.Ps, Ps.ie, S.g, He] }), m })(); a.q6().bootstrapModule(I).catch(m => console.error(m)) }, 5619: (nn, Qe, C) => { C.d(Qe, { X: () => y }); var a = C(8645); class y extends a.x { constructor(Y) { super(), this._value = Y } get value() { return this.getValue() } _subscribe(Y) { const he = super._subscribe(Y); return !he.closed && Y.next(this._value), he } getValue() { const { hasError: Y, thrownError: he, _value: Se } = this; if (Y) throw he; return this._throwIfClosed(), Se } next(Y) { super.next(this._value = Y) } } }, 5592: (nn, Qe, C) => { C.d(Qe, { y: () => re }); var a = C(305), y = C(7394), v = C(4850), Y = C(8407), he = C(2653), Se = C(4674), ke = C(1441); let re = (() => { class xe { constructor(Oe) { Oe && (this._subscribe = Oe) } lift(Oe) { const We = new xe; return We.source = this, We.operator = Oe, We } subscribe(Oe, We, Pe) { const Ve = function _e(xe) { return xe && xe instanceof a.Lv || function Q(xe) { return xe && (0, Se.m)(xe.next) && (0, Se.m)(xe.error) && (0, Se.m)(xe.complete) }(xe) && (0, y.Nn)(xe) }(Oe) ? Oe : new a.Hp(Oe, We, Pe); return (0, ke.x)(() => { const { operator: tt, source: Ye } = this; Ve.add(tt ? tt.call(Ve, Ye) : Ye ? this._subscribe(Ve) : this._trySubscribe(Ve)) }), Ve } _trySubscribe(Oe) { try { return this._subscribe(Oe) } catch (We) { Oe.error(We) } } forEach(Oe, We) { return new (We = Ie(We))((Pe, Ve) => { const tt = new a.Hp({ next: Ye => { try { Oe(Ye) } catch (ut) { Ve(ut), tt.unsubscribe() } }, error: Ve, complete: Pe }); this.subscribe(tt) }) } _subscribe(Oe) { var We; return null === (We = this.source) || void 0 === We ? void 0 : We.subscribe(Oe) } [v.L]() { return this } pipe(...Oe) { return (0, Y.U)(Oe)(this) } toPromise(Oe) { return new (Oe = Ie(Oe))((We, Pe) => { let Ve; this.subscribe(tt => Ve = tt, tt => Pe(tt), () => We(Ve)) }) } } return xe.create = ze => new xe(ze), xe })(); function Ie(xe) { var ze; return null !== (ze = xe ?? he.config.Promise) && void 0 !== ze ? ze : Promise } }, 7328: (nn, Qe, C) => { C.d(Qe, { t: () => v }); var a = C(8645), y = C(4552); class v extends a.x { constructor(he = 1 / 0, Se = 1 / 0, ke = y.l) { super(), this._bufferSize = he, this._windowTime = Se, this._timestampProvider = ke, this._buffer = [], this._infiniteTimeWindow = !0, this._infiniteTimeWindow = Se === 1 / 0, this._bufferSize = Math.max(1, he), this._windowTime = Math.max(1, Se) } next(he) { const { isStopped: Se, _buffer: ke, _infiniteTimeWindow: re, _timestampProvider: Ie, _windowTime: Q } = this; Se || (ke.push(he), !re && ke.push(Ie.now() + Q)), this._trimBuffer(), super.next(he) } _subscribe(he) { this._throwIfClosed(), this._trimBuffer(); const Se = this._innerSubscribe(he), { _infiniteTimeWindow: ke, _buffer: re } = this, Ie = re.slice(); for (let Q = 0; Q < Ie.length && !he.closed; Q += ke ? 1 : 2)he.next(Ie[Q]); return this._checkFinalizedStatuses(he), Se } _trimBuffer() { const { _bufferSize: he, _timestampProvider: Se, _buffer: ke, _infiniteTimeWindow: re } = this, Ie = (re ? 1 : 2) * he; if (he < 1 / 0 && Ie < ke.length && ke.splice(0, ke.length - Ie), !re) { const Q = Se.now(); let _e = 0; for (let xe = 1; xe < ke.length && ke[xe] <= Q; xe += 2)_e = xe; _e && ke.splice(0, _e + 1) } } } }, 8645: (nn, Qe, C) => { C.d(Qe, { x: () => ke }); var a = C(5592), y = C(7394); const Y = (0, C(2306).d)(Ie => function () { Ie(this), this.name = "ObjectUnsubscribedError", this.message = "object unsubscribed" }); var he = C(9039), Se = C(1441); let ke = (() => { class Ie extends a.y { constructor() { super(), this.closed = !1, this.currentObservers = null, this.observers = [], this.isStopped = !1, this.hasError = !1, this.thrownError = null } lift(_e) { const xe = new re(this, this); return xe.operator = _e, xe } _throwIfClosed() { if (this.closed) throw new Y } next(_e) { (0, Se.x)(() => { if (this._throwIfClosed(), !this.isStopped) { this.currentObservers || (this.currentObservers = Array.from(this.observers)); for (const xe of this.currentObservers) xe.next(_e) } }) } error(_e) { (0, Se.x)(() => { if (this._throwIfClosed(), !this.isStopped) { this.hasError = this.isStopped = !0, this.thrownError = _e; const { observers: xe } = this; for (; xe.length;)xe.shift().error(_e) } }) } complete() { (0, Se.x)(() => { if (this._throwIfClosed(), !this.isStopped) { this.isStopped = !0; const { observers: _e } = this; for (; _e.length;)_e.shift().complete() } }) } unsubscribe() { this.isStopped = this.closed = !0, this.observers = this.currentObservers = null } get observed() { var _e; return (null === (_e = this.observers) || void 0 === _e ? void 0 : _e.length) > 0 } _trySubscribe(_e) { return this._throwIfClosed(), super._trySubscribe(_e) } _subscribe(_e) { return this._throwIfClosed(), this._checkFinalizedStatuses(_e), this._innerSubscribe(_e) } _innerSubscribe(_e) { const { hasError: xe, isStopped: ze, observers: Oe } = this; return xe || ze ? y.Lc : (this.currentObservers = null, Oe.push(_e), new y.w0(() => { this.currentObservers = null, (0, he.P)(Oe, _e) })) } _checkFinalizedStatuses(_e) { const { hasError: xe, thrownError: ze, isStopped: Oe } = this; xe ? _e.error(ze) : Oe && _e.complete() } asObservable() { const _e = new a.y; return _e.source = this, _e } } return Ie.create = (Q, _e) => new re(Q, _e), Ie })(); class re extends ke { constructor(Q, _e) { super(), this.destination = Q, this.source = _e } next(Q) { var _e, xe; null === (xe = null === (_e = this.destination) || void 0 === _e ? void 0 : _e.next) || void 0 === xe || xe.call(_e, Q) } error(Q) { var _e, xe; null === (xe = null === (_e = this.destination) || void 0 === _e ? void 0 : _e.error) || void 0 === xe || xe.call(_e, Q) } complete() { var Q, _e; null === (_e = null === (Q = this.destination) || void 0 === Q ? void 0 : Q.complete) || void 0 === _e || _e.call(Q) } _subscribe(Q) { var _e, xe; return null !== (xe = null === (_e = this.source) || void 0 === _e ? void 0 : _e.subscribe(Q)) && void 0 !== xe ? xe : y.Lc } } }, 305: (nn, Qe, C) => { C.d(Qe, { Hp: () => Pe, Lv: () => xe }); var a = C(4674), y = C(7394), v = C(2653), Y = C(3894), he = C(2420); const Se = Ie("C", void 0, void 0); function Ie(ie, Le, le) { return { kind: ie, value: Le, error: le } } var Q = C(7599), _e = C(1441); class xe extends y.w0 { constructor(Le) { super(), this.isStopped = !1, Le ? (this.destination = Le, (0, y.Nn)(Le) && Le.add(this)) : this.destination = ut } static create(Le, le, ge) { return new Pe(Le, le, ge) } next(Le) { this.isStopped ? Ye(function re(ie) { return Ie("N", ie, void 0) }(Le), this) : this._next(Le) } error(Le) { this.isStopped ? Ye(function ke(ie) { return Ie("E", void 0, ie) }(Le), this) : (this.isStopped = !0, this._error(Le)) } complete() { this.isStopped ? Ye(Se, this) : (this.isStopped = !0, this._complete()) } unsubscribe() { this.closed || (this.isStopped = !0, super.unsubscribe(), this.destination = null) } _next(Le) { this.destination.next(Le) } _error(Le) { try { this.destination.error(Le) } finally { this.unsubscribe() } } _complete() { try { this.destination.complete() } finally { this.unsubscribe() } } } const ze = Function.prototype.bind; function Oe(ie, Le) { return ze.call(ie, Le) } class We { constructor(Le) { this.partialObserver = Le } next(Le) { const { partialObserver: le } = this; if (le.next) try { le.next(Le) } catch (ge) { Ve(ge) } } error(Le) { const { partialObserver: le } = this; if (le.error) try { le.error(Le) } catch (ge) { Ve(ge) } else Ve(Le) } complete() { const { partialObserver: Le } = this; if (Le.complete) try { Le.complete() } catch (le) { Ve(le) } } } class Pe extends xe { constructor(Le, le, ge) { let ue; if (super(), (0, a.m)(Le) || !Le) ue = { next: Le ?? void 0, error: le ?? void 0, complete: ge ?? void 0 }; else { let ee; this && v.config.useDeprecatedNextContext ? (ee = Object.create(Le), ee.unsubscribe = () => this.unsubscribe(), ue = { next: Le.next && Oe(Le.next, ee), error: Le.error && Oe(Le.error, ee), complete: Le.complete && Oe(Le.complete, ee) }) : ue = Le } this.destination = new We(ue) } } function Ve(ie) { v.config.useDeprecatedSynchronousErrorHandling ? (0, _e.O)(ie) : (0, Y.h)(ie) } function Ye(ie, Le) { const { onStoppedNotification: le } = v.config; le && Q.z.setTimeout(() => le(ie, Le)) } const ut = { closed: !0, next: he.Z, error: function tt(ie) { throw ie }, complete: he.Z } }, 7394: (nn, Qe, C) => { C.d(Qe, { Lc: () => Se, w0: () => he, Nn: () => ke }); var a = C(4674); const v = (0, C(2306).d)(Ie => function (_e) { Ie(this), this.message = _e ? `${_e.length} errors occurred during unsubscription:\n${_e.map((xe, ze) => `${ze + 1}) ${xe.toString()}`).join("\n  ")}` : "", this.name = "UnsubscriptionError", this.errors = _e }); var Y = C(9039); class he { constructor(Q) { this.initialTeardown = Q, this.closed = !1, this._parentage = null, this._finalizers = null } unsubscribe() { let Q; if (!this.closed) { this.closed = !0; const { _parentage: _e } = this; if (_e) if (this._parentage = null, Array.isArray(_e)) for (const Oe of _e) Oe.remove(this); else _e.remove(this); const { initialTeardown: xe } = this; if ((0, a.m)(xe)) try { xe() } catch (Oe) { Q = Oe instanceof v ? Oe.errors : [Oe] } const { _finalizers: ze } = this; if (ze) { this._finalizers = null; for (const Oe of ze) try { re(Oe) } catch (We) { Q = Q ?? [], We instanceof v ? Q = [...Q, ...We.errors] : Q.push(We) } } if (Q) throw new v(Q) } } add(Q) { var _e; if (Q && Q !== this) if (this.closed) re(Q); else { if (Q instanceof he) { if (Q.closed || Q._hasParent(this)) return; Q._addParent(this) } (this._finalizers = null !== (_e = this._finalizers) && void 0 !== _e ? _e : []).push(Q) } } _hasParent(Q) { const { _parentage: _e } = this; return _e === Q || Array.isArray(_e) && _e.includes(Q) } _addParent(Q) { const { _parentage: _e } = this; this._parentage = Array.isArray(_e) ? (_e.push(Q), _e) : _e ? [_e, Q] : Q } _removeParent(Q) { const { _parentage: _e } = this; _e === Q ? this._parentage = null : Array.isArray(_e) && (0, Y.P)(_e, Q) } remove(Q) { const { _finalizers: _e } = this; _e && (0, Y.P)(_e, Q), Q instanceof he && Q._removeParent(this) } } he.EMPTY = (() => { const Ie = new he; return Ie.closed = !0, Ie })(); const Se = he.EMPTY; function ke(Ie) { return Ie instanceof he || Ie && "closed" in Ie && (0, a.m)(Ie.remove) && (0, a.m)(Ie.add) && (0, a.m)(Ie.unsubscribe) } function re(Ie) { (0, a.m)(Ie) ? Ie() : Ie.unsubscribe() } }, 2653: (nn, Qe, C) => { C.d(Qe, { config: () => a }); const a = { onUnhandledError: null, onStoppedNotification: null, Promise: void 0, useDeprecatedSynchronousErrorHandling: !1, useDeprecatedNextContext: !1 } }, 3168: (nn, Qe, C) => { C.d(Qe, { c: () => Se }); var a = C(5592), y = C(7394), v = C(6196), Y = C(8251), he = C(9360); class Se extends a.y { constructor(re, Ie) { super(), this.source = re, this.subjectFactory = Ie, this._subject = null, this._refCount = 0, this._connection = null, (0, he.A)(re) && (this.lift = re.lift) } _subscribe(re) { return this.getSubject().subscribe(re) } getSubject() { const re = this._subject; return (!re || re.isStopped) && (this._subject = this.subjectFactory()), this._subject } _teardown() { this._refCount = 0; const { _connection: re } = this; this._subject = this._connection = null, re?.unsubscribe() } connect() { let re = this._connection; if (!re) { re = this._connection = new y.w0; const Ie = this.getSubject(); re.add(this.source.subscribe((0, Y.x)(Ie, void 0, () => { this._teardown(), Ie.complete() }, Q => { this._teardown(), Ie.error(Q) }, () => this._teardown()))), re.closed && (this._connection = null, re = y.w0.EMPTY) } return re } refCount() { return (0, v.x)()(this) } } }, 2572: (nn, Qe, C) => { C.d(Qe, { a: () => Q }); var a = C(5592), y = C(7453), v = C(2459), Y = C(2737), he = C(7400), Se = C(9940), ke = C(2714), re = C(8251), Ie = C(7103); function Q(...ze) { const Oe = (0, Se.yG)(ze), We = (0, Se.jO)(ze), { args: Pe, keys: Ve } = (0, y.D)(ze); if (0 === Pe.length) return (0, v.D)([], Oe); const tt = new a.y(function _e(ze, Oe, We = Y.y) { return Pe => { xe(Oe, () => { const { length: Ve } = ze, tt = new Array(Ve); let Ye = Ve, ut = Ve; for (let ie = 0; ie < Ve; ie++)xe(Oe, () => { const Le = (0, v.D)(ze[ie], Oe); let le = !1; Le.subscribe((0, re.x)(Pe, ge => { tt[ie] = ge, le || (le = !0, ut--), ut || Pe.next(We(tt.slice())) }, () => { --Ye || Pe.complete() })) }, Pe) }, Pe) } }(Pe, Oe, Ve ? Ye => (0, ke.n)(Ve, Ye) : Y.y)); return We ? tt.pipe((0, he.Z)(We)) : tt } function xe(ze, Oe, We) { ze ? (0, Ie.f)(We, ze, Oe) : Oe() } }, 5211: (nn, Qe, C) => { C.d(Qe, { z: () => he }); var a = C(7537), v = C(9940), Y = C(2459); function he(...Se) { return function y() { return (0, a.J)(1) }()((0, Y.D)(Se, (0, v.yG)(Se))) } }, 4911: (nn, Qe, C) => { C.d(Qe, { P: () => v }); var a = C(5592), y = C(4829); function v(Y) { return new a.y(he => { (0, y.Xf)(Y()).subscribe(he) }) } }, 6232: (nn, Qe, C) => { C.d(Qe, { E: () => y }); const y = new (C(5592).y)(he => he.complete()) }, 9315: (nn, Qe, C) => { C.d(Qe, { D: () => re }); var a = C(5592), y = C(7453), v = C(4829), Y = C(9940), he = C(8251), Se = C(7400), ke = C(2714); function re(...Ie) { const Q = (0, Y.jO)(Ie), { args: _e, keys: xe } = (0, y.D)(Ie), ze = new a.y(Oe => { const { length: We } = _e; if (!We) return void Oe.complete(); const Pe = new Array(We); let Ve = We, tt = We; for (let Ye = 0; Ye < We; Ye++) { let ut = !1; (0, v.Xf)(_e[Ye]).subscribe((0, he.x)(Oe, ie => { ut || (ut = !0, tt--), Pe[Ye] = ie }, () => Ve--, void 0, () => { (!Ve || !ut) && (tt || Oe.next(xe ? (0, ke.n)(xe, Pe) : Pe), Oe.complete()) })) } }); return Q ? ze.pipe((0, Se.Z)(Q)) : ze } }, 2459: (nn, Qe, C) => { C.d(Qe, { D: () => Le }); var a = C(4829), y = C(3093), v = C(5137), Se = C(5592), re = C(4971), Ie = C(4674), Q = C(7103); function xe(le, ge) { if (!le) throw new Error("Iterable cannot be null"); return new Se.y(ue => { (0, Q.f)(ue, ge, () => { const ee = le[Symbol.asyncIterator](); (0, Q.f)(ue, ge, () => { ee.next().then($e => { $e.done ? ue.complete() : ue.next($e.value) }) }, 0, !0) }) }) } var ze = C(8382), Oe = C(4026), We = C(4266), Pe = C(3664), Ve = C(5726), tt = C(9853), Ye = C(541); function Le(le, ge) { return ge ? function ie(le, ge) { if (null != le) { if ((0, ze.c)(le)) return function Y(le, ge) { return (0, a.Xf)(le).pipe((0, v.R)(ge), (0, y.Q)(ge)) }(le, ge); if ((0, We.z)(le)) return function ke(le, ge) { return new Se.y(ue => { let ee = 0; return ge.schedule(function () { ee === le.length ? ue.complete() : (ue.next(le[ee++]), ue.closed || this.schedule()) }) }) }(le, ge); if ((0, Oe.t)(le)) return function he(le, ge) { return (0, a.Xf)(le).pipe((0, v.R)(ge), (0, y.Q)(ge)) }(le, ge); if ((0, Ve.D)(le)) return xe(le, ge); if ((0, Pe.T)(le)) return function _e(le, ge) { return new Se.y(ue => { let ee; return (0, Q.f)(ue, ge, () => { ee = le[re.h](), (0, Q.f)(ue, ge, () => { let $e, rt; try { ({ value: $e, done: rt } = ee.next()) } catch (Kt) { return void ue.error(Kt) } rt ? ue.complete() : ue.next($e) }, 0, !0) }), () => (0, Ie.m)(ee?.return) && ee.return() }) }(le, ge); if ((0, Ye.L)(le)) return function ut(le, ge) { return xe((0, Ye.Q)(le), ge) }(le, ge) } throw (0, tt.z)(le) }(le, ge) : (0, a.Xf)(le) } }, 2438: (nn, Qe, C) => { C.d(Qe, { R: () => Q }); var a = C(4829), y = C(5592), v = C(1631), Y = C(4266), he = C(4674), Se = C(7400); const ke = ["addListener", "removeListener"], re = ["addEventListener", "removeEventListener"], Ie = ["on", "off"]; function Q(We, Pe, Ve, tt) { if ((0, he.m)(Ve) && (tt = Ve, Ve = void 0), tt) return Q(We, Pe, Ve).pipe((0, Se.Z)(tt)); const [Ye, ut] = function Oe(We) { return (0, he.m)(We.addEventListener) && (0, he.m)(We.removeEventListener) }(We) ? re.map(ie => Le => We[ie](Pe, Le, Ve)) : function xe(We) { return (0, he.m)(We.addListener) && (0, he.m)(We.removeListener) }(We) ? ke.map(_e(We, Pe)) : function ze(We) { return (0, he.m)(We.on) && (0, he.m)(We.off) }(We) ? Ie.map(_e(We, Pe)) : []; if (!Ye && (0, Y.z)(We)) return (0, v.z)(ie => Q(ie, Pe, Ve))((0, a.Xf)(We)); if (!Ye) throw new TypeError("Invalid event target"); return new y.y(ie => { const Le = (...le) => ie.next(1 < le.length ? le : le[0]); return Ye(Le), () => ut(Le) }) } function _e(We, Pe) { return Ve => tt => We[Ve](Pe, tt) } }, 4829: (nn, Qe, C) => { C.d(Qe, { Xf: () => ze }); var a = C(7582), y = C(4266), v = C(4026), Y = C(5592), he = C(8382), Se = C(5726), ke = C(9853), re = C(3664), Ie = C(541), Q = C(4674), _e = C(3894), xe = C(4850); function ze(ie) { if (ie instanceof Y.y) return ie; if (null != ie) { if ((0, he.c)(ie)) return function Oe(ie) { return new Y.y(Le => { const le = ie[xe.L](); if ((0, Q.m)(le.subscribe)) return le.subscribe(Le); throw new TypeError("Provided object does not correctly implement Symbol.observable") }) }(ie); if ((0, y.z)(ie)) return function We(ie) { return new Y.y(Le => { for (let le = 0; le < ie.length && !Le.closed; le++)Le.next(ie[le]); Le.complete() }) }(ie); if ((0, v.t)(ie)) return function Pe(ie) { return new Y.y(Le => { ie.then(le => { Le.closed || (Le.next(le), Le.complete()) }, le => Le.error(le)).then(null, _e.h) }) }(ie); if ((0, Se.D)(ie)) return tt(ie); if ((0, re.T)(ie)) return function Ve(ie) { return new Y.y(Le => { for (const le of ie) if (Le.next(le), Le.closed) return; Le.complete() }) }(ie); if ((0, Ie.L)(ie)) return function Ye(ie) { return tt((0, Ie.Q)(ie)) }(ie) } throw (0, ke.z)(ie) } function tt(ie) { return new Y.y(Le => { (function ut(ie, Le) { var le, ge, ue, ee; return (0, a.mG)(this, void 0, void 0, function* () { try { for (le = (0, a.KL)(ie); !(ge = yield le.next()).done;)if (Le.next(ge.value), Le.closed) return } catch ($e) { ue = { error: $e } } finally { try { ge && !ge.done && (ee = le.return) && (yield ee.call(le)) } finally { if (ue) throw ue.error } } Le.complete() }) })(ie, Le).catch(le => Le.error(le)) }) } }, 3019: (nn, Qe, C) => { C.d(Qe, { T: () => Se }); var a = C(7537), y = C(4829), v = C(6232), Y = C(9940), he = C(2459); function Se(...ke) { const re = (0, Y.yG)(ke), Ie = (0, Y._6)(ke, 1 / 0), Q = ke; return Q.length ? 1 === Q.length ? (0, y.Xf)(Q[0]) : (0, a.J)(Ie)((0, he.D)(Q, re)) : v.E } }, 2096: (nn, Qe, C) => { C.d(Qe, { of: () => v }); var a = C(9940), y = C(2459); function v(...Y) { const he = (0, a.yG)(Y); return (0, y.D)(Y, he) } }, 8504: (nn, Qe, C) => { C.d(Qe, { _: () => v }); var a = C(5592), y = C(4674); function v(Y, he) { const Se = (0, y.m)(Y) ? Y : () => Y, ke = re => re.error(Se()); return new a.y(he ? re => he.schedule(ke, 0, re) : ke) } }, 4825: (nn, Qe, C) => { C.d(Qe, { H: () => he }); var a = C(5592), y = C(6321), v = C(671); function he(Se = 0, ke, re = y.P) { let Ie = -1; return null != ke && ((0, v.K)(ke) ? re = ke : Ie = ke), new a.y(Q => { let _e = function Y(Se) { return Se instanceof Date && !isNaN(Se) }(Se) ? +Se - re.now() : Se; _e < 0 && (_e = 0); let xe = 0; return re.schedule(function () { Q.closed || (Q.next(xe++), 0 <= Ie ? this.schedule(void 0, Ie) : Q.complete()) }, _e) }) } }, 8251: (nn, Qe, C) => { C.d(Qe, { x: () => y }); var a = C(305); function y(Y, he, Se, ke, re) { return new v(Y, he, Se, ke, re) } class v extends a.Lv { constructor(he, Se, ke, re, Ie, Q) { super(he), this.onFinalize = Ie, this.shouldUnsubscribe = Q, this._next = Se ? function (_e) { try { Se(_e) } catch (xe) { he.error(xe) } } : super._next, this._error = re ? function (_e) { try { re(_e) } catch (xe) { he.error(xe) } finally { this.unsubscribe() } } : super._error, this._complete = ke ? function () { try { ke() } catch (_e) { he.error(_e) } finally { this.unsubscribe() } } : super._complete } unsubscribe() { var he; if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) { const { closed: Se } = this; super.unsubscribe(), !Se && (null === (he = this.onFinalize) || void 0 === he || he.call(this)) } } } }, 6306: (nn, Qe, C) => { C.d(Qe, { K: () => Y }); var a = C(4829), y = C(8251), v = C(9360); function Y(he) { return (0, v.e)((Se, ke) => { let Q, re = null, Ie = !1; re = Se.subscribe((0, y.x)(ke, void 0, void 0, _e => { Q = (0, a.Xf)(he(_e, Y(he)(Se))), re ? (re.unsubscribe(), re = null, Q.subscribe(ke)) : Ie = !0 })), Ie && (re.unsubscribe(), re = null, Q.subscribe(ke)) }) } }, 6328: (nn, Qe, C) => { C.d(Qe, { b: () => v }); var a = C(1631), y = C(4674); function v(Y, he) { return (0, y.m)(he) ? (0, a.z)(Y, he, 1) : (0, a.z)(Y, 1) } }, 3620: (nn, Qe, C) => { C.d(Qe, { b: () => Y }); var a = C(6321), y = C(9360), v = C(8251); function Y(he, Se = a.z) { return (0, y.e)((ke, re) => { let Ie = null, Q = null, _e = null; const xe = () => { if (Ie) { Ie.unsubscribe(), Ie = null; const Oe = Q; Q = null, re.next(Oe) } }; function ze() { const Oe = _e + he, We = Se.now(); if (We < Oe) return Ie = this.schedule(void 0, Oe - We), void re.add(Ie); xe() } ke.subscribe((0, v.x)(re, Oe => { Q = Oe, _e = Se.now(), Ie || (Ie = Se.schedule(ze, he), re.add(Ie)) }, () => { xe(), re.complete() }, void 0, () => { Q = Ie = null })) }) } }, 3572: (nn, Qe, C) => { C.d(Qe, { d: () => v }); var a = C(9360), y = C(8251); function v(Y) { return (0, a.e)((he, Se) => { let ke = !1; he.subscribe((0, y.x)(Se, re => { ke = !0, Se.next(re) }, () => { ke || Se.next(Y), Se.complete() })) }) } }, 3997: (nn, Qe, C) => { C.d(Qe, { x: () => Y }); var a = C(2737), y = C(9360), v = C(8251); function Y(Se, ke = a.y) { return Se = Se ?? he, (0, y.e)((re, Ie) => { let Q, _e = !0; re.subscribe((0, v.x)(Ie, xe => { const ze = ke(xe); (_e || !Se(Q, ze)) && (_e = !1, Q = ze, Ie.next(xe)) })) }) } function he(Se, ke) { return Se === ke } }, 2181: (nn, Qe, C) => { C.d(Qe, { h: () => v }); var a = C(9360), y = C(8251); function v(Y, he) { return (0, a.e)((Se, ke) => { let re = 0; Se.subscribe((0, y.x)(ke, Ie => Y.call(he, Ie, re++) && ke.next(Ie))) }) } }, 4716: (nn, Qe, C) => { C.d(Qe, { x: () => y }); var a = C(9360); function y(v) { return (0, a.e)((Y, he) => { try { Y.subscribe(he) } finally { he.add(v) } }) } }, 1374: (nn, Qe, C) => { C.d(Qe, { P: () => ke }); var a = C(6973), y = C(2181), v = C(8180), Y = C(3572), he = C(3026), Se = C(2737); function ke(re, Ie) { const Q = arguments.length >= 2; return _e => _e.pipe(re ? (0, y.h)((xe, ze) => re(xe, ze, _e)) : Se.y, (0, v.q)(1), Q ? (0, Y.d)(Ie) : (0, he.T)(() => new a.K)) } }, 7398: (nn, Qe, C) => { C.d(Qe, { U: () => v }); var a = C(9360), y = C(8251); function v(Y, he) { return (0, a.e)((Se, ke) => { let re = 0; Se.subscribe((0, y.x)(ke, Ie => { ke.next(Y.call(he, Ie, re++)) })) }) } }, 975: (nn, Qe, C) => { C.d(Qe, { h: () => y }); var a = C(7398); function y(v) { return (0, a.U)(() => v) } }, 7537: (nn, Qe, C) => { C.d(Qe, { J: () => v }); var a = C(1631), y = C(2737); function v(Y = 1 / 0) { return (0, a.z)(y.y, Y) } }, 1631: (nn, Qe, C) => { C.d(Qe, { z: () => re }); var a = C(7398), y = C(4829), v = C(9360), Y = C(7103), he = C(8251), ke = C(4674); function re(Ie, Q, _e = 1 / 0) { return (0, ke.m)(Q) ? re((xe, ze) => (0, a.U)((Oe, We) => Q(xe, Oe, ze, We))((0, y.Xf)(Ie(xe, ze))), _e) : ("number" == typeof Q && (_e = Q), (0, v.e)((xe, ze) => function Se(Ie, Q, _e, xe, ze, Oe, We, Pe) { const Ve = []; let tt = 0, Ye = 0, ut = !1; const ie = () => { ut && !Ve.length && !tt && Q.complete() }, Le = ge => tt < xe ? le(ge) : Ve.push(ge), le = ge => { Oe && Q.next(ge), tt++; let ue = !1; (0, y.Xf)(_e(ge, Ye++)).subscribe((0, he.x)(Q, ee => { ze?.(ee), Oe ? Le(ee) : Q.next(ee) }, () => { ue = !0 }, void 0, () => { if (ue) try { for (tt--; Ve.length && tt < xe;) { const ee = Ve.shift(); We ? (0, Y.f)(Q, We, () => le(ee)) : le(ee) } ie() } catch (ee) { Q.error(ee) } })) }; return Ie.subscribe((0, he.x)(Q, Le, () => { ut = !0, ie() })), () => { Pe?.() } }(xe, ze, Ie, _e))) } }, 3093: (nn, Qe, C) => { C.d(Qe, { Q: () => Y }); var a = C(7103), y = C(9360), v = C(8251); function Y(he, Se = 0) { return (0, y.e)((ke, re) => { ke.subscribe((0, v.x)(re, Ie => (0, a.f)(re, he, () => re.next(Ie), Se), () => (0, a.f)(re, he, () => re.complete(), Se), Ie => (0, a.f)(re, he, () => re.error(Ie), Se))) }) } }, 6196: (nn, Qe, C) => { C.d(Qe, { x: () => v }); var a = C(9360), y = C(8251); function v() { return (0, a.e)((Y, he) => { let Se = null; Y._refCount++; const ke = (0, y.x)(he, void 0, void 0, void 0, () => { if (!Y || Y._refCount <= 0 || 0 < --Y._refCount) return void (Se = null); const re = Y._connection, Ie = Se; Se = null, re && (!Ie || re === Ie) && re.unsubscribe(), he.unsubscribe() }); Y.subscribe(ke), ke.closed || (Se = Y.connect()) }) } }, 6699: (nn, Qe, C) => { C.d(Qe, { R: () => Y }); var a = C(9360), y = C(8251); function Y(he, Se) { return (0, a.e)(function v(he, Se, ke, re, Ie) { return (Q, _e) => { let xe = ke, ze = Se, Oe = 0; Q.subscribe((0, y.x)(_e, We => { const Pe = Oe++; ze = xe ? he(ze, We, Pe) : (xe = !0, We), re && _e.next(ze) }, Ie && (() => { xe && _e.next(ze), _e.complete() }))) } }(he, Se, arguments.length >= 2, !0)) } }, 3020: (nn, Qe, C) => { C.d(Qe, { B: () => he }); var a = C(4829), y = C(8645), v = C(305), Y = C(9360); function he(ke = {}) { const { connector: re = (() => new y.x), resetOnError: Ie = !0, resetOnComplete: Q = !0, resetOnRefCountZero: _e = !0 } = ke; return xe => { let ze, Oe, We, Pe = 0, Ve = !1, tt = !1; const Ye = () => { Oe?.unsubscribe(), Oe = void 0 }, ut = () => { Ye(), ze = We = void 0, Ve = tt = !1 }, ie = () => { const Le = ze; ut(), Le?.unsubscribe() }; return (0, Y.e)((Le, le) => { Pe++, !tt && !Ve && Ye(); const ge = We = We ?? re(); le.add(() => { Pe--, 0 === Pe && !tt && !Ve && (Oe = Se(ie, _e)) }), ge.subscribe(le), !ze && Pe > 0 && (ze = new v.Hp({ next: ue => ge.next(ue), error: ue => { tt = !0, Ye(), Oe = Se(ut, Ie, ue), ge.error(ue) }, complete: () => { Ve = !0, Ye(), Oe = Se(ut, Q), ge.complete() } }), (0, a.Xf)(Le).subscribe(ze)) })(xe) } } function Se(ke, re, ...Ie) { if (!0 === re) return void ke(); if (!1 === re) return; const Q = new v.Hp({ next: () => { Q.unsubscribe(), ke() } }); return (0, a.Xf)(re(...Ie)).subscribe(Q) } }, 7081: (nn, Qe, C) => { C.d(Qe, { d: () => v }); var a = C(7328), y = C(3020); function v(Y, he, Se) { let ke, re = !1; return Y && "object" == typeof Y ? ({ bufferSize: ke = 1 / 0, windowTime: he = 1 / 0, refCount: re = !1, scheduler: Se } = Y) : ke = Y ?? 1 / 0, (0, y.B)({ connector: () => new a.t(ke, he, Se), resetOnError: !0, resetOnComplete: !1, resetOnRefCountZero: re }) } }, 836: (nn, Qe, C) => { C.d(Qe, { T: () => y }); var a = C(2181); function y(v) { return (0, a.h)((Y, he) => v <= he) } }, 7921: (nn, Qe, C) => { C.d(Qe, { O: () => Y }); var a = C(5211), y = C(9940), v = C(9360); function Y(...he) { const Se = (0, y.yG)(he); return (0, v.e)((ke, re) => { (Se ? (0, a.z)(he, ke, Se) : (0, a.z)(he, ke)).subscribe(re) }) } }, 5137: (nn, Qe, C) => { C.d(Qe, { R: () => y }); var a = C(9360); function y(v, Y = 0) { return (0, a.e)((he, Se) => { Se.add(v.schedule(() => he.subscribe(Se), Y)) }) } }, 4664: (nn, Qe, C) => { C.d(Qe, { w: () => Y }); var a = C(4829), y = C(9360), v = C(8251); function Y(he, Se) { return (0, y.e)((ke, re) => { let Ie = null, Q = 0, _e = !1; const xe = () => _e && !Ie && re.complete(); ke.subscribe((0, v.x)(re, ze => { Ie?.unsubscribe(); let Oe = 0; const We = Q++; (0, a.Xf)(he(ze, We)).subscribe(Ie = (0, v.x)(re, Pe => re.next(Se ? Se(ze, Pe, We, Oe++) : Pe), () => { Ie = null, xe() })) }, () => { _e = !0, xe() })) }) } }, 8180: (nn, Qe, C) => { C.d(Qe, { q: () => Y }); var a = C(6232), y = C(9360), v = C(8251); function Y(he) { return he <= 0 ? () => a.E : (0, y.e)((Se, ke) => { let re = 0; Se.subscribe((0, v.x)(ke, Ie => { ++re <= he && (ke.next(Ie), he <= re && ke.complete()) })) }) } }, 9773: (nn, Qe, C) => { C.d(Qe, { R: () => he }); var a = C(9360), y = C(8251), v = C(4829), Y = C(2420); function he(Se) { return (0, a.e)((ke, re) => { (0, v.Xf)(Se).subscribe((0, y.x)(re, () => re.complete(), Y.Z)), !re.closed && ke.subscribe(re) }) } }, 9397: (nn, Qe, C) => { C.d(Qe, { b: () => he }); var a = C(4674), y = C(9360), v = C(8251), Y = C(2737); function he(Se, ke, re) { const Ie = (0, a.m)(Se) || ke || re ? { next: Se, error: ke, complete: re } : Se; return Ie ? (0, y.e)((Q, _e) => { var xe; null === (xe = Ie.subscribe) || void 0 === xe || xe.call(Ie); let ze = !0; Q.subscribe((0, v.x)(_e, Oe => { var We; null === (We = Ie.next) || void 0 === We || We.call(Ie, Oe), _e.next(Oe) }, () => { var Oe; ze = !1, null === (Oe = Ie.complete) || void 0 === Oe || Oe.call(Ie), _e.complete() }, Oe => { var We; ze = !1, null === (We = Ie.error) || void 0 === We || We.call(Ie, Oe), _e.error(Oe) }, () => { var Oe, We; ze && (null === (Oe = Ie.unsubscribe) || void 0 === Oe || Oe.call(Ie)), null === (We = Ie.finalize) || void 0 === We || We.call(Ie) })) }) : Y.y } }, 3026: (nn, Qe, C) => { C.d(Qe, { T: () => Y }); var a = C(6973), y = C(9360), v = C(8251); function Y(Se = he) { return (0, y.e)((ke, re) => { let Ie = !1; ke.subscribe((0, v.x)(re, Q => { Ie = !0, re.next(Q) }, () => Ie ? re.complete() : re.error(Se()))) }) } function he() { return new a.K } }, 1954: (nn, Qe, C) => { C.d(Qe, { o: () => he }); var a = C(7394); class y extends a.w0 { constructor(ke, re) { super() } schedule(ke, re = 0) { return this } } const v = { setInterval(Se, ke, ...re) { const { delegate: Ie } = v; return Ie?.setInterval ? Ie.setInterval(Se, ke, ...re) : setInterval(Se, ke, ...re) }, clearInterval(Se) { const { delegate: ke } = v; return (ke?.clearInterval || clearInterval)(Se) }, delegate: void 0 }; var Y = C(9039); class he extends y { constructor(ke, re) { super(ke, re), this.scheduler = ke, this.work = re, this.pending = !1 } schedule(ke, re = 0) { var Ie; if (this.closed) return this; this.state = ke; const Q = this.id, _e = this.scheduler; return null != Q && (this.id = this.recycleAsyncId(_e, Q, re)), this.pending = !0, this.delay = re, this.id = null !== (Ie = this.id) && void 0 !== Ie ? Ie : this.requestAsyncId(_e, this.id, re), this } requestAsyncId(ke, re, Ie = 0) { return v.setInterval(ke.flush.bind(ke, this), Ie) } recycleAsyncId(ke, re, Ie = 0) { if (null != Ie && this.delay === Ie && !1 === this.pending) return re; null != re && v.clearInterval(re) } execute(ke, re) { if (this.closed) return new Error("executing a cancelled action"); this.pending = !1; const Ie = this._execute(ke, re); if (Ie) return Ie; !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null)) } _execute(ke, re) { let Q, Ie = !1; try { this.work(ke) } catch (_e) { Ie = !0, Q = _e || new Error("Scheduled action threw falsy error") } if (Ie) return this.unsubscribe(), Q } unsubscribe() { if (!this.closed) { const { id: ke, scheduler: re } = this, { actions: Ie } = re; this.work = this.state = this.scheduler = null, this.pending = !1, (0, Y.P)(Ie, this), null != ke && (this.id = this.recycleAsyncId(re, ke, null)), this.delay = null, super.unsubscribe() } } } }, 2631: (nn, Qe, C) => { C.d(Qe, { v: () => v }); var a = C(4552); class y { constructor(he, Se = y.now) { this.schedulerActionCtor = he, this.now = Se } schedule(he, Se = 0, ke) { return new this.schedulerActionCtor(this, he).schedule(ke, Se) } } y.now = a.l.now; class v extends y { constructor(he, Se = y.now) { super(he, Se), this.actions = [], this._active = !1 } flush(he) { const { actions: Se } = this; if (this._active) return void Se.push(he); let ke; this._active = !0; do { if (ke = he.execute(he.state, he.delay)) break } while (he = Se.shift()); if (this._active = !1, ke) { for (; he = Se.shift();)he.unsubscribe(); throw ke } } } }, 6410: (nn, Qe, C) => { C.d(Qe, { E: () => Oe }); var a = C(1954); let v, y = 1; const Y = {}; function he(Pe) { return Pe in Y && (delete Y[Pe], !0) } const Se = { setImmediate(Pe) { const Ve = y++; return Y[Ve] = !0, v || (v = Promise.resolve()), v.then(() => he(Ve) && Pe()), Ve }, clearImmediate(Pe) { he(Pe) } }, { setImmediate: re, clearImmediate: Ie } = Se, Q = { setImmediate(...Pe) { const { delegate: Ve } = Q; return (Ve?.setImmediate || re)(...Pe) }, clearImmediate(Pe) { const { delegate: Ve } = Q; return (Ve?.clearImmediate || Ie)(Pe) }, delegate: void 0 }; var xe = C(2631); const Oe = new class ze extends xe.v { flush(Ve) { this._active = !0; const tt = this._scheduled; this._scheduled = void 0; const { actions: Ye } = this; let ut; Ve = Ve || Ye.shift(); do { if (ut = Ve.execute(Ve.state, Ve.delay)) break } while ((Ve = Ye[0]) && Ve.id === tt && Ye.shift()); if (this._active = !1, ut) { for (; (Ve = Ye[0]) && Ve.id === tt && Ye.shift();)Ve.unsubscribe(); throw ut } } }(class _e extends a.o { constructor(Ve, tt) { super(Ve, tt), this.scheduler = Ve, this.work = tt } requestAsyncId(Ve, tt, Ye = 0) { return null !== Ye && Ye > 0 ? super.requestAsyncId(Ve, tt, Ye) : (Ve.actions.push(this), Ve._scheduled || (Ve._scheduled = Q.setImmediate(Ve.flush.bind(Ve, void 0)))) } recycleAsyncId(Ve, tt, Ye = 0) { var ut; if (null != Ye ? Ye > 0 : this.delay > 0) return super.recycleAsyncId(Ve, tt, Ye); const { actions: ie } = Ve; null != tt && (null === (ut = ie[ie.length - 1]) || void 0 === ut ? void 0 : ut.id) !== tt && (Q.clearImmediate(tt), Ve._scheduled === tt && (Ve._scheduled = void 0)) } }) }, 6321: (nn, Qe, C) => { C.d(Qe, { P: () => Y, z: () => v }); var a = C(1954); const v = new (C(2631).v)(a.o), Y = v }, 4552: (nn, Qe, C) => { C.d(Qe, { l: () => a }); const a = { now: () => (a.delegate || Date).now(), delegate: void 0 } }, 7599: (nn, Qe, C) => { C.d(Qe, { z: () => a }); const a = { setTimeout(y, v, ...Y) { const { delegate: he } = a; return he?.setTimeout ? he.setTimeout(y, v, ...Y) : setTimeout(y, v, ...Y) }, clearTimeout(y) { const { delegate: v } = a; return (v?.clearTimeout || clearTimeout)(y) }, delegate: void 0 } }, 4971: (nn, Qe, C) => { C.d(Qe, { h: () => y }); const y = function a() { return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator" }() }, 4850: (nn, Qe, C) => { C.d(Qe, { L: () => a }); const a = "function" == typeof Symbol && Symbol.observable || "@@observable" }, 6973: (nn, Qe, C) => { C.d(Qe, { K: () => y }); const y = (0, C(2306).d)(v => function () { v(this), this.name = "EmptyError", this.message = "no elements in sequence" }) }, 9940: (nn, Qe, C) => { C.d(Qe, { _6: () => Se, jO: () => Y, yG: () => he }); var a = C(4674), y = C(671); function v(ke) { return ke[ke.length - 1] } function Y(ke) { return (0, a.m)(v(ke)) ? ke.pop() : void 0 } function he(ke) { return (0, y.K)(v(ke)) ? ke.pop() : void 0 } function Se(ke, re) { return "number" == typeof v(ke) ? ke.pop() : re } }, 7453: (nn, Qe, C) => { C.d(Qe, { D: () => he }); const { isArray: a } = Array, { getPrototypeOf: y, prototype: v, keys: Y } = Object; function he(ke) { if (1 === ke.length) { const re = ke[0]; if (a(re)) return { args: re, keys: null }; if (function Se(ke) { return ke && "object" == typeof ke && y(ke) === v }(re)) { const Ie = Y(re); return { args: Ie.map(Q => re[Q]), keys: Ie } } } return { args: ke, keys: null } } }, 9039: (nn, Qe, C) => { function a(y, v) { if (y) { const Y = y.indexOf(v); 0 <= Y && y.splice(Y, 1) } } C.d(Qe, { P: () => a }) }, 2306: (nn, Qe, C) => { function a(y) { const Y = y(he => { Error.call(he), he.stack = (new Error).stack }); return Y.prototype = Object.create(Error.prototype), Y.prototype.constructor = Y, Y } C.d(Qe, { d: () => a }) }, 2714: (nn, Qe, C) => { function a(y, v) { return y.reduce((Y, he, Se) => (Y[he] = v[Se], Y), {}) } C.d(Qe, { n: () => a }) }, 1441: (nn, Qe, C) => { C.d(Qe, { O: () => Y, x: () => v }); var a = C(2653); let y = null; function v(he) { if (a.config.useDeprecatedSynchronousErrorHandling) { const Se = !y; if (Se && (y = { errorThrown: !1, error: null }), he(), Se) { const { errorThrown: ke, error: re } = y; if (y = null, ke) throw re } } else he() } function Y(he) { a.config.useDeprecatedSynchronousErrorHandling && y && (y.errorThrown = !0, y.error = he) } }, 7103: (nn, Qe, C) => { function a(y, v, Y, he = 0, Se = !1) { const ke = v.schedule(function () { Y(), Se ? y.add(this.schedule(null, he)) : this.unsubscribe() }, he); if (y.add(ke), !Se) return ke } C.d(Qe, { f: () => a }) }, 2737: (nn, Qe, C) => { function a(y) { return y } C.d(Qe, { y: () => a }) }, 4266: (nn, Qe, C) => { C.d(Qe, { z: () => a }); const a = y => y && "number" == typeof y.length && "function" != typeof y }, 5726: (nn, Qe, C) => { C.d(Qe, { D: () => y }); var a = C(4674); function y(v) { return Symbol.asyncIterator && (0, a.m)(v?.[Symbol.asyncIterator]) } }, 4674: (nn, Qe, C) => { function a(y) { return "function" == typeof y } C.d(Qe, { m: () => a }) }, 8382: (nn, Qe, C) => { C.d(Qe, { c: () => v }); var a = C(4850), y = C(4674); function v(Y) { return (0, y.m)(Y[a.L]) } }, 3664: (nn, Qe, C) => { C.d(Qe, { T: () => v }); var a = C(4971), y = C(4674); function v(Y) { return (0, y.m)(Y?.[a.h]) } }, 2664: (nn, Qe, C) => { C.d(Qe, { b: () => v }); var a = C(5592), y = C(4674); function v(Y) { return !!Y && (Y instanceof a.y || (0, y.m)(Y.lift) && (0, y.m)(Y.subscribe)) } }, 4026: (nn, Qe, C) => { C.d(Qe, { t: () => y }); var a = C(4674); function y(v) { return (0, a.m)(v?.then) } }, 541: (nn, Qe, C) => { C.d(Qe, { L: () => Y, Q: () => v }); var a = C(7582), y = C(4674); function v(he) { return (0, a.FC)(this, arguments, function* () { const ke = he.getReader(); try { for (; ;) { const { value: re, done: Ie } = yield (0, a.qq)(ke.read()); if (Ie) return yield (0, a.qq)(void 0); yield yield (0, a.qq)(re) } } finally { ke.releaseLock() } }) } function Y(he) { return (0, y.m)(he?.getReader) } }, 671: (nn, Qe, C) => { C.d(Qe, { K: () => y }); var a = C(4674); function y(v) { return v && (0, a.m)(v.schedule) } }, 9360: (nn, Qe, C) => { C.d(Qe, { A: () => y, e: () => v }); var a = C(4674); function y(Y) { return (0, a.m)(Y?.lift) } function v(Y) { return he => { if (y(he)) return he.lift(function (Se) { try { return Y(Se, this) } catch (ke) { this.error(ke) } }); throw new TypeError("Unable to lift unknown Observable type") } } }, 7400: (nn, Qe, C) => { C.d(Qe, { Z: () => Y }); var a = C(7398); const { isArray: y } = Array; function Y(he) { return (0, a.U)(Se => function v(he, Se) { return y(Se) ? he(...Se) : he(Se) }(he, Se)) } }, 2420: (nn, Qe, C) => { function a() { } C.d(Qe, { Z: () => a }) }, 8407: (nn, Qe, C) => { C.d(Qe, { U: () => v, z: () => y }); var a = C(2737); function y(...Y) { return v(Y) } function v(Y) { return 0 === Y.length ? a.y : 1 === Y.length ? Y[0] : function (Se) { return Y.reduce((ke, re) => re(ke), Se) } } }, 3894: (nn, Qe, C) => { C.d(Qe, { h: () => v }); var a = C(2653), y = C(7599); function v(Y) { y.z.setTimeout(() => { const { onUnhandledError: he } = a.config; if (!he) throw Y; he(Y) }) } }, 9853: (nn, Qe, C) => { function a(y) { return new TypeError(`You provided ${null !== y && "object" == typeof y ? "an invalid object" : `'${y}'`} where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`) } C.d(Qe, { z: () => a }) }, 6825: (nn, Qe, C) => { C.d(Qe, { F4: () => Q, IO: () => We, LC: () => y, SB: () => Ie, X$: () => Y, ZE: () => tt, ZN: () => Ve, _j: () => a, eR: () => _e, jt: () => he, k1: () => Ye, l3: () => v, oB: () => re, pV: () => ze, ru: () => Se, vP: () => ke }); class a { } class y { } const v = "*"; function Y(ut, ie) { return { type: 7, name: ut, definitions: ie, options: {} } } function he(ut, ie = null) { return { type: 4, styles: ie, timings: ut } } function Se(ut, ie = null) { return { type: 3, steps: ut, options: ie } } function ke(ut, ie = null) { return { type: 2, steps: ut, options: ie } } function re(ut) { return { type: 6, styles: ut, offset: null } } function Ie(ut, ie, Le) { return { type: 0, name: ut, styles: ie, options: Le } } function Q(ut) { return { type: 5, steps: ut } } function _e(ut, ie, Le = null) { return { type: 1, expr: ut, animation: ie, options: Le } } function ze(ut = null) { return { type: 9, options: ut } } function We(ut, ie, Le = null) { return { type: 11, selector: ut, animation: ie, options: Le } } class Ve { constructor(ie = 0, Le = 0) { this._onDoneFns = [], this._onStartFns = [], this._onDestroyFns = [], this._originalOnDoneFns = [], this._originalOnStartFns = [], this._started = !1, this._destroyed = !1, this._finished = !1, this._position = 0, this.parentPlayer = null, this.totalTime = ie + Le } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(ie => ie()), this._onDoneFns = []) } onStart(ie) { this._originalOnStartFns.push(ie), this._onStartFns.push(ie) } onDone(ie) { this._originalOnDoneFns.push(ie), this._onDoneFns.push(ie) } onDestroy(ie) { this._onDestroyFns.push(ie) } hasStarted() { return this._started } init() { } play() { this.hasStarted() || (this._onStart(), this.triggerMicrotask()), this._started = !0 } triggerMicrotask() { queueMicrotask(() => this._onFinish()) } _onStart() { this._onStartFns.forEach(ie => ie()), this._onStartFns = [] } pause() { } restart() { } finish() { this._onFinish() } destroy() { this._destroyed || (this._destroyed = !0, this.hasStarted() || this._onStart(), this.finish(), this._onDestroyFns.forEach(ie => ie()), this._onDestroyFns = []) } reset() { this._started = !1, this._finished = !1, this._onStartFns = this._originalOnStartFns, this._onDoneFns = this._originalOnDoneFns } setPosition(ie) { this._position = this.totalTime ? ie * this.totalTime : 1 } getPosition() { return this.totalTime ? this._position / this.totalTime : 1 } triggerCallback(ie) { const Le = "start" == ie ? this._onStartFns : this._onDoneFns; Le.forEach(le => le()), Le.length = 0 } } class tt { constructor(ie) { this._onDoneFns = [], this._onStartFns = [], this._finished = !1, this._started = !1, this._destroyed = !1, this._onDestroyFns = [], this.parentPlayer = null, this.totalTime = 0, this.players = ie; let Le = 0, le = 0, ge = 0; const ue = this.players.length; 0 == ue ? queueMicrotask(() => this._onFinish()) : this.players.forEach(ee => { ee.onDone(() => { ++Le == ue && this._onFinish() }), ee.onDestroy(() => { ++le == ue && this._onDestroy() }), ee.onStart(() => { ++ge == ue && this._onStart() }) }), this.totalTime = this.players.reduce((ee, $e) => Math.max(ee, $e.totalTime), 0) } _onFinish() { this._finished || (this._finished = !0, this._onDoneFns.forEach(ie => ie()), this._onDoneFns = []) } init() { this.players.forEach(ie => ie.init()) } onStart(ie) { this._onStartFns.push(ie) } _onStart() { this.hasStarted() || (this._started = !0, this._onStartFns.forEach(ie => ie()), this._onStartFns = []) } onDone(ie) { this._onDoneFns.push(ie) } onDestroy(ie) { this._onDestroyFns.push(ie) } hasStarted() { return this._started } play() { this.parentPlayer || this.init(), this._onStart(), this.players.forEach(ie => ie.play()) } pause() { this.players.forEach(ie => ie.pause()) } restart() { this.players.forEach(ie => ie.restart()) } finish() { this._onFinish(), this.players.forEach(ie => ie.finish()) } destroy() { this._onDestroy() } _onDestroy() { this._destroyed || (this._destroyed = !0, this._onFinish(), this.players.forEach(ie => ie.destroy()), this._onDestroyFns.forEach(ie => ie()), this._onDestroyFns = []) } reset() { this.players.forEach(ie => ie.reset()), this._destroyed = !1, this._finished = !1, this._started = !1 } setPosition(ie) { const Le = ie * this.totalTime; this.players.forEach(le => { const ge = le.totalTime ? Math.min(1, Le / le.totalTime) : 1; le.setPosition(ge) }) } getPosition() { const ie = this.players.reduce((Le, le) => null === Le || le.totalTime > Le.totalTime ? le : Le, null); return null != ie ? ie.getPosition() : 0 } beforeDestroy() { this.players.forEach(ie => { ie.beforeDestroy && ie.beforeDestroy() }) } triggerCallback(ie) { const Le = "start" == ie ? this._onStartFns : this._onDoneFns; Le.forEach(le => le()), Le.length = 0 } } const Ye = "!" }, 4191: (nn, Qe, C) => { C.d(Qe, { rt: () => pt, s1: () => tn, $s: () => Ft, kH: () => ae, Em: () => St, tE: () => He, qV: () => Me, qm: () => Ne, ic: () => Ae, Kd: () => me, Zf: () => On, X6: () => ct, yG: () => Mt, iD: () => Wn }); var a = C(6814), y = C(5879), v = C(2831), Y = C(8645), he = C(7394), Se = C(5619), ke = C(2096), re = C(6028), Ie = C(9397), Q = C(3620), _e = C(2181), xe = C(7398), ze = C(8180), Oe = C(836), We = C(3997), Pe = C(9773), Ve = C(2495), tt = C(7131), Ye = C(2572), ut = C(5211), ie = C(5592), Le = C(7921); const ge = new Set; let ue, ee = (() => { class pe { constructor(F, J) { this._platform = F, this._nonce = J, this._matchMedia = this._platform.isBrowser && window.matchMedia ? window.matchMedia.bind(window) : rt } matchMedia(F) { return (this._platform.WEBKIT || this._platform.BLINK) && function $e(pe, fe) { if (!ge.has(pe)) try { ue || (ue = document.createElement("style"), fe && (ue.nonce = fe), ue.setAttribute("type", "text/css"), document.head.appendChild(ue)), ue.sheet && (ue.sheet.insertRule(`@media ${pe} {body{ }}`, 0), ge.add(pe)) } catch (F) { console.error(F) } }(F, this._nonce), this._matchMedia(F) } } return pe.\u0275fac = function (F) { return new (F || pe)(y.LFG(v.t4), y.LFG(y.Ojb, 8)) }, pe.\u0275prov = y.Yz7({ token: pe, factory: pe.\u0275fac, providedIn: "root" }), pe })(); function rt(pe) { return { matches: "all" === pe || "" === pe, media: pe, addListener: () => { }, removeListener: () => { } } } let Kt = (() => { class pe { constructor(F, J) { this._mediaMatcher = F, this._zone = J, this._queries = new Map, this._destroySubject = new Y.x } ngOnDestroy() { this._destroySubject.next(), this._destroySubject.complete() } isMatched(F) { return bn((0, Ve.Eq)(F)).some(Te => this._registerQuery(Te).mql.matches) } observe(F) { const Te = bn((0, Ve.Eq)(F)).map(gt => this._registerQuery(gt).observable); let lt = (0, Ye.a)(Te); return lt = (0, ut.z)(lt.pipe((0, ze.q)(1)), lt.pipe((0, Oe.T)(1), (0, Q.b)(0))), lt.pipe((0, xe.U)(gt => { const Ht = { matches: !1, breakpoints: {} }; return gt.forEach(({ matches: un, query: yt }) => { Ht.matches = Ht.matches || un, Ht.breakpoints[yt] = un }), Ht })) } _registerQuery(F) { if (this._queries.has(F)) return this._queries.get(F); const J = this._mediaMatcher.matchMedia(F), lt = { observable: new ie.y(gt => { const Ht = un => this._zone.run(() => gt.next(un)); return J.addListener(Ht), () => { J.removeListener(Ht) } }).pipe((0, Le.O)(J), (0, xe.U)(({ matches: gt }) => ({ query: F, matches: gt })), (0, Pe.R)(this._destroySubject)), mql: J }; return this._queries.set(F, lt), lt } } return pe.\u0275fac = function (F) { return new (F || pe)(y.LFG(ee), y.LFG(y.R0b)) }, pe.\u0275prov = y.Yz7({ token: pe, factory: pe.\u0275fac, providedIn: "root" }), pe })(); function bn(pe) { return pe.map(fe => fe.split(",")).reduce((fe, F) => fe.concat(F)).map(fe => fe.trim()) } const Mn = " "; function On(pe, fe, F) { const J = Hn(pe, fe); J.some(Te => Te.trim() == F.trim()) || (J.push(F.trim()), pe.setAttribute(fe, J.join(Mn))) } function Wn(pe, fe, F) { const Te = Hn(pe, fe).filter(lt => lt != F.trim()); Te.length ? pe.setAttribute(fe, Te.join(Mn)) : pe.removeAttribute(fe) } function Hn(pe, fe) { return (pe.getAttribute(fe) || "").match(/\S+/g) || [] } const vt = "cdk-describedby-message", xt = "cdk-describedby-host"; let it = 0, Ft = (() => { class pe { constructor(F, J) { this._platform = J, this._messageRegistry = new Map, this._messagesContainer = null, this._id = "" + it++, this._document = F, this._id = (0, y.f3M)(y.AFp) + "-" + it++ } describe(F, J, Te) { if (!this._canBeDescribed(F, J)) return; const lt = Wt(J, Te); "string" != typeof J ? (rn(J, this._id), this._messageRegistry.set(lt, { messageElement: J, referenceCount: 0 })) : this._messageRegistry.has(lt) || this._createMessageElement(J, Te), this._isElementDescribedByMessage(F, lt) || this._addMessageReference(F, lt) } removeDescription(F, J, Te) { if (!J || !this._isElementNode(F)) return; const lt = Wt(J, Te); if (this._isElementDescribedByMessage(F, lt) && this._removeMessageReference(F, lt), "string" == typeof J) { const gt = this._messageRegistry.get(lt); gt && 0 === gt.referenceCount && this._deleteMessageElement(lt) } 0 === this._messagesContainer?.childNodes.length && (this._messagesContainer.remove(), this._messagesContainer = null) } ngOnDestroy() { const F = this._document.querySelectorAll(`[${xt}="${this._id}"]`); for (let J = 0; J < F.length; J++)this._removeCdkDescribedByReferenceIds(F[J]), F[J].removeAttribute(xt); this._messagesContainer?.remove(), this._messagesContainer = null, this._messageRegistry.clear() } _createMessageElement(F, J) { const Te = this._document.createElement("div"); rn(Te, this._id), Te.textContent = F, J && Te.setAttribute("role", J), this._createMessagesContainer(), this._messagesContainer.appendChild(Te), this._messageRegistry.set(Wt(F, J), { messageElement: Te, referenceCount: 0 }) } _deleteMessageElement(F) { this._messageRegistry.get(F)?.messageElement?.remove(), this._messageRegistry.delete(F) } _createMessagesContainer() { if (this._messagesContainer) return; const F = "cdk-describedby-message-container", J = this._document.querySelectorAll(`.${F}[platform="server"]`); for (let lt = 0; lt < J.length; lt++)J[lt].remove(); const Te = this._document.createElement("div"); Te.style.visibility = "hidden", Te.classList.add(F), Te.classList.add("cdk-visually-hidden"), this._platform && !this._platform.isBrowser && Te.setAttribute("platform", "server"), this._document.body.appendChild(Te), this._messagesContainer = Te } _removeCdkDescribedByReferenceIds(F) { const J = Hn(F, "aria-describedby").filter(Te => 0 != Te.indexOf(vt)); F.setAttribute("aria-describedby", J.join(" ")) } _addMessageReference(F, J) { const Te = this._messageRegistry.get(J); On(F, "aria-describedby", Te.messageElement.id), F.setAttribute(xt, this._id), Te.referenceCount++ } _removeMessageReference(F, J) { const Te = this._messageRegistry.get(J); Te.referenceCount--, Wn(F, "aria-describedby", Te.messageElement.id), F.removeAttribute(xt) } _isElementDescribedByMessage(F, J) { const Te = Hn(F, "aria-describedby"), lt = this._messageRegistry.get(J), gt = lt && lt.messageElement.id; return !!gt && -1 != Te.indexOf(gt) } _canBeDescribed(F, J) { if (!this._isElementNode(F)) return !1; if (J && "object" == typeof J) return !0; const Te = null == J ? "" : `${J}`.trim(), lt = F.getAttribute("aria-label"); return !(!Te || lt && lt.trim() === Te) } _isElementNode(F) { return F.nodeType === this._document.ELEMENT_NODE } } return pe.\u0275fac = function (F) { return new (F || pe)(y.LFG(a.K0), y.LFG(v.t4)) }, pe.\u0275prov = y.Yz7({ token: pe, factory: pe.\u0275fac, providedIn: "root" }), pe })(); function Wt(pe, fe) { return "string" == typeof pe ? `${fe || ""}/${pe}` : pe } function rn(pe, fe) { pe.id || (pe.id = `${vt}-${fe}-${it++}`) } class Jt { constructor(fe) { this._items = fe, this._activeItemIndex = -1, this._activeItem = null, this._wrap = !1, this._letterKeyStream = new Y.x, this._typeaheadSubscription = he.w0.EMPTY, this._vertical = !0, this._allowedModifierKeys = [], this._homeAndEnd = !1, this._pageUpAndDown = { enabled: !1, delta: 10 }, this._skipPredicateFn = F => F.disabled, this._pressedLetters = [], this.tabOut = new Y.x, this.change = new Y.x, fe instanceof y.n_E && (this._itemChangesSubscription = fe.changes.subscribe(F => { if (this._activeItem) { const Te = F.toArray().indexOf(this._activeItem); Te > -1 && Te !== this._activeItemIndex && (this._activeItemIndex = Te) } })) } skipPredicate(fe) { return this._skipPredicateFn = fe, this } withWrap(fe = !0) { return this._wrap = fe, this } withVerticalOrientation(fe = !0) { return this._vertical = fe, this } withHorizontalOrientation(fe) { return this._horizontal = fe, this } withAllowedModifierKeys(fe) { return this._allowedModifierKeys = fe, this } withTypeAhead(fe = 200) { return this._typeaheadSubscription.unsubscribe(), this._typeaheadSubscription = this._letterKeyStream.pipe((0, Ie.b)(F => this._pressedLetters.push(F)), (0, Q.b)(fe), (0, _e.h)(() => this._pressedLetters.length > 0), (0, xe.U)(() => this._pressedLetters.join(""))).subscribe(F => { const J = this._getItemsArray(); for (let Te = 1; Te < J.length + 1; Te++) { const lt = (this._activeItemIndex + Te) % J.length, gt = J[lt]; if (!this._skipPredicateFn(gt) && 0 === gt.getLabel().toUpperCase().trim().indexOf(F)) { this.setActiveItem(lt); break } } this._pressedLetters = [] }), this } cancelTypeahead() { return this._pressedLetters = [], this } withHomeAndEnd(fe = !0) { return this._homeAndEnd = fe, this } withPageUpDown(fe = !0, F = 10) { return this._pageUpAndDown = { enabled: fe, delta: F }, this } setActiveItem(fe) { const F = this._activeItem; this.updateActiveItem(fe), this._activeItem !== F && this.change.next(this._activeItemIndex) } onKeydown(fe) { const F = fe.keyCode, Te = ["altKey", "ctrlKey", "metaKey", "shiftKey"].every(lt => !fe[lt] || this._allowedModifierKeys.indexOf(lt) > -1); switch (F) { case re.Mf: return void this.tabOut.next(); case re.JH: if (this._vertical && Te) { this.setNextItemActive(); break } return; case re.LH: if (this._vertical && Te) { this.setPreviousItemActive(); break } return; case re.SV: if (this._horizontal && Te) { "rtl" === this._horizontal ? this.setPreviousItemActive() : this.setNextItemActive(); break } return; case re.oh: if (this._horizontal && Te) { "rtl" === this._horizontal ? this.setNextItemActive() : this.setPreviousItemActive(); break } return; case re.Sd: if (this._homeAndEnd && Te) { this.setFirstItemActive(); break } return; case re.uR: if (this._homeAndEnd && Te) { this.setLastItemActive(); break } return; case re.Ku: if (this._pageUpAndDown.enabled && Te) { const lt = this._activeItemIndex - this._pageUpAndDown.delta; this._setActiveItemByIndex(lt > 0 ? lt : 0, 1); break } return; case re.VM: if (this._pageUpAndDown.enabled && Te) { const lt = this._activeItemIndex + this._pageUpAndDown.delta, gt = this._getItemsArray().length; this._setActiveItemByIndex(lt < gt ? lt : gt - 1, -1); break } return; default: return void ((Te || (0, re.Vb)(fe, "shiftKey")) && (fe.key && 1 === fe.key.length ? this._letterKeyStream.next(fe.key.toLocaleUpperCase()) : (F >= re.A && F <= re.Z || F >= re.xE && F <= re.aO) && this._letterKeyStream.next(String.fromCharCode(F)))) }this._pressedLetters = [], fe.preventDefault() } get activeItemIndex() { return this._activeItemIndex } get activeItem() { return this._activeItem } isTyping() { return this._pressedLetters.length > 0 } setFirstItemActive() { this._setActiveItemByIndex(0, 1) } setLastItemActive() { this._setActiveItemByIndex(this._items.length - 1, -1) } setNextItemActive() { this._activeItemIndex < 0 ? this.setFirstItemActive() : this._setActiveItemByDelta(1) } setPreviousItemActive() { this._activeItemIndex < 0 && this._wrap ? this.setLastItemActive() : this._setActiveItemByDelta(-1) } updateActiveItem(fe) { const F = this._getItemsArray(), J = "number" == typeof fe ? fe : F.indexOf(fe); this._activeItem = F[J] ?? null, this._activeItemIndex = J } destroy() { this._typeaheadSubscription.unsubscribe(), this._itemChangesSubscription?.unsubscribe(), this._letterKeyStream.complete(), this.tabOut.complete(), this.change.complete(), this._pressedLetters = [] } _setActiveItemByDelta(fe) { this._wrap ? this._setActiveInWrapMode(fe) : this._setActiveInDefaultMode(fe) } _setActiveInWrapMode(fe) { const F = this._getItemsArray(); for (let J = 1; J <= F.length; J++) { const Te = (this._activeItemIndex + fe * J + F.length) % F.length; if (!this._skipPredicateFn(F[Te])) return void this.setActiveItem(Te) } } _setActiveInDefaultMode(fe) { this._setActiveItemByIndex(this._activeItemIndex + fe, fe) } _setActiveItemByIndex(fe, F) { const J = this._getItemsArray(); if (J[fe]) { for (; this._skipPredicateFn(J[fe]);)if (!J[fe += F]) return; this.setActiveItem(fe) } } _getItemsArray() { return this._items instanceof y.n_E ? this._items.toArray() : this._items } } class tn extends Jt { setActiveItem(fe) { this.activeItem && this.activeItem.setInactiveStyles(), super.setActiveItem(fe), this.activeItem && this.activeItem.setActiveStyles() } } class St extends Jt { constructor() { super(...arguments), this._origin = "program" } setFocusOrigin(fe) { return this._origin = fe, this } setActiveItem(fe) { super.setActiveItem(fe), this.activeItem && this.activeItem.focus(this._origin) } } let Ae = (() => { class pe { constructor(F) { this._platform = F } isDisabled(F) { return F.hasAttribute("disabled") } isVisible(F) { return function qt(pe) { return !!(pe.offsetWidth || pe.offsetHeight || "function" == typeof pe.getClientRects && pe.getClientRects().length) }(F) && "visible" === getComputedStyle(F).visibility } isTabbable(F) { if (!this._platform.isBrowser) return !1; const J = function nt(pe) { try { return pe.frameElement } catch { return null } }(function Ke(pe) { return pe.ownerDocument && pe.ownerDocument.defaultView || window }(F)); if (J && (-1 === gn(J) || !this.isVisible(J))) return !1; let Te = F.nodeName.toLowerCase(), lt = gn(F); return F.hasAttribute("contenteditable") ? -1 !== lt : !("iframe" === Te || "object" === Te || this._platform.WEBKIT && this._platform.IOS && !function $n(pe) { let fe = pe.nodeName.toLowerCase(), F = "input" === fe && pe.type; return "text" === F || "password" === F || "select" === fe || "textarea" === fe }(F)) && ("audio" === Te ? !!F.hasAttribute("controls") && -1 !== lt : "video" === Te ? -1 !== lt && (null !== lt || this._platform.FIREFOX || F.hasAttribute("controls")) : F.tabIndex >= 0) } isFocusable(F, J) { return function Fn(pe) { return !function Pt(pe) { return function Nt(pe) { return "input" == pe.nodeName.toLowerCase() }(pe) && "hidden" == pe.type }(pe) && (function jt(pe) { let fe = pe.nodeName.toLowerCase(); return "input" === fe || "select" === fe || "button" === fe || "textarea" === fe }(pe) || function qe(pe) { return function on(pe) { return "a" == pe.nodeName.toLowerCase() }(pe) && pe.hasAttribute("href") }(pe) || pe.hasAttribute("contenteditable") || Zt(pe)) }(F) && !this.isDisabled(F) && (J?.ignoreVisibility || this.isVisible(F)) } } return pe.\u0275fac = function (F) { return new (F || pe)(y.LFG(v.t4)) }, pe.\u0275prov = y.Yz7({ token: pe, factory: pe.\u0275fac, providedIn: "root" }), pe })(); function Zt(pe) { if (!pe.hasAttribute("tabindex") || void 0 === pe.tabIndex) return !1; let fe = pe.getAttribute("tabindex"); return !(!fe || isNaN(parseInt(fe, 10))) } function gn(pe) { if (!Zt(pe)) return null; const fe = parseInt(pe.getAttribute("tabindex") || "", 10); return isNaN(fe) ? -1 : fe } class se { get enabled() { return this._enabled } set enabled(fe) { this._enabled = fe, this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(fe, this._startAnchor), this._toggleAnchorTabIndex(fe, this._endAnchor)) } constructor(fe, F, J, Te, lt = !1) { this._element = fe, this._checker = F, this._ngZone = J, this._document = Te, this._hasAttached = !1, this.startAnchorListener = () => this.focusLastTabbableElement(), this.endAnchorListener = () => this.focusFirstTabbableElement(), this._enabled = !0, lt || this.attachAnchors() } destroy() { const fe = this._startAnchor, F = this._endAnchor; fe && (fe.removeEventListener("focus", this.startAnchorListener), fe.remove()), F && (F.removeEventListener("focus", this.endAnchorListener), F.remove()), this._startAnchor = this._endAnchor = null, this._hasAttached = !1 } attachAnchors() { return !!this._hasAttached || (this._ngZone.runOutsideAngular(() => { this._startAnchor || (this._startAnchor = this._createAnchor(), this._startAnchor.addEventListener("focus", this.startAnchorListener)), this._endAnchor || (this._endAnchor = this._createAnchor(), this._endAnchor.addEventListener("focus", this.endAnchorListener)) }), this._element.parentNode && (this._element.parentNode.insertBefore(this._startAnchor, this._element), this._element.parentNode.insertBefore(this._endAnchor, this._element.nextSibling), this._hasAttached = !0), this._hasAttached) } focusInitialElementWhenReady(fe) { return new Promise(F => { this._executeOnStable(() => F(this.focusInitialElement(fe))) }) } focusFirstTabbableElementWhenReady(fe) { return new Promise(F => { this._executeOnStable(() => F(this.focusFirstTabbableElement(fe))) }) } focusLastTabbableElementWhenReady(fe) { return new Promise(F => { this._executeOnStable(() => F(this.focusLastTabbableElement(fe))) }) } _getRegionBoundary(fe) { const F = this._element.querySelectorAll(`[cdk-focus-region-${fe}], [cdkFocusRegion${fe}], [cdk-focus-${fe}]`); return "start" == fe ? F.length ? F[0] : this._getFirstTabbableElement(this._element) : F.length ? F[F.length - 1] : this._getLastTabbableElement(this._element) } focusInitialElement(fe) { const F = this._element.querySelector("[cdk-focus-initial], [cdkFocusInitial]"); if (F) { if (!this._checker.isFocusable(F)) { const J = this._getFirstTabbableElement(F); return J?.focus(fe), !!J } return F.focus(fe), !0 } return this.focusFirstTabbableElement(fe) } focusFirstTabbableElement(fe) { const F = this._getRegionBoundary("start"); return F && F.focus(fe), !!F } focusLastTabbableElement(fe) { const F = this._getRegionBoundary("end"); return F && F.focus(fe), !!F } hasAttached() { return this._hasAttached } _getFirstTabbableElement(fe) { if (this._checker.isFocusable(fe) && this._checker.isTabbable(fe)) return fe; const F = fe.children; for (let J = 0; J < F.length; J++) { const Te = F[J].nodeType === this._document.ELEMENT_NODE ? this._getFirstTabbableElement(F[J]) : null; if (Te) return Te } return null } _getLastTabbableElement(fe) { if (this._checker.isFocusable(fe) && this._checker.isTabbable(fe)) return fe; const F = fe.children; for (let J = F.length - 1; J >= 0; J--) { const Te = F[J].nodeType === this._document.ELEMENT_NODE ? this._getLastTabbableElement(F[J]) : null; if (Te) return Te } return null } _createAnchor() { const fe = this._document.createElement("div"); return this._toggleAnchorTabIndex(this._enabled, fe), fe.classList.add("cdk-visually-hidden"), fe.classList.add("cdk-focus-trap-anchor"), fe.setAttribute("aria-hidden", "true"), fe } _toggleAnchorTabIndex(fe, F) { fe ? F.setAttribute("tabindex", "0") : F.removeAttribute("tabindex") } toggleAnchors(fe) { this._startAnchor && this._endAnchor && (this._toggleAnchorTabIndex(fe, this._startAnchor), this._toggleAnchorTabIndex(fe, this._endAnchor)) } _executeOnStable(fe) { this._ngZone.isStable ? fe() : this._ngZone.onStable.pipe((0, ze.q)(1)).subscribe(fe) } } let Me = (() => { class pe { constructor(F, J, Te) { this._checker = F, this._ngZone = J, this._document = Te } create(F, J = !1) { return new se(F, this._checker, this._ngZone, this._document, J) } } return pe.\u0275fac = function (F) { return new (F || pe)(y.LFG(Ae), y.LFG(y.R0b), y.LFG(a.K0)) }, pe.\u0275prov = y.Yz7({ token: pe, factory: pe.\u0275fac, providedIn: "root" }), pe })(); function ct(pe) { return 0 === pe.buttons || 0 === pe.offsetX && 0 === pe.offsetY } function Mt(pe) { const fe = pe.touches && pe.touches[0] || pe.changedTouches && pe.changedTouches[0]; return !(!fe || -1 !== fe.identifier || null != fe.radiusX && 1 !== fe.radiusX || null != fe.radiusY && 1 !== fe.radiusY) } const Qt = new y.OlP("cdk-input-modality-detector-options"), fn = { ignoreKeys: [re.zL, re.jx, re.b2, re.MW, re.JU] }, Ln = (0, v.i$)({ passive: !0, capture: !0 }); let In = (() => { class pe { get mostRecentModality() { return this._modality.value } constructor(F, J, Te, lt) { this._platform = F, this._mostRecentTarget = null, this._modality = new Se.X(null), this._lastTouchMs = 0, this._onKeydown = gt => { this._options?.ignoreKeys?.some(Ht => Ht === gt.keyCode) || (this._modality.next("keyboard"), this._mostRecentTarget = (0, v.sA)(gt)) }, this._onMousedown = gt => { Date.now() - this._lastTouchMs < 650 || (this._modality.next(ct(gt) ? "keyboard" : "mouse"), this._mostRecentTarget = (0, v.sA)(gt)) }, this._onTouchstart = gt => { Mt(gt) ? this._modality.next("keyboard") : (this._lastTouchMs = Date.now(), this._modality.next("touch"), this._mostRecentTarget = (0, v.sA)(gt)) }, this._options = { ...fn, ...lt }, this.modalityDetected = this._modality.pipe((0, Oe.T)(1)), this.modalityChanged = this.modalityDetected.pipe((0, We.x)()), F.isBrowser && J.runOutsideAngular(() => { Te.addEventListener("keydown", this._onKeydown, Ln), Te.addEventListener("mousedown", this._onMousedown, Ln), Te.addEventListener("touchstart", this._onTouchstart, Ln) }) } ngOnDestroy() { this._modality.complete(), this._platform.isBrowser && (document.removeEventListener("keydown", this._onKeydown, Ln), document.removeEventListener("mousedown", this._onMousedown, Ln), document.removeEventListener("touchstart", this._onTouchstart, Ln)) } } return pe.\u0275fac = function (F) { return new (F || pe)(y.LFG(v.t4), y.LFG(y.R0b), y.LFG(a.K0), y.LFG(Qt, 8)) }, pe.\u0275prov = y.Yz7({ token: pe, factory: pe.\u0275fac, providedIn: "root" }), pe })(); const Et = new y.OlP("liveAnnouncerElement", { providedIn: "root", factory: function _t() { return null } }), G = new y.OlP("LIVE_ANNOUNCER_DEFAULT_OPTIONS"); let W = 0, me = (() => { class pe { constructor(F, J, Te, lt) { this._ngZone = J, this._defaultOptions = lt, this._document = Te, this._liveElement = F || this._createLiveElement() } announce(F, ...J) { const Te = this._defaultOptions; let lt, gt; return 1 === J.length && "number" == typeof J[0] ? gt = J[0] : [lt, gt] = J, this.clear(), clearTimeout(this._previousTimeout), lt || (lt = Te && Te.politeness ? Te.politeness : "polite"), null == gt && Te && (gt = Te.duration), this._liveElement.setAttribute("aria-live", lt), this._liveElement.id && this._exposeAnnouncerToModals(this._liveElement.id), this._ngZone.runOutsideAngular(() => (this._currentPromise || (this._currentPromise = new Promise(Ht => this._currentResolve = Ht)), clearTimeout(this._previousTimeout), this._previousTimeout = setTimeout(() => { this._liveElement.textContent = F, "number" == typeof gt && (this._previousTimeout = setTimeout(() => this.clear(), gt)), this._currentResolve(), this._currentPromise = this._currentResolve = void 0 }, 100), this._currentPromise)) } clear() { this._liveElement && (this._liveElement.textContent = "") } ngOnDestroy() { clearTimeout(this._previousTimeout), this._liveElement?.remove(), this._liveElement = null, this._currentResolve?.(), this._currentPromise = this._currentResolve = void 0 } _createLiveElement() { const F = "cdk-live-announcer-element", J = this._document.getElementsByClassName(F), Te = this._document.createElement("div"); for (let lt = 0; lt < J.length; lt++)J[lt].remove(); return Te.classList.add(F), Te.classList.add("cdk-visually-hidden"), Te.setAttribute("aria-atomic", "true"), Te.setAttribute("aria-live", "polite"), Te.id = "cdk-live-announcer-" + W++, this._document.body.appendChild(Te), Te } _exposeAnnouncerToModals(F) { const J = this._document.querySelectorAll('body > .cdk-overlay-container [aria-modal="true"]'); for (let Te = 0; Te < J.length; Te++) { const lt = J[Te], gt = lt.getAttribute("aria-owns"); gt ? -1 === gt.indexOf(F) && lt.setAttribute("aria-owns", gt + " " + F) : lt.setAttribute("aria-owns", F) } } } return pe.\u0275fac = function (F) { return new (F || pe)(y.LFG(Et, 8), y.LFG(y.R0b), y.LFG(a.K0), y.LFG(G, 8)) }, pe.\u0275prov = y.Yz7({ token: pe, factory: pe.\u0275fac, providedIn: "root" }), pe })(); const st = new y.OlP("cdk-focus-monitor-default-options"), Lt = (0, v.i$)({ passive: !0, capture: !0 }); let He = (() => { class pe { constructor(F, J, Te, lt, gt) { this._ngZone = F, this._platform = J, this._inputModalityDetector = Te, this._origin = null, this._windowFocused = !1, this._originFromTouchInteraction = !1, this._elementInfo = new Map, this._monitoredElementCount = 0, this._rootNodeFocusListenerCount = new Map, this._windowFocusListener = () => { this._windowFocused = !0, this._windowFocusTimeoutId = window.setTimeout(() => this._windowFocused = !1) }, this._stopInputModalityDetector = new Y.x, this._rootNodeFocusAndBlurListener = Ht => { for (let yt = (0, v.sA)(Ht); yt; yt = yt.parentElement)"focus" === Ht.type ? this._onFocus(Ht, yt) : this._onBlur(Ht, yt) }, this._document = lt, this._detectionMode = gt?.detectionMode || 0 } monitor(F, J = !1) { const Te = (0, Ve.fI)(F); if (!this._platform.isBrowser || 1 !== Te.nodeType) return (0, ke.of)(); const lt = (0, v.kV)(Te) || this._getDocument(), gt = this._elementInfo.get(Te); if (gt) return J && (gt.checkChildren = !0), gt.subject; const Ht = { checkChildren: J, subject: new Y.x, rootNode: lt }; return this._elementInfo.set(Te, Ht), this._registerGlobalListeners(Ht), Ht.subject } stopMonitoring(F) { const J = (0, Ve.fI)(F), Te = this._elementInfo.get(J); Te && (Te.subject.complete(), this._setClasses(J), this._elementInfo.delete(J), this._removeGlobalListeners(Te)) } focusVia(F, J, Te) { const lt = (0, Ve.fI)(F); lt === this._getDocument().activeElement ? this._getClosestElementsInfo(lt).forEach(([Ht, un]) => this._originChanged(Ht, J, un)) : (this._setOrigin(J), "function" == typeof lt.focus && lt.focus(Te)) } ngOnDestroy() { this._elementInfo.forEach((F, J) => this.stopMonitoring(J)) } _getDocument() { return this._document || document } _getWindow() { return this._getDocument().defaultView || window } _getFocusOrigin(F) { return this._origin ? this._originFromTouchInteraction ? this._shouldBeAttributedToTouch(F) ? "touch" : "program" : this._origin : this._windowFocused && this._lastFocusOrigin ? this._lastFocusOrigin : F && this._isLastInteractionFromInputLabel(F) ? "mouse" : "program" } _shouldBeAttributedToTouch(F) { return 1 === this._detectionMode || !!F?.contains(this._inputModalityDetector._mostRecentTarget) } _setClasses(F, J) { F.classList.toggle("cdk-focused", !!J), F.classList.toggle("cdk-touch-focused", "touch" === J), F.classList.toggle("cdk-keyboard-focused", "keyboard" === J), F.classList.toggle("cdk-mouse-focused", "mouse" === J), F.classList.toggle("cdk-program-focused", "program" === J) } _setOrigin(F, J = !1) { this._ngZone.runOutsideAngular(() => { this._origin = F, this._originFromTouchInteraction = "touch" === F && J, 0 === this._detectionMode && (clearTimeout(this._originTimeoutId), this._originTimeoutId = setTimeout(() => this._origin = null, this._originFromTouchInteraction ? 650 : 1)) }) } _onFocus(F, J) { const Te = this._elementInfo.get(J), lt = (0, v.sA)(F); !Te || !Te.checkChildren && J !== lt || this._originChanged(J, this._getFocusOrigin(lt), Te) } _onBlur(F, J) { const Te = this._elementInfo.get(J); !Te || Te.checkChildren && F.relatedTarget instanceof Node && J.contains(F.relatedTarget) || (this._setClasses(J), this._emitOrigin(Te, null)) } _emitOrigin(F, J) { F.subject.observers.length && this._ngZone.run(() => F.subject.next(J)) } _registerGlobalListeners(F) { if (!this._platform.isBrowser) return; const J = F.rootNode, Te = this._rootNodeFocusListenerCount.get(J) || 0; Te || this._ngZone.runOutsideAngular(() => { J.addEventListener("focus", this._rootNodeFocusAndBlurListener, Lt), J.addEventListener("blur", this._rootNodeFocusAndBlurListener, Lt) }), this._rootNodeFocusListenerCount.set(J, Te + 1), 1 == ++this._monitoredElementCount && (this._ngZone.runOutsideAngular(() => { this._getWindow().addEventListener("focus", this._windowFocusListener) }), this._inputModalityDetector.modalityDetected.pipe((0, Pe.R)(this._stopInputModalityDetector)).subscribe(lt => { this._setOrigin(lt, !0) })) } _removeGlobalListeners(F) { const J = F.rootNode; if (this._rootNodeFocusListenerCount.has(J)) { const Te = this._rootNodeFocusListenerCount.get(J); Te > 1 ? this._rootNodeFocusListenerCount.set(J, Te - 1) : (J.removeEventListener("focus", this._rootNodeFocusAndBlurListener, Lt), J.removeEventListener("blur", this._rootNodeFocusAndBlurListener, Lt), this._rootNodeFocusListenerCount.delete(J)) } --this._monitoredElementCount || (this._getWindow().removeEventListener("focus", this._windowFocusListener), this._stopInputModalityDetector.next(), clearTimeout(this._windowFocusTimeoutId), clearTimeout(this._originTimeoutId)) } _originChanged(F, J, Te) { this._setClasses(F, J), this._emitOrigin(Te, J), this._lastFocusOrigin = J } _getClosestElementsInfo(F) { const J = []; return this._elementInfo.forEach((Te, lt) => { (lt === F || Te.checkChildren && lt.contains(F)) && J.push([lt, Te]) }), J } _isLastInteractionFromInputLabel(F) { const { _mostRecentTarget: J, mostRecentModality: Te } = this._inputModalityDetector; if ("mouse" !== Te || !J || J === F || "INPUT" !== F.nodeName && "TEXTAREA" !== F.nodeName || F.disabled) return !1; const lt = F.labels; if (lt) for (let gt = 0; gt < lt.length; gt++)if (lt[gt].contains(J)) return !0; return !1 } } return pe.\u0275fac = function (F) { return new (F || pe)(y.LFG(y.R0b), y.LFG(v.t4), y.LFG(In), y.LFG(a.K0, 8), y.LFG(st, 8)) }, pe.\u0275prov = y.Yz7({ token: pe, factory: pe.\u0275fac, providedIn: "root" }), pe })(), ae = (() => { class pe { constructor(F, J) { this._elementRef = F, this._focusMonitor = J, this._focusOrigin = null, this.cdkFocusChange = new y.vpe } get focusOrigin() { return this._focusOrigin } ngAfterViewInit() { const F = this._elementRef.nativeElement; this._monitorSubscription = this._focusMonitor.monitor(F, 1 === F.nodeType && F.hasAttribute("cdkMonitorSubtreeFocus")).subscribe(J => { this._focusOrigin = J, this.cdkFocusChange.emit(J) }) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef), this._monitorSubscription && this._monitorSubscription.unsubscribe() } } return pe.\u0275fac = function (F) { return new (F || pe)(y.Y36(y.SBq), y.Y36(He)) }, pe.\u0275dir = y.lG2({ type: pe, selectors: [["", "cdkMonitorElementFocus", ""], ["", "cdkMonitorSubtreeFocus", ""]], outputs: { cdkFocusChange: "cdkFocusChange" }, exportAs: ["cdkMonitorFocus"] }), pe })(); const z = "cdk-high-contrast-black-on-white", L = "cdk-high-contrast-white-on-black", H = "cdk-high-contrast-active"; let Ne = (() => { class pe { constructor(F, J) { this._platform = F, this._document = J, this._breakpointSubscription = (0, y.f3M)(Kt).observe("(forced-colors: active)").subscribe(() => { this._hasCheckedHighContrastMode && (this._hasCheckedHighContrastMode = !1, this._applyBodyHighContrastModeCssClasses()) }) } getHighContrastMode() { if (!this._platform.isBrowser) return 0; const F = this._document.createElement("div"); F.style.backgroundColor = "rgb(1,2,3)", F.style.position = "absolute", this._document.body.appendChild(F); const J = this._document.defaultView || window, Te = J && J.getComputedStyle ? J.getComputedStyle(F) : null, lt = (Te && Te.backgroundColor || "").replace(/ /g, ""); switch (F.remove(), lt) { case "rgb(0,0,0)": case "rgb(45,50,54)": case "rgb(32,32,32)": return 2; case "rgb(255,255,255)": case "rgb(255,250,239)": return 1 }return 0 } ngOnDestroy() { this._breakpointSubscription.unsubscribe() } _applyBodyHighContrastModeCssClasses() { if (!this._hasCheckedHighContrastMode && this._platform.isBrowser && this._document.body) { const F = this._document.body.classList; F.remove(H, z, L), this._hasCheckedHighContrastMode = !0; const J = this.getHighContrastMode(); 1 === J ? F.add(H, z) : 2 === J && F.add(H, L) } } } return pe.\u0275fac = function (F) { return new (F || pe)(y.LFG(v.t4), y.LFG(a.K0)) }, pe.\u0275prov = y.Yz7({ token: pe, factory: pe.\u0275fac, providedIn: "root" }), pe })(), pt = (() => { class pe { constructor(F) { F._applyBodyHighContrastModeCssClasses() } } return pe.\u0275fac = function (F) { return new (F || pe)(y.LFG(Ne)) }, pe.\u0275mod = y.oAB({ type: pe }), pe.\u0275inj = y.cJS({ imports: [tt.Q8] }), pe })() }, 9388: (nn, Qe, C) => { C.d(Qe, { Is: () => ke, vT: () => Ie }); var a = C(5879), y = C(6814); const v = new a.OlP("cdk-dir-doc", { providedIn: "root", factory: function Y() { return (0, a.f3M)(y.K0) } }), he = /^(ar|ckb|dv|he|iw|fa|nqo|ps|sd|ug|ur|yi|.*[-_](Adlm|Arab|Hebr|Nkoo|Rohg|Thaa))(?!.*[-_](Latn|Cyrl)($|-|_))($|-|_)/i; let ke = (() => { class Q { constructor(xe) { this.value = "ltr", this.change = new a.vpe, xe && (this.value = function Se(Q) { const _e = Q?.toLowerCase() || ""; return "auto" === _e && typeof navigator < "u" && navigator?.language ? he.test(navigator.language) ? "rtl" : "ltr" : "rtl" === _e ? "rtl" : "ltr" }((xe.body ? xe.body.dir : null) || (xe.documentElement ? xe.documentElement.dir : null) || "ltr")) } ngOnDestroy() { this.change.complete() } } return Q.\u0275fac = function (xe) { return new (xe || Q)(a.LFG(v, 8)) }, Q.\u0275prov = a.Yz7({ token: Q, factory: Q.\u0275fac, providedIn: "root" }), Q })(), Ie = (() => { class Q { } return Q.\u0275fac = function (xe) { return new (xe || Q) }, Q.\u0275mod = a.oAB({ type: Q }), Q.\u0275inj = a.cJS({}), Q })() }, 2495: (nn, Qe, C) => { C.d(Qe, { Eq: () => he, HM: () => Se, Ig: () => y, fI: () => ke, su: () => v, t6: () => Y }); var a = C(5879); function y(Ie) { return null != Ie && "false" != `${Ie}` } function v(Ie, Q = 0) { return Y(Ie) ? Number(Ie) : Q } function Y(Ie) { return !isNaN(parseFloat(Ie)) && !isNaN(Number(Ie)) } function he(Ie) { return Array.isArray(Ie) ? Ie : [Ie] } function Se(Ie) { return null == Ie ? "" : "string" == typeof Ie ? Ie : `${Ie}px` } function ke(Ie) { return Ie instanceof a.SBq ? Ie.nativeElement : Ie } }, 8337: (nn, Qe, C) => { C.d(Qe, { A8: () => _e, Ov: () => Ie, Z9: () => he, eX: () => re, k: () => xe, o2: () => Y, yy: () => ke }); var a = C(3168), y = C(8645), v = C(5879); class Y { } function he(ze) { return ze && "function" == typeof ze.connect && !(ze instanceof a.c) } class ke { applyChanges(Oe, We, Pe, Ve, tt) { Oe.forEachOperation((Ye, ut, ie) => { let Le, le; if (null == Ye.previousIndex) { const ge = Pe(Ye, ut, ie); Le = We.createEmbeddedView(ge.templateRef, ge.context, ge.index), le = 1 } else null == ie ? (We.remove(ut), le = 3) : (Le = We.get(ut), We.move(Le, ie), le = 2); tt && tt({ context: Le?.context, operation: le, record: Ye }) }) } detach() { } } class re { constructor() { this.viewCacheSize = 20, this._viewCache = [] } applyChanges(Oe, We, Pe, Ve, tt) { Oe.forEachOperation((Ye, ut, ie) => { let Le, le; null == Ye.previousIndex ? (Le = this._insertView(() => Pe(Ye, ut, ie), ie, We, Ve(Ye)), le = Le ? 1 : 0) : null == ie ? (this._detachAndCacheView(ut, We), le = 3) : (Le = this._moveView(ut, ie, We, Ve(Ye)), le = 2), tt && tt({ context: Le?.context, operation: le, record: Ye }) }) } detach() { for (const Oe of this._viewCache) Oe.destroy(); this._viewCache = [] } _insertView(Oe, We, Pe, Ve) { const tt = this._insertViewFromCache(We, Pe); if (tt) return void (tt.context.$implicit = Ve); const Ye = Oe(); return Pe.createEmbeddedView(Ye.templateRef, Ye.context, Ye.index) } _detachAndCacheView(Oe, We) { const Pe = We.detach(Oe); this._maybeCacheView(Pe, We) } _moveView(Oe, We, Pe, Ve) { const tt = Pe.get(Oe); return Pe.move(tt, We), tt.context.$implicit = Ve, tt } _maybeCacheView(Oe, We) { if (this._viewCache.length < this.viewCacheSize) this._viewCache.push(Oe); else { const Pe = We.indexOf(Oe); -1 === Pe ? Oe.destroy() : We.remove(Pe) } } _insertViewFromCache(Oe, We) { const Pe = this._viewCache.pop(); return Pe && We.insert(Pe, Oe), Pe || null } } class Ie { get selected() { return this._selected || (this._selected = Array.from(this._selection.values())), this._selected } constructor(Oe = !1, We, Pe = !0, Ve) { this._multiple = Oe, this._emitChanges = Pe, this.compareWith = Ve, this._selection = new Set, this._deselectedToEmit = [], this._selectedToEmit = [], this.changed = new y.x, We && We.length && (Oe ? We.forEach(tt => this._markSelected(tt)) : this._markSelected(We[0]), this._selectedToEmit.length = 0) } select(...Oe) { this._verifyValueAssignment(Oe), Oe.forEach(Pe => this._markSelected(Pe)); const We = this._hasQueuedChanges(); return this._emitChangeEvent(), We } deselect(...Oe) { this._verifyValueAssignment(Oe), Oe.forEach(Pe => this._unmarkSelected(Pe)); const We = this._hasQueuedChanges(); return this._emitChangeEvent(), We } setSelection(...Oe) { this._verifyValueAssignment(Oe); const We = this.selected, Pe = new Set(Oe); Oe.forEach(tt => this._markSelected(tt)), We.filter(tt => !Pe.has(tt)).forEach(tt => this._unmarkSelected(tt)); const Ve = this._hasQueuedChanges(); return this._emitChangeEvent(), Ve } toggle(Oe) { return this.isSelected(Oe) ? this.deselect(Oe) : this.select(Oe) } clear(Oe = !0) { this._unmarkAll(); const We = this._hasQueuedChanges(); return Oe && this._emitChangeEvent(), We } isSelected(Oe) { return this._selection.has(this._getConcreteValue(Oe)) } isEmpty() { return 0 === this._selection.size } hasValue() { return !this.isEmpty() } sort(Oe) { this._multiple && this.selected && this._selected.sort(Oe) } isMultipleSelection() { return this._multiple } _emitChangeEvent() { this._selected = null, (this._selectedToEmit.length || this._deselectedToEmit.length) && (this.changed.next({ source: this, added: this._selectedToEmit, removed: this._deselectedToEmit }), this._deselectedToEmit = [], this._selectedToEmit = []) } _markSelected(Oe) { Oe = this._getConcreteValue(Oe), this.isSelected(Oe) || (this._multiple || this._unmarkAll(), this.isSelected(Oe) || this._selection.add(Oe), this._emitChanges && this._selectedToEmit.push(Oe)) } _unmarkSelected(Oe) { Oe = this._getConcreteValue(Oe), this.isSelected(Oe) && (this._selection.delete(Oe), this._emitChanges && this._deselectedToEmit.push(Oe)) } _unmarkAll() { this.isEmpty() || this._selection.forEach(Oe => this._unmarkSelected(Oe)) } _verifyValueAssignment(Oe) { } _hasQueuedChanges() { return !(!this._deselectedToEmit.length && !this._selectedToEmit.length) } _getConcreteValue(Oe) { if (this.compareWith) { for (let We of this._selection) if (this.compareWith(Oe, We)) return We; return Oe } return Oe } } let _e = (() => { class ze { constructor() { this._listeners = [] } notify(We, Pe) { for (let Ve of this._listeners) Ve(We, Pe) } listen(We) { return this._listeners.push(We), () => { this._listeners = this._listeners.filter(Pe => We !== Pe) } } ngOnDestroy() { this._listeners = [] } } return ze.\u0275fac = function (We) { return new (We || ze) }, ze.\u0275prov = v.Yz7({ token: ze, factory: ze.\u0275fac, providedIn: "root" }), ze })(); const xe = new v.OlP("_ViewRepeater") }, 6028: (nn, Qe, C) => { C.d(Qe, { A: () => it, JH: () => ut, JU: () => Se, K5: () => he, Ku: () => ze, LH: () => tt, L_: () => xe, MW: () => Ue, Mf: () => v, SV: () => Ye, Sd: () => Pe, VM: () => Oe, Vb: () => Jo, Z: () => ve, aO: () => Wn, b2: () => fo, hY: () => _e, jx: () => ke, oh: () => Ve, uR: () => We, xE: () => ue, zL: () => re }); const v = 9, he = 13, Se = 16, ke = 17, re = 18, _e = 27, xe = 32, ze = 33, Oe = 34, We = 35, Pe = 36, Ve = 37, tt = 38, Ye = 39, ut = 40, ue = 48, Wn = 57, it = 65, ve = 90, Ue = 91, fo = 224; function Jo(sr, ...wt) { return wt.length ? wt.some(bt => sr[bt]) : sr.altKey || sr.shiftKey || sr.ctrlKey || sr.metaKey } }, 7131: (nn, Qe, C) => { C.d(Qe, { Q8: () => Ie, wD: () => re }); var a = C(2495), y = C(5879), v = C(5592), Y = C(8645), he = C(3620); let Se = (() => { class Q { create(xe) { return typeof MutationObserver > "u" ? null : new MutationObserver(xe) } } return Q.\u0275fac = function (xe) { return new (xe || Q) }, Q.\u0275prov = y.Yz7({ token: Q, factory: Q.\u0275fac, providedIn: "root" }), Q })(), ke = (() => { class Q { constructor(xe) { this._mutationObserverFactory = xe, this._observedElements = new Map } ngOnDestroy() { this._observedElements.forEach((xe, ze) => this._cleanupObserver(ze)) } observe(xe) { const ze = (0, a.fI)(xe); return new v.y(Oe => { const Pe = this._observeElement(ze).subscribe(Oe); return () => { Pe.unsubscribe(), this._unobserveElement(ze) } }) } _observeElement(xe) { if (this._observedElements.has(xe)) this._observedElements.get(xe).count++; else { const ze = new Y.x, Oe = this._mutationObserverFactory.create(We => ze.next(We)); Oe && Oe.observe(xe, { characterData: !0, childList: !0, subtree: !0 }), this._observedElements.set(xe, { observer: Oe, stream: ze, count: 1 }) } return this._observedElements.get(xe).stream } _unobserveElement(xe) { this._observedElements.has(xe) && (this._observedElements.get(xe).count--, this._observedElements.get(xe).count || this._cleanupObserver(xe)) } _cleanupObserver(xe) { if (this._observedElements.has(xe)) { const { observer: ze, stream: Oe } = this._observedElements.get(xe); ze && ze.disconnect(), Oe.complete(), this._observedElements.delete(xe) } } } return Q.\u0275fac = function (xe) { return new (xe || Q)(y.LFG(Se)) }, Q.\u0275prov = y.Yz7({ token: Q, factory: Q.\u0275fac, providedIn: "root" }), Q })(), re = (() => { class Q { get disabled() { return this._disabled } set disabled(xe) { this._disabled = (0, a.Ig)(xe), this._disabled ? this._unsubscribe() : this._subscribe() } get debounce() { return this._debounce } set debounce(xe) { this._debounce = (0, a.su)(xe), this._subscribe() } constructor(xe, ze, Oe) { this._contentObserver = xe, this._elementRef = ze, this._ngZone = Oe, this.event = new y.vpe, this._disabled = !1, this._currentSubscription = null } ngAfterContentInit() { !this._currentSubscription && !this.disabled && this._subscribe() } ngOnDestroy() { this._unsubscribe() } _subscribe() { this._unsubscribe(); const xe = this._contentObserver.observe(this._elementRef); this._ngZone.runOutsideAngular(() => { this._currentSubscription = (this.debounce ? xe.pipe((0, he.b)(this.debounce)) : xe).subscribe(this.event) }) } _unsubscribe() { this._currentSubscription?.unsubscribe() } } return Q.\u0275fac = function (xe) { return new (xe || Q)(y.Y36(ke), y.Y36(y.SBq), y.Y36(y.R0b)) }, Q.\u0275dir = y.lG2({ type: Q, selectors: [["", "cdkObserveContent", ""]], inputs: { disabled: ["cdkObserveContentDisabled", "disabled"], debounce: "debounce" }, outputs: { event: "cdkObserveContent" }, exportAs: ["cdkObserveContent"] }), Q })(), Ie = (() => { class Q { } return Q.\u0275fac = function (xe) { return new (xe || Q) }, Q.\u0275mod = y.oAB({ type: Q }), Q.\u0275inj = y.cJS({ providers: [Se] }), Q })() }, 3651: (nn, Qe, C) => { C.d(Qe, { pI: () => on, xu: () => Nt, aV: () => jt, X_: () => $e, Xj: () => at, U8: () => $n, Iu: () => vt }); var a = C(9829), y = C(6814), v = C(5879), Y = C(2495), he = C(2831), Se = C(2181), ke = C(8180), re = C(9773), Ie = C(9360), Q = C(8251), xe = C(9388), ze = C(8484), Oe = C(8645), We = C(7394), Pe = C(3019), Ve = C(6028); const tt = (0, he.Mq)(); class Ye { constructor(se, Me) { this._viewportRuler = se, this._previousHTMLStyles = { top: "", left: "" }, this._isEnabled = !1, this._document = Me } attach() { } enable() { if (this._canBeEnabled()) { const se = this._document.documentElement; this._previousScrollPosition = this._viewportRuler.getViewportScrollPosition(), this._previousHTMLStyles.left = se.style.left || "", this._previousHTMLStyles.top = se.style.top || "", se.style.left = (0, Y.HM)(-this._previousScrollPosition.left), se.style.top = (0, Y.HM)(-this._previousScrollPosition.top), se.classList.add("cdk-global-scrollblock"), this._isEnabled = !0 } } disable() { if (this._isEnabled) { const se = this._document.documentElement, Xe = se.style, Ot = this._document.body.style, ve = Xe.scrollBehavior || "", Ue = Ot.scrollBehavior || ""; this._isEnabled = !1, Xe.left = this._previousHTMLStyles.left, Xe.top = this._previousHTMLStyles.top, se.classList.remove("cdk-global-scrollblock"), tt && (Xe.scrollBehavior = Ot.scrollBehavior = "auto"), window.scroll(this._previousScrollPosition.left, this._previousScrollPosition.top), tt && (Xe.scrollBehavior = ve, Ot.scrollBehavior = Ue) } } _canBeEnabled() { if (this._document.documentElement.classList.contains("cdk-global-scrollblock") || this._isEnabled) return !1; const Me = this._document.body, Xe = this._viewportRuler.getViewportSize(); return Me.scrollHeight > Xe.height || Me.scrollWidth > Xe.width } } class ie { constructor(se, Me, Xe, Ot) { this._scrollDispatcher = se, this._ngZone = Me, this._viewportRuler = Xe, this._config = Ot, this._scrollSubscription = null, this._detach = () => { this.disable(), this._overlayRef.hasAttached() && this._ngZone.run(() => this._overlayRef.detach()) } } attach(se) { this._overlayRef = se } enable() { if (this._scrollSubscription) return; const se = this._scrollDispatcher.scrolled(0).pipe((0, Se.h)(Me => !Me || !this._overlayRef.overlayElement.contains(Me.getElementRef().nativeElement))); this._config && this._config.threshold && this._config.threshold > 1 ? (this._initialScrollPosition = this._viewportRuler.getViewportScrollPosition().top, this._scrollSubscription = se.subscribe(() => { const Me = this._viewportRuler.getViewportScrollPosition().top; Math.abs(Me - this._initialScrollPosition) > this._config.threshold ? this._detach() : this._overlayRef.updatePosition() })) : this._scrollSubscription = se.subscribe(this._detach) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } class Le { enable() { } disable() { } attach() { } } function le(Ke, se) { return se.some(Me => Ke.bottom < Me.top || Ke.top > Me.bottom || Ke.right < Me.left || Ke.left > Me.right) } function ge(Ke, se) { return se.some(Me => Ke.top < Me.top || Ke.bottom > Me.bottom || Ke.left < Me.left || Ke.right > Me.right) } class ue { constructor(se, Me, Xe, Ot) { this._scrollDispatcher = se, this._viewportRuler = Me, this._ngZone = Xe, this._config = Ot, this._scrollSubscription = null } attach(se) { this._overlayRef = se } enable() { this._scrollSubscription || (this._scrollSubscription = this._scrollDispatcher.scrolled(this._config ? this._config.scrollThrottle : 0).subscribe(() => { if (this._overlayRef.updatePosition(), this._config && this._config.autoClose) { const Me = this._overlayRef.overlayElement.getBoundingClientRect(), { width: Xe, height: Ot } = this._viewportRuler.getViewportSize(); le(Me, [{ width: Xe, height: Ot, bottom: Ot, right: Xe, top: 0, left: 0 }]) && (this.disable(), this._ngZone.run(() => this._overlayRef.detach())) } })) } disable() { this._scrollSubscription && (this._scrollSubscription.unsubscribe(), this._scrollSubscription = null) } detach() { this.disable(), this._overlayRef = null } } let ee = (() => { class Ke { constructor(Me, Xe, Ot, ve) { this._scrollDispatcher = Me, this._viewportRuler = Xe, this._ngZone = Ot, this.noop = () => new Le, this.close = Ue => new ie(this._scrollDispatcher, this._ngZone, this._viewportRuler, Ue), this.block = () => new Ye(this._viewportRuler, this._document), this.reposition = Ue => new ue(this._scrollDispatcher, this._viewportRuler, this._ngZone, Ue), this._document = ve } } return Ke.\u0275fac = function (Me) { return new (Me || Ke)(v.LFG(a.mF), v.LFG(a.rL), v.LFG(v.R0b), v.LFG(y.K0)) }, Ke.\u0275prov = v.Yz7({ token: Ke, factory: Ke.\u0275fac, providedIn: "root" }), Ke })(); class $e { constructor(se) { if (this.scrollStrategy = new Le, this.panelClass = "", this.hasBackdrop = !1, this.backdropClass = "cdk-overlay-dark-backdrop", this.disposeOnNavigation = !1, se) { const Me = Object.keys(se); for (const Xe of Me) void 0 !== se[Xe] && (this[Xe] = se[Xe]) } } } class bn { constructor(se, Me) { this.connectionPair = se, this.scrollableViewProperties = Me } } let On = (() => { class Ke { constructor(Me) { this._attachedOverlays = [], this._document = Me } ngOnDestroy() { this.detach() } add(Me) { this.remove(Me), this._attachedOverlays.push(Me) } remove(Me) { const Xe = this._attachedOverlays.indexOf(Me); Xe > -1 && this._attachedOverlays.splice(Xe, 1), 0 === this._attachedOverlays.length && this.detach() } } return Ke.\u0275fac = function (Me) { return new (Me || Ke)(v.LFG(y.K0)) }, Ke.\u0275prov = v.Yz7({ token: Ke, factory: Ke.\u0275fac, providedIn: "root" }), Ke })(), Wn = (() => { class Ke extends On { constructor(Me, Xe) { super(Me), this._ngZone = Xe, this._keydownListener = Ot => { const ve = this._attachedOverlays; for (let Ue = ve.length - 1; Ue > -1; Ue--)if (ve[Ue]._keydownEvents.observers.length > 0) { const Z = ve[Ue]._keydownEvents; this._ngZone ? this._ngZone.run(() => Z.next(Ot)) : Z.next(Ot); break } } } add(Me) { super.add(Me), this._isAttached || (this._ngZone ? this._ngZone.runOutsideAngular(() => this._document.body.addEventListener("keydown", this._keydownListener)) : this._document.body.addEventListener("keydown", this._keydownListener), this._isAttached = !0) } detach() { this._isAttached && (this._document.body.removeEventListener("keydown", this._keydownListener), this._isAttached = !1) } } return Ke.\u0275fac = function (Me) { return new (Me || Ke)(v.LFG(y.K0), v.LFG(v.R0b, 8)) }, Ke.\u0275prov = v.Yz7({ token: Ke, factory: Ke.\u0275fac, providedIn: "root" }), Ke })(), Hn = (() => { class Ke extends On { constructor(Me, Xe, Ot) { super(Me), this._platform = Xe, this._ngZone = Ot, this._cursorStyleIsSet = !1, this._pointerDownListener = ve => { this._pointerDownEventTarget = (0, he.sA)(ve) }, this._clickListener = ve => { const Ue = (0, he.sA)(ve), Z = "click" === ve.type && this._pointerDownEventTarget ? this._pointerDownEventTarget : Ue; this._pointerDownEventTarget = null; const Fe = this._attachedOverlays.slice(); for (let ct = Fe.length - 1; ct > -1; ct--) { const Mt = Fe[ct]; if (Mt._outsidePointerEvents.observers.length < 1 || !Mt.hasAttached()) continue; if (Mt.overlayElement.contains(Ue) || Mt.overlayElement.contains(Z)) break; const Qt = Mt._outsidePointerEvents; this._ngZone ? this._ngZone.run(() => Qt.next(ve)) : Qt.next(ve) } } } add(Me) { if (super.add(Me), !this._isAttached) { const Xe = this._document.body; this._ngZone ? this._ngZone.runOutsideAngular(() => this._addEventListeners(Xe)) : this._addEventListeners(Xe), this._platform.IOS && !this._cursorStyleIsSet && (this._cursorOriginalValue = Xe.style.cursor, Xe.style.cursor = "pointer", this._cursorStyleIsSet = !0), this._isAttached = !0 } } detach() { if (this._isAttached) { const Me = this._document.body; Me.removeEventListener("pointerdown", this._pointerDownListener, !0), Me.removeEventListener("click", this._clickListener, !0), Me.removeEventListener("auxclick", this._clickListener, !0), Me.removeEventListener("contextmenu", this._clickListener, !0), this._platform.IOS && this._cursorStyleIsSet && (Me.style.cursor = this._cursorOriginalValue, this._cursorStyleIsSet = !1), this._isAttached = !1 } } _addEventListeners(Me) { Me.addEventListener("pointerdown", this._pointerDownListener, !0), Me.addEventListener("click", this._clickListener, !0), Me.addEventListener("auxclick", this._clickListener, !0), Me.addEventListener("contextmenu", this._clickListener, !0) } } return Ke.\u0275fac = function (Me) { return new (Me || Ke)(v.LFG(y.K0), v.LFG(he.t4), v.LFG(v.R0b, 8)) }, Ke.\u0275prov = v.Yz7({ token: Ke, factory: Ke.\u0275fac, providedIn: "root" }), Ke })(), at = (() => { class Ke { constructor(Me, Xe) { this._platform = Xe, this._document = Me } ngOnDestroy() { this._containerElement?.remove() } getContainerElement() { return this._containerElement || this._createContainer(), this._containerElement } _createContainer() { const Me = "cdk-overlay-container"; if (this._platform.isBrowser || (0, he.Oy)()) { const Ot = this._document.querySelectorAll(`.${Me}[platform="server"], .${Me}[platform="test"]`); for (let ve = 0; ve < Ot.length; ve++)Ot[ve].remove() } const Xe = this._document.createElement("div"); Xe.classList.add(Me), (0, he.Oy)() ? Xe.setAttribute("platform", "test") : this._platform.isBrowser || Xe.setAttribute("platform", "server"), this._document.body.appendChild(Xe), this._containerElement = Xe } } return Ke.\u0275fac = function (Me) { return new (Me || Ke)(v.LFG(y.K0), v.LFG(he.t4)) }, Ke.\u0275prov = v.Yz7({ token: Ke, factory: Ke.\u0275fac, providedIn: "root" }), Ke })(); class vt { constructor(se, Me, Xe, Ot, ve, Ue, Z, Fe, ct, Mt = !1) { this._portalOutlet = se, this._host = Me, this._pane = Xe, this._config = Ot, this._ngZone = ve, this._keyboardDispatcher = Ue, this._document = Z, this._location = Fe, this._outsideClickDispatcher = ct, this._animationsDisabled = Mt, this._backdropElement = null, this._backdropClick = new Oe.x, this._attachments = new Oe.x, this._detachments = new Oe.x, this._locationChanges = We.w0.EMPTY, this._backdropClickHandler = Qt => this._backdropClick.next(Qt), this._backdropTransitionendHandler = Qt => { this._disposeBackdrop(Qt.target) }, this._keydownEvents = new Oe.x, this._outsidePointerEvents = new Oe.x, Ot.scrollStrategy && (this._scrollStrategy = Ot.scrollStrategy, this._scrollStrategy.attach(this)), this._positionStrategy = Ot.positionStrategy } get overlayElement() { return this._pane } get backdropElement() { return this._backdropElement } get hostElement() { return this._host } attach(se) { !this._host.parentElement && this._previousHostParent && this._previousHostParent.appendChild(this._host); const Me = this._portalOutlet.attach(se); return this._positionStrategy && this._positionStrategy.attach(this), this._updateStackingOrder(), this._updateElementSize(), this._updateElementDirection(), this._scrollStrategy && this._scrollStrategy.enable(), this._ngZone.onStable.pipe((0, ke.q)(1)).subscribe(() => { this.hasAttached() && this.updatePosition() }), this._togglePointerEvents(!0), this._config.hasBackdrop && this._attachBackdrop(), this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !0), this._attachments.next(), this._keyboardDispatcher.add(this), this._config.disposeOnNavigation && (this._locationChanges = this._location.subscribe(() => this.dispose())), this._outsideClickDispatcher.add(this), "function" == typeof Me?.onDestroy && Me.onDestroy(() => { this.hasAttached() && this._ngZone.runOutsideAngular(() => Promise.resolve().then(() => this.detach())) }), Me } detach() { if (!this.hasAttached()) return; this.detachBackdrop(), this._togglePointerEvents(!1), this._positionStrategy && this._positionStrategy.detach && this._positionStrategy.detach(), this._scrollStrategy && this._scrollStrategy.disable(); const se = this._portalOutlet.detach(); return this._detachments.next(), this._keyboardDispatcher.remove(this), this._detachContentWhenStable(), this._locationChanges.unsubscribe(), this._outsideClickDispatcher.remove(this), se } dispose() { const se = this.hasAttached(); this._positionStrategy && this._positionStrategy.dispose(), this._disposeScrollStrategy(), this._disposeBackdrop(this._backdropElement), this._locationChanges.unsubscribe(), this._keyboardDispatcher.remove(this), this._portalOutlet.dispose(), this._attachments.complete(), this._backdropClick.complete(), this._keydownEvents.complete(), this._outsidePointerEvents.complete(), this._outsideClickDispatcher.remove(this), this._host?.remove(), this._previousHostParent = this._pane = this._host = null, se && this._detachments.next(), this._detachments.complete() } hasAttached() { return this._portalOutlet.hasAttached() } backdropClick() { return this._backdropClick } attachments() { return this._attachments } detachments() { return this._detachments } keydownEvents() { return this._keydownEvents } outsidePointerEvents() { return this._outsidePointerEvents } getConfig() { return this._config } updatePosition() { this._positionStrategy && this._positionStrategy.apply() } updatePositionStrategy(se) { se !== this._positionStrategy && (this._positionStrategy && this._positionStrategy.dispose(), this._positionStrategy = se, this.hasAttached() && (se.attach(this), this.updatePosition())) } updateSize(se) { this._config = { ...this._config, ...se }, this._updateElementSize() } setDirection(se) { this._config = { ...this._config, direction: se }, this._updateElementDirection() } addPanelClass(se) { this._pane && this._toggleClasses(this._pane, se, !0) } removePanelClass(se) { this._pane && this._toggleClasses(this._pane, se, !1) } getDirection() { const se = this._config.direction; return se ? "string" == typeof se ? se : se.value : "ltr" } updateScrollStrategy(se) { se !== this._scrollStrategy && (this._disposeScrollStrategy(), this._scrollStrategy = se, this.hasAttached() && (se.attach(this), se.enable())) } _updateElementDirection() { this._host.setAttribute("dir", this.getDirection()) } _updateElementSize() { if (!this._pane) return; const se = this._pane.style; se.width = (0, Y.HM)(this._config.width), se.height = (0, Y.HM)(this._config.height), se.minWidth = (0, Y.HM)(this._config.minWidth), se.minHeight = (0, Y.HM)(this._config.minHeight), se.maxWidth = (0, Y.HM)(this._config.maxWidth), se.maxHeight = (0, Y.HM)(this._config.maxHeight) } _togglePointerEvents(se) { this._pane.style.pointerEvents = se ? "" : "none" } _attachBackdrop() { const se = "cdk-overlay-backdrop-showing"; this._backdropElement = this._document.createElement("div"), this._backdropElement.classList.add("cdk-overlay-backdrop"), this._animationsDisabled && this._backdropElement.classList.add("cdk-overlay-backdrop-noop-animation"), this._config.backdropClass && this._toggleClasses(this._backdropElement, this._config.backdropClass, !0), this._host.parentElement.insertBefore(this._backdropElement, this._host), this._backdropElement.addEventListener("click", this._backdropClickHandler), !this._animationsDisabled && typeof requestAnimationFrame < "u" ? this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => { this._backdropElement && this._backdropElement.classList.add(se) }) }) : this._backdropElement.classList.add(se) } _updateStackingOrder() { this._host.nextSibling && this._host.parentNode.appendChild(this._host) } detachBackdrop() { const se = this._backdropElement; if (se) { if (this._animationsDisabled) return void this._disposeBackdrop(se); se.classList.remove("cdk-overlay-backdrop-showing"), this._ngZone.runOutsideAngular(() => { se.addEventListener("transitionend", this._backdropTransitionendHandler) }), se.style.pointerEvents = "none", this._backdropTimeout = this._ngZone.runOutsideAngular(() => setTimeout(() => { this._disposeBackdrop(se) }, 500)) } } _toggleClasses(se, Me, Xe) { const Ot = (0, Y.Eq)(Me || []).filter(ve => !!ve); Ot.length && (Xe ? se.classList.add(...Ot) : se.classList.remove(...Ot)) } _detachContentWhenStable() { this._ngZone.runOutsideAngular(() => { const se = this._ngZone.onStable.pipe((0, re.R)((0, Pe.T)(this._attachments, this._detachments))).subscribe(() => { (!this._pane || !this._host || 0 === this._pane.children.length) && (this._pane && this._config.panelClass && this._toggleClasses(this._pane, this._config.panelClass, !1), this._host && this._host.parentElement && (this._previousHostParent = this._host.parentElement, this._host.remove()), se.unsubscribe()) }) }) } _disposeScrollStrategy() { const se = this._scrollStrategy; se && (se.disable(), se.detach && se.detach()) } _disposeBackdrop(se) { se && (se.removeEventListener("click", this._backdropClickHandler), se.removeEventListener("transitionend", this._backdropTransitionendHandler), se.remove(), this._backdropElement === se && (this._backdropElement = null)), this._backdropTimeout && (clearTimeout(this._backdropTimeout), this._backdropTimeout = void 0) } } const xt = "cdk-overlay-connected-position-bounding-box", it = /([A-Za-z%]+)$/; class Ft { get positions() { return this._preferredPositions } constructor(se, Me, Xe, Ot, ve) { this._viewportRuler = Me, this._document = Xe, this._platform = Ot, this._overlayContainer = ve, this._lastBoundingBoxSize = { width: 0, height: 0 }, this._isPushed = !1, this._canPush = !0, this._growAfterOpen = !1, this._hasFlexibleDimensions = !0, this._positionLocked = !1, this._viewportMargin = 0, this._scrollables = [], this._preferredPositions = [], this._positionChanges = new Oe.x, this._resizeSubscription = We.w0.EMPTY, this._offsetX = 0, this._offsetY = 0, this._appliedPanelClasses = [], this.positionChanges = this._positionChanges, this.setOrigin(se) } attach(se) { this._validatePositions(), se.hostElement.classList.add(xt), this._overlayRef = se, this._boundingBox = se.hostElement, this._pane = se.overlayElement, this._isDisposed = !1, this._isInitialRender = !0, this._lastPosition = null, this._resizeSubscription.unsubscribe(), this._resizeSubscription = this._viewportRuler.change().subscribe(() => { this._isInitialRender = !0, this.apply() }) } apply() { if (this._isDisposed || !this._platform.isBrowser) return; if (!this._isInitialRender && this._positionLocked && this._lastPosition) return void this.reapplyLastPosition(); this._clearPanelClasses(), this._resetOverlayElementStyles(), this._resetBoundingBoxStyles(), this._viewportRect = this._getNarrowedViewportRect(), this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect(); const se = this._originRect, Me = this._overlayRect, Xe = this._viewportRect, Ot = this._containerRect, ve = []; let Ue; for (let Z of this._preferredPositions) { let Fe = this._getOriginPoint(se, Ot, Z), ct = this._getOverlayPoint(Fe, Me, Z), Mt = this._getOverlayFit(ct, Me, Xe, Z); if (Mt.isCompletelyWithinViewport) return this._isPushed = !1, void this._applyPosition(Z, Fe); this._canFitWithFlexibleDimensions(Mt, ct, Xe) ? ve.push({ position: Z, origin: Fe, overlayRect: Me, boundingBoxRect: this._calculateBoundingBoxRect(Fe, Z) }) : (!Ue || Ue.overlayFit.visibleArea < Mt.visibleArea) && (Ue = { overlayFit: Mt, overlayPoint: ct, originPoint: Fe, position: Z, overlayRect: Me }) } if (ve.length) { let Z = null, Fe = -1; for (const ct of ve) { const Mt = ct.boundingBoxRect.width * ct.boundingBoxRect.height * (ct.position.weight || 1); Mt > Fe && (Fe = Mt, Z = ct) } return this._isPushed = !1, void this._applyPosition(Z.position, Z.origin) } if (this._canPush) return this._isPushed = !0, void this._applyPosition(Ue.position, Ue.originPoint); this._applyPosition(Ue.position, Ue.originPoint) } detach() { this._clearPanelClasses(), this._lastPosition = null, this._previousPushAmount = null, this._resizeSubscription.unsubscribe() } dispose() { this._isDisposed || (this._boundingBox && Wt(this._boundingBox.style, { top: "", left: "", right: "", bottom: "", height: "", width: "", alignItems: "", justifyContent: "" }), this._pane && this._resetOverlayElementStyles(), this._overlayRef && this._overlayRef.hostElement.classList.remove(xt), this.detach(), this._positionChanges.complete(), this._overlayRef = this._boundingBox = null, this._isDisposed = !0) } reapplyLastPosition() { if (this._isDisposed || !this._platform.isBrowser) return; const se = this._lastPosition; if (se) { this._originRect = this._getOriginRect(), this._overlayRect = this._pane.getBoundingClientRect(), this._viewportRect = this._getNarrowedViewportRect(), this._containerRect = this._overlayContainer.getContainerElement().getBoundingClientRect(); const Me = this._getOriginPoint(this._originRect, this._containerRect, se); this._applyPosition(se, Me) } else this.apply() } withScrollableContainers(se) { return this._scrollables = se, this } withPositions(se) { return this._preferredPositions = se, -1 === se.indexOf(this._lastPosition) && (this._lastPosition = null), this._validatePositions(), this } withViewportMargin(se) { return this._viewportMargin = se, this } withFlexibleDimensions(se = !0) { return this._hasFlexibleDimensions = se, this } withGrowAfterOpen(se = !0) { return this._growAfterOpen = se, this } withPush(se = !0) { return this._canPush = se, this } withLockedPosition(se = !0) { return this._positionLocked = se, this } setOrigin(se) { return this._origin = se, this } withDefaultOffsetX(se) { return this._offsetX = se, this } withDefaultOffsetY(se) { return this._offsetY = se, this } withTransformOriginOn(se) { return this._transformOriginSelector = se, this } _getOriginPoint(se, Me, Xe) { let Ot, ve; if ("center" == Xe.originX) Ot = se.left + se.width / 2; else { const Ue = this._isRtl() ? se.right : se.left, Z = this._isRtl() ? se.left : se.right; Ot = "start" == Xe.originX ? Ue : Z } return Me.left < 0 && (Ot -= Me.left), ve = "center" == Xe.originY ? se.top + se.height / 2 : "top" == Xe.originY ? se.top : se.bottom, Me.top < 0 && (ve -= Me.top), { x: Ot, y: ve } } _getOverlayPoint(se, Me, Xe) { let Ot, ve; return Ot = "center" == Xe.overlayX ? -Me.width / 2 : "start" === Xe.overlayX ? this._isRtl() ? -Me.width : 0 : this._isRtl() ? 0 : -Me.width, ve = "center" == Xe.overlayY ? -Me.height / 2 : "top" == Xe.overlayY ? 0 : -Me.height, { x: se.x + Ot, y: se.y + ve } } _getOverlayFit(se, Me, Xe, Ot) { const ve = Jt(Me); let { x: Ue, y: Z } = se, Fe = this._getOffset(Ot, "x"), ct = this._getOffset(Ot, "y"); Fe && (Ue += Fe), ct && (Z += ct); let fn = 0 - Z, En = Z + ve.height - Xe.height, Ln = this._subtractOverflows(ve.width, 0 - Ue, Ue + ve.width - Xe.width), In = this._subtractOverflows(ve.height, fn, En), Et = Ln * In; return { visibleArea: Et, isCompletelyWithinViewport: ve.width * ve.height === Et, fitsInViewportVertically: In === ve.height, fitsInViewportHorizontally: Ln == ve.width } } _canFitWithFlexibleDimensions(se, Me, Xe) { if (this._hasFlexibleDimensions) { const Ot = Xe.bottom - Me.y, ve = Xe.right - Me.x, Ue = rn(this._overlayRef.getConfig().minHeight), Z = rn(this._overlayRef.getConfig().minWidth); return (se.fitsInViewportVertically || null != Ue && Ue <= Ot) && (se.fitsInViewportHorizontally || null != Z && Z <= ve) } return !1 } _pushOverlayOnScreen(se, Me, Xe) { if (this._previousPushAmount && this._positionLocked) return { x: se.x + this._previousPushAmount.x, y: se.y + this._previousPushAmount.y }; const Ot = Jt(Me), ve = this._viewportRect, Ue = Math.max(se.x + Ot.width - ve.width, 0), Z = Math.max(se.y + Ot.height - ve.height, 0), Fe = Math.max(ve.top - Xe.top - se.y, 0), ct = Math.max(ve.left - Xe.left - se.x, 0); let Mt = 0, Qt = 0; return Mt = Ot.width <= ve.width ? ct || -Ue : se.x < this._viewportMargin ? ve.left - Xe.left - se.x : 0, Qt = Ot.height <= ve.height ? Fe || -Z : se.y < this._viewportMargin ? ve.top - Xe.top - se.y : 0, this._previousPushAmount = { x: Mt, y: Qt }, { x: se.x + Mt, y: se.y + Qt } } _applyPosition(se, Me) { if (this._setTransformOrigin(se), this._setOverlayElementStyles(Me, se), this._setBoundingBoxStyles(Me, se), se.panelClass && this._addPanelClasses(se.panelClass), this._lastPosition = se, this._positionChanges.observers.length) { const Xe = this._getScrollVisibility(), Ot = new bn(se, Xe); this._positionChanges.next(Ot) } this._isInitialRender = !1 } _setTransformOrigin(se) { if (!this._transformOriginSelector) return; const Me = this._boundingBox.querySelectorAll(this._transformOriginSelector); let Xe, Ot = se.overlayY; Xe = "center" === se.overlayX ? "center" : this._isRtl() ? "start" === se.overlayX ? "right" : "left" : "start" === se.overlayX ? "left" : "right"; for (let ve = 0; ve < Me.length; ve++)Me[ve].style.transformOrigin = `${Xe} ${Ot}` } _calculateBoundingBoxRect(se, Me) { const Xe = this._viewportRect, Ot = this._isRtl(); let ve, Ue, Z, Mt, Qt, fn; if ("top" === Me.overlayY) Ue = se.y, ve = Xe.height - Ue + this._viewportMargin; else if ("bottom" === Me.overlayY) Z = Xe.height - se.y + 2 * this._viewportMargin, ve = Xe.height - Z + this._viewportMargin; else { const En = Math.min(Xe.bottom - se.y + Xe.top, se.y), Ln = this._lastBoundingBoxSize.height; ve = 2 * En, Ue = se.y - En, ve > Ln && !this._isInitialRender && !this._growAfterOpen && (Ue = se.y - Ln / 2) } if ("end" === Me.overlayX && !Ot || "start" === Me.overlayX && Ot) fn = Xe.width - se.x + this._viewportMargin, Mt = se.x - this._viewportMargin; else if ("start" === Me.overlayX && !Ot || "end" === Me.overlayX && Ot) Qt = se.x, Mt = Xe.right - se.x; else { const En = Math.min(Xe.right - se.x + Xe.left, se.x), Ln = this._lastBoundingBoxSize.width; Mt = 2 * En, Qt = se.x - En, Mt > Ln && !this._isInitialRender && !this._growAfterOpen && (Qt = se.x - Ln / 2) } return { top: Ue, left: Qt, bottom: Z, right: fn, width: Mt, height: ve } } _setBoundingBoxStyles(se, Me) { const Xe = this._calculateBoundingBoxRect(se, Me); !this._isInitialRender && !this._growAfterOpen && (Xe.height = Math.min(Xe.height, this._lastBoundingBoxSize.height), Xe.width = Math.min(Xe.width, this._lastBoundingBoxSize.width)); const Ot = {}; if (this._hasExactPosition()) Ot.top = Ot.left = "0", Ot.bottom = Ot.right = Ot.maxHeight = Ot.maxWidth = "", Ot.width = Ot.height = "100%"; else { const ve = this._overlayRef.getConfig().maxHeight, Ue = this._overlayRef.getConfig().maxWidth; Ot.height = (0, Y.HM)(Xe.height), Ot.top = (0, Y.HM)(Xe.top), Ot.bottom = (0, Y.HM)(Xe.bottom), Ot.width = (0, Y.HM)(Xe.width), Ot.left = (0, Y.HM)(Xe.left), Ot.right = (0, Y.HM)(Xe.right), Ot.alignItems = "center" === Me.overlayX ? "center" : "end" === Me.overlayX ? "flex-end" : "flex-start", Ot.justifyContent = "center" === Me.overlayY ? "center" : "bottom" === Me.overlayY ? "flex-end" : "flex-start", ve && (Ot.maxHeight = (0, Y.HM)(ve)), Ue && (Ot.maxWidth = (0, Y.HM)(Ue)) } this._lastBoundingBoxSize = Xe, Wt(this._boundingBox.style, Ot) } _resetBoundingBoxStyles() { Wt(this._boundingBox.style, { top: "0", left: "0", right: "0", bottom: "0", height: "", width: "", alignItems: "", justifyContent: "" }) } _resetOverlayElementStyles() { Wt(this._pane.style, { top: "", left: "", bottom: "", right: "", position: "", transform: "" }) } _setOverlayElementStyles(se, Me) { const Xe = {}, Ot = this._hasExactPosition(), ve = this._hasFlexibleDimensions, Ue = this._overlayRef.getConfig(); if (Ot) { const Mt = this._viewportRuler.getViewportScrollPosition(); Wt(Xe, this._getExactOverlayY(Me, se, Mt)), Wt(Xe, this._getExactOverlayX(Me, se, Mt)) } else Xe.position = "static"; let Z = "", Fe = this._getOffset(Me, "x"), ct = this._getOffset(Me, "y"); Fe && (Z += `translateX(${Fe}px) `), ct && (Z += `translateY(${ct}px)`), Xe.transform = Z.trim(), Ue.maxHeight && (Ot ? Xe.maxHeight = (0, Y.HM)(Ue.maxHeight) : ve && (Xe.maxHeight = "")), Ue.maxWidth && (Ot ? Xe.maxWidth = (0, Y.HM)(Ue.maxWidth) : ve && (Xe.maxWidth = "")), Wt(this._pane.style, Xe) } _getExactOverlayY(se, Me, Xe) { let Ot = { top: "", bottom: "" }, ve = this._getOverlayPoint(Me, this._overlayRect, se); return this._isPushed && (ve = this._pushOverlayOnScreen(ve, this._overlayRect, Xe)), "bottom" === se.overlayY ? Ot.bottom = this._document.documentElement.clientHeight - (ve.y + this._overlayRect.height) + "px" : Ot.top = (0, Y.HM)(ve.y), Ot } _getExactOverlayX(se, Me, Xe) { let Ue, Ot = { left: "", right: "" }, ve = this._getOverlayPoint(Me, this._overlayRect, se); return this._isPushed && (ve = this._pushOverlayOnScreen(ve, this._overlayRect, Xe)), Ue = this._isRtl() ? "end" === se.overlayX ? "left" : "right" : "end" === se.overlayX ? "right" : "left", "right" === Ue ? Ot.right = this._document.documentElement.clientWidth - (ve.x + this._overlayRect.width) + "px" : Ot.left = (0, Y.HM)(ve.x), Ot } _getScrollVisibility() { const se = this._getOriginRect(), Me = this._pane.getBoundingClientRect(), Xe = this._scrollables.map(Ot => Ot.getElementRef().nativeElement.getBoundingClientRect()); return { isOriginClipped: ge(se, Xe), isOriginOutsideView: le(se, Xe), isOverlayClipped: ge(Me, Xe), isOverlayOutsideView: le(Me, Xe) } } _subtractOverflows(se, ...Me) { return Me.reduce((Xe, Ot) => Xe - Math.max(Ot, 0), se) } _getNarrowedViewportRect() { const se = this._document.documentElement.clientWidth, Me = this._document.documentElement.clientHeight, Xe = this._viewportRuler.getViewportScrollPosition(); return { top: Xe.top + this._viewportMargin, left: Xe.left + this._viewportMargin, right: Xe.left + se - this._viewportMargin, bottom: Xe.top + Me - this._viewportMargin, width: se - 2 * this._viewportMargin, height: Me - 2 * this._viewportMargin } } _isRtl() { return "rtl" === this._overlayRef.getDirection() } _hasExactPosition() { return !this._hasFlexibleDimensions || this._isPushed } _getOffset(se, Me) { return "x" === Me ? null == se.offsetX ? this._offsetX : se.offsetX : null == se.offsetY ? this._offsetY : se.offsetY } _validatePositions() { } _addPanelClasses(se) { this._pane && (0, Y.Eq)(se).forEach(Me => { "" !== Me && -1 === this._appliedPanelClasses.indexOf(Me) && (this._appliedPanelClasses.push(Me), this._pane.classList.add(Me)) }) } _clearPanelClasses() { this._pane && (this._appliedPanelClasses.forEach(se => { this._pane.classList.remove(se) }), this._appliedPanelClasses = []) } _getOriginRect() { const se = this._origin; if (se instanceof v.SBq) return se.nativeElement.getBoundingClientRect(); if (se instanceof Element) return se.getBoundingClientRect(); const Me = se.width || 0, Xe = se.height || 0; return { top: se.y, bottom: se.y + Xe, left: se.x, right: se.x + Me, height: Xe, width: Me } } } function Wt(Ke, se) { for (let Me in se) se.hasOwnProperty(Me) && (Ke[Me] = se[Me]); return Ke } function rn(Ke) { if ("number" != typeof Ke && null != Ke) { const [se, Me] = Ke.split(it); return Me && "px" !== Me ? null : parseFloat(se) } return Ke || null } function Jt(Ke) { return { top: Math.floor(Ke.top), right: Math.floor(Ke.right), bottom: Math.floor(Ke.bottom), left: Math.floor(Ke.left), width: Math.floor(Ke.width), height: Math.floor(Ke.height) } } const ht = "cdk-global-overlay-wrapper"; class Ae { constructor() { this._cssPosition = "static", this._topOffset = "", this._bottomOffset = "", this._alignItems = "", this._xPosition = "", this._xOffset = "", this._width = "", this._height = "", this._isDisposed = !1 } attach(se) { const Me = se.getConfig(); this._overlayRef = se, this._width && !Me.width && se.updateSize({ width: this._width }), this._height && !Me.height && se.updateSize({ height: this._height }), se.hostElement.classList.add(ht), this._isDisposed = !1 } top(se = "") { return this._bottomOffset = "", this._topOffset = se, this._alignItems = "flex-start", this } left(se = "") { return this._xOffset = se, this._xPosition = "left", this } bottom(se = "") { return this._topOffset = "", this._bottomOffset = se, this._alignItems = "flex-end", this } right(se = "") { return this._xOffset = se, this._xPosition = "right", this } start(se = "") { return this._xOffset = se, this._xPosition = "start", this } end(se = "") { return this._xOffset = se, this._xPosition = "end", this } width(se = "") { return this._overlayRef ? this._overlayRef.updateSize({ width: se }) : this._width = se, this } height(se = "") { return this._overlayRef ? this._overlayRef.updateSize({ height: se }) : this._height = se, this } centerHorizontally(se = "") { return this.left(se), this._xPosition = "center", this } centerVertically(se = "") { return this.top(se), this._alignItems = "center", this } apply() { if (!this._overlayRef || !this._overlayRef.hasAttached()) return; const se = this._overlayRef.overlayElement.style, Me = this._overlayRef.hostElement.style, Xe = this._overlayRef.getConfig(), { width: Ot, height: ve, maxWidth: Ue, maxHeight: Z } = Xe, Fe = !("100%" !== Ot && "100vw" !== Ot || Ue && "100%" !== Ue && "100vw" !== Ue), ct = !("100%" !== ve && "100vh" !== ve || Z && "100%" !== Z && "100vh" !== Z), Mt = this._xPosition, Qt = this._xOffset, fn = "rtl" === this._overlayRef.getConfig().direction; let En = "", Ln = "", In = ""; Fe ? In = "flex-start" : "center" === Mt ? (In = "center", fn ? Ln = Qt : En = Qt) : fn ? "left" === Mt || "end" === Mt ? (In = "flex-end", En = Qt) : ("right" === Mt || "start" === Mt) && (In = "flex-start", Ln = Qt) : "left" === Mt || "start" === Mt ? (In = "flex-start", En = Qt) : ("right" === Mt || "end" === Mt) && (In = "flex-end", Ln = Qt), se.position = this._cssPosition, se.marginLeft = Fe ? "0" : En, se.marginTop = ct ? "0" : this._topOffset, se.marginBottom = this._bottomOffset, se.marginRight = Fe ? "0" : Ln, Me.justifyContent = In, Me.alignItems = ct ? "flex-start" : this._alignItems } dispose() { if (this._isDisposed || !this._overlayRef) return; const se = this._overlayRef.overlayElement.style, Me = this._overlayRef.hostElement, Xe = Me.style; Me.classList.remove(ht), Xe.justifyContent = Xe.alignItems = se.marginTop = se.marginBottom = se.marginLeft = se.marginRight = se.position = "", this._overlayRef = null, this._isDisposed = !0 } } let nt = (() => { class Ke { constructor(Me, Xe, Ot, ve) { this._viewportRuler = Me, this._document = Xe, this._platform = Ot, this._overlayContainer = ve } global() { return new Ae } flexibleConnectedTo(Me) { return new Ft(Me, this._viewportRuler, this._document, this._platform, this._overlayContainer) } } return Ke.\u0275fac = function (Me) { return new (Me || Ke)(v.LFG(a.rL), v.LFG(y.K0), v.LFG(he.t4), v.LFG(at)) }, Ke.\u0275prov = v.Yz7({ token: Ke, factory: Ke.\u0275fac, providedIn: "root" }), Ke })(), qt = 0, jt = (() => { class Ke { constructor(Me, Xe, Ot, ve, Ue, Z, Fe, ct, Mt, Qt, fn, En) { this.scrollStrategies = Me, this._overlayContainer = Xe, this._componentFactoryResolver = Ot, this._positionBuilder = ve, this._keyboardDispatcher = Ue, this._injector = Z, this._ngZone = Fe, this._document = ct, this._directionality = Mt, this._location = Qt, this._outsideClickDispatcher = fn, this._animationsModuleType = En } create(Me) { const Xe = this._createHostElement(), Ot = this._createPaneElement(Xe), ve = this._createPortalOutlet(Ot), Ue = new $e(Me); return Ue.direction = Ue.direction || this._directionality.value, new vt(ve, Xe, Ot, Ue, this._ngZone, this._keyboardDispatcher, this._document, this._location, this._outsideClickDispatcher, "NoopAnimations" === this._animationsModuleType) } position() { return this._positionBuilder } _createPaneElement(Me) { const Xe = this._document.createElement("div"); return Xe.id = "cdk-overlay-" + qt++, Xe.classList.add("cdk-overlay-pane"), Me.appendChild(Xe), Xe } _createHostElement() { const Me = this._document.createElement("div"); return this._overlayContainer.getContainerElement().appendChild(Me), Me } _createPortalOutlet(Me) { return this._appRef || (this._appRef = this._injector.get(v.z2F)), new ze.u0(Me, this._componentFactoryResolver, this._appRef, this._injector, this._document) } } return Ke.\u0275fac = function (Me) { return new (Me || Ke)(v.LFG(ee), v.LFG(at), v.LFG(v._Vd), v.LFG(nt), v.LFG(Wn), v.LFG(v.zs3), v.LFG(v.R0b), v.LFG(y.K0), v.LFG(xe.Is), v.LFG(y.Ye), v.LFG(Hn), v.LFG(v.QbO, 8)) }, Ke.\u0275prov = v.Yz7({ token: Ke, factory: Ke.\u0275fac, providedIn: "root" }), Ke })(); const Pt = [{ originX: "start", originY: "bottom", overlayX: "start", overlayY: "top" }, { originX: "start", originY: "top", overlayX: "start", overlayY: "bottom" }, { originX: "end", originY: "top", overlayX: "end", overlayY: "bottom" }, { originX: "end", originY: "bottom", overlayX: "end", overlayY: "top" }], qe = new v.OlP("cdk-connected-overlay-scroll-strategy"); let Nt = (() => { class Ke { constructor(Me) { this.elementRef = Me } } return Ke.\u0275fac = function (Me) { return new (Me || Ke)(v.Y36(v.SBq)) }, Ke.\u0275dir = v.lG2({ type: Ke, selectors: [["", "cdk-overlay-origin", ""], ["", "overlay-origin", ""], ["", "cdkOverlayOrigin", ""]], exportAs: ["cdkOverlayOrigin"], standalone: !0 }), Ke })(), on = (() => { class Ke { get offsetX() { return this._offsetX } set offsetX(Me) { this._offsetX = Me, this._position && this._updatePositionStrategy(this._position) } get offsetY() { return this._offsetY } set offsetY(Me) { this._offsetY = Me, this._position && this._updatePositionStrategy(this._position) } get hasBackdrop() { return this._hasBackdrop } set hasBackdrop(Me) { this._hasBackdrop = (0, Y.Ig)(Me) } get lockPosition() { return this._lockPosition } set lockPosition(Me) { this._lockPosition = (0, Y.Ig)(Me) } get flexibleDimensions() { return this._flexibleDimensions } set flexibleDimensions(Me) { this._flexibleDimensions = (0, Y.Ig)(Me) } get growAfterOpen() { return this._growAfterOpen } set growAfterOpen(Me) { this._growAfterOpen = (0, Y.Ig)(Me) } get push() { return this._push } set push(Me) { this._push = (0, Y.Ig)(Me) } constructor(Me, Xe, Ot, ve, Ue) { this._overlay = Me, this._dir = Ue, this._hasBackdrop = !1, this._lockPosition = !1, this._growAfterOpen = !1, this._flexibleDimensions = !1, this._push = !1, this._backdropSubscription = We.w0.EMPTY, this._attachSubscription = We.w0.EMPTY, this._detachSubscription = We.w0.EMPTY, this._positionSubscription = We.w0.EMPTY, this.viewportMargin = 0, this.open = !1, this.disableClose = !1, this.backdropClick = new v.vpe, this.positionChange = new v.vpe, this.attach = new v.vpe, this.detach = new v.vpe, this.overlayKeydown = new v.vpe, this.overlayOutsideClick = new v.vpe, this._templatePortal = new ze.UE(Xe, Ot), this._scrollStrategyFactory = ve, this.scrollStrategy = this._scrollStrategyFactory() } get overlayRef() { return this._overlayRef } get dir() { return this._dir ? this._dir.value : "ltr" } ngOnDestroy() { this._attachSubscription.unsubscribe(), this._detachSubscription.unsubscribe(), this._backdropSubscription.unsubscribe(), this._positionSubscription.unsubscribe(), this._overlayRef && this._overlayRef.dispose() } ngOnChanges(Me) { this._position && (this._updatePositionStrategy(this._position), this._overlayRef.updateSize({ width: this.width, minWidth: this.minWidth, height: this.height, minHeight: this.minHeight }), Me.origin && this.open && this._position.apply()), Me.open && (this.open ? this._attachOverlay() : this._detachOverlay()) } _createOverlay() { (!this.positions || !this.positions.length) && (this.positions = Pt); const Me = this._overlayRef = this._overlay.create(this._buildConfig()); this._attachSubscription = Me.attachments().subscribe(() => this.attach.emit()), this._detachSubscription = Me.detachments().subscribe(() => this.detach.emit()), Me.keydownEvents().subscribe(Xe => { this.overlayKeydown.next(Xe), Xe.keyCode === Ve.hY && !this.disableClose && !(0, Ve.Vb)(Xe) && (Xe.preventDefault(), this._detachOverlay()) }), this._overlayRef.outsidePointerEvents().subscribe(Xe => { this.overlayOutsideClick.next(Xe) }) } _buildConfig() { const Me = this._position = this.positionStrategy || this._createPositionStrategy(), Xe = new $e({ direction: this._dir, positionStrategy: Me, scrollStrategy: this.scrollStrategy, hasBackdrop: this.hasBackdrop }); return (this.width || 0 === this.width) && (Xe.width = this.width), (this.height || 0 === this.height) && (Xe.height = this.height), (this.minWidth || 0 === this.minWidth) && (Xe.minWidth = this.minWidth), (this.minHeight || 0 === this.minHeight) && (Xe.minHeight = this.minHeight), this.backdropClass && (Xe.backdropClass = this.backdropClass), this.panelClass && (Xe.panelClass = this.panelClass), Xe } _updatePositionStrategy(Me) { const Xe = this.positions.map(Ot => ({ originX: Ot.originX, originY: Ot.originY, overlayX: Ot.overlayX, overlayY: Ot.overlayY, offsetX: Ot.offsetX || this.offsetX, offsetY: Ot.offsetY || this.offsetY, panelClass: Ot.panelClass || void 0 })); return Me.setOrigin(this._getFlexibleConnectedPositionStrategyOrigin()).withPositions(Xe).withFlexibleDimensions(this.flexibleDimensions).withPush(this.push).withGrowAfterOpen(this.growAfterOpen).withViewportMargin(this.viewportMargin).withLockedPosition(this.lockPosition).withTransformOriginOn(this.transformOriginSelector) } _createPositionStrategy() { const Me = this._overlay.position().flexibleConnectedTo(this._getFlexibleConnectedPositionStrategyOrigin()); return this._updatePositionStrategy(Me), Me } _getFlexibleConnectedPositionStrategyOrigin() { return this.origin instanceof Nt ? this.origin.elementRef : this.origin } _attachOverlay() { this._overlayRef ? this._overlayRef.getConfig().hasBackdrop = this.hasBackdrop : this._createOverlay(), this._overlayRef.hasAttached() || this._overlayRef.attach(this._templatePortal), this.hasBackdrop ? this._backdropSubscription = this._overlayRef.backdropClick().subscribe(Me => { this.backdropClick.emit(Me) }) : this._backdropSubscription.unsubscribe(), this._positionSubscription.unsubscribe(), this.positionChange.observers.length > 0 && (this._positionSubscription = this._position.positionChanges.pipe(function _e(Ke, se = !1) { return (0, Ie.e)((Me, Xe) => { let Ot = 0; Me.subscribe((0, Q.x)(Xe, ve => { const Ue = Ke(ve, Ot++); (Ue || se) && Xe.next(ve), !Ue && Xe.complete() })) }) }(() => this.positionChange.observers.length > 0)).subscribe(Me => { this.positionChange.emit(Me), 0 === this.positionChange.observers.length && this._positionSubscription.unsubscribe() })) } _detachOverlay() { this._overlayRef && this._overlayRef.detach(), this._backdropSubscription.unsubscribe(), this._positionSubscription.unsubscribe() } } return Ke.\u0275fac = function (Me) { return new (Me || Ke)(v.Y36(jt), v.Y36(v.Rgc), v.Y36(v.s_b), v.Y36(qe), v.Y36(xe.Is, 8)) }, Ke.\u0275dir = v.lG2({ type: Ke, selectors: [["", "cdk-connected-overlay", ""], ["", "connected-overlay", ""], ["", "cdkConnectedOverlay", ""]], inputs: { origin: ["cdkConnectedOverlayOrigin", "origin"], positions: ["cdkConnectedOverlayPositions", "positions"], positionStrategy: ["cdkConnectedOverlayPositionStrategy", "positionStrategy"], offsetX: ["cdkConnectedOverlayOffsetX", "offsetX"], offsetY: ["cdkConnectedOverlayOffsetY", "offsetY"], width: ["cdkConnectedOverlayWidth", "width"], height: ["cdkConnectedOverlayHeight", "height"], minWidth: ["cdkConnectedOverlayMinWidth", "minWidth"], minHeight: ["cdkConnectedOverlayMinHeight", "minHeight"], backdropClass: ["cdkConnectedOverlayBackdropClass", "backdropClass"], panelClass: ["cdkConnectedOverlayPanelClass", "panelClass"], viewportMargin: ["cdkConnectedOverlayViewportMargin", "viewportMargin"], scrollStrategy: ["cdkConnectedOverlayScrollStrategy", "scrollStrategy"], open: ["cdkConnectedOverlayOpen", "open"], disableClose: ["cdkConnectedOverlayDisableClose", "disableClose"], transformOriginSelector: ["cdkConnectedOverlayTransformOriginOn", "transformOriginSelector"], hasBackdrop: ["cdkConnectedOverlayHasBackdrop", "hasBackdrop"], lockPosition: ["cdkConnectedOverlayLockPosition", "lockPosition"], flexibleDimensions: ["cdkConnectedOverlayFlexibleDimensions", "flexibleDimensions"], growAfterOpen: ["cdkConnectedOverlayGrowAfterOpen", "growAfterOpen"], push: ["cdkConnectedOverlayPush", "push"] }, outputs: { backdropClick: "backdropClick", positionChange: "positionChange", attach: "attach", detach: "detach", overlayKeydown: "overlayKeydown", overlayOutsideClick: "overlayOutsideClick" }, exportAs: ["cdkConnectedOverlay"], standalone: !0, features: [v.TTD] }), Ke })(); const gn = { provide: qe, deps: [jt], useFactory: function Zt(Ke) { return () => Ke.scrollStrategies.reposition() } }; let $n = (() => { class Ke { } return Ke.\u0275fac = function (Me) { return new (Me || Ke) }, Ke.\u0275mod = v.oAB({ type: Ke }), Ke.\u0275inj = v.cJS({ providers: [jt, gn], imports: [xe.vT, ze.eL, a.Cl, a.Cl] }), Ke })() }, 2831: (nn, Qe, C) => { C.d(Qe, { Mq: () => Oe, Oy: () => ie, _i: () => We, ht: () => Ye, i$: () => _e, kV: () => tt, qK: () => re, sA: () => ut, t4: () => Y }); var a = C(5879), y = C(6814); let v; try { v = typeof Intl < "u" && Intl.v8BreakIterator } catch { v = !1 } let Se, Y = (() => { class Le { constructor(ge) { this._platformId = ge, this.isBrowser = this._platformId ? (0, y.NF)(this._platformId) : "object" == typeof document && !!document, this.EDGE = this.isBrowser && /(edge)/i.test(navigator.userAgent), this.TRIDENT = this.isBrowser && /(msie|trident)/i.test(navigator.userAgent), this.BLINK = this.isBrowser && !(!window.chrome && !v) && typeof CSS < "u" && !this.EDGE && !this.TRIDENT, this.WEBKIT = this.isBrowser && /AppleWebKit/i.test(navigator.userAgent) && !this.BLINK && !this.EDGE && !this.TRIDENT, this.IOS = this.isBrowser && /iPad|iPhone|iPod/.test(navigator.userAgent) && !("MSStream" in window), this.FIREFOX = this.isBrowser && /(firefox|minefield)/i.test(navigator.userAgent), this.ANDROID = this.isBrowser && /android/i.test(navigator.userAgent) && !this.TRIDENT, this.SAFARI = this.isBrowser && /safari/i.test(navigator.userAgent) && this.WEBKIT } } return Le.\u0275fac = function (ge) { return new (ge || Le)(a.LFG(a.Lbi)) }, Le.\u0275prov = a.Yz7({ token: Le, factory: Le.\u0275fac, providedIn: "root" }), Le })(); const ke = ["color", "button", "checkbox", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week"]; function re() { if (Se) return Se; if ("object" != typeof document || !document) return Se = new Set(ke), Se; let Le = document.createElement("input"); return Se = new Set(ke.filter(le => (Le.setAttribute("type", le), Le.type === le))), Se } let Ie, xe, ze, Pe; function _e(Le) { return function Q() { if (null == Ie && typeof window < "u") try { window.addEventListener("test", null, Object.defineProperty({}, "passive", { get: () => Ie = !0 })) } finally { Ie = Ie || !1 } return Ie }() ? Le : !!Le.capture } function Oe() { if (null == ze) { if ("object" != typeof document || !document || "function" != typeof Element || !Element) return ze = !1, ze; if ("scrollBehavior" in document.documentElement.style) ze = !0; else { const Le = Element.prototype.scrollTo; ze = !!Le && !/\{\s*\[native code\]\s*\}/.test(Le.toString()) } } return ze } function We() { if ("object" != typeof document || !document) return 0; if (null == xe) { const Le = document.createElement("div"), le = Le.style; Le.dir = "rtl", le.width = "1px", le.overflow = "auto", le.visibility = "hidden", le.pointerEvents = "none", le.position = "absolute"; const ge = document.createElement("div"), ue = ge.style; ue.width = "2px", ue.height = "1px", Le.appendChild(ge), document.body.appendChild(Le), xe = 0, 0 === Le.scrollLeft && (Le.scrollLeft = 1, xe = 0 === Le.scrollLeft ? 1 : 2), Le.remove() } return xe } function tt(Le) { if (function Ve() { if (null == Pe) { const Le = typeof document < "u" ? document.head : null; Pe = !(!Le || !Le.createShadowRoot && !Le.attachShadow) } return Pe }()) { const le = Le.getRootNode ? Le.getRootNode() : null; if (typeof ShadowRoot < "u" && ShadowRoot && le instanceof ShadowRoot) return le } return null } function Ye() { let Le = typeof document < "u" && document ? document.activeElement : null; for (; Le && Le.shadowRoot;) { const le = Le.shadowRoot.activeElement; if (le === Le) break; Le = le } return Le } function ut(Le) { return Le.composedPath ? Le.composedPath()[0] : Le.target } function ie() { return typeof __karma__ < "u" && !!__karma__ || typeof jasmine < "u" && !!jasmine || typeof jest < "u" && !!jest || typeof Mocha < "u" && !!Mocha } }, 8484: (nn, Qe, C) => { C.d(Qe, { C5: () => Q, Pl: () => Ye, UE: () => _e, eL: () => ie, en: () => ze, u0: () => We }); var a = C(5879), y = C(6814); class Ie { attach(ge) { return this._attachedHost = ge, ge.attach(this) } detach() { let ge = this._attachedHost; null != ge && (this._attachedHost = null, ge.detach()) } get isAttached() { return null != this._attachedHost } setAttachedHost(ge) { this._attachedHost = ge } } class Q extends Ie { constructor(ge, ue, ee, $e, rt) { super(), this.component = ge, this.viewContainerRef = ue, this.injector = ee, this.componentFactoryResolver = $e, this.projectableNodes = rt } } class _e extends Ie { constructor(ge, ue, ee, $e) { super(), this.templateRef = ge, this.viewContainerRef = ue, this.context = ee, this.injector = $e } get origin() { return this.templateRef.elementRef } attach(ge, ue = this.context) { return this.context = ue, super.attach(ge) } detach() { return this.context = void 0, super.detach() } } class xe extends Ie { constructor(ge) { super(), this.element = ge instanceof a.SBq ? ge.nativeElement : ge } } class ze { constructor() { this._isDisposed = !1, this.attachDomPortal = null } hasAttached() { return !!this._attachedPortal } attach(ge) { return ge instanceof Q ? (this._attachedPortal = ge, this.attachComponentPortal(ge)) : ge instanceof _e ? (this._attachedPortal = ge, this.attachTemplatePortal(ge)) : this.attachDomPortal && ge instanceof xe ? (this._attachedPortal = ge, this.attachDomPortal(ge)) : void 0 } detach() { this._attachedPortal && (this._attachedPortal.setAttachedHost(null), this._attachedPortal = null), this._invokeDisposeFn() } dispose() { this.hasAttached() && this.detach(), this._invokeDisposeFn(), this._isDisposed = !0 } setDisposeFn(ge) { this._disposeFn = ge } _invokeDisposeFn() { this._disposeFn && (this._disposeFn(), this._disposeFn = null) } } class We extends ze { constructor(ge, ue, ee, $e, rt) { super(), this.outletElement = ge, this._componentFactoryResolver = ue, this._appRef = ee, this._defaultInjector = $e, this.attachDomPortal = Kt => { const bn = Kt.element, Dn = this._document.createComment("dom-portal"); bn.parentNode.insertBefore(Dn, bn), this.outletElement.appendChild(bn), this._attachedPortal = Kt, super.setDisposeFn(() => { Dn.parentNode && Dn.parentNode.replaceChild(bn, Dn) }) }, this._document = rt } attachComponentPortal(ge) { const ee = (ge.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(ge.component); let $e; return ge.viewContainerRef ? ($e = ge.viewContainerRef.createComponent(ee, ge.viewContainerRef.length, ge.injector || ge.viewContainerRef.injector, ge.projectableNodes || void 0), this.setDisposeFn(() => $e.destroy())) : ($e = ee.create(ge.injector || this._defaultInjector || a.zs3.NULL), this._appRef.attachView($e.hostView), this.setDisposeFn(() => { this._appRef.viewCount > 0 && this._appRef.detachView($e.hostView), $e.destroy() })), this.outletElement.appendChild(this._getComponentRootNode($e)), this._attachedPortal = ge, $e } attachTemplatePortal(ge) { let ue = ge.viewContainerRef, ee = ue.createEmbeddedView(ge.templateRef, ge.context, { injector: ge.injector }); return ee.rootNodes.forEach($e => this.outletElement.appendChild($e)), ee.detectChanges(), this.setDisposeFn(() => { let $e = ue.indexOf(ee); -1 !== $e && ue.remove($e) }), this._attachedPortal = ge, ee } dispose() { super.dispose(), this.outletElement.remove() } _getComponentRootNode(ge) { return ge.hostView.rootNodes[0] } } let Ye = (() => { class le extends ze { constructor(ue, ee, $e) { super(), this._componentFactoryResolver = ue, this._viewContainerRef = ee, this._isInitialized = !1, this.attached = new a.vpe, this.attachDomPortal = rt => { const Kt = rt.element, bn = this._document.createComment("dom-portal"); rt.setAttachedHost(this), Kt.parentNode.insertBefore(bn, Kt), this._getRootNode().appendChild(Kt), this._attachedPortal = rt, super.setDisposeFn(() => { bn.parentNode && bn.parentNode.replaceChild(Kt, bn) }) }, this._document = $e } get portal() { return this._attachedPortal } set portal(ue) { this.hasAttached() && !ue && !this._isInitialized || (this.hasAttached() && super.detach(), ue && super.attach(ue), this._attachedPortal = ue || null) } get attachedRef() { return this._attachedRef } ngOnInit() { this._isInitialized = !0 } ngOnDestroy() { super.dispose(), this._attachedRef = this._attachedPortal = null } attachComponentPortal(ue) { ue.setAttachedHost(this); const ee = null != ue.viewContainerRef ? ue.viewContainerRef : this._viewContainerRef, rt = (ue.componentFactoryResolver || this._componentFactoryResolver).resolveComponentFactory(ue.component), Kt = ee.createComponent(rt, ee.length, ue.injector || ee.injector, ue.projectableNodes || void 0); return ee !== this._viewContainerRef && this._getRootNode().appendChild(Kt.hostView.rootNodes[0]), super.setDisposeFn(() => Kt.destroy()), this._attachedPortal = ue, this._attachedRef = Kt, this.attached.emit(Kt), Kt } attachTemplatePortal(ue) { ue.setAttachedHost(this); const ee = this._viewContainerRef.createEmbeddedView(ue.templateRef, ue.context, { injector: ue.injector }); return super.setDisposeFn(() => this._viewContainerRef.clear()), this._attachedPortal = ue, this._attachedRef = ee, this.attached.emit(ee), ee } _getRootNode() { const ue = this._viewContainerRef.element.nativeElement; return ue.nodeType === ue.ELEMENT_NODE ? ue : ue.parentNode } } return le.\u0275fac = function (ue) { return new (ue || le)(a.Y36(a._Vd), a.Y36(a.s_b), a.Y36(y.K0)) }, le.\u0275dir = a.lG2({ type: le, selectors: [["", "cdkPortalOutlet", ""]], inputs: { portal: ["cdkPortalOutlet", "portal"] }, outputs: { attached: "attached" }, exportAs: ["cdkPortalOutlet"], features: [a.qOj] }), le })(), ie = (() => { class le { } return le.\u0275fac = function (ue) { return new (ue || le) }, le.\u0275mod = a.oAB({ type: le }), le.\u0275inj = a.cJS({}), le })() }, 9829: (nn, Qe, C) => { C.d(Qe, { PQ: () => at, ZD: () => nt, mF: () => Hn, Cl: () => qt, rL: () => xt }); var a = C(2495), y = C(5879), v = C(8645), Y = C(2096), he = C(5592), Se = C(2438), ke = C(1954), re = C(7394); const Ie = { schedule(jt) { let Pt = requestAnimationFrame, qe = cancelAnimationFrame; const { delegate: Nt } = Ie; Nt && (Pt = Nt.requestAnimationFrame, qe = Nt.cancelAnimationFrame); const on = Pt(Zt => { qe = void 0, jt(Zt) }); return new re.w0(() => qe?.(on)) }, requestAnimationFrame(...jt) { const { delegate: Pt } = Ie; return (Pt?.requestAnimationFrame || requestAnimationFrame)(...jt) }, cancelAnimationFrame(...jt) { const { delegate: Pt } = Ie; return (Pt?.cancelAnimationFrame || cancelAnimationFrame)(...jt) }, delegate: void 0 }; var _e = C(2631); new class xe extends _e.v { flush(Pt) { this._active = !0; const qe = this._scheduled; this._scheduled = void 0; const { actions: Nt } = this; let on; Pt = Pt || Nt.shift(); do { if (on = Pt.execute(Pt.state, Pt.delay)) break } while ((Pt = Nt[0]) && Pt.id === qe && Nt.shift()); if (this._active = !1, on) { for (; (Pt = Nt[0]) && Pt.id === qe && Nt.shift();)Pt.unsubscribe(); throw on } } }(class Q extends ke.o { constructor(Pt, qe) { super(Pt, qe), this.scheduler = Pt, this.work = qe } requestAsyncId(Pt, qe, Nt = 0) { return null !== Nt && Nt > 0 ? super.requestAsyncId(Pt, qe, Nt) : (Pt.actions.push(this), Pt._scheduled || (Pt._scheduled = Ie.requestAnimationFrame(() => Pt.flush(void 0)))) } recycleAsyncId(Pt, qe, Nt = 0) { var on; if (null != Nt ? Nt > 0 : this.delay > 0) return super.recycleAsyncId(Pt, qe, Nt); const { actions: Zt } = Pt; null != qe && (null === (on = Zt[Zt.length - 1]) || void 0 === on ? void 0 : on.id) !== qe && (Ie.cancelAnimationFrame(qe), Pt._scheduled = void 0) } }); C(6410); var Pe = C(6321), Ve = C(9360), tt = C(4829), Ye = C(8251), ie = C(4825); function Le(jt, Pt = Pe.z) { return function ut(jt) { return (0, Ve.e)((Pt, qe) => { let Nt = !1, on = null, Zt = null, gn = !1; const $n = () => { if (Zt?.unsubscribe(), Zt = null, Nt) { Nt = !1; const Ke = on; on = null, qe.next(Ke) } gn && qe.complete() }, Fn = () => { Zt = null, gn && qe.complete() }; Pt.subscribe((0, Ye.x)(qe, Ke => { Nt = !0, on = Ke, Zt || (0, tt.Xf)(jt(Ke)).subscribe(Zt = (0, Ye.x)(qe, $n, Fn)) }, () => { gn = !0, (!Nt || !Zt || Zt.closed) && qe.complete() })) }) }(() => (0, ie.H)(jt, Pt)) } var le = C(2181), ge = C(9773), ue = C(2831), ee = C(6814), $e = C(9388); let Hn = (() => { class jt { constructor(qe, Nt, on) { this._ngZone = qe, this._platform = Nt, this._scrolled = new v.x, this._globalSubscription = null, this._scrolledCount = 0, this.scrollContainers = new Map, this._document = on } register(qe) { this.scrollContainers.has(qe) || this.scrollContainers.set(qe, qe.elementScrolled().subscribe(() => this._scrolled.next(qe))) } deregister(qe) { const Nt = this.scrollContainers.get(qe); Nt && (Nt.unsubscribe(), this.scrollContainers.delete(qe)) } scrolled(qe = 20) { return this._platform.isBrowser ? new he.y(Nt => { this._globalSubscription || this._addGlobalListener(); const on = qe > 0 ? this._scrolled.pipe(Le(qe)).subscribe(Nt) : this._scrolled.subscribe(Nt); return this._scrolledCount++, () => { on.unsubscribe(), this._scrolledCount--, this._scrolledCount || this._removeGlobalListener() } }) : (0, Y.of)() } ngOnDestroy() { this._removeGlobalListener(), this.scrollContainers.forEach((qe, Nt) => this.deregister(Nt)), this._scrolled.complete() } ancestorScrolled(qe, Nt) { const on = this.getAncestorScrollContainers(qe); return this.scrolled(Nt).pipe((0, le.h)(Zt => !Zt || on.indexOf(Zt) > -1)) } getAncestorScrollContainers(qe) { const Nt = []; return this.scrollContainers.forEach((on, Zt) => { this._scrollableContainsElement(Zt, qe) && Nt.push(Zt) }), Nt } _getWindow() { return this._document.defaultView || window } _scrollableContainsElement(qe, Nt) { let on = (0, a.fI)(Nt), Zt = qe.getElementRef().nativeElement; do { if (on == Zt) return !0 } while (on = on.parentElement); return !1 } _addGlobalListener() { this._globalSubscription = this._ngZone.runOutsideAngular(() => { const qe = this._getWindow(); return (0, Se.R)(qe.document, "scroll").subscribe(() => this._scrolled.next()) }) } _removeGlobalListener() { this._globalSubscription && (this._globalSubscription.unsubscribe(), this._globalSubscription = null) } } return jt.\u0275fac = function (qe) { return new (qe || jt)(y.LFG(y.R0b), y.LFG(ue.t4), y.LFG(ee.K0, 8)) }, jt.\u0275prov = y.Yz7({ token: jt, factory: jt.\u0275fac, providedIn: "root" }), jt })(), at = (() => { class jt { constructor(qe, Nt, on, Zt) { this.elementRef = qe, this.scrollDispatcher = Nt, this.ngZone = on, this.dir = Zt, this._destroyed = new v.x, this._elementScrolled = new he.y(gn => this.ngZone.runOutsideAngular(() => (0, Se.R)(this.elementRef.nativeElement, "scroll").pipe((0, ge.R)(this._destroyed)).subscribe(gn))) } ngOnInit() { this.scrollDispatcher.register(this) } ngOnDestroy() { this.scrollDispatcher.deregister(this), this._destroyed.next(), this._destroyed.complete() } elementScrolled() { return this._elementScrolled } getElementRef() { return this.elementRef } scrollTo(qe) { const Nt = this.elementRef.nativeElement, on = this.dir && "rtl" == this.dir.value; null == qe.left && (qe.left = on ? qe.end : qe.start), null == qe.right && (qe.right = on ? qe.start : qe.end), null != qe.bottom && (qe.top = Nt.scrollHeight - Nt.clientHeight - qe.bottom), on && 0 != (0, ue._i)() ? (null != qe.left && (qe.right = Nt.scrollWidth - Nt.clientWidth - qe.left), 2 == (0, ue._i)() ? qe.left = qe.right : 1 == (0, ue._i)() && (qe.left = qe.right ? -qe.right : qe.right)) : null != qe.right && (qe.left = Nt.scrollWidth - Nt.clientWidth - qe.right), this._applyScrollToOptions(qe) } _applyScrollToOptions(qe) { const Nt = this.elementRef.nativeElement; (0, ue.Mq)() ? Nt.scrollTo(qe) : (null != qe.top && (Nt.scrollTop = qe.top), null != qe.left && (Nt.scrollLeft = qe.left)) } measureScrollOffset(qe) { const Nt = "left", Zt = this.elementRef.nativeElement; if ("top" == qe) return Zt.scrollTop; if ("bottom" == qe) return Zt.scrollHeight - Zt.clientHeight - Zt.scrollTop; const gn = this.dir && "rtl" == this.dir.value; return "start" == qe ? qe = gn ? "right" : Nt : "end" == qe && (qe = gn ? Nt : "right"), gn && 2 == (0, ue._i)() ? qe == Nt ? Zt.scrollWidth - Zt.clientWidth - Zt.scrollLeft : Zt.scrollLeft : gn && 1 == (0, ue._i)() ? qe == Nt ? Zt.scrollLeft + Zt.scrollWidth - Zt.clientWidth : -Zt.scrollLeft : qe == Nt ? Zt.scrollLeft : Zt.scrollWidth - Zt.clientWidth - Zt.scrollLeft } } return jt.\u0275fac = function (qe) { return new (qe || jt)(y.Y36(y.SBq), y.Y36(Hn), y.Y36(y.R0b), y.Y36($e.Is, 8)) }, jt.\u0275dir = y.lG2({ type: jt, selectors: [["", "cdk-scrollable", ""], ["", "cdkScrollable", ""]], standalone: !0 }), jt })(), xt = (() => { class jt { constructor(qe, Nt, on) { this._platform = qe, this._change = new v.x, this._changeListener = Zt => { this._change.next(Zt) }, this._document = on, Nt.runOutsideAngular(() => { if (qe.isBrowser) { const Zt = this._getWindow(); Zt.addEventListener("resize", this._changeListener), Zt.addEventListener("orientationchange", this._changeListener) } this.change().subscribe(() => this._viewportSize = null) }) } ngOnDestroy() { if (this._platform.isBrowser) { const qe = this._getWindow(); qe.removeEventListener("resize", this._changeListener), qe.removeEventListener("orientationchange", this._changeListener) } this._change.complete() } getViewportSize() { this._viewportSize || this._updateViewportSize(); const qe = { width: this._viewportSize.width, height: this._viewportSize.height }; return this._platform.isBrowser || (this._viewportSize = null), qe } getViewportRect() { const qe = this.getViewportScrollPosition(), { width: Nt, height: on } = this.getViewportSize(); return { top: qe.top, left: qe.left, bottom: qe.top + on, right: qe.left + Nt, height: on, width: Nt } } getViewportScrollPosition() { if (!this._platform.isBrowser) return { top: 0, left: 0 }; const qe = this._document, Nt = this._getWindow(), on = qe.documentElement, Zt = on.getBoundingClientRect(); return { top: -Zt.top || qe.body.scrollTop || Nt.scrollY || on.scrollTop || 0, left: -Zt.left || qe.body.scrollLeft || Nt.scrollX || on.scrollLeft || 0 } } change(qe = 20) { return qe > 0 ? this._change.pipe(Le(qe)) : this._change } _getWindow() { return this._document.defaultView || window } _updateViewportSize() { const qe = this._getWindow(); this._viewportSize = this._platform.isBrowser ? { width: qe.innerWidth, height: qe.innerHeight } : { width: 0, height: 0 } } } return jt.\u0275fac = function (qe) { return new (qe || jt)(y.LFG(ue.t4), y.LFG(y.R0b), y.LFG(ee.K0, 8)) }, jt.\u0275prov = y.Yz7({ token: jt, factory: jt.\u0275fac, providedIn: "root" }), jt })(), nt = (() => { class jt { } return jt.\u0275fac = function (qe) { return new (qe || jt) }, jt.\u0275mod = y.oAB({ type: jt }), jt.\u0275inj = y.cJS({}), jt })(), qt = (() => { class jt { } return jt.\u0275fac = function (qe) { return new (qe || jt) }, jt.\u0275mod = y.oAB({ type: jt }), jt.\u0275inj = y.cJS({ imports: [$e.vT, nt, $e.vT, nt] }), jt })() }, 6814: (nn, Qe, C) => { C.d(Qe, { Do: () => Pe, ED: () => sn, EM: () => Ro, HT: () => Y, JF: () => Ki, K0: () => Se, Mx: () => $r, NF: () => Yo, O5: () => fo, PM: () => so, RF: () => bt, S$: () => ze, V_: () => re, Ye: () => Ve, b0: () => We, bD: () => Qr, ez: () => oo, mk: () => Ti, n9: () => Rt, q: () => v, sg: () => Nr, tP: () => et, w_: () => he }); var a = C(5879); let y = null; function v() { return y } function Y(P) { y || (y = P) } class he { } const Se = new a.OlP("DocumentToken"); let ke = (() => { class P { historyGo(B) { throw new Error("Not implemented") } } return P.\u0275fac = function (B) { return new (B || P) }, P.\u0275prov = a.Yz7({ token: P, factory: function () { return (0, a.f3M)(Ie) }, providedIn: "platform" }), P })(); const re = new a.OlP("Location Initialized"); let Ie = (() => { class P extends ke { constructor() { super(), this._doc = (0, a.f3M)(Se), this._location = window.location, this._history = window.history } getBaseHrefFromDOM() { return v().getBaseHref(this._doc) } onPopState(B) { const be = v().getGlobalEventTarget(this._doc, "window"); return be.addEventListener("popstate", B, !1), () => be.removeEventListener("popstate", B) } onHashChange(B) { const be = v().getGlobalEventTarget(this._doc, "window"); return be.addEventListener("hashchange", B, !1), () => be.removeEventListener("hashchange", B) } get href() { return this._location.href } get protocol() { return this._location.protocol } get hostname() { return this._location.hostname } get port() { return this._location.port } get pathname() { return this._location.pathname } get search() { return this._location.search } get hash() { return this._location.hash } set pathname(B) { this._location.pathname = B } pushState(B, be, Je) { this._history.pushState(B, be, Je) } replaceState(B, be, Je) { this._history.replaceState(B, be, Je) } forward() { this._history.forward() } back() { this._history.back() } historyGo(B = 0) { this._history.go(B) } getState() { return this._history.state } } return P.\u0275fac = function (B) { return new (B || P) }, P.\u0275prov = a.Yz7({ token: P, factory: function () { return new P }, providedIn: "platform" }), P })(); function Q(P, X) { if (0 == P.length) return X; if (0 == X.length) return P; let B = 0; return P.endsWith("/") && B++, X.startsWith("/") && B++, 2 == B ? P + X.substring(1) : 1 == B ? P + X : P + "/" + X } function _e(P) { const X = P.match(/#|\?|$/), B = X && X.index || P.length; return P.slice(0, B - ("/" === P[B - 1] ? 1 : 0)) + P.slice(B) } function xe(P) { return P && "?" !== P[0] ? "?" + P : P } let ze = (() => { class P { historyGo(B) { throw new Error("Not implemented") } } return P.\u0275fac = function (B) { return new (B || P) }, P.\u0275prov = a.Yz7({ token: P, factory: function () { return (0, a.f3M)(We) }, providedIn: "root" }), P })(); const Oe = new a.OlP("appBaseHref"); let We = (() => { class P extends ze { constructor(B, be) { super(), this._platformLocation = B, this._removeListenerFns = [], this._baseHref = be ?? this._platformLocation.getBaseHrefFromDOM() ?? (0, a.f3M)(Se).location?.origin ?? "" } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(B) { this._removeListenerFns.push(this._platformLocation.onPopState(B), this._platformLocation.onHashChange(B)) } getBaseHref() { return this._baseHref } prepareExternalUrl(B) { return Q(this._baseHref, B) } path(B = !1) { const be = this._platformLocation.pathname + xe(this._platformLocation.search), Je = this._platformLocation.hash; return Je && B ? `${be}${Je}` : be } pushState(B, be, Je, $t) { const en = this.prepareExternalUrl(Je + xe($t)); this._platformLocation.pushState(B, be, en) } replaceState(B, be, Je, $t) { const en = this.prepareExternalUrl(Je + xe($t)); this._platformLocation.replaceState(B, be, en) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(B = 0) { this._platformLocation.historyGo?.(B) } } return P.\u0275fac = function (B) { return new (B || P)(a.LFG(ke), a.LFG(Oe, 8)) }, P.\u0275prov = a.Yz7({ token: P, factory: P.\u0275fac, providedIn: "root" }), P })(), Pe = (() => { class P extends ze { constructor(B, be) { super(), this._platformLocation = B, this._baseHref = "", this._removeListenerFns = [], null != be && (this._baseHref = be) } ngOnDestroy() { for (; this._removeListenerFns.length;)this._removeListenerFns.pop()() } onPopState(B) { this._removeListenerFns.push(this._platformLocation.onPopState(B), this._platformLocation.onHashChange(B)) } getBaseHref() { return this._baseHref } path(B = !1) { let be = this._platformLocation.hash; return null == be && (be = "#"), be.length > 0 ? be.substring(1) : be } prepareExternalUrl(B) { const be = Q(this._baseHref, B); return be.length > 0 ? "#" + be : be } pushState(B, be, Je, $t) { let en = this.prepareExternalUrl(Je + xe($t)); 0 == en.length && (en = this._platformLocation.pathname), this._platformLocation.pushState(B, be, en) } replaceState(B, be, Je, $t) { let en = this.prepareExternalUrl(Je + xe($t)); 0 == en.length && (en = this._platformLocation.pathname), this._platformLocation.replaceState(B, be, en) } forward() { this._platformLocation.forward() } back() { this._platformLocation.back() } getState() { return this._platformLocation.getState() } historyGo(B = 0) { this._platformLocation.historyGo?.(B) } } return P.\u0275fac = function (B) { return new (B || P)(a.LFG(ke), a.LFG(Oe, 8)) }, P.\u0275prov = a.Yz7({ token: P, factory: P.\u0275fac }), P })(), Ve = (() => { class P { constructor(B) { this._subject = new a.vpe, this._urlChangeListeners = [], this._urlChangeSubscription = null, this._locationStrategy = B; const be = this._locationStrategy.getBaseHref(); this._basePath = function ie(P) { if (new RegExp("^(https?:)?//").test(P)) { const [, B] = P.split(/\/\/[^\/]+/); return B } return P }(_e(ut(be))), this._locationStrategy.onPopState(Je => { this._subject.emit({ url: this.path(!0), pop: !0, state: Je.state, type: Je.type }) }) } ngOnDestroy() { this._urlChangeSubscription?.unsubscribe(), this._urlChangeListeners = [] } path(B = !1) { return this.normalize(this._locationStrategy.path(B)) } getState() { return this._locationStrategy.getState() } isCurrentPathEqualTo(B, be = "") { return this.path() == this.normalize(B + xe(be)) } normalize(B) { return P.stripTrailingSlash(function Ye(P, X) { if (!P || !X.startsWith(P)) return X; const B = X.substring(P.length); return "" === B || ["/", ";", "?", "#"].includes(B[0]) ? B : X }(this._basePath, ut(B))) } prepareExternalUrl(B) { return B && "/" !== B[0] && (B = "/" + B), this._locationStrategy.prepareExternalUrl(B) } go(B, be = "", Je = null) { this._locationStrategy.pushState(Je, "", B, be), this._notifyUrlChangeListeners(this.prepareExternalUrl(B + xe(be)), Je) } replaceState(B, be = "", Je = null) { this._locationStrategy.replaceState(Je, "", B, be), this._notifyUrlChangeListeners(this.prepareExternalUrl(B + xe(be)), Je) } forward() { this._locationStrategy.forward() } back() { this._locationStrategy.back() } historyGo(B = 0) { this._locationStrategy.historyGo?.(B) } onUrlChange(B) { return this._urlChangeListeners.push(B), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe(be => { this._notifyUrlChangeListeners(be.url, be.state) })), () => { const be = this._urlChangeListeners.indexOf(B); this._urlChangeListeners.splice(be, 1), 0 === this._urlChangeListeners.length && (this._urlChangeSubscription?.unsubscribe(), this._urlChangeSubscription = null) } } _notifyUrlChangeListeners(B = "", be) { this._urlChangeListeners.forEach(Je => Je(B, be)) } subscribe(B, be, Je) { return this._subject.subscribe({ next: B, error: be, complete: Je }) } } return P.normalizeQueryParams = xe, P.joinWithSlash = Q, P.stripTrailingSlash = _e, P.\u0275fac = function (B) { return new (B || P)(a.LFG(ze)) }, P.\u0275prov = a.Yz7({ token: P, factory: function () { return function tt() { return new Ve((0, a.LFG)(ze)) }() }, providedIn: "root" }), P })(); function ut(P) { return P.replace(/\/index.html$/, "") } function $r(P, X) { X = encodeURIComponent(X); for (const B of P.split(";")) { const be = B.indexOf("="), [Je, $t] = -1 == be ? [B, ""] : [B.slice(0, be), B.slice(be + 1)]; if (Je.trim() === X) return decodeURIComponent($t) } return null } const Io = /\s+/, zi = []; let Ti = (() => { class P { constructor(B, be, Je, $t) { this._iterableDiffers = B, this._keyValueDiffers = be, this._ngEl = Je, this._renderer = $t, this.initialClasses = zi, this.stateMap = new Map } set klass(B) { this.initialClasses = null != B ? B.trim().split(Io) : zi } set ngClass(B) { this.rawClass = "string" == typeof B ? B.trim().split(Io) : B } ngDoCheck() { for (const be of this.initialClasses) this._updateState(be, !0); const B = this.rawClass; if (Array.isArray(B) || B instanceof Set) for (const be of B) this._updateState(be, !0); else if (null != B) for (const be of Object.keys(B)) this._updateState(be, !!B[be]); this._applyStateDiff() } _updateState(B, be) { const Je = this.stateMap.get(B); void 0 !== Je ? (Je.enabled !== be && (Je.changed = !0, Je.enabled = be), Je.touched = !0) : this.stateMap.set(B, { enabled: be, changed: !0, touched: !0 }) } _applyStateDiff() { for (const B of this.stateMap) { const be = B[0], Je = B[1]; Je.changed ? (this._toggleClass(be, Je.enabled), Je.changed = !1) : Je.touched || (Je.enabled && this._toggleClass(be, !1), this.stateMap.delete(be)), Je.touched = !1 } } _toggleClass(B, be) { (B = B.trim()).length > 0 && B.split(Io).forEach(Je => { be ? this._renderer.addClass(this._ngEl.nativeElement, Je) : this._renderer.removeClass(this._ngEl.nativeElement, Je) }) } } return P.\u0275fac = function (B) { return new (B || P)(a.Y36(a.ZZ4), a.Y36(a.aQg), a.Y36(a.SBq), a.Y36(a.Qsj)) }, P.\u0275dir = a.lG2({ type: P, selectors: [["", "ngClass", ""]], inputs: { klass: ["class", "klass"], ngClass: "ngClass" }, standalone: !0 }), P })(); class bo { constructor(X, B, be, Je) { this.$implicit = X, this.ngForOf = B, this.index = be, this.count = Je } get first() { return 0 === this.index } get last() { return this.index === this.count - 1 } get even() { return this.index % 2 == 0 } get odd() { return !this.even } } let Nr = (() => { class P { set ngForOf(B) { this._ngForOf = B, this._ngForOfDirty = !0 } set ngForTrackBy(B) { this._trackByFn = B } get ngForTrackBy() { return this._trackByFn } constructor(B, be, Je) { this._viewContainer = B, this._template = be, this._differs = Je, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null } set ngForTemplate(B) { B && (this._template = B) } ngDoCheck() { if (this._ngForOfDirty) { this._ngForOfDirty = !1; const B = this._ngForOf; !this._differ && B && (this._differ = this._differs.find(B).create(this.ngForTrackBy)) } if (this._differ) { const B = this._differ.diff(this._ngForOf); B && this._applyChanges(B) } } _applyChanges(B) { const be = this._viewContainer; B.forEachOperation((Je, $t, en) => { if (null == Je.previousIndex) be.createEmbeddedView(this._template, new bo(Je.item, this._ngForOf, -1, -1), null === en ? void 0 : en); else if (null == en) be.remove(null === $t ? void 0 : $t); else if (null !== $t) { const Zn = be.get($t); be.move(Zn, en), Vi(Zn, Je) } }); for (let Je = 0, $t = be.length; Je < $t; Je++) { const Zn = be.get(Je).context; Zn.index = Je, Zn.count = $t, Zn.ngForOf = this._ngForOf } B.forEachIdentityChange(Je => { Vi(be.get(Je.currentIndex), Je) }) } static ngTemplateContextGuard(B, be) { return !0 } } return P.\u0275fac = function (B) { return new (B || P)(a.Y36(a.s_b), a.Y36(a.Rgc), a.Y36(a.ZZ4)) }, P.\u0275dir = a.lG2({ type: P, selectors: [["", "ngFor", "", "ngForOf", ""]], inputs: { ngForOf: "ngForOf", ngForTrackBy: "ngForTrackBy", ngForTemplate: "ngForTemplate" }, standalone: !0 }), P })(); function Vi(P, X) { P.context.$implicit = X.item } let fo = (() => { class P { constructor(B, be) { this._viewContainer = B, this._context = new Jo, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = be } set ngIf(B) { this._context.$implicit = this._context.ngIf = B, this._updateView() } set ngIfThen(B) { sr("ngIfThen", B), this._thenTemplateRef = B, this._thenViewRef = null, this._updateView() } set ngIfElse(B) { sr("ngIfElse", B), this._elseTemplateRef = B, this._elseViewRef = null, this._updateView() } _updateView() { this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context))) } static ngTemplateContextGuard(B, be) { return !0 } } return P.\u0275fac = function (B) { return new (B || P)(a.Y36(a.s_b), a.Y36(a.Rgc)) }, P.\u0275dir = a.lG2({ type: P, selectors: [["", "ngIf", ""]], inputs: { ngIf: "ngIf", ngIfThen: "ngIfThen", ngIfElse: "ngIfElse" }, standalone: !0 }), P })(); class Jo { constructor() { this.$implicit = null, this.ngIf = null } } function sr(P, X) { if (X && !X.createEmbeddedView) throw new Error(`${P} must be a TemplateRef, but received '${(0, a.AaK)(X)}'.`) } class wt { constructor(X, B) { this._viewContainerRef = X, this._templateRef = B, this._created = !1 } create() { this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef) } destroy() { this._created = !1, this._viewContainerRef.clear() } enforceState(X) { X && !this._created ? this.create() : !X && this._created && this.destroy() } } let bt = (() => { class P { constructor() { this._defaultViews = [], this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1 } set ngSwitch(B) { this._ngSwitch = B, 0 === this._caseCount && this._updateDefaultCases(!0) } _addCase() { return this._caseCount++ } _addDefault(B) { this._defaultViews.push(B) } _matchCase(B) { const be = B == this._ngSwitch; return this._lastCasesMatched = this._lastCasesMatched || be, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), be } _updateDefaultCases(B) { if (this._defaultViews.length > 0 && B !== this._defaultUsed) { this._defaultUsed = B; for (const be of this._defaultViews) be.enforceState(B) } } } return P.\u0275fac = function (B) { return new (B || P) }, P.\u0275dir = a.lG2({ type: P, selectors: [["", "ngSwitch", ""]], inputs: { ngSwitch: "ngSwitch" }, standalone: !0 }), P })(), Rt = (() => { class P { constructor(B, be, Je) { this.ngSwitch = Je, Je._addCase(), this._view = new wt(B, be) } ngDoCheck() { this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase)) } } return P.\u0275fac = function (B) { return new (B || P)(a.Y36(a.s_b), a.Y36(a.Rgc), a.Y36(bt, 9)) }, P.\u0275dir = a.lG2({ type: P, selectors: [["", "ngSwitchCase", ""]], inputs: { ngSwitchCase: "ngSwitchCase" }, standalone: !0 }), P })(), sn = (() => { class P { constructor(B, be, Je) { Je._addDefault(new wt(B, be)) } } return P.\u0275fac = function (B) { return new (B || P)(a.Y36(a.s_b), a.Y36(a.Rgc), a.Y36(bt, 9)) }, P.\u0275dir = a.lG2({ type: P, selectors: [["", "ngSwitchDefault", ""]], standalone: !0 }), P })(), et = (() => { class P { constructor(B) { this._viewContainerRef = B, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null, this.ngTemplateOutletInjector = null } ngOnChanges(B) { if (B.ngTemplateOutlet || B.ngTemplateOutletInjector) { const be = this._viewContainerRef; if (this._viewRef && be.remove(be.indexOf(this._viewRef)), this.ngTemplateOutlet) { const { ngTemplateOutlet: Je, ngTemplateOutletContext: $t, ngTemplateOutletInjector: en } = this; this._viewRef = be.createEmbeddedView(Je, $t, en ? { injector: en } : void 0) } else this._viewRef = null } else this._viewRef && B.ngTemplateOutletContext && this.ngTemplateOutletContext && (this._viewRef.context = this.ngTemplateOutletContext) } } return P.\u0275fac = function (B) { return new (B || P)(a.Y36(a.s_b)) }, P.\u0275dir = a.lG2({ type: P, selectors: [["", "ngTemplateOutlet", ""]], inputs: { ngTemplateOutletContext: "ngTemplateOutletContext", ngTemplateOutlet: "ngTemplateOutlet", ngTemplateOutletInjector: "ngTemplateOutletInjector" }, standalone: !0, features: [a.TTD] }), P })(), oo = (() => { class P { } return P.\u0275fac = function (B) { return new (B || P) }, P.\u0275mod = a.oAB({ type: P }), P.\u0275inj = a.cJS({}), P })(); const Qr = "browser", es = "server"; function Yo(P) { return P === Qr } function so(P) { return P === es } let Ro = (() => { class P { } return P.\u0275prov = (0, a.Yz7)({ token: P, providedIn: "root", factory: () => new yo((0, a.LFG)(Se), window) }), P })(); class yo { constructor(X, B) { this.document = X, this.window = B, this.offset = () => [0, 0] } setOffset(X) { this.offset = Array.isArray(X) ? () => X : X } getScrollPosition() { return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0] } scrollToPosition(X) { this.supportsScrolling() && this.window.scrollTo(X[0], X[1]) } scrollToAnchor(X) { if (!this.supportsScrolling()) return; const B = function Qo(P, X) { const B = P.getElementById(X) || P.getElementsByName(X)[0]; if (B) return B; if ("function" == typeof P.createTreeWalker && P.body && "function" == typeof P.body.attachShadow) { const be = P.createTreeWalker(P.body, NodeFilter.SHOW_ELEMENT); let Je = be.currentNode; for (; Je;) { const $t = Je.shadowRoot; if ($t) { const en = $t.getElementById(X) || $t.querySelector(`[name="${X}"]`); if (en) return en } Je = be.nextNode() } } return null }(this.document, X); B && (this.scrollToElement(B), B.focus()) } setHistoryScrollRestoration(X) { if (this.supportScrollRestoration()) { const B = this.window.history; B && B.scrollRestoration && (B.scrollRestoration = X) } } scrollToElement(X) { const B = X.getBoundingClientRect(), be = B.left + this.window.pageXOffset, Je = B.top + this.window.pageYOffset, $t = this.offset(); this.window.scrollTo(be - $t[0], Je - $t[1]) } supportScrollRestoration() { try { if (!this.supportsScrolling()) return !1; const X = zo(this.window.history) || zo(Object.getPrototypeOf(this.window.history)); return !(!X || !X.writable && !X.set) } catch { return !1 } } supportsScrolling() { try { return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window } catch { return !1 } } } function zo(P) { return Object.getOwnPropertyDescriptor(P, "scrollRestoration") } class Ki { } }, 5879: (nn, Qe, C) => { C.d(Qe, { $8M: () => qs, $WT: () => ii, $Z: () => Yh, AFp: () => pm, ALo: () => F0, AaK: () => xe, AsE: () => ua, B6R: () => Rt, BQk: () => yf, CHM: () => Cl, CRH: () => Q0, DdM: () => M0, EJc: () => PC, EiD: () => rm, EpF: () => Cp, F$t: () => gb, F4k: () => Ip, FYo: () => kg, FiY: () => tc, Gf: () => Y0, GfV: () => Rg, GkF: () => Zd, Gpc: () => We, Gre: () => Ry, HDt: () => yw, Hsn: () => _b, Ikx: () => Tb, JOm: () => _l, JVY: () => cg, JZr: () => ut, Jf7: () => Hh, KtG: () => al, L6k: () => fv, LAX: () => ug, LFG: () => de, LSH: () => Gs, Lbi: () => qc, Lck: () => xE, MAs: () => Wd, MMx: () => y0, NdJ: () => xf, O4$: () => x, Ojb: () => bm, OlP: () => Cr, Oqu: () => ls, P3R: () => Yc, PXZ: () => ZC, Q6J: () => wp, QGY: () => wf, QbO: () => vm, Qsj: () => Sv, R0b: () => Wa, RDi: () => og, Rgc: () => Hp, SBq: () => Sd, Sil: () => FC, Suo: () => q0, TTD: () => pa, TgZ: () => xp, Udp: () => kp, VKq: () => S0, VuI: () => MI, W1O: () => tw, WFA: () => Ef, WLB: () => A0, X6Q: () => nI, XFs: () => Ke, Xpm: () => bt, Xq5: () => $u, Xts: () => Td, Y36: () => wc, YKP: () => v0, YNc: () => M_, Yjl: () => Vt, Yz7: () => Ae, Z0I: () => Pt, ZZ4: () => cy, _Bn: () => _0, _UZ: () => Ep, _Vd: () => gc, _c5: () => vI, _uU: () => Qi, aQg: () => dy, c2e: () => bw, cJS: () => qt, cg1: () => Sb, d8E: () => Mb, dDg: () => $C, dqk: () => Ue, eBb: () => dg, eFA: () => Pw, eJc: () => Kb, ekj: () => Rp, eoX: () => Aw, f3M: () => Lt, g9A: () => Oh, h0i: () => Tf, hGG: () => bI, hij: () => Co, iGM: () => Z0, ifc: () => fe, ip1: () => vw, jDz: () => w0, kL8: () => zy, kcU: () => $, lG2: () => et, lqb: () => Wl, lri: () => Mw, mCW: () => wh, n5z: () => vo, n_E: () => K_, oAB: () => dt, oxw: () => mb, pB0: () => yh, q3G: () => Wo, q4F: () => Og, qFp: () => AI, qLn: () => Sl, qOj: () => sp, qZA: () => Kd, qzn: () => uc, rWj: () => Sw, rg0: () => _r, s9C: () => Yl, sBO: () => iI, s_b: () => Y_, soG: () => Q_, tb: () => iy, tp0: () => nc, uIk: () => Zu, vHH: () => ie, vpe: () => Oc, wAp: () => Si, xi3: () => L0, xp6: () => Wh, ynx: () => bf, z2F: () => Af, z3N: () => bl, zSh: () => Mh, zs3: () => yc }); var a = C(8645), y = C(7394), v = C(5619), Y = C(5592), he = C(3019), Se = C(2096), ke = C(3020), re = C(4664), Ie = C(3997); function Q(n) { for (let i in n) if (n[i] === Q) return i; throw Error("Could not find renamed property on target object.") } function _e(n, i) { for (const o in i) i.hasOwnProperty(o) && !n.hasOwnProperty(o) && (n[o] = i[o]) } function xe(n) { if ("string" == typeof n) return n; if (Array.isArray(n)) return "[" + n.map(xe).join(", ") + "]"; if (null == n) return "" + n; if (n.overriddenName) return `${n.overriddenName}`; if (n.name) return `${n.name}`; const i = n.toString(); if (null == i) return "" + i; const o = i.indexOf("\n"); return -1 === o ? i : i.substring(0, o) } function ze(n, i) { return null == n || "" === n ? null === i ? "" : i : null == i || "" === i ? n : n + " " + i } const Oe = Q({ __forward_ref__: Q }); function We(n) { return n.__forward_ref__ = We, n.toString = function () { return xe(this()) }, n } function Pe(n) { return Ve(n) ? n() : n } function Ve(n) { return "function" == typeof n && n.hasOwnProperty(Oe) && n.__forward_ref__ === We } function tt(n) { return n && !!n.\u0275providers } const ut = "https://g.co/ng/security#xss"; class ie extends Error { constructor(i, o) { super(function Le(n, i) { return `NG0${Math.abs(n)}${i ? ": " + i : ""}` }(i, o)), this.code = i } } function le(n) { return "string" == typeof n ? n : null == n ? "" : String(n) } function rt(n, i) { throw new ie(-201, !1) } function rn(n, i) { null == n && function Jt(n, i, o, l) { throw new Error(`ASSERTION ERROR: ${n}` + (null == l ? "" : ` [Expected=> ${o} ${l} ${i} <=Actual]`)) }(i, n, null, "!=") } function Ae(n) { return { token: n.token, providedIn: n.providedIn || null, factory: n.factory, value: void 0 } } function qt(n) { return { providers: n.providers || [], imports: n.imports || [] } } function jt(n) { return qe(n, Zt) || qe(n, $n) } function Pt(n) { return null !== jt(n) } function qe(n, i) { return n.hasOwnProperty(i) ? n[i] : null } function on(n) { return n && (n.hasOwnProperty(gn) || n.hasOwnProperty(Fn)) ? n[gn] : null } const Zt = Q({ \u0275prov: Q }), gn = Q({ \u0275inj: Q }), $n = Q({ ngInjectableDef: Q }), Fn = Q({ ngInjectorDef: Q }); var Ke = (() => ((Ke = Ke || {})[Ke.Default = 0] = "Default", Ke[Ke.Host = 1] = "Host", Ke[Ke.Self = 2] = "Self", Ke[Ke.SkipSelf = 4] = "SkipSelf", Ke[Ke.Optional = 8] = "Optional", Ke))(); let se; function Xe(n) { const i = se; return se = n, i } function Ot(n, i, o) { const l = jt(n); return l && "root" == l.providedIn ? void 0 === l.value ? l.value = l.factory() : l.value : o & Ke.Optional ? null : void 0 !== i ? i : void rt(xe(n)) } const Ue = (() => typeof globalThis < "u" && globalThis || typeof global < "u" && global || typeof window < "u" && window || typeof self < "u" && typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && self)(), Mt = {}, Qt = "__NG_DI_FLAG__", fn = "ngTempTokenPath", Ln = /\n/gm, Et = "__source"; let _t; function W(n) { const i = _t; return _t = n, i } function me(n, i = Ke.Default) { if (void 0 === _t) throw new ie(-203, !1); return null === _t ? Ot(n, void 0, i) : _t.get(n, i & Ke.Optional ? null : void 0, i) } function de(n, i = Ke.Default) { return (function Me() { return se }() || me)(Pe(n), i) } function Lt(n, i = Ke.Default) { return de(n, He(i)) } function He(n) { return typeof n > "u" || "number" == typeof n ? n : 0 | (n.optional && 8) | (n.host && 1) | (n.self && 2) | (n.skipSelf && 4) } function ae(n) { const i = []; for (let o = 0; o < n.length; o++) { const l = Pe(n[o]); if (Array.isArray(l)) { if (0 === l.length) throw new ie(900, !1); let d, p = Ke.Default; for (let E = 0; E < l.length; E++) { const A = l[E], N = L(A); "number" == typeof N ? -1 === N ? d = A.token : p |= N : d = A } i.push(de(d, p)) } else i.push(de(l)) } return i } function z(n, i) { return n[Qt] = i, n.prototype[Qt] = i, n } function L(n) { return n[Qt] } function pt(n) { return { toString: n }.toString() } var pe = (() => ((pe = pe || {})[pe.OnPush = 0] = "OnPush", pe[pe.Default = 1] = "Default", pe))(), fe = (() => { return (n = fe || (fe = {}))[n.Emulated = 0] = "Emulated", n[n.None = 2] = "None", n[n.ShadowDom = 3] = "ShadowDom", fe; var n })(); const F = {}, J = [], Te = Q({ \u0275cmp: Q }), lt = Q({ \u0275dir: Q }), gt = Q({ \u0275pipe: Q }), Ht = Q({ \u0275mod: Q }), un = Q({ \u0275fac: Q }), yt = Q({ __NG_ELEMENT_ID__: Q }), It = Q({ __NG_ENV_ID__: Q }); function dn(n, i, o) { let l = n.length; for (; ;) { const d = n.indexOf(i, o); if (-1 === d) return d; if (0 === d || n.charCodeAt(d - 1) <= 32) { const p = i.length; if (d + p === l || n.charCodeAt(d + p) <= 32) return d } o = d + 1 } } function Pn(n, i, o) { let l = 0; for (; l < o.length;) { const d = o[l]; if ("number" == typeof d) { if (0 !== d) break; l++; const p = o[l++], E = o[l++], A = o[l++]; n.setAttribute(i, E, A, p) } else { const p = d, E = o[++l]; ni(p) ? n.setProperty(i, p, E) : n.setAttribute(i, p, E), l++ } } return l } function qn(n) { return 3 === n || 4 === n || 6 === n } function ni(n) { return 64 === n.charCodeAt(0) } function si(n, i) { if (null !== i && 0 !== i.length) if (null === n || 0 === n.length) n = i.slice(); else { let o = -1; for (let l = 0; l < i.length; l++) { const d = i[l]; "number" == typeof d ? o = d : 0 === o || Ai(n, o, d, null, -1 === o || 2 === o ? i[++l] : null) } } return n } function Ai(n, i, o, l, d) { let p = 0, E = n.length; if (-1 === i) E = -1; else for (; p < n.length;) { const A = n[p++]; if ("number" == typeof A) { if (A === i) { E = -1; break } if (A > i) { E = p - 1; break } } } for (; p < n.length;) { const A = n[p]; if ("number" == typeof A) break; if (A === o) { if (null === l) return void (null !== d && (n[p + 1] = d)); if (l === n[p + 1]) return void (n[p + 2] = d) } p++, null !== l && p++, null !== d && p++ } -1 !== E && (n.splice(E, 0, i), p = E + 1), n.splice(p++, 0, o), null !== l && n.splice(p++, 0, l), null !== d && n.splice(p++, 0, d) } const Li = "ng-template"; function ho(n, i, o) { let l = 0, d = !0; for (; l < n.length;) { let p = n[l++]; if ("string" == typeof p && d) { const E = n[l++]; if (o && "class" === p && -1 !== dn(E.toLowerCase(), i, 0)) return !0 } else { if (1 === p) { for (; l < n.length && "string" == typeof (p = n[l++]);)if (p.toLowerCase() === i) return !0; return !1 } "number" == typeof p && (d = !1) } } return !1 } function $r(n) { return 4 === n.type && n.value !== Li } function Io(n, i, o) { return i === (4 !== n.type || o ? n.value : Li) } function zi(n, i, o) { let l = 4; const d = n.attrs || [], p = function Nr(n) { for (let i = 0; i < n.length; i++)if (qn(n[i])) return i; return n.length }(d); let E = !1; for (let A = 0; A < i.length; A++) { const N = i[A]; if ("number" != typeof N) { if (!E) if (4 & l) { if (l = 2 | 1 & l, "" !== N && !Io(n, N, o) || "" === N && 1 === i.length) { if (Ti(l)) return !1; E = !0 } } else { const q = 8 & l ? N : i[++A]; if (8 & l && null !== n.attrs) { if (!ho(n.attrs, q, o)) { if (Ti(l)) return !1; E = !0 } continue } const Ge = Pr(8 & l ? "class" : N, d, $r(n), o); if (-1 === Ge) { if (Ti(l)) return !1; E = !0; continue } if ("" !== q) { let Dt; Dt = Ge > p ? "" : d[Ge + 1].toLowerCase(); const Bt = 8 & l ? Dt : null; if (Bt && -1 !== dn(Bt, q, 0) || 2 & l && q !== Dt) { if (Ti(l)) return !1; E = !0 } } } } else { if (!E && !Ti(l) && !Ti(N)) return !1; if (E && Ti(N)) continue; E = !1, l = N | 1 & l } } return Ti(l) || E } function Ti(n) { return 0 == (1 & n) } function Pr(n, i, o, l) { if (null === i) return -1; let d = 0; if (l || !o) { let p = !1; for (; d < i.length;) { const E = i[d]; if (E === n) return d; if (3 === E || 6 === E) p = !0; else { if (1 === E || 2 === E) { let A = i[++d]; for (; "string" == typeof A;)A = i[++d]; continue } if (4 === E) break; if (0 === E) { d += 4; continue } } d += p ? 1 : 2 } return -1 } return function Vi(n, i) { let o = n.indexOf(4); if (o > -1) for (o++; o < n.length;) { const l = n[o]; if ("number" == typeof l) return -1; if (l === i) return o; o++ } return -1 }(i, n) } function Ir(n, i, o = !1) { for (let l = 0; l < i.length; l++)if (zi(n, i[l], o)) return !0; return !1 } function cs(n, i) { e: for (let o = 0; o < i.length; o++) { const l = i[o]; if (n.length === l.length) { for (let d = 0; d < n.length; d++)if (n[d] !== l[d]) continue e; return !0 } } return !1 } function fo(n, i) { return n ? ":not(" + i.trim() + ")" : i } function Jo(n) { let i = n[0], o = 1, l = 2, d = "", p = !1; for (; o < n.length;) { let E = n[o]; if ("string" == typeof E) if (2 & l) { const A = n[++o]; d += "[" + E + (A.length > 0 ? '="' + A + '"' : "") + "]" } else 8 & l ? d += "." + E : 4 & l && (d += " " + E); else "" !== d && !Ti(E) && (i += fo(p, d), d = ""), l = E, p = p || !Ti(l); o++ } return "" !== d && (i += fo(p, d)), i } function bt(n) { return pt(() => { const i = Xi(n), o = { ...i, decls: n.decls, vars: n.vars, template: n.template, consts: n.consts || null, ngContentSelectors: n.ngContentSelectors, onPush: n.changeDetection === pe.OnPush, directiveDefs: null, pipeDefs: null, dependencies: i.standalone && n.dependencies || null, getStandaloneInjector: null, signals: n.signals ?? !1, data: n.data || {}, encapsulation: n.encapsulation || fe.Emulated, styles: n.styles || J, _: null, schemas: n.schemas || null, tView: null, id: "" }; Dr(o); const l = n.dependencies; return o.directiveDefs = xr(l, !1), o.pipeDefs = xr(l, !0), o.id = function mo(n) { let i = 0; const o = [n.selectors, n.ngContentSelectors, n.hostVars, n.hostAttrs, n.consts, n.vars, n.decls, n.encapsulation, n.standalone, n.signals, n.exportAs, JSON.stringify(n.inputs), JSON.stringify(n.outputs), Object.getOwnPropertyNames(n.type.prototype), !!n.contentQueries, !!n.viewQuery].join("|"); for (const d of o) i = Math.imul(31, i) + d.charCodeAt(0) << 0; return i += 2147483648, "c" + i }(o), o }) } function Rt(n, i, o) { const l = n.\u0275cmp; l.directiveDefs = xr(i, !1), l.pipeDefs = xr(o, !0) } function sn(n) { return At(n) || cn(n) } function wn(n) { return null !== n } function dt(n) { return pt(() => ({ type: n.type, bootstrap: n.bootstrap || J, declarations: n.declarations || J, imports: n.imports || J, exports: n.exports || J, transitiveCompileScopes: null, schemas: n.schemas || null, id: n.id || null })) } function ye(n, i) { if (null == n) return F; const o = {}; for (const l in n) if (n.hasOwnProperty(l)) { let d = n[l], p = d; Array.isArray(d) && (p = d[1], d = d[0]), o[d] = l, i && (i[d] = p) } return o } function et(n) { return pt(() => { const i = Xi(n); return Dr(i), i }) } function Vt(n) { return { type: n.type, name: n.name, factory: null, pure: !1 !== n.pure, standalone: !0 === n.standalone, onDestroy: n.type.prototype.ngOnDestroy || null } } function At(n) { return n[Te] || null } function cn(n) { return n[lt] || null } function Tn(n) { return n[gt] || null } function ii(n) { const i = At(n) || cn(n) || Tn(n); return null !== i && i.standalone } function wi(n, i) { const o = n[Ht] || null; if (!o && !0 === i) throw new Error(`Type ${xe(n)} does not have '\u0275mod' property.`); return o } function Xi(n) { const i = {}; return { type: n.type, providersResolver: null, factory: null, hostBindings: n.hostBindings || null, hostVars: n.hostVars || 0, hostAttrs: n.hostAttrs || null, contentQueries: n.contentQueries || null, declaredInputs: i, inputTransforms: null, inputConfig: n.inputs || F, exportAs: n.exportAs || null, standalone: !0 === n.standalone, signals: !0 === n.signals, selectors: n.selectors || J, viewQuery: n.viewQuery || null, features: n.features || null, setInput: null, findHostDirectiveDefs: null, hostDirectives: null, inputs: ye(n.inputs, i), outputs: ye(n.outputs) } } function Dr(n) { n.features?.forEach(i => i(n)) } function xr(n, i) { if (!n) return null; const o = i ? Tn : sn; return () => ("function" == typeof n ? n() : n).map(l => o(l)).filter(wn) } const _i = 0, Sn = 1, ci = 2, ki = 3, tr = 4, Lr = 5, nr = 6, io = 7, di = 8, qr = 9, ro = 10, Xn = 11, vs = 12, Ao = 13, ko = 14, cr = 15, Zo = 16, ds = 17, oo = 18, Qr = 19, es = 20, Tr = 21, Br = 22, Yo = 23, so = 24, Mi = 25, Ho = 1, Ro = 2, yo = 7, Qo = 9, Ki = 11; function Er(n) { return Array.isArray(n) && "object" == typeof n[Ho] } function Gr(n) { return Array.isArray(n) && !0 === n[Ho] } function us(n) { return 0 != (4 & n.flags) } function dr(n) { return n.componentOffset > -1 } function Wr(n) { return 1 == (1 & n.flags) } function Ni(n) { return !!n.template } function As(n) { return 0 != (512 & n[ci]) } function kt(n, i) { return n.hasOwnProperty(un) ? n[un] : null } let Zi = Ue.WeakRef ?? class Ii { constructor(i) { this.ref = i } deref() { return this.ref } }, ir = 0, ar = null, gr = !1; function Yi(n) { const i = ar; return ar = n, i } class Kr { constructor() { this.id = ir++, this.ref = function ji(n) { return new Zi(n) }(this), this.producers = new Map, this.consumers = new Map, this.trackingVersion = 0, this.valueVersion = 0 } consumerPollProducersForChange() { for (const [i, o] of this.producers) { const l = o.producerNode.deref(); if (void 0 !== l && o.atTrackingVersion === this.trackingVersion) { if (l.producerPollStatus(o.seenValueVersion)) return !0 } else this.producers.delete(i), l?.consumers.delete(this.id) } return !1 } producerMayHaveChanged() { const i = gr; gr = !0; try { for (const [o, l] of this.consumers) { const d = l.consumerNode.deref(); void 0 !== d && d.trackingVersion === l.atTrackingVersion ? d.onConsumerDependencyMayHaveChanged() : (this.consumers.delete(o), d?.producers.delete(this.id)) } } finally { gr = i } } producerAccessed() { if (gr) throw new Error(""); if (null === ar) return; let i = ar.producers.get(this.id); void 0 === i ? (i = { consumerNode: ar.ref, producerNode: this.ref, seenValueVersion: this.valueVersion, atTrackingVersion: ar.trackingVersion }, ar.producers.set(this.id, i), this.consumers.set(ar.id, i)) : (i.seenValueVersion = this.valueVersion, i.atTrackingVersion = ar.trackingVersion) } get hasProducers() { return this.producers.size > 0 } get producerUpdatesAllowed() { return !1 !== ar?.consumerAllowSignalWrites } producerPollStatus(i) { return this.valueVersion !== i || (this.onProducerUpdateValueVersion(), this.valueVersion !== i) } } let Jr = null; function _r(n) { const i = Yi(null); try { return n() } finally { Yi(i) } } const ma = () => { }; class Ya extends Kr { constructor(i, o, l) { super(), this.watch = i, this.schedule = o, this.dirty = !1, this.cleanupFn = ma, this.registerOnCleanup = d => { this.cleanupFn = d }, this.consumerAllowSignalWrites = l } notify() { this.dirty || this.schedule(this), this.dirty = !0 } onConsumerDependencyMayHaveChanged() { this.notify() } onProducerUpdateValueVersion() { } run() { if (this.dirty = !1, 0 !== this.trackingVersion && !this.consumerPollProducersForChange()) return; const i = Yi(this); this.trackingVersion++; try { this.cleanupFn(), this.cleanupFn = ma, this.watch(this.registerOnCleanup) } finally { Yi(i) } } cleanup() { this.cleanupFn() } } class To { constructor(i, o, l) { this.previousValue = i, this.currentValue = o, this.firstChange = l } isFirstChange() { return this.firstChange } } function pa() { return ia } function ia(n) { return n.type.prototype.ngOnChanges && (n.setInput = Ta), Bs } function Bs() { const n = ms(this), i = n?.current; if (i) { const o = n.previous; if (o === F) n.previous = i; else for (let l in i) o[l] = i[l]; n.current = null, this.ngOnChanges(i) } } function Ta(n, i, o, l) { const d = this.declaredInputs[o], p = ms(n) || function ts(n, i) { return n[Ma] = i }(n, { previous: F, current: null }), E = p.current || (p.current = {}), A = p.previous, N = A[d]; E[d] = new To(N && N.currentValue, i, A === F), n[l] = i } pa.ngInherit = !0; const Ma = "__ngSimpleChanges__"; function ms(n) { return n[Ma] || null } const go = function (n, i, o) { }, Os = "svg"; function yr(n) { for (; Array.isArray(n);)n = n[_i]; return n } function P(n, i) { return yr(i[n]) } function X(n, i) { return yr(i[n.index]) } function be(n, i) { return n.data[i] } function Je(n, i) { return n[i] } function $t(n, i) { const o = i[n]; return Er(o) ? o : o[_i] } function xi(n, i) { return null == i ? null : n[i] } function Hi(n) { n[ds] = 0 } function Fi(n) { 1024 & n[ci] || (n[ci] |= 1024, qi(n, 1)) } function Di(n) { 1024 & n[ci] && (n[ci] &= -1025, qi(n, -1)) } function qi(n, i) { let o = n[ki]; if (null === o) return; o[Lr] += i; let l = o; for (o = o[ki]; null !== o && (1 === i && 1 === l[Lr] || -1 === i && 0 === l[Lr]);)o[Lr] += i, l = o, o = o[ki] } const ui = { lFrame: cl(null), bindingsEnabled: !0, skipHydrationRootTNode: null }; function ai() { return ui.bindingsEnabled } function co() { return null !== ui.skipHydrationRootTNode } function vn() { return ui.lFrame.lView } function $i() { return ui.lFrame.tView } function Cl(n) { return ui.lFrame.contextLView = n, n[di] } function al(n) { return ui.lFrame.contextLView = null, n } function xo() { let n = qa(); for (; null !== n && 64 === n.type;)n = n.parent; return n } function qa() { return ui.lFrame.currentTNode } function ps(n, i) { const o = ui.lFrame; o.currentTNode = n, o.isParent = i } function Qa() { return ui.lFrame.isParent } function Vr() { ui.lFrame.isParent = !1 } function Ri() { const n = ui.lFrame; let i = n.bindingRootIndex; return -1 === i && (i = n.bindingRootIndex = n.tView.bindingStartIndex), i } function Pi() { return ui.lFrame.bindingIndex++ } function Es(n) { const i = ui.lFrame, o = i.bindingIndex; return i.bindingIndex = i.bindingIndex + n, o } function Vs(n, i) { const o = ui.lFrame; o.bindingIndex = o.bindingRootIndex = n, Ys(i) } function Ys(n) { ui.lFrame.currentDirectiveIndex = n } function Sa(n) { const i = ui.lFrame.currentDirectiveIndex; return -1 === i ? null : n[i] } function Ba() { return ui.lFrame.currentQueryIndex } function Aa(n) { ui.lFrame.currentQueryIndex = n } function ka(n) { const i = n[Sn]; return 2 === i.type ? i.declTNode : 1 === i.type ? n[nr] : null } function va(n, i, o) { if (o & Ke.SkipSelf) { let d = i, p = n; for (; !(d = d.parent, null !== d || o & Ke.Host || (d = ka(p), null === d || (p = p[ko], 10 & d.type)));); if (null === d) return !1; i = d, n = p } const l = ui.lFrame = ns(); return l.currentTNode = i, l.lView = n, !0 } function Xa(n) { const i = ns(), o = n[Sn]; ui.lFrame = i, i.currentTNode = o.firstChild, i.lView = n, i.tView = o, i.contextLView = n, i.bindingIndex = o.bindingStartIndex, i.inI18n = !1 } function ns() { const n = ui.lFrame, i = null === n ? null : n.child; return null === i ? cl(n) : i } function cl(n) { const i = { currentTNode: null, isParent: !0, lView: null, tView: null, selectedIndex: -1, contextLView: null, elementDepthCount: 0, currentNamespace: null, currentDirectiveIndex: -1, bindingRootIndex: -1, bindingIndex: -1, currentQueryIndex: 0, parent: n, child: null, inI18n: !1 }; return null !== n && (n.child = i), i } function dl() { const n = ui.lFrame; return ui.lFrame = n.parent, n.currentTNode = null, n.lView = null, n } const ul = dl; function Ps() { const n = dl(); n.isParent = !0, n.tView = null, n.selectedIndex = -1, n.contextLView = null, n.elementDepthCount = 0, n.currentDirectiveIndex = -1, n.currentNamespace = null, n.bindingRootIndex = -1, n.bindingIndex = -1, n.currentQueryIndex = 0 } function m() { return ui.lFrame.selectedIndex } function u(n) { ui.lFrame.selectedIndex = n } function h() { const n = ui.lFrame; return be(n.tView, n.selectedIndex) } function x() { ui.lFrame.currentNamespace = Os } function $() { !function Ee() { ui.lFrame.currentNamespace = null }() } let ft = !0; function zt() { return ft } function xn(n) { ft = n } function ri(n, i) { for (let o = i.directiveStart, l = i.directiveEnd; o < l; o++) { const p = n.data[o].type.prototype, { ngAfterContentInit: E, ngAfterContentChecked: A, ngAfterViewInit: N, ngAfterViewChecked: q, ngOnDestroy: we } = p; E && (n.contentHooks ??= []).push(-o, E), A && ((n.contentHooks ??= []).push(o, A), (n.contentCheckHooks ??= []).push(o, A)), N && (n.viewHooks ??= []).push(-o, N), q && ((n.viewHooks ??= []).push(o, q), (n.viewCheckHooks ??= []).push(o, q)), null != we && (n.destroyHooks ??= []).push(o, we) } } function hi(n, i, o) { zr(n, i, 3, o) } function fi(n, i, o, l) { (3 & n[ci]) === o && zr(n, i, o, l) } function ei(n, i) { let o = n[ci]; (3 & o) === i && (o &= 8191, o += 1, n[ci] = o) } function zr(n, i, o, l) { const p = l ?? -1, E = i.length - 1; let A = 0; for (let N = void 0 !== l ? 65535 & n[ds] : 0; N < E; N++)if ("number" == typeof i[N + 1]) { if (A = i[N], null != l && A >= l) break } else i[N] < 0 && (n[ds] += 65536), (A < p || -1 == p) && (Ar(n, o, i, N), n[ds] = (4294901760 & n[ds]) + N + 2), N++ } function Po(n, i) { go(4, n, i); const o = Yi(null); try { i.call(n) } finally { Yi(o), go(5, n, i) } } function Ar(n, i, o, l) { const d = o[l] < 0, p = o[l + 1], A = n[d ? -o[l] : o[l]]; d ? n[ci] >> 13 < n[ds] >> 16 && (3 & n[ci]) === i && (n[ci] += 8192, Po(A, p)) : Po(A, p) } const Mo = -1; class Fr { constructor(i, o, l) { this.factory = i, this.resolving = !1, this.canSeeViewProviders = o, this.injectImpl = l } } function ya(n) { return n !== Mo } function el(n) { return 32767 & n } function oi(n, i) { let o = function Pl(n) { return n >> 16 }(n), l = i; for (; o > 0;)l = l[ko], o--; return l } let pi = !0; function bi(n) { const i = pi; return pi = n, i } const Go = 255, Cs = 5; let Hs = 0; const No = {}; function Ua(n, i) { const o = or(n, i); if (-1 !== o) return o; const l = i[Sn]; l.firstCreatePass && (n.injectorIndex = i.length, wa(l.data, n), wa(i, null), wa(l.blueprint, null)); const d = Is(n, i), p = n.injectorIndex; if (ya(d)) { const E = el(d), A = oi(d, i), N = A[Sn].data; for (let q = 0; q < 8; q++)i[p + q] = A[E + q] | N[E + q] } return i[p + 8] = d, p } function wa(n, i) { n.push(0, 0, 0, 0, 0, 0, 0, 0, i) } function or(n, i) { return -1 === n.injectorIndex || n.parent && n.parent.injectorIndex === n.injectorIndex || null === i[n.injectorIndex + 8] ? -1 : n.injectorIndex } function Is(n, i) { if (n.parent && -1 !== n.parent.injectorIndex) return n.parent.injectorIndex; let o = 0, l = null, d = i; for (; null !== d;) { if (l = hl(d), null === l) return Mo; if (o++, d = d[ko], -1 !== l.injectorIndex) return l.injectorIndex | o << 16 } return Mo } function _o(n, i, o) { !function to(n, i, o) { let l; "string" == typeof o ? l = o.charCodeAt(0) || 0 : o.hasOwnProperty(yt) && (l = o[yt]), null == l && (l = o[yt] = Hs++); const d = l & Go; i.data[n + (d >> Cs)] |= 1 << d }(n, i, o) } function ur(n, i, o) { if (o & Ke.Optional || void 0 !== n) return n; rt() } function Ha(n, i, o, l) { if (o & Ke.Optional && void 0 === l && (l = null), !(o & (Ke.Self | Ke.Host))) { const d = n[qr], p = Xe(void 0); try { return d ? d.get(i, l, o & Ke.Optional) : Ot(i, l, o & Ke.Optional) } finally { Xe(p) } } return ur(l, 0, o) } function Fo(n, i, o, l = Ke.Default, d) { if (null !== n) { if (2048 & i[ci] && !(l & Ke.Self)) { const E = function Oa(n, i, o, l, d) { let p = n, E = i; for (; null !== p && null !== E && 2048 & E[ci] && !(512 & E[ci]);) { const A = Zr(p, E, o, l | Ke.Self, No); if (A !== No) return A; let N = p.parent; if (!N) { const q = E[es]; if (q) { const we = q.get(o, No, l); if (we !== No) return we } N = hl(E), E = E[ko] } p = N } return d }(n, i, o, l, No); if (E !== No) return E } const p = Zr(n, i, o, l, No); if (p !== No) return p } return Ha(i, o, l, d) } function Zr(n, i, o, l, d) { const p = function Xd(n) { if ("string" == typeof n) return n.charCodeAt(0) || 0; const i = n.hasOwnProperty(yt) ? n[yt] : void 0; return "number" == typeof i ? i >= 0 ? i & Go : ja : i }(o); if ("function" == typeof p) { if (!va(i, n, l)) return l & Ke.Host ? ur(d, 0, l) : Ha(i, o, l, d); try { const E = p(l); if (null != E || l & Ke.Optional) return E; rt() } finally { ul() } } else if ("number" == typeof p) { let E = null, A = or(n, i), N = Mo, q = l & Ke.Host ? i[cr][nr] : null; for ((-1 === A || l & Ke.SkipSelf) && (N = -1 === A ? Is(n, i) : i[A + 8], N !== Mo && Lo(l, !1) ? (E = i[Sn], A = el(N), i = oi(N, i)) : A = -1); -1 !== A;) { const we = i[Sn]; if (ud(p, A, we.data)) { const Ge = Nl(A, i, o, E, l, q); if (Ge !== No) return Ge } N = i[A + 8], N !== Mo && Lo(l, i[Sn].data[A + 8] === q) && ud(p, A, i) ? (E = we, A = el(N), i = oi(N, i)) : A = -1 } } return d } function Nl(n, i, o, l, d, p) { const E = i[Sn], A = E.data[n + 8], we = za(A, E, o, null == l ? dr(A) && pi : l != E && 0 != (3 & A.type), d & Ke.Host && p === A); return null !== we ? Xo(i, E, we, A) : No } function za(n, i, o, l, d) { const p = n.providerIndexes, E = i.data, A = 1048575 & p, N = n.directiveStart, we = p >> 20, Dt = d ? A + we : n.directiveEnd; for (let Bt = l ? A : A + we; Bt < Dt; Bt++) { const hn = E[Bt]; if (Bt < N && o === hn || Bt >= N && hn.type === o) return Bt } if (d) { const Bt = E[N]; if (Bt && Ni(Bt) && Bt.type === o) return N } return null } function Xo(n, i, o, l) { let d = n[o]; const p = i.data; if (function Ja(n) { return n instanceof Fr }(d)) { const E = d; E.resolving && function ue(n, i) { const o = i ? `. Dependency path: ${i.join(" > ")} > ${n}` : ""; throw new ie(-200, `Circular dependency in DI detected for ${n}${o}`) }(function ge(n) { return "function" == typeof n ? n.name || n.toString() : "object" == typeof n && null != n && "function" == typeof n.type ? n.type.name || n.type.toString() : le(n) }(p[o])); const A = bi(E.canSeeViewProviders); E.resolving = !0; const N = E.injectImpl ? Xe(E.injectImpl) : null; va(n, l, Ke.Default); try { d = n[o] = E.factory(void 0, p, n, l), i.firstCreatePass && o >= l.directiveStart && function An(n, i, o) { const { ngOnChanges: l, ngOnInit: d, ngDoCheck: p } = i.type.prototype; if (l) { const E = ia(i); (o.preOrderHooks ??= []).push(n, E), (o.preOrderCheckHooks ??= []).push(n, E) } d && (o.preOrderHooks ??= []).push(0 - n, d), p && ((o.preOrderHooks ??= []).push(n, p), (o.preOrderCheckHooks ??= []).push(n, p)) }(o, p[o], i) } finally { null !== N && Xe(N), bi(A), E.resolving = !1, ul() } } return d } function ud(n, i, o) { return !!(o[i + (n >> Cs)] & 1 << n) } function Lo(n, i) { return !(n & Ke.Self || n & Ke.Host && i) } class xa { constructor(i, o) { this._tNode = i, this._lView = o } get(i, o, l) { return Fo(this._tNode, this._lView, i, He(l), o) } } function ja() { return new xa(xo(), vn()) } function vo(n) { return pt(() => { const i = n.prototype.constructor, o = i[un] || Ea(i), l = Object.prototype; let d = Object.getPrototypeOf(n.prototype).constructor; for (; d && d !== l;) { const p = d[un] || Ea(d); if (p && p !== o) return p; d = Object.getPrototypeOf(d) } return p => new p }) } function Ea(n) { return Ve(n) ? () => { const i = Ea(Pe(n)); return i && i() } : kt(n) } function hl(n) { const i = n[Sn], o = i.type; return 2 === o ? i.declTNode : 1 === o ? n[nr] : null } function qs(n) { return function Va(n, i) { if ("class" === i) return n.classes; if ("style" === i) return n.styles; const o = n.attrs; if (o) { const l = o.length; let d = 0; for (; d < l;) { const p = o[d]; if (qn(p)) break; if (0 === p) d += 2; else if ("number" == typeof p) for (d++; d < l && "string" == typeof o[d];)d++; else { if (p === i) return o[d + 1]; d += 2 } } } return null }(xo(), n) } const zs = "__parameters__"; function Ns(n, i, o) { return pt(() => { const l = function la(n) { return function (...o) { if (n) { const l = n(...o); for (const d in l) this[d] = l[d] } } }(i); function d(...p) { if (this instanceof d) return l.apply(this, p), this; const E = new d(...p); return A.annotation = E, A; function A(N, q, we) { const Ge = N.hasOwnProperty(zs) ? N[zs] : Object.defineProperty(N, zs, { value: [] })[zs]; for (; Ge.length <= we;)Ge.push(null); return (Ge[we] = Ge[we] || []).push(E), N } } return o && (d.prototype = Object.create(o.prototype)), d.prototype.ngMetadataName = n, d.annotationCls = d, d }) } function Pa(n, i) { n.forEach(o => Array.isArray(o) ? Pa(o, i) : i(o)) } function Qs(n, i, o) { i >= n.length ? n.push(o) : n.splice(i, 0, o) } function no(n, i) { return i >= n.length - 1 ? n.pop() : n.splice(i, 1)[0] } function ml(n, i) { const o = []; for (let l = 0; l < n; l++)o.push(i); return o } function Ts(n, i, o) { let l = Ll(n, i); return l >= 0 ? n[1 | l] = o : (l = ~l, function ch(n, i, o, l) { let d = n.length; if (d == i) n.push(o, l); else if (1 === d) n.push(l, n[0]), n[0] = o; else { for (d--, n.push(n[d - 1], n[d]); d > i;)n[d] = n[d - 2], d--; n[i] = o, n[i + 1] = l } }(n, l, i, o)), l } function eu(n, i) { const o = Ll(n, i); if (o >= 0) return n[1 | o] } function Ll(n, i) { return function Yr(n, i, o) { let l = 0, d = n.length >> o; for (; d !== l;) { const p = l + (d - l >> 1), E = n[p << o]; if (i === E) return p << o; E > i ? d = p : l = p + 1 } return ~(d << o) }(n, i, 1) } const tc = z(Ns("Optional"), 8), nc = z(Ns("SkipSelf"), 4); function hu(n) { return 128 == (128 & n.flags) } var _l = (() => ((_l = _l || {})[_l.Important = 1] = "Important", _l[_l.DashCase = 2] = "DashCase", _l))(); const fh = /^>|^->|<!--|-->|--!>|<!-$/g, iv = /(<|>)/, rv = "\u200b$1\u200b"; const ic = new Map; let Lc = 0; const Bf = "__ngContext__"; function fr(n, i) { Er(i) ? (n[Bf] = i[Qr], function Bc(n) { ic.set(n[Qr], n) }(i)) : n[Bf] = i } let mh; function oc(n, i) { return mh(n, i) } function Vc(n) { const i = n[ki]; return Gr(i) ? i[ki] : i } function Zp(n) { return _s(n[vs]) } function Yp(n) { return _s(n[tr]) } function _s(n) { for (; null !== n && !Gr(n);)n = n[tr]; return n } function mr(n, i, o, l, d) { if (null != l) { let p, E = !1; Gr(l) ? p = l : Er(l) && (E = !0, l = l[_i]); const A = yr(l); 0 === n && null !== o ? null == d ? tg(i, o, A) : sc(i, o, A, d || null, !0) : 1 === n && null !== o ? sc(i, o, A, d || null, !0) : 2 === n ? function lc(n, i, o) { const l = xd(n, i); l && function lv(n, i, o, l) { n.removeChild(i, o, l) }(n, l, i, o) }(i, A, E) : 3 === n && i.destroyNode(A), null != p && function yu(n, i, o, l, d) { const p = o[yo]; p !== yr(o) && mr(i, n, l, p, d); for (let A = Ki; A < o.length; A++) { const N = o[A]; Cd(N[Sn], N, n, i, l, p) } }(i, n, p, o, d) } } function gu(n, i) { return n.createComment(function Ff(n) { return n.replace(fh, i => i.replace(iv, rv)) }(i)) } function Hc(n, i, o) { return n.createElement(i, o) } function wd(n, i) { const o = n[Qo], l = o.indexOf(i); Di(i), o.splice(l, 1) } function zc(n, i) { if (n.length <= Ki) return; const o = Ki + i, l = n[o]; if (l) { const d = l[Zo]; null !== d && d !== n && wd(d, l), i > 0 && (n[o - 1][tr] = l[tr]); const p = no(n, Ki + i); !function qp(n, i) { Cd(n, i, i[Xn], 2, null, null), i[_i] = null, i[nr] = null }(l[Sn], l); const E = p[oo]; null !== E && E.detachView(p[Sn]), l[ki] = null, l[tr] = null, l[ci] &= -129 } return l } function vu(n, i) { if (!(256 & i[ci])) { const o = i[Xn]; i[Yo]?.destroy(), i[so]?.destroy(), o.destroyNode && Cd(n, i, o, 3, null, null), function Xp(n) { let i = n[vs]; if (!i) return ph(n[Sn], n); for (; i;) { let o = null; if (Er(i)) o = i[vs]; else { const l = i[Ki]; l && (o = l) } if (!o) { for (; i && !i[tr] && i !== n;)Er(i) && ph(i[Sn], i), i = i[ki]; null === i && (i = n), Er(i) && ph(i[Sn], i), o = i && i[tr] } i = o } }(i) } } function ph(n, i) { if (!(256 & i[ci])) { i[ci] &= -129, i[ci] |= 256, function eg(n, i) { let o; if (null != n && null != (o = n.destroyHooks)) for (let l = 0; l < o.length; l += 2) { const d = i[o[l]]; if (!(d instanceof Fr)) { const p = o[l + 1]; if (Array.isArray(p)) for (let E = 0; E < p.length; E += 2) { const A = d[p[E]], N = p[E + 1]; go(4, A, N); try { N.call(A) } finally { go(5, A, N) } } else { go(4, d, p); try { p.call(d) } finally { go(5, d, p) } } } } }(n, i), function Jp(n, i) { const o = n.cleanup, l = i[io]; if (null !== o) for (let p = 0; p < o.length - 1; p += 2)if ("string" == typeof o[p]) { const E = o[p + 3]; E >= 0 ? l[E]() : l[-E].unsubscribe(), p += 2 } else o[p].call(l[o[p + 1]]); null !== l && (i[io] = null); const d = i[Tr]; if (null !== d) { i[Tr] = null; for (let p = 0; p < d.length; p++)(0, d[p])() } }(n, i), 1 === i[Sn].type && i[Xn].destroy(); const o = i[Zo]; if (null !== o && Gr(i[ki])) { o !== i[ki] && wd(o, i); const l = i[oo]; null !== l && l.detachView(n) } !function vd(n) { ic.delete(n[Qr]) }(i) } } function Wf(n, i, o) { return function Kf(n, i, o) { let l = i; for (; null !== l && 40 & l.type;)l = (i = l).parent; if (null === l) return o[_i]; { const { componentOffset: d } = l; if (d > -1) { const { encapsulation: p } = n.data[l.directiveStart + d]; if (p === fe.None || p === fe.Emulated) return null } return X(l, o) } }(n, i.parent, o) } function sc(n, i, o, l, d) { n.insertBefore(i, o, l, d) } function tg(n, i, o) { n.appendChild(i, o) } function ng(n, i, o, l, d) { null !== l ? sc(n, i, o, l, d) : tg(n, i, o) } function xd(n, i) { return n.parentNode(i) } function Zf(n, i, o) { return ss(n, i, o) } let bu, wu, dc, Eu, ss = function ig(n, i, o) { return 40 & n.type ? X(n, o) : null }; function ac(n, i, o, l) { const d = Wf(n, l, i), p = i[Xn], A = Zf(l.parent || i[nr], l, i); if (null != d) if (Array.isArray(o)) for (let N = 0; N < o.length; N++)ng(p, d, o[N], A, !1); else ng(p, d, o, A, !1); void 0 !== bu && bu(p, l, i, o, d) } function Na(n, i) { if (null !== i) { const o = i.type; if (3 & o) return X(i, n); if (4 & o) return _h(-1, n[i.index]); if (8 & o) { const l = i.child; if (null !== l) return Na(n, l); { const d = n[i.index]; return Gr(d) ? _h(-1, d) : yr(d) } } if (32 & o) return oc(i, n)() || yr(n[i.index]); { const l = gh(n, i); return null !== l ? Array.isArray(l) ? l[0] : Na(Vc(n[cr]), l) : Na(n, i.next) } } return null } function gh(n, i) { return null !== i ? n[cr][nr].projection[i.projection] : null } function _h(n, i) { const o = Ki + n + 1; if (o < i.length) { const l = i[o], d = l[Sn].firstChild; if (null !== d) return Na(l, d) } return i[yo] } function vh(n, i, o, l, d, p, E) { for (; null != o;) { const A = l[o.index], N = o.type; if (E && 0 === i && (A && fr(yr(A), l), o.flags |= 2), 32 != (32 & o.flags)) if (8 & N) vh(n, i, o.child, l, d, p, !1), mr(i, n, d, A, p); else if (32 & N) { const q = oc(o, l); let we; for (; we = q();)mr(i, n, d, we, p); mr(i, n, d, A, p) } else 16 & N ? rg(n, i, l, o, d, p) : mr(i, n, d, A, p); o = E ? o.projectionNext : o.next } } function Cd(n, i, o, l, d, p) { vh(o, l, n.firstChild, i, d, p, !1) } function rg(n, i, o, l, d, p) { const E = o[cr], N = E[nr].projection[l.projection]; if (Array.isArray(N)) for (let q = 0; q < N.length; q++)mr(i, n, d, N[q], p); else { let q = N; const we = E[ki]; hu(l) && (q.flags |= 128), vh(n, i, q, we, d, p, !0) } } function Xf(n, i, o) { "" === o ? n.removeAttribute(i, "class") : n.setAttribute(i, "class", o) } function bh(n, i, o) { const { mergedAttrs: l, classes: d, styles: p } = o; null !== l && Pn(n, i, l), null !== d && Xf(n, i, d), null !== p && function dv(n, i, o) { n.setAttribute(i, "style", o) }(n, i, p) } function jc(n) { return function Jf() { if (void 0 === wu && (wu = null, Ue.trustedTypes)) try { wu = Ue.trustedTypes.createPolicy("angular", { createHTML: n => n, createScript: n => n, createScriptURL: n => n }) } catch { } return wu }()?.createHTML(n) || n } function og(n) { dc = n } function tm(n) { return function vl() { if (void 0 === Eu && (Eu = null, Ue.trustedTypes)) try { Eu = Ue.trustedTypes.createPolicy("angular#unsafe-bypass", { createHTML: n => n, createScript: n => n, createScriptURL: n => n }) } catch { } return Eu }()?.createScriptURL(n) || n } class Tl { constructor(i) { this.changingThisBreaksApplicationSecurity = i } toString() { return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see ${ut})` } } class $c extends Tl { getTypeName() { return "HTML" } } class Gc extends Tl { getTypeName() { return "Style" } } class Wc extends Tl { getTypeName() { return "Script" } } class Cu extends Tl { getTypeName() { return "URL" } } class ag extends Tl { getTypeName() { return "ResourceURL" } } function bl(n) { return n instanceof Tl ? n.changingThisBreaksApplicationSecurity : n } function uc(n, i) { const o = function lg(n) { return n instanceof Tl && n.getTypeName() || null }(n); if (null != o && o !== i) { if ("ResourceURL" === o && "URL" === i) return !0; throw new Error(`Required a safe ${i}, got a ${o} (see ${ut})`) } return o === i } function cg(n) { return new $c(n) } function fv(n) { return new Gc(n) } function dg(n) { return new Wc(n) } function ug(n) { return new Cu(n) } function yh(n) { return new ag(n) } class Kc { constructor(i) { this.inertDocumentHelper = i } getInertBodyElement(i) { i = "<body><remove></remove>" + i; try { const o = (new window.DOMParser).parseFromString(jc(i), "text/html").body; return null === o ? this.inertDocumentHelper.getInertBodyElement(i) : (o.removeChild(o.firstChild), o) } catch { return null } } } class mv { constructor(i) { this.defaultDoc = i, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert") } getInertBodyElement(i) { const o = this.inertDocument.createElement("template"); return o.innerHTML = jc(i), o } } const pv = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:\/?#]*(?:[\/?#]|$))/i; function wh(n) { return (n = String(n)).match(pv) ? n : "unsafe:" + n } function zl(n) { const i = {}; for (const o of n.split(",")) i[o] = !0; return i } function jl(...n) { const i = {}; for (const o of n) for (const l in o) o.hasOwnProperty(l) && (i[l] = !0); return i } const hc = zl("area,br,col,hr,img,wbr"), $l = zl("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), nm = zl("rp,rt"), Iu = jl(hc, jl($l, zl("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")), jl(nm, zl("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")), jl(nm, $l)), Du = zl("background,cite,href,itemtype,longdesc,poster,src,xlink:href"), xh = jl(Du, zl("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,srcset,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"), zl("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext")), mg = zl("script,style,template"); class Eh { constructor() { this.sanitizedSomething = !1, this.buf = [] } sanitizeChildren(i) { let o = i.firstChild, l = !0; for (; o;)if (o.nodeType === Node.ELEMENT_NODE ? l = this.startElement(o) : o.nodeType === Node.TEXT_NODE ? this.chars(o.nodeValue) : this.sanitizedSomething = !0, l && o.firstChild) o = o.firstChild; else for (; o;) { o.nodeType === Node.ELEMENT_NODE && this.endElement(o); let d = this.checkClobberedElement(o, o.nextSibling); if (d) { o = d; break } o = this.checkClobberedElement(o, o.parentNode) } return this.buf.join("") } startElement(i) { const o = i.nodeName.toLowerCase(); if (!Iu.hasOwnProperty(o)) return this.sanitizedSomething = !0, !mg.hasOwnProperty(o); this.buf.push("<"), this.buf.push(o); const l = i.attributes; for (let d = 0; d < l.length; d++) { const p = l.item(d), E = p.name, A = E.toLowerCase(); if (!xh.hasOwnProperty(A)) { this.sanitizedSomething = !0; continue } let N = p.value; Du[A] && (N = wh(N)), this.buf.push(" ", E, '="', Tu(N), '"') } return this.buf.push(">"), !0 } endElement(i) { const o = i.nodeName.toLowerCase(); Iu.hasOwnProperty(o) && !hc.hasOwnProperty(o) && (this.buf.push("</"), this.buf.push(o), this.buf.push(">")) } chars(i) { this.buf.push(Tu(i)) } checkClobberedElement(i, o) { if (o && (i.compareDocumentPosition(o) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${i.outerHTML}`); return o } } const vv = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, im = /([^\#-~ |!])/g; function Tu(n) { return n.replace(/&/g, "&amp;").replace(vv, function (i) { return "&#" + (1024 * (i.charCodeAt(0) - 55296) + (i.charCodeAt(1) - 56320) + 65536) + ";" }).replace(im, function (i) { return "&#" + i.charCodeAt(0) + ";" }).replace(/</g, "&lt;").replace(/>/g, "&gt;") } let Ch; function rm(n, i) { let o = null; try { Ch = Ch || function Id(n) { const i = new mv(n); return function hg() { try { return !!(new window.DOMParser).parseFromString(jc(""), "text/html") } catch { return !1 } }() ? new Kc(i) : i }(n); let l = i ? String(i) : ""; o = Ch.getInertBodyElement(l); let d = 5, p = l; do { if (0 === d) throw new Error("Failed to sanitize html because the input is unstable"); d--, l = p, p = o.innerHTML, o = Ch.getInertBodyElement(l) } while (l !== p); return jc((new Eh).sanitizeChildren(Zc(o) || o)) } finally { if (o) { const l = Zc(o) || o; for (; l.firstChild;)l.removeChild(l.firstChild) } } } function Zc(n) { return "content" in n && function Ih(n) { return n.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === n.nodeName }(n) ? n.content : null } var Wo = (() => ((Wo = Wo || {})[Wo.NONE = 0] = "NONE", Wo[Wo.HTML = 1] = "HTML", Wo[Wo.STYLE = 2] = "STYLE", Wo[Wo.SCRIPT = 3] = "SCRIPT", Wo[Wo.URL = 4] = "URL", Wo[Wo.RESOURCE_URL = 5] = "RESOURCE_URL", Wo))(); function Gs(n) { const i = Mu(); return i ? i.sanitize(Wo.URL, n) || "" : uc(n, "URL") ? bl(n) : wh(le(n)) } function om(n) { const i = Mu(); if (i) return tm(i.sanitize(Wo.RESOURCE_URL, n) || ""); if (uc(n, "ResourceURL")) return tm(bl(n)); throw new ie(904, !1) } function Yc(n, i, o) { return function fc(n, i) { return "src" === i && ("embed" === n || "frame" === n || "iframe" === n || "media" === n || "script" === n) || "href" === i && ("base" === n || "link" === n) ? om : Gs }(i, o)(n) } function Mu() { const n = vn(); return n && n[ro].sanitizer } class Cr { constructor(i, o) { this._desc = i, this.ngMetadataName = "InjectionToken", this.\u0275prov = void 0, "number" == typeof o ? this.__NG_ELEMENT_ID__ = o : void 0 !== o && (this.\u0275prov = Ae({ token: this, providedIn: o.providedIn || "root", factory: o.factory })) } get multi() { return this } toString() { return `InjectionToken ${this._desc}` } } const Td = new Cr("ENVIRONMENT_INITIALIZER"), Gl = new Cr("INJECTOR", -1), sm = new Cr("INJECTOR_DEF_TYPES"); class vg { get(i, o = Mt) { if (o === Mt) { const l = new Error(`NullInjectorError: No provider for ${xe(i)}!`); throw l.name = "NullInjectorError", l } return o } } function yv(...n) { return { \u0275providers: lm(0, n), \u0275fromNgModule: !0 } } function lm(n, ...i) { const o = [], l = new Set; let d; return Pa(i, p => { const E = p; Md(E, o, [], l) && (d ||= [], d.push(E)) }), void 0 !== d && bg(d, o), o } function bg(n, i) { for (let o = 0; o < n.length; o++) { const { providers: d } = n[o]; cm(d, p => { i.push(p) }) } } function Md(n, i, o, l) { if (!(n = Pe(n))) return !1; let d = null, p = on(n); const E = !p && At(n); if (p || E) { if (E && !E.standalone) return !1; d = n } else { const N = n.ngModule; if (p = on(N), !p) return !1; d = N } const A = l.has(d); if (E) { if (A) return !1; if (l.add(d), E.dependencies) { const N = "function" == typeof E.dependencies ? E.dependencies() : E.dependencies; for (const q of N) Md(q, i, o, l) } } else { if (!p) return !1; { if (null != p.imports && !A) { let q; l.add(d); try { Pa(p.imports, we => { Md(we, i, o, l) && (q ||= [], q.push(we)) }) } finally { } void 0 !== q && bg(q, i) } if (!A) { const q = kt(d) || (() => new d); i.push({ provide: d, useFactory: q, deps: J }, { provide: sm, useValue: d, multi: !0 }, { provide: Td, useValue: () => de(d), multi: !0 }) } const N = p.providers; null == N || A || cm(N, we => { i.push(we) }) } } return d !== n && void 0 !== n.providers } function cm(n, i) { for (let o of n) tt(o) && (o = o.\u0275providers), Array.isArray(o) ? cm(o, i) : i(o) } const yg = Q({ provide: String, useValue: Q }); function dm(n) { return null !== n && "object" == typeof n && yg in n } function yl(n) { return "function" == typeof n } const Mh = new Cr("Set Injector scope."), Sh = {}, xg = {}; let hm; function Ah() { return void 0 === hm && (hm = new vg), hm } class Wl { } class Ms extends Wl { get destroyed() { return this._destroyed } constructor(i, o, l, d) { super(), this.parent = o, this.source = l, this.scopes = d, this.records = new Map, this._ngOnDestroyHooks = new Set, this._onDestroyHooks = [], this._destroyed = !1, mm(i, E => this.processProvider(E)), this.records.set(Gl, pc(void 0, this)), d.has("environment") && this.records.set(Wl, pc(void 0, this)); const p = this.records.get(Mh); null != p && "string" == typeof p.value && this.scopes.add(p.value), this.injectorDefTypes = new Set(this.get(sm.multi, J, Ke.Self)) } destroy() { this.assertNotDestroyed(), this._destroyed = !0; try { for (const o of this._ngOnDestroyHooks) o.ngOnDestroy(); const i = this._onDestroyHooks; this._onDestroyHooks = []; for (const o of i) o() } finally { this.records.clear(), this._ngOnDestroyHooks.clear(), this.injectorDefTypes.clear() } } onDestroy(i) { return this.assertNotDestroyed(), this._onDestroyHooks.push(i), () => this.removeOnDestroy(i) } runInContext(i) { this.assertNotDestroyed(); const o = W(this), l = Xe(void 0); try { return i() } finally { W(o), Xe(l) } } get(i, o = Mt, l = Ke.Default) { if (this.assertNotDestroyed(), i.hasOwnProperty(It)) return i[It](this); l = He(l); const d = W(this), p = Xe(void 0); try { if (!(l & Ke.SkipSelf)) { let A = this.records.get(i); if (void 0 === A) { const N = function Rh(n) { return "function" == typeof n || "object" == typeof n && n instanceof Cr }(i) && jt(i); A = N && this.injectableDefInScope(N) ? pc(fm(i), Sh) : null, this.records.set(i, A) } if (null != A) return this.hydrate(i, A) } return (l & Ke.Self ? Ah() : this.parent).get(i, o = l & Ke.Optional && o === Mt ? null : o) } catch (E) { if ("NullInjectorError" === E.name) { if ((E[fn] = E[fn] || []).unshift(xe(i)), d) throw E; return function H(n, i, o, l) { const d = n[fn]; throw i[Et] && d.unshift(i[Et]), n.message = function Ne(n, i, o, l = null) { n = n && "\n" === n.charAt(0) && "\u0275" == n.charAt(1) ? n.slice(2) : n; let d = xe(i); if (Array.isArray(i)) d = i.map(xe).join(" -> "); else if ("object" == typeof i) { let p = []; for (let E in i) if (i.hasOwnProperty(E)) { let A = i[E]; p.push(E + ":" + ("string" == typeof A ? JSON.stringify(A) : xe(A))) } d = `{${p.join(", ")}}` } return `${o}${l ? "(" + l + ")" : ""}[${d}]: ${n.replace(Ln, "\n  ")}` }("\n" + n.message, d, o, l), n.ngTokenPath = d, n[fn] = null, n }(E, i, "R3InjectorError", this.source) } throw E } finally { Xe(p), W(d) } } resolveInjectorInitializers() { const i = W(this), o = Xe(void 0); try { const l = this.get(Td.multi, J, Ke.Self); for (const d of l) d() } finally { W(i), Xe(o) } } toString() { const i = [], o = this.records; for (const l of o.keys()) i.push(xe(l)); return `R3Injector[${i.join(", ")}]` } assertNotDestroyed() { if (this._destroyed) throw new ie(205, !1) } processProvider(i) { let o = yl(i = Pe(i)) ? i : Pe(i && i.provide); const l = function Ev(n) { return dm(n) ? pc(void 0, n.useValue) : pc(Eg(n), Sh) }(i); if (yl(i) || !0 !== i.multi) this.records.get(o); else { let d = this.records.get(o); d || (d = pc(void 0, Sh, !0), d.factory = () => ae(d.multi), this.records.set(o, d)), o = i, d.multi.push(i) } this.records.set(o, l) } hydrate(i, o) { return o.value === Sh && (o.value = xg, o.value = o.factory()), "object" == typeof o.value && o.value && function kh(n) { return null !== n && "object" == typeof n && "function" == typeof n.ngOnDestroy }(o.value) && this._ngOnDestroyHooks.add(o.value), o.value } injectableDefInScope(i) { if (!i.providedIn) return !1; const o = Pe(i.providedIn); return "string" == typeof o ? "any" === o || this.scopes.has(o) : this.injectorDefTypes.has(o) } removeOnDestroy(i) { const o = this._onDestroyHooks.indexOf(i); -1 !== o && this._onDestroyHooks.splice(o, 1) } } function fm(n) { const i = jt(n), o = null !== i ? i.factory : kt(n); if (null !== o) return o; if (n instanceof Cr) throw new ie(204, !1); if (n instanceof Function) return function xv(n) { const i = n.length; if (i > 0) throw ml(i, "?"), new ie(204, !1); const o = function Nt(n) { return n && (n[Zt] || n[$n]) || null }(n); return null !== o ? () => o.factory(n) : () => new n }(n); throw new ie(204, !1) } function Eg(n, i, o) { let l; if (yl(n)) { const d = Pe(n); return kt(d) || fm(d) } if (dm(n)) l = () => Pe(n.useValue); else if (function mc(n) { return !(!n || !n.useFactory) }(n)) l = () => n.useFactory(...ae(n.deps || [])); else if (function um(n) { return !(!n || !n.useExisting) }(n)) l = () => de(Pe(n.useExisting)); else { const d = Pe(n && (n.useClass || n.provide)); if (!function Cv(n) { return !!n.deps }(n)) return kt(d) || fm(d); l = () => new d(...ae(n.deps)) } return l } function pc(n, i, o = !1) { return { factory: n, value: i, multi: o ? [] : void 0 } } function mm(n, i) { for (const o of n) Array.isArray(o) ? mm(o, i) : o && tt(o) ? mm(o.\u0275providers, i) : i(o) } const pm = new Cr("AppId", { providedIn: "root", factory: () => gm }), gm = "ng", Oh = new Cr("Platform Initializer"), qc = new Cr("Platform ID", { providedIn: "platform", factory: () => "unknown" }), vm = new Cr("AnimationModuleType"), bm = new Cr("CSP nonce", { providedIn: "root", factory: () => function xu() { if (void 0 !== dc) return dc; if (typeof document < "u") return document; throw new ie(210, !1) }().body?.querySelector("[ngCspNonce]")?.getAttribute("ngCspNonce") || null }); let Ig = (n, i) => null; function Im(n, i) { return Ig(n, i) } class Mm { } class Sg { } class Ag { resolveComponentFactory(i) { throw function Tv(n) { const i = Error(`No component factory found for ${xe(n)}.`); return i.ngComponent = n, i }(i) } } let gc = (() => { class n { } return n.NULL = new Ag, n })(); function Lu() { return _c(xo(), vn()) } function _c(n, i) { return new Sd(X(n, i)) } let Sd = (() => { class n { constructor(o) { this.nativeElement = o } } return n.__NG_ELEMENT_ID__ = Lu, n })(); function Mv(n) { return n instanceof Sd ? n.nativeElement : n } class kg { } let Sv = (() => { class n { constructor() { this.destroyNode = null } } return n.__NG_ELEMENT_ID__ = () => function Av() { const n = vn(), o = $t(xo().index, n); return (Er(o) ? o : n)[Xn] }(), n })(), Sm = (() => { class n { } return n.\u0275prov = Ae({ token: n, providedIn: "root", factory: () => null }), n })(); class Rg { constructor(i) { this.full = i, this.major = i.split(".")[0], this.minor = i.split(".")[1], this.patch = i.split(".").slice(2).join(".") } } const Og = new Rg("16.1.4"), Jc = {}; function ed(n) { for (; n;) { n[ci] |= 64; const i = Vc(n); if (As(n) && !i) return n; n = i } return null } function Ad(n) { return n.ngOriginalError } class Sl { constructor() { this._console = console } handleError(i) { const o = this._findOriginalError(i); this._console.error("ERROR", i), o && this._console.error("ORIGINAL ERROR", o) } _findOriginalError(i) { let o = i && Ad(i); for (; o && Ad(o);)o = Ad(o); return o || null } } const Vh = new Cr("", { providedIn: "root", factory: () => !1 }); function Hh(n) { return n.ownerDocument.defaultView } function wl(n) { return n instanceof Function ? n() : n } class Rm extends Kr { constructor() { super(...arguments), this.consumerAllowSignalWrites = !1, this._lView = null } set lView(i) { this._lView = i } onConsumerDependencyMayHaveChanged() { ed(this._lView) } onProducerUpdateValueVersion() { } get hasReadASignal() { return this.hasProducers } runInContext(i, o, l) { const d = Yi(this); this.trackingVersion++; try { i(o, l) } finally { Yi(d) } } destroy() { this.trackingVersion++ } } let jh = null; function $h() { return jh ??= new Rm, jh } function Hg(n, i) { return n[i] ?? $h() } function Gh(n, i) { const o = $h(); o.hasReadASignal && (n[i] = jh, o.lView = n, jh = new Rm) } const Gi = {}; function Wh(n) { zg($i(), vn(), m() + n, !1) } function zg(n, i, o, l) { if (!l) if (3 == (3 & i[ci])) { const p = n.preOrderCheckHooks; null !== p && hi(i, p, o) } else { const p = n.preOrderHooks; null !== p && fi(i, p, 0, o) } u(o) } function id(n, i = null, o = null, l) { const d = Gg(n, i, o, l); return d.resolveInjectorInitializers(), d } function Gg(n, i = null, o = null, l, d = new Set) { const p = [o || J, yv(n)]; return l = l || ("object" == typeof n ? void 0 : xe(n)), new Ms(p, i || Ah(), l || null, d) } let yc = (() => { class n { static create(o, l) { if (Array.isArray(o)) return id({ name: "" }, l, o, ""); { const d = o.name ?? ""; return id({ name: d }, o.parent, o.providers, d) } } } return n.THROW_IF_NOT_FOUND = Mt, n.NULL = new vg, n.\u0275prov = Ae({ token: n, providedIn: "any", factory: () => de(Gl) }), n.__NG_ELEMENT_ID__ = -1, n })(); function wc(n, i = Ke.Default) { const o = vn(); return null === o ? de(n, i) : Fo(xo(), o, Pe(n), i) } function Yh() { throw new Error("invalid") } function Nd(n, i, o, l, d, p, E, A, N, q, we) { const Ge = i.blueprint.slice(); return Ge[_i] = d, Ge[ci] = 140 | l, (null !== q || n && 2048 & n[ci]) && (Ge[ci] |= 2048), Hi(Ge), Ge[ki] = Ge[ko] = n, Ge[di] = o, Ge[ro] = E || n && n[ro], Ge[Xn] = A || n && n[Xn], Ge[qr] = N || n && n[qr] || null, Ge[nr] = p, Ge[Qr] = function jp() { return Lc++ }(), Ge[Br] = we, Ge[es] = q, Ge[cr] = 2 == i.type ? n[cr] : Ge, Ge } function Fd(n, i, o, l, d) { let p = n.data[i]; if (null === p) p = function Fm(n, i, o, l, d) { const p = qa(), E = Qa(), N = n.data[i] = function Hm(n, i, o, l, d, p) { let E = i ? i.injectorIndex : -1, A = 0; return co() && (A |= 128), { type: o, index: l, insertBeforeIndex: null, injectorIndex: E, directiveStart: -1, directiveEnd: -1, directiveStylingLast: -1, componentOffset: -1, propertyBindings: null, flags: A, providerIndexes: 0, value: d, attrs: p, mergedAttrs: null, localNames: null, initialInputs: void 0, inputs: null, outputs: null, tView: null, next: null, prev: null, projectionNext: null, child: null, parent: i, projection: null, styles: null, stylesWithoutHost: null, residualStyles: void 0, classes: null, classesWithoutHost: null, residualClasses: void 0, classBindings: 0, styleBindings: 0 } }(0, E ? p : p && p.parent, o, i, l, d); return null === n.firstChild && (n.firstChild = N), null !== p && (E ? null == p.child && null !== N.parent && (p.child = N) : null === p.next && (p.next = N, N.prev = p)), N }(n, i, o, l, d), function Hr() { return ui.lFrame.inI18n }() && (p.flags |= 32); else if (64 & p.type) { p.type = o, p.value = l, p.attrs = d; const E = function ga() { const n = ui.lFrame, i = n.currentTNode; return n.isParent ? i : i.parent }(); p.injectorIndex = null === E ? -1 : E.injectorIndex } return ps(p, !0), p } function rd(n, i, o, l) { if (0 === o) return -1; const d = i.length; for (let p = 0; p < o; p++)i.push(l), n.blueprint.push(l), n.data.push(null); return d } function qh(n, i, o, l, d) { const p = Hg(i, Yo), E = m(), A = 2 & l; try { if (u(-1), A && i.length > Mi && zg(n, i, Mi, !1), go(A ? 2 : 0, d), A) p.runInContext(o, l, d); else { const q = Yi(null); try { o(l, d) } finally { Yi(q) } } } finally { A && null === i[Yo] && Gh(i, Yo), u(E), go(A ? 3 : 1, d) } } function Lm(n, i, o) { if (us(i)) { const l = Yi(null); try { const p = i.directiveEnd; for (let E = i.directiveStart; E < p; E++) { const A = n.data[E]; A.contentQueries && A.contentQueries(1, o[E], E) } } finally { Yi(l) } } } function Qh(n, i, o) { ai() && (function Hv(n, i, o, l) { const d = o.directiveStart, p = o.directiveEnd; dr(o) && function jv(n, i, o) { const l = X(i, n), d = Um(o); let E = 16; o.signals ? E = 4096 : o.onPush && (E = 64); const A = Bd(n, Nd(n, d, null, E, l, i, null, n[ro].rendererFactory.createRenderer(l, o), null, null, null)); n[i.index] = A }(i, o, n.data[d + o.componentOffset]), n.firstCreatePass || Ua(o, i), fr(l, i); const E = o.initialInputs; for (let A = d; A < p; A++) { const N = n.data[A], q = Xo(i, n, A, o); fr(q, i), null !== E && Ym(0, A - d, q, N, 0, E), Ni(N) && ($t(o.index, i)[di] = Xo(i, n, A, o)) } }(n, i, o, X(o, i)), 64 == (64 & o.flags) && tf(n, i, o)) } function Bm(n, i, o = X) { const l = i.localNames; if (null !== l) { let d = i.index + 1; for (let p = 0; p < l.length; p += 2) { const E = l[p + 1], A = -1 === E ? o(i, n) : n[E]; n[d++] = A } } } function Um(n) { const i = n.tView; return null === i || i.incompleteFirstPass ? n.tView = Xh(1, null, n.template, n.decls, n.vars, n.directiveDefs, n.pipeDefs, n.viewQuery, n.schemas, n.consts, n.id) : i } function Xh(n, i, o, l, d, p, E, A, N, q, we) { const Ge = Mi + l, Dt = Ge + d, Bt = function Wg(n, i) { const o = []; for (let l = 0; l < i; l++)o.push(l < n ? null : Gi); return o }(Ge, Dt), hn = "function" == typeof q ? q() : q; return Bt[Sn] = { type: n, blueprint: Bt, template: o, queries: null, viewQuery: A, declTNode: i, data: Bt.slice().fill(null, Ge), bindingStartIndex: Ge, expandoStartIndex: Dt, hostBindingOpCodes: null, firstCreatePass: !0, firstUpdatePass: !0, staticViewQueries: !1, staticContentQueries: !1, preOrderHooks: null, preOrderCheckHooks: null, contentHooks: null, contentCheckHooks: null, viewHooks: null, viewCheckHooks: null, destroyHooks: null, cleanup: null, contentQueries: null, components: null, directiveRegistry: "function" == typeof p ? p() : p, pipeRegistry: "function" == typeof E ? E() : E, firstChild: null, schemas: N, consts: hn, incompleteFirstPass: !1, ssrId: we } } let Zg = n => null; function Jh(n, i, o, l) { for (let d in n) if (n.hasOwnProperty(d)) { o = null === o ? {} : o; const p = n[d]; null === l ? Yg(o, i, d, p) : l.hasOwnProperty(d) && Yg(o, i, l[d], p) } return o } function Yg(n, i, o, l) { n.hasOwnProperty(o) ? n[o].push(i, l) : n[o] = [i, l] } function Ia(n, i, o, l, d, p, E, A) { const N = X(i, o); let we, q = i.inputs; !A && null != q && (we = q[l]) ? (sf(n, o, we, l, d), dr(i) && function qg(n, i) { const o = $t(i, n); 16 & o[ci] || (o[ci] |= 64) }(o, i.index)) : 3 & i.type && (l = function Bv(n) { return "class" === n ? "className" : "for" === n ? "htmlFor" : "formaction" === n ? "formAction" : "innerHtml" === n ? "innerHTML" : "readonly" === n ? "readOnly" : "tabindex" === n ? "tabIndex" : n }(l), d = null != E ? E(d, i.value || "", l) : d, p.setProperty(N, l, d)) } function $m(n, i, o, l) { if (ai()) { const d = null === l ? null : { "": -1 }, p = function Wm(n, i) { const o = n.directiveRegistry; let l = null, d = null; if (o) for (let p = 0; p < o.length; p++) { const E = o[p]; if (Ir(i, E.selectors, !1)) if (l || (l = []), Ni(E)) if (null !== E.findHostDirectiveDefs) { const A = []; d = d || new Map, E.findHostDirectiveDefs(E, A, d), l.unshift(...A, E), Vu(n, i, A.length) } else l.unshift(E), Vu(n, i, 0); else d = d || new Map, E.findHostDirectiveDefs?.(E, l, d), l.push(E) } return null === l ? null : [l, d] }(n, o); let E, A; null === p ? E = A = null : [E, A] = p, null !== E && ef(n, i, o, E, d, A), d && function Km(n, i, o) { if (i) { const l = n.localNames = []; for (let d = 0; d < i.length; d += 2) { const p = o[i[d + 1]]; if (null == p) throw new ie(-301, !1); l.push(i[d], p) } } }(o, l, d) } o.mergedAttrs = si(o.mergedAttrs, o.attrs) } function ef(n, i, o, l, d, p) { for (let q = 0; q < l.length; q++)_o(Ua(o, i), n, l[q].type); !function Qg(n, i, o) { n.flags |= 1, n.directiveStart = i, n.directiveEnd = i + o, n.providerIndexes = i }(o, n.data.length, l.length); for (let q = 0; q < l.length; q++) { const we = l[q]; we.providersResolver && we.providersResolver(we) } let E = !1, A = !1, N = rd(n, i, l.length, null); for (let q = 0; q < l.length; q++) { const we = l[q]; o.mergedAttrs = si(o.mergedAttrs, we.hostAttrs), Zm(n, o, i, N, we), Ld(N, we, d), null !== we.contentQueries && (o.flags |= 4), (null !== we.hostBindings || null !== we.hostAttrs || 0 !== we.hostVars) && (o.flags |= 64); const Ge = we.type.prototype; !E && (Ge.ngOnChanges || Ge.ngOnInit || Ge.ngDoCheck) && ((n.preOrderHooks ??= []).push(o.index), E = !0), !A && (Ge.ngOnChanges || Ge.ngDoCheck) && ((n.preOrderCheckHooks ??= []).push(o.index), A = !0), N++ } !function zm(n, i, o) { const d = i.directiveEnd, p = n.data, E = i.attrs, A = []; let N = null, q = null; for (let we = i.directiveStart; we < d; we++) { const Ge = p[we], Dt = o ? o.get(Ge) : null, hn = Dt ? Dt.outputs : null; N = Jh(Ge.inputs, we, N, Dt ? Dt.inputs : null), q = Jh(Ge.outputs, we, q, hn); const Rn = null === N || null === E || $r(i) ? null : qm(N, we, E); A.push(Rn) } null !== N && (N.hasOwnProperty("class") && (i.flags |= 8), N.hasOwnProperty("style") && (i.flags |= 16)), i.initialInputs = A, i.inputs = N, i.outputs = q }(n, o, p) } function tf(n, i, o) { const l = o.directiveStart, d = o.directiveEnd, p = o.index, E = function Zs() { return ui.lFrame.currentDirectiveIndex }(); try { u(p); for (let A = l; A < d; A++) { const N = n.data[A], q = i[A]; Ys(A), (null !== N.hostBindings || 0 !== N.hostVars || null !== N.hostAttrs) && zv(N, q) } } finally { u(-1), Ys(E) } } function zv(n, i) { null !== n.hostBindings && n.hostBindings(1, i) } function Vu(n, i, o) { i.componentOffset = o, (n.components ??= []).push(i.index) } function Ld(n, i, o) { if (o) { if (i.exportAs) for (let l = 0; l < i.exportAs.length; l++)o[i.exportAs[l]] = n; Ni(i) && (o[""] = n) } } function Zm(n, i, o, l, d) { n.data[l] = d; const p = d.factory || (d.factory = kt(d.type)), E = new Fr(p, Ni(d), wc); n.blueprint[l] = E, o[l] = E, function Vv(n, i, o, l, d) { const p = d.hostBindings; if (p) { let E = n.hostBindingOpCodes; null === E && (E = n.hostBindingOpCodes = []); const A = ~i.index; (function Gm(n) { let i = n.length; for (; i > 0;) { const o = n[--i]; if ("number" == typeof o && o < 0) return o } return 0 })(E) != A && E.push(A), E.push(o, l, p) } }(n, i, l, rd(n, o, d.hostVars, Gi), d) } function il(n, i, o, l, d, p) { const E = X(n, i); !function xl(n, i, o, l, d, p, E) { if (null == p) n.removeAttribute(i, d, o); else { const A = null == E ? le(p) : E(p, l || "", d); n.setAttribute(i, d, A, o) } }(i[Xn], E, p, n.value, o, l, d) } function Ym(n, i, o, l, d, p) { const E = p[i]; if (null !== E) for (let A = 0; A < E.length;)Xg(l, o, E[A++], E[A++], E[A++]) } function Xg(n, i, o, l, d) { const p = Yi(null); try { const E = n.inputTransforms; null !== E && E.hasOwnProperty(l) && (d = E[l].call(i, d)), null !== n.setInput ? n.setInput(i, d, o, l) : i[l] = d } finally { Yi(p) } } function qm(n, i, o) { let l = null, d = 0; for (; d < o.length;) { const p = o[d]; if (0 !== p) if (5 !== p) { if ("number" == typeof p) break; if (n.hasOwnProperty(p)) { null === l && (l = []); const E = n[p]; for (let A = 0; A < E.length; A += 2)if (E[A] === i) { l.push(p, E[A + 1], o[d + 1]); break } } d += 2 } else d += 2; else d += 4 } return l } function Jg(n, i, o, l) { return [n, !0, !1, i, null, 0, l, o, null, null, null] } function e_(n, i) { const o = n.contentQueries; if (null !== o) for (let l = 0; l < o.length; l += 2) { const p = o[l + 1]; if (-1 !== p) { const E = n.data[p]; Aa(o[l]), E.contentQueries(2, i[p], p) } } } function Bd(n, i) { return n[vs] ? n[Ao][tr] = i : n[vs] = i, n[Ao] = i, i } function Qm(n, i, o) { Aa(0); const l = Yi(null); try { i(n, o) } finally { Yi(l) } } function n_(n) { return n[io] || (n[io] = []) } function nf(n) { return n.cleanup || (n.cleanup = []) } function i_(n, i, o) { return (null === n || Ni(n)) && (o = function Oo(n) { for (; Array.isArray(n);) { if ("object" == typeof n[Ho]) return n; n = n[_i] } return null }(o[i.index])), o[Xn] } function rf(n, i) { const o = n[qr], l = o ? o.get(Sl, null) : null; l && l.handleError(i) } function sf(n, i, o, l, d) { for (let p = 0; p < o.length;) { const E = o[p++], A = o[p++]; Xg(n.data[E], i[E], l, A, d) } } function El(n, i, o) { const l = P(i, n); !function $f(n, i, o) { n.setValue(i, o) }(n[Xn], l, o) } function r_(n, i) { const o = $t(i, n), l = o[Sn]; !function $v(n, i) { for (let o = i.length; o < n.blueprint.length; o++)i.push(n.blueprint[o]) }(l, o); const d = o[_i]; null !== d && null === o[Br] && (o[Br] = Im(d, o[qr])), Xm(l, o, o[di]) } function Xm(n, i, o) { Xa(i); try { const l = n.viewQuery; null !== l && Qm(1, l, o); const d = n.template; null !== d && qh(n, i, d, 1, o), n.firstCreatePass && (n.firstCreatePass = !1), n.staticContentQueries && e_(n, i), n.staticViewQueries && Qm(2, n.viewQuery, o); const p = n.components; null !== p && function Jm(n, i) { for (let o = 0; o < i.length; o++)r_(n, i[o]) }(i, p) } catch (l) { throw n.firstCreatePass && (n.incompleteFirstPass = !0, n.firstCreatePass = !1), l } finally { i[ci] &= -5, Ps() } } let af = (() => { class n { constructor() { this.all = new Set, this.queue = new Map } create(o, l, d) { const p = typeof Zone > "u" ? null : Zone.current, E = new Ya(o, q => { this.all.has(q) && this.queue.set(q, p) }, d); let A; this.all.add(E), E.notify(); const N = () => { E.cleanup(), A?.(), this.all.delete(E), this.queue.delete(E) }; return A = l?.onDestroy(N), { destroy: N } } flush() { if (0 !== this.queue.size) for (const [o, l] of this.queue) this.queue.delete(o), l ? l.run(() => o.run()) : o.run() } get isQueueEmpty() { return 0 === this.queue.size } } return n.\u0275prov = Ae({ token: n, providedIn: "root", factory: () => new n }), n })(); function xc(n, i, o) { let l = o ? n.styles : null, d = o ? n.classes : null, p = 0; if (null !== i) for (let E = 0; E < i.length; E++) { const A = i[E]; "number" == typeof A ? p = A : 1 == p ? d = ze(d, A) : 2 == p && (l = ze(l, A + ": " + i[++E] + ";")) } o ? n.styles = l : n.stylesWithoutHost = l, o ? n.classes = d : n.classesWithoutHost = d } function Hu(n, i, o, l, d = !1) { for (; null !== o;) { const p = i[o.index]; if (null !== p && l.push(yr(p)), Gr(p)) { for (let A = Ki; A < p.length; A++) { const N = p[A], q = N[Sn].firstChild; null !== q && Hu(N[Sn], N, q, l) } p[yo] !== p[_i] && l.push(p[yo]) } const E = o.type; if (8 & E) Hu(n, i, o.child, l); else if (32 & E) { const A = oc(o, i); let N; for (; N = A();)l.push(N) } else if (16 & E) { const A = gh(i, o); if (Array.isArray(A)) l.push(...A); else { const N = Vc(i[cr]); Hu(N[Sn], N, A, l, !0) } } o = d ? o.projectionNext : o.next } return l } function Ud(n, i, o, l = !0) { const d = i[ro].rendererFactory; d.begin && d.begin(); try { tp(n, i, n.template, o) } catch (E) { throw l && rf(i, E), E } finally { d.end && d.end(), i[ro].effectManager?.flush() } } function tp(n, i, o, l) { const d = i[ci]; if (256 != (256 & d)) { i[ro].effectManager?.flush(), Xa(i); try { Hi(i), function ra(n) { return ui.lFrame.bindingIndex = n }(n.bindingStartIndex), null !== o && qh(n, i, o, 2, l); const E = 3 == (3 & d); if (E) { const q = n.preOrderCheckHooks; null !== q && hi(i, q, null) } else { const q = n.preOrderHooks; null !== q && fi(i, q, 0, null), ei(i, 0) } if (function Zv(n) { for (let i = Zp(n); null !== i; i = Yp(i)) { if (!i[Ro]) continue; const o = i[Qo]; for (let l = 0; l < o.length; l++) { Fi(o[l]) } } }(i), zu(i, 2), null !== n.contentQueries && e_(n, i), E) { const q = n.contentCheckHooks; null !== q && hi(i, q) } else { const q = n.contentHooks; null !== q && fi(i, q, 1), ei(i, 1) } !function Nm(n, i) { const o = n.hostBindingOpCodes; if (null === o) return; const l = Hg(i, so); try { for (let d = 0; d < o.length; d++) { const p = o[d]; if (p < 0) u(~p); else { const E = p, A = o[++d], N = o[++d]; Vs(A, E), l.runInContext(N, 2, i[E]) } } } finally { null === i[so] && Gh(i, so), u(-1) } }(n, i); const A = n.components; null !== A && a_(i, A, 0); const N = n.viewQuery; if (null !== N && Qm(2, N, l), E) { const q = n.viewCheckHooks; null !== q && hi(i, q) } else { const q = n.viewHooks; null !== q && fi(i, q, 2), ei(i, 2) } !0 === n.firstUpdatePass && (n.firstUpdatePass = !1), i[ci] &= -73, Di(i) } finally { Ps() } } } function zu(n, i) { for (let o = Zp(n); null !== o; o = Yp(o))for (let l = Ki; l < o.length; l++)s_(o[l], i) } function Yv(n, i, o) { s_($t(i, n), o) } function s_(n, i) { if (!function Zn(n) { return 128 == (128 & n[ci]) }(n)) return; const o = n[Sn]; if (80 & n[ci] && 0 === i || 1024 & n[ci] || 2 === i) tp(o, n, o.template, n[di]); else if (n[Lr] > 0) { zu(n, 1); const d = n[Sn].components; null !== d && a_(n, d, 1) } } function a_(n, i, o) { for (let l = 0; l < i.length; l++)Yv(n, i[l], o) } class Ec { get rootNodes() { const i = this._lView, o = i[Sn]; return Hu(o, i, o.firstChild, []) } constructor(i, o) { this._lView = i, this._cdRefInjectingView = o, this._appRef = null, this._attachedToViewContainer = !1 } get context() { return this._lView[di] } set context(i) { this._lView[di] = i } get destroyed() { return 256 == (256 & this._lView[ci]) } destroy() { if (this._appRef) this._appRef.detachView(this); else if (this._attachedToViewContainer) { const i = this._lView[ki]; if (Gr(i)) { const o = i[8], l = o ? o.indexOf(this) : -1; l > -1 && (zc(i, l), no(o, l)) } this._attachedToViewContainer = !1 } vu(this._lView[Sn], this._lView) } onDestroy(i) { !function rr(n, i) { if (256 == (256 & n[ci])) throw new ie(911, !1); null === n[Tr] && (n[Tr] = []), n[Tr].push(i) }(this._lView, i) } markForCheck() { ed(this._cdRefInjectingView || this._lView) } detach() { this._lView[ci] &= -129 } reattach() { this._lView[ci] |= 128 } detectChanges() { Ud(this._lView[Sn], this._lView, this.context) } checkNoChanges() { } attachToViewContainerRef() { if (this._appRef) throw new ie(902, !1); this._attachedToViewContainer = !0 } detachFromAppRef() { this._appRef = null, function Qp(n, i) { Cd(n, i, i[Xn], 2, null, null) }(this._lView[Sn], this._lView) } attachToAppRef(i) { if (this._attachedToViewContainer) throw new ie(902, !1); this._appRef = i } } class np extends Ec { constructor(i) { super(i), this._view = i } detectChanges() { const i = this._view; Ud(i[Sn], i, i[di], !1) } checkNoChanges() { } get context() { return null } } class lf extends gc { constructor(i) { super(), this.ngModule = i } resolveComponentFactory(i) { const o = At(i); return new od(o, this.ngModule) } } function cf(n) { const i = []; for (let o in n) n.hasOwnProperty(o) && i.push({ propName: n[o], templateName: o }); return i } class ip { constructor(i, o) { this.injector = i, this.parentInjector = o } get(i, o, l) { l = He(l); const d = this.injector.get(i, Jc, l); return d !== Jc || o === Jc ? d : this.parentInjector.get(i, o, l) } } class od extends Sg { get inputs() { const i = this.componentDef, o = i.inputTransforms, l = cf(i.inputs); if (null !== o) for (const d of l) o.hasOwnProperty(d.propName) && (d.transform = o[d.propName]); return l } get outputs() { return cf(this.componentDef.outputs) } constructor(i, o) { super(), this.componentDef = i, this.ngModule = o, this.componentType = i.type, this.selector = function sr(n) { return n.map(Jo).join(",") }(i.selectors), this.ngContentSelectors = i.ngContentSelectors ? i.ngContentSelectors : [], this.isBoundToModule = !!o } create(i, o, l, d) { let p = (d = d || this.ngModule) instanceof Wl ? d : d?.injector; p && null !== this.componentDef.getStandaloneInjector && (p = this.componentDef.getStandaloneInjector(p) || p); const E = p ? new ip(i, p) : i, A = E.get(kg, null); if (null === A) throw new ie(407, !1); const we = { rendererFactory: A, sanitizer: E.get(Sm, null), effectManager: E.get(af, null) }, Ge = A.createRenderer(null, this.componentDef), Dt = this.componentDef.selectors[0][0] || "div", Bt = l ? function Kg(n, i, o, l) { const p = l.get(Vh, !1) || o === fe.ShadowDom, E = n.selectRootElement(i, p); return function Nv(n) { Zg(n) }(E), E }(Ge, l, this.componentDef.encapsulation, E) : Hc(Ge, Dt, function l_(n) { const i = n.toLowerCase(); return "svg" === i ? Os : "math" === i ? "math" : null }(Dt)), Qn = this.componentDef.signals ? 4608 : this.componentDef.onPush ? 576 : 528, yi = Xh(0, null, null, 1, 0, null, null, null, null, null, null), yn = Nd(null, yi, null, Qn, null, null, we, Ge, E, null, null); let Wi, Or; Xa(yn); try { const jr = this.componentDef; let La, nv = null; jr.findHostDirectiveDefs ? (La = [], nv = new Map, jr.findHostDirectiveDefs(jr, La, nv), La.push(jr)) : La = [jr]; const kI = function d_(n, i) { const o = n[Sn], l = Mi; return n[l] = i, Fd(o, l, 2, "#host", null) }(yn, Bt), RI = function uf(n, i, o, l, d, p, E) { const A = d[Sn]; !function u_(n, i, o, l) { for (const d of n) i.mergedAttrs = si(i.mergedAttrs, d.hostAttrs); null !== i.mergedAttrs && (xc(i, i.mergedAttrs, !0), null !== o && bh(l, o, i)) }(l, n, i, E); let N = null; null !== i && (N = Im(i, d[qr])); const q = p.rendererFactory.createRenderer(i, o); let we = 16; o.signals ? we = 4096 : o.onPush && (we = 64); const Ge = Nd(d, Um(o), null, we, d[n.index], n, p, q, null, null, N); return A.firstCreatePass && Vu(A, n, l.length - 1), Bd(d, Ge), d[n.index] = Ge }(kI, Bt, jr, La, yn, we, Ge); Or = be(yi, Mi), Bt && function h_(n, i, o, l) { if (l) Pn(n, o, ["ng-version", Og.full]); else { const { attrs: d, classes: p } = function wt(n) { const i = [], o = []; let l = 1, d = 2; for (; l < n.length;) { let p = n[l]; if ("string" == typeof p) 2 === d ? "" !== p && i.push(p, n[++l]) : 8 === d && o.push(p); else { if (!Ti(d)) break; d = p } l++ } return { attrs: i, classes: o } }(i.selectors[0]); d && Pn(n, o, d), p && p.length > 0 && Xf(n, o, p.join(" ")) } }(Ge, jr, Bt, l), void 0 !== o && function Hd(n, i, o) { const l = n.projection = []; for (let d = 0; d < i.length; d++) { const p = o[d]; l.push(null != p ? Array.from(p) : null) } }(Or, this.ngContentSelectors, o), Wi = function rp(n, i, o, l, d, p) { const E = xo(), A = d[Sn], N = X(E, d); ef(A, d, E, o, null, l); for (let we = 0; we < o.length; we++)fr(Xo(d, A, E.directiveStart + we, E), d); tf(A, d, E), N && fr(N, d); const q = Xo(d, A, E.directiveStart + E.componentOffset, E); if (n[di] = d[di] = q, null !== p) for (const we of p) we(q, i); return Lm(A, E, n), q }(RI, jr, La, nv, yn, [op]), Xm(yi, yn, null) } finally { Ps() } return new df(this.componentType, Wi, _c(Or, yn), yn, Or) } } class df extends Mm { constructor(i, o, l, d, p) { super(), this.location = l, this._rootLView = d, this._tNode = p, this.previousInputValues = null, this.instance = o, this.hostView = this.changeDetectorRef = new np(d), this.componentType = i } setInput(i, o) { const l = this._tNode.inputs; let d; if (null !== l && (d = l[i])) { if (this.previousInputValues ??= new Map, this.previousInputValues.has(i) && Object.is(this.previousInputValues.get(i), o)) return; const p = this._rootLView; sf(p[Sn], p, d, i, o), this.previousInputValues.set(i, o), ed($t(this._tNode.index, p)) } } get injector() { return new xa(this._tNode, this._rootLView) } destroy() { this.hostView.destroy() } onDestroy(i) { this.hostView.onDestroy(i) } } function op() { const n = xo(); ri(vn()[Sn], n) } function sp(n) { let i = function f_(n) { return Object.getPrototypeOf(n.prototype).constructor }(n.type), o = !0; const l = [n]; for (; i;) { let d; if (Ni(n)) d = i.\u0275cmp || i.\u0275dir; else { if (i.\u0275cmp) throw new ie(903, !1); d = i.\u0275dir } if (d) { if (o) { l.push(d); const E = n; E.inputs = ju(n.inputs), E.inputTransforms = ju(n.inputTransforms), E.declaredInputs = ju(n.declaredInputs), E.outputs = ju(n.outputs); const A = d.hostBindings; A && Xv(n, A); const N = d.viewQuery, q = d.contentQueries; if (N && Qv(n, N), q && m_(n, q), _e(n.inputs, d.inputs), _e(n.declaredInputs, d.declaredInputs), _e(n.outputs, d.outputs), null !== d.inputTransforms && (null === E.inputTransforms && (E.inputTransforms = {}), _e(E.inputTransforms, d.inputTransforms)), Ni(d) && d.data.animation) { const we = n.data; we.animation = (we.animation || []).concat(d.data.animation) } } const p = d.features; if (p) for (let E = 0; E < p.length; E++) { const A = p[E]; A && A.ngInherit && A(n), A === sp && (o = !1) } } i = Object.getPrototypeOf(i) } !function qv(n) { let i = 0, o = null; for (let l = n.length - 1; l >= 0; l--) { const d = n[l]; d.hostVars = i += d.hostVars, d.hostAttrs = si(d.hostAttrs, o = si(o, d.hostAttrs)) } }(l) } function ju(n) { return n === F ? {} : n === J ? [] : n } function Qv(n, i) { const o = n.viewQuery; n.viewQuery = o ? (l, d) => { i(l, d), o(l, d) } : i } function m_(n, i) { const o = n.contentQueries; n.contentQueries = o ? (l, d, p) => { i(l, d, p), o(l, d, p) } : i } function Xv(n, i) { const o = n.hostBindings; n.hostBindings = o ? (l, d) => { i(l, d), o(l, d) } : i } function $u(n) { const i = n.inputConfig, o = {}; for (const l in i) if (i.hasOwnProperty(l)) { const d = i[l]; Array.isArray(d) && d[2] && (o[l] = d[2]) } n.inputTransforms = o } function Gu(n) { return !!ff(n) && (Array.isArray(n) || !(n instanceof Map) && Symbol.iterator in n) } function ff(n) { return null !== n && ("function" == typeof n || "object" == typeof n) } function Uo(n, i, o) { return n[i] = o } function da(n, i, o) { return !Object.is(n[i], o) && (n[i] = o, !0) } function sd(n, i, o, l) { const d = da(n, i, o); return da(n, i + 1, l) || d } function Zu(n, i, o, l) { const d = vn(); return da(d, Pi(), i) && ($i(), il(h(), d, n, i, o, l)), Zu } function Cc(n, i, o, l) { return da(n, Pi(), o) ? i + le(o) + l : Gi } function jd(n, i, o, l, d, p) { const A = sd(n, function Jn() { return ui.lFrame.bindingIndex }(), o, d); return Es(2), A ? i + le(o) + l + le(d) + p : Gi } function M_(n, i, o, l, d, p, E, A) { const N = vn(), q = $i(), we = n + Mi, Ge = q.firstCreatePass ? function th(n, i, o, l, d, p, E, A, N) { const q = i.consts, we = Fd(i, n, 4, E || null, xi(q, A)); $m(i, o, we, xi(q, N)), ri(i, we); const Ge = we.tView = Xh(2, we, l, d, p, i.directiveRegistry, i.pipeRegistry, null, i.schemas, q, null); return null !== i.queries && (i.queries.template(i, we), Ge.queries = i.queries.embeddedTView(we)), we }(we, q, N, i, o, l, d, p, E) : q.data[we]; ps(Ge, !1); const Dt = nh(q, N, Ge, n); zt() && ac(q, N, Dt, Ge), fr(Dt, N), Bd(N, N[we] = Jg(Dt, N, Dt, Ge)), Wr(Ge) && Qh(q, N, Ge), null != E && Bm(N, Ge, A) } let nh = function bp(n, i, o, l) { return xn(!0), i[Xn].createComment("") }; function Wd(n) { return Je(function Ei() { return ui.lFrame.contextLView }(), Mi + n) } function wp(n, i, o) { const l = vn(); return da(l, Pi(), i) && Ia($i(), h(), l, n, i, l[Xn], o, !1), wp } function Mc(n, i, o, l, d) { const E = d ? "class" : "style"; sf(n, o, i.inputs[E], E, l) } function xp(n, i, o, l) { const d = vn(), p = $i(), E = Mi + n, A = d[Xn], N = p.firstCreatePass ? function yy(n, i, o, l, d, p) { const E = i.consts, N = Fd(i, n, 2, l, xi(E, d)); return $m(i, o, N, xi(E, p)), null !== N.attrs && xc(N, N.attrs, !1), null !== N.mergedAttrs && xc(N, N.mergedAttrs, !0), null !== i.queries && i.queries.elementStart(i, N), N }(E, p, d, i, o, l) : p.data[E], q = rh(p, d, N, A, i, n); d[E] = q; const we = Wr(N); return ps(N, !0), bh(A, q, N), 32 != (32 & N.flags) && zt() && ac(p, d, q, N), 0 === function wo() { return ui.lFrame.elementDepthCount }() && fr(q, d), function Ur() { ui.lFrame.elementDepthCount++ }(), we && (Qh(p, d, N), Lm(p, N, d)), null !== l && Bm(d, N), xp } function Kd() { let n = xo(); Qa() ? Vr() : (n = n.parent, ps(n, !1)); const i = n; (function Un(n) { return ui.skipHydrationRootTNode === n })(i) && function Us() { ui.skipHydrationRootTNode = null }(), function Cn() { ui.lFrame.elementDepthCount-- }(); const o = $i(); return o.firstCreatePass && (ri(o, n), us(n) && o.queries.elementEnd(n)), null != i.classesWithoutHost && function Ra(n) { return 0 != (8 & n.flags) }(i) && Mc(o, i, vn(), i.classesWithoutHost, !0), null != i.stylesWithoutHost && function sa(n) { return 0 != (16 & n.flags) }(i) && Mc(o, i, vn(), i.stylesWithoutHost, !1), Kd } function Ep(n, i, o, l) { return xp(n, i, o, l), Kd(), Ep } let rh = (n, i, o, l, d, p) => (xn(!0), Hc(l, d, function je() { return ui.lFrame.currentNamespace }())); function bf(n, i, o) { const l = vn(), d = $i(), p = n + Mi, E = d.firstCreatePass ? function vf(n, i, o, l, d) { const p = i.consts, E = xi(p, l), A = Fd(i, n, 8, "ng-container", E); return null !== E && xc(A, E, !0), $m(i, o, A, xi(p, d)), null !== i.queries && i.queries.elementStart(i, A), A }(p, d, l, i, o) : d.data[p]; ps(E, !0); const A = S_(d, l, E, n); return l[p] = A, zt() && ac(d, l, A, E), fr(A, l), Wr(E) && (Qh(d, l, E), Lm(d, E, l)), null != o && Bm(l, E), bf } function yf() { let n = xo(); const i = $i(); return Qa() ? Vr() : (n = n.parent, ps(n, !1)), i.firstCreatePass && (ri(i, n), us(n) && i.queries.elementEnd(n)), yf } function Zd(n, i, o) { return bf(n, i, o), yf(), Zd } let S_ = (n, i, o, l) => (xn(!0), gu(i[Xn], "")); function Cp() { return vn() } function wf(n) { return !!n && "function" == typeof n.then } function Ip(n) { return !!n && "function" == typeof n.subscribe } function xf(n, i, o, l) { const d = vn(), p = $i(), E = xo(); return oh(p, d, d[Xn], E, n, i, l), xf } function Ef(n, i) { const o = xo(), l = vn(), d = $i(); return oh(d, l, i_(Sa(d.data), o, l), o, n, i), Ef } function oh(n, i, o, l, d, p, E) { const A = Wr(l), q = n.firstCreatePass && nf(n), we = i[di], Ge = n_(i); let Dt = !0; if (3 & l.type || E) { const Rn = X(l, i), Qn = E ? E(Rn) : Rn, yi = Ge.length, yn = E ? Or => E(yr(Or[l.index])) : l.index; let Wi = null; if (!E && A && (Wi = function Dp(n, i, o, l) { const d = n.cleanup; if (null != d) for (let p = 0; p < d.length - 1; p += 2) { const E = d[p]; if (E === o && d[p + 1] === l) { const A = i[io], N = d[p + 2]; return A.length > N ? A[N] : null } "string" == typeof E && (p += 2) } return null }(n, i, d, l.index)), null !== Wi) (Wi.__ngLastListenerFn__ || Wi).__ngNextListenerFn__ = p, Wi.__ngLastListenerFn__ = p, Dt = !1; else { p = fb(l, i, we, p, !1); const Or = o.listen(Qn, d, p); Ge.push(p, Or), q && q.push(d, yn, yi, yi + 1) } } else p = fb(l, i, we, p, !1); const Bt = l.outputs; let hn; if (Dt && null !== Bt && (hn = Bt[d])) { const Rn = hn.length; if (Rn) for (let Qn = 0; Qn < Rn; Qn += 2) { const jr = i[hn[Qn]][hn[Qn + 1]].subscribe(p), La = Ge.length; Ge.push(p, jr), q && q.push(d, l.index, La, -(La + 1)) } } } function k_(n, i, o, l) { try { return go(6, i, o), !1 !== o(l) } catch (d) { return rf(n, d), !1 } finally { go(7, i, o) } } function fb(n, i, o, l, d) { return function p(E) { if (E === Function) return l; ed(n.componentOffset > -1 ? $t(n.index, i) : i); let N = k_(i, o, l, E), q = p.__ngNextListenerFn__; for (; q;)N = k_(i, o, q, E) && N, q = q.__ngNextListenerFn__; return d && !1 === N && E.preventDefault(), N } } function mb(n = 1) { return function S(n) { return (ui.lFrame.contextLView = function I(n, i) { for (; n > 0;)i = i[ko], n--; return i }(n, ui.lFrame.contextLView))[di] }(n) } function pb(n, i) { let o = null; const l = function bo(n) { const i = n.attrs; if (null != i) { const o = i.indexOf(5); if (!(1 & o)) return i[o + 1] } return null }(n); for (let d = 0; d < i.length; d++) { const p = i[d]; if ("*" !== p) { if (null === l ? Ir(n, p, !0) : cs(l, p)) return d } else o = d } return o } function gb(n) { const i = vn()[cr][nr]; if (!i.projection) { const l = i.projection = ml(n ? n.length : 1, null), d = l.slice(); let p = i.child; for (; null !== p;) { const E = n ? pb(p, n) : 0; null !== E && (d[E] ? d[E].projectionNext = p : l[E] = p, d[E] = p), p = p.next } } } function _b(n, i = 0, o) { const l = vn(), d = $i(), p = Fd(d, Mi + n, 16, null, o || null); null === p.projection && (p.projection = i), Vr(), (!l[Br] || co()) && 32 != (32 & p.flags) && function cv(n, i, o) { rg(i[Xn], 0, i, o, Wf(n, o, i), Zf(o.parent || i[nr], o, i)) }(d, l, p) } function Yl(n, i, o) { return ql(n, "", i, "", o), Yl } function ql(n, i, o, l, d) { const p = vn(), E = Cc(p, i, o, l); return E !== Gi && Ia($i(), h(), p, n, E, p[Xn], d, !1), ql } function Cf(n, i) { return n << 17 | i << 2 } function Ac(n) { return n >> 17 & 32767 } function Tp(n) { return 2 | n } function cd(n) { return (131068 & n) >> 2 } function Mp(n, i) { return -131069 & n | i << 2 } function Sp(n) { return 1 | n } function B_(n, i, o, l, d) { const p = n[o + 1], E = null === i; let A = l ? Ac(p) : cd(p), N = !1; for (; 0 !== A && (!1 === N || E);) { const we = n[A + 1]; xb(n[A], i) && (N = !0, n[A + 1] = l ? Sp(we) : Tp(we)), A = l ? Ac(we) : cd(we) } N && (n[o + 1] = l ? Tp(p) : Sp(p)) } function xb(n, i) { return null === n || null == i || (Array.isArray(n) ? n[1] : n) === i || !(!Array.isArray(n) || "string" != typeof i) && Ll(n, i) >= 0 } const Fs = { textEnd: 0, key: 0, keyEnd: 0, value: 0, valueEnd: 0 }; function U_(n) { return n.substring(Fs.key, Fs.keyEnd) } function Eb(n, i) { const o = Fs.textEnd; return o === i ? -1 : (i = Fs.keyEnd = function Iy(n, i, o) { for (; i < o && n.charCodeAt(i) > 32;)i++; return i }(n, Fs.key = i, o), qd(n, i, o)) } function qd(n, i, o) { for (; i < o && n.charCodeAt(i) <= 32;)i++; return i } function kp(n, i, o) { return Ol(n, i, o, !1), kp } function Rp(n, i) { return Ol(n, i, null, !0), Rp } function Xl(n, i) { for (let o = function Ey(n) { return function H_(n) { Fs.key = 0, Fs.keyEnd = 0, Fs.value = 0, Fs.valueEnd = 0, Fs.textEnd = n.length }(n), Eb(n, qd(n, 0, Fs.textEnd)) }(i); o >= 0; o = Eb(i, o))Ts(n, U_(i), !0) } function Ol(n, i, o, l) { const d = vn(), p = $i(), E = Es(2); p.firstUpdatePass && e(p, n, E, l), i !== Gi && da(d, E, i) && Gt(p, p.data[m()], d, d[Xn], n, d[E + 1] = function Yn(n, i) { return null == n || "" === n || ("string" == typeof i ? n += i : "object" == typeof n && (n = xe(bl(n)))), n }(i, o), l, E) } function r(n, i) { return i >= n.expandoStartIndex } function e(n, i, o, l) { const d = n.data; if (null === d[o + 1]) { const p = d[m()], E = r(n, o); ti(p, l) && null === i && !E && (i = !1), i = function t(n, i, o, l) { const d = Sa(n); let p = l ? i.residualClasses : i.residualStyles; if (null === d) 0 === (l ? i.classBindings : i.styleBindings) && (o = R(o = _(null, n, i, o, l), i.attrs, l), p = null); else { const E = i.directiveStylingLast; if (-1 === E || n[E] !== d) if (o = _(d, n, i, o, l), null === p) { let N = function s(n, i, o) { const l = o ? i.classBindings : i.styleBindings; if (0 !== cd(l)) return n[Ac(l)] }(n, i, l); void 0 !== N && Array.isArray(N) && (N = _(null, n, i, N[1], l), N = R(N, i.attrs, l), function c(n, i, o, l) { n[Ac(o ? i.classBindings : i.styleBindings)] = l }(n, i, l, N)) } else p = function f(n, i, o) { let l; const d = i.directiveEnd; for (let p = 1 + i.directiveStylingLast; p < d; p++)l = R(l, n[p].hostAttrs, o); return R(l, i.attrs, o) }(n, i, l) } return void 0 !== p && (l ? i.residualClasses = p : i.residualStyles = p), o }(d, p, i, l), function wy(n, i, o, l, d, p) { let E = p ? i.classBindings : i.styleBindings, A = Ac(E), N = cd(E); n[l] = o; let we, q = !1; if (Array.isArray(o) ? (we = o[1], (null === we || Ll(o, we) > 0) && (q = !0)) : we = o, d) if (0 !== N) { const Dt = Ac(n[A + 1]); n[l + 1] = Cf(Dt, A), 0 !== Dt && (n[Dt + 1] = Mp(n[Dt + 1], l)), n[A + 1] = function bb(n, i) { return 131071 & n | i << 17 }(n[A + 1], l) } else n[l + 1] = Cf(A, 0), 0 !== A && (n[A + 1] = Mp(n[A + 1], l)), A = l; else n[l + 1] = Cf(N, 0), 0 === A ? A = l : n[N + 1] = Mp(n[N + 1], l), N = l; q && (n[l + 1] = Tp(n[l + 1])), B_(n, we, l, !0), B_(n, we, l, !1), function wb(n, i, o, l, d) { const p = d ? n.residualClasses : n.residualStyles; null != p && "string" == typeof i && Ll(p, i) >= 0 && (o[l + 1] = Sp(o[l + 1])) }(i, we, n, l, p), E = Cf(A, N), p ? i.classBindings = E : i.styleBindings = E }(d, p, i, o, E, l) } } function _(n, i, o, l, d) { let p = null; const E = o.directiveEnd; let A = o.directiveStylingLast; for (-1 === A ? A = o.directiveStart : A++; A < E && (p = i[A], l = R(l, p.hostAttrs, d), p !== n);)A++; return null !== n && (o.directiveStylingLast = A), l } function R(n, i, o) { const l = o ? 1 : 2; let d = -1; if (null !== i) for (let p = 0; p < i.length; p++) { const E = i[p]; "number" == typeof E ? d = E : d === l && (Array.isArray(n) || (n = void 0 === n ? [] : ["", n]), Ts(n, E, !!o || i[++p])) } return void 0 === n ? null : n } function Gt(n, i, o, l, d, p, E, A) { if (!(3 & i.type)) return; const N = n.data, q = N[A + 1], we = function yb(n) { return 1 == (1 & n) }(q) ? an(N, i, o, d, cd(q), E) : void 0; kn(we) || (kn(p) || function vb(n) { return 2 == (2 & n) }(q) && (p = an(N, null, o, d, A, E)), function Qf(n, i, o, l, d) { if (i) d ? n.addClass(o, l) : n.removeClass(o, l); else { let p = -1 === l.indexOf("-") ? void 0 : _l.DashCase; null == d ? n.removeStyle(o, l, p) : ("string" == typeof d && d.endsWith("!important") && (d = d.slice(0, -10), p |= _l.Important), n.setStyle(o, l, d, p)) } }(l, E, P(m(), o), d, p)) } function an(n, i, o, l, d, p) { const E = null === i; let A; for (; d > 0;) { const N = n[d], q = Array.isArray(N), we = q ? N[1] : N, Ge = null === we; let Dt = o[d + 1]; Dt === Gi && (Dt = Ge ? J : void 0); let Bt = Ge ? eu(Dt, l) : we === l ? Dt : void 0; if (q && !kn(Bt) && (Bt = eu(N, l)), kn(Bt) && (A = Bt, E)) return A; const hn = n[d + 1]; d = E ? Ac(hn) : cd(hn) } if (null !== i) { let N = p ? i.residualClasses : i.residualStyles; null != N && (A = eu(N, l)) } return A } function kn(n) { return void 0 !== n } function ti(n, i) { return 0 != (n.flags & (i ? 8 : 16)) } function Qi(n, i = "") { const o = vn(), l = $i(), d = n + Mi, p = l.firstCreatePass ? Fd(l, d, 1, i, null) : l.data[d], E = Rr(l, o, p, i, n); o[d] = E, zt() && ac(l, o, E, p), ps(p, !1) } let Rr = (n, i, o, l, d) => (xn(!0), function pu(n, i) { return n.createText(i) }(i[Xn], l)); function ls(n) { return Co("", n, ""), ls } function Co(n, i, o) { const l = vn(), d = Cc(l, n, i, o); return d !== Gi && El(l, m(), d), Co } function ua(n, i, o, l, d) { const p = vn(), E = jd(p, n, i, o, l, d); return E !== Gi && El(p, m(), E), ua } function Ry(n, i, o) { !function ol(n, i, o, l) { const d = $i(), p = Es(2); d.firstUpdatePass && e(d, null, p, l); const E = vn(); if (o !== Gi && da(E, p, o)) { const A = d.data[m()]; if (ti(A, l) && !r(d, p)) { let N = l ? A.classesWithoutHost : A.stylesWithoutHost; null !== N && (o = ze(N, o || "")), Mc(d, A, E, o, l) } else !function ot(n, i, o, l, d, p, E, A) { d === Gi && (d = J); let N = 0, q = 0, we = 0 < d.length ? d[0] : null, Ge = 0 < p.length ? p[0] : null; for (; null !== we || null !== Ge;) { const Dt = N < d.length ? d[N + 1] : void 0, Bt = q < p.length ? p[q + 1] : void 0; let Rn, hn = null; we === Ge ? (N += 2, q += 2, Dt !== Bt && (hn = Ge, Rn = Bt)) : null === Ge || null !== we && we < Ge ? (N += 2, hn = we) : (q += 2, hn = Ge, Rn = Bt), null !== hn && Gt(n, i, o, l, hn, Rn, E, A), we = N < d.length ? d[N] : null, Ge = q < p.length ? p[q] : null } }(d, A, E, E[Xn], E[p + 1], E[p + 1] = function j(n, i, o) { if (null == o || "" === o) return J; const l = [], d = bl(o); if (Array.isArray(d)) for (let p = 0; p < d.length; p++)n(l, d[p], !0); else if ("object" == typeof d) for (const p in d) d.hasOwnProperty(p) && n(l, p, d[p]); else "string" == typeof d && i(l, d); return l }(n, i, o), l, p) } }(Ts, Xl, Cc(vn(), n, i, o), !0) } function Tb(n, i, o) { const l = vn(); return da(l, Pi(), i) && Ia($i(), h(), l, n, i, l[Xn], o, !0), Tb } function Mb(n, i, o) { const l = vn(); if (da(l, Pi(), i)) { const p = $i(), E = h(); Ia(p, E, l, n, i, i_(Sa(p.data), E, l), o, !0) } return Mb } const ah = void 0; var Ex = ["en", [["a", "p"], ["AM", "PM"], ah], [["AM", "PM"], ah, ah], [["S", "M", "T", "W", "T", "F", "S"], ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]], ah, [["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"], ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]], ah, [["B", "A"], ["BC", "AD"], ["Before Christ", "Anno Domini"]], 0, [6, 0], ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"], ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"], ["{1}, {0}", ah, "{1} 'at' {0}", ah], [".", ",", ";", "%", "+", "-", "E", "\xd7", "\u2030", "\u221e", "NaN", ":"], ["#,##0.###", "#,##0%", "\xa4#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr", function xx(n) { const o = Math.floor(Math.abs(n)), l = n.toString().replace(/^[^.]*\.?/, "").length; return 1 === o && 0 === l ? 1 : 5 }]; let If = {}; function Sb(n) { const i = function Cx(n) { return n.toLowerCase().replace(/_/g, "-") }(n); let o = jy(i); if (o) return o; const l = i.split("-")[0]; if (o = jy(l), o) return o; if ("en" === l) return Ex; throw new ie(701, !1) } function zy(n) { return Sb(n)[Si.PluralCase] } function jy(n) { return n in If || (If[n] = Ue.ng && Ue.ng.common && Ue.ng.common.locales && Ue.ng.common.locales[n]), If[n] } var Si = (() => ((Si = Si || {})[Si.LocaleId = 0] = "LocaleId", Si[Si.DayPeriodsFormat = 1] = "DayPeriodsFormat", Si[Si.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", Si[Si.DaysFormat = 3] = "DaysFormat", Si[Si.DaysStandalone = 4] = "DaysStandalone", Si[Si.MonthsFormat = 5] = "MonthsFormat", Si[Si.MonthsStandalone = 6] = "MonthsStandalone", Si[Si.Eras = 7] = "Eras", Si[Si.FirstDayOfWeek = 8] = "FirstDayOfWeek", Si[Si.WeekendRange = 9] = "WeekendRange", Si[Si.DateFormat = 10] = "DateFormat", Si[Si.TimeFormat = 11] = "TimeFormat", Si[Si.DateTimeFormat = 12] = "DateTimeFormat", Si[Si.NumberSymbols = 13] = "NumberSymbols", Si[Si.NumberFormats = 14] = "NumberFormats", Si[Si.CurrencyCode = 15] = "CurrencyCode", Si[Si.CurrencySymbol = 16] = "CurrencySymbol", Si[Si.CurrencyName = 17] = "CurrencyName", Si[Si.Currencies = 18] = "Currencies", Si[Si.Directionality = 19] = "Directionality", Si[Si.PluralCase = 20] = "PluralCase", Si[Si.ExtraData = 21] = "ExtraData", Si))(); const Df = "en-US"; let $y = Df; function Rb(n, i, o, l, d) { if (n = Pe(n), Array.isArray(n)) for (let p = 0; p < n.length; p++)Rb(n[p], i, o, l, d); else { const p = $i(), E = vn(); let A = yl(n) ? n : Pe(n.provide), N = Eg(n); const q = xo(), we = 1048575 & q.providerIndexes, Ge = q.directiveStart, Dt = q.providerIndexes >> 20; if (yl(n) || !n.multi) { const Bt = new Fr(N, d, wc), hn = Pb(A, i, d ? we : we + Dt, Ge); -1 === hn ? (_o(Ua(q, E), p, A), Ob(p, n, i.length), i.push(A), q.directiveStart++, q.directiveEnd++, d && (q.providerIndexes += 1048576), o.push(Bt), E.push(Bt)) : (o[hn] = Bt, E[hn] = Bt) } else { const Bt = Pb(A, i, we + Dt, Ge), hn = Pb(A, i, we, we + Dt), Qn = hn >= 0 && o[hn]; if (d && !Qn || !d && !(Bt >= 0 && o[Bt])) { _o(Ua(q, E), p, A); const yi = function wE(n, i, o, l, d) { const p = new Fr(n, o, wc); return p.multi = [], p.index = i, p.componentProviders = 0, g0(p, d, l && !o), p }(d ? yE : bE, o.length, d, l, N); !d && Qn && (o[hn].providerFactory = yi), Ob(p, n, i.length, 0), i.push(A), q.directiveStart++, q.directiveEnd++, d && (q.providerIndexes += 1048576), o.push(yi), E.push(yi) } else Ob(p, n, Bt > -1 ? Bt : hn, g0(o[d ? hn : Bt], N, !d && l)); !d && l && Qn && o[hn].componentProviders++ } } } function Ob(n, i, o, l) { const d = yl(i), p = function wg(n) { return !!n.useClass }(i); if (d || p) { const N = (p ? Pe(i.useClass) : i).prototype.ngOnDestroy; if (N) { const q = n.destroyHooks || (n.destroyHooks = []); if (!d && i.multi) { const we = q.indexOf(o); -1 === we ? q.push(o, [l, N]) : q[we + 1].push(l, N) } else q.push(o, N) } } } function g0(n, i, o) { return o && n.componentProviders++, n.multi.push(i) - 1 } function Pb(n, i, o, l) { for (let d = o; d < l; d++)if (i[d] === n) return d; return -1 } function bE(n, i, o, l) { return Nb(this.multi, []) } function yE(n, i, o, l) { const d = this.multi; let p; if (this.providerFactory) { const E = this.providerFactory.componentProviders, A = Xo(o, o[Sn], this.providerFactory.index, l); p = A.slice(0, E), Nb(d, p); for (let N = E; N < A.length; N++)p.push(A[N]) } else p = [], Nb(d, p); return p } function Nb(n, i) { for (let o = 0; o < n.length; o++)i.push((0, n[o])()); return i } function _0(n, i = []) { return o => { o.providersResolver = (l, d) => function vE(n, i, o) { const l = $i(); if (l.firstCreatePass) { const d = Ni(n); Rb(o, l.data, l.blueprint, d, !0), Rb(i, l.data, l.blueprint, d, !1) } }(l, d ? d(n) : n, i) } } class Tf { } class v0 { } function xE(n, i) { return new Fb(n, i ?? null, []) } class Fb extends Tf { constructor(i, o, l) { super(), this._parent = o, this._bootstrapComponents = [], this.destroyCbs = [], this.componentFactoryResolver = new lf(this); const d = wi(i); this._bootstrapComponents = wl(d.bootstrap), this._r3Injector = Gg(i, o, [{ provide: Tf, useValue: this }, { provide: gc, useValue: this.componentFactoryResolver }, ...l], xe(i), new Set(["environment"])), this._r3Injector.resolveInjectorInitializers(), this.instance = this._r3Injector.get(i) } get injector() { return this._r3Injector } destroy() { const i = this._r3Injector; !i.destroyed && i.destroy(), this.destroyCbs.forEach(o => o()), this.destroyCbs = null } onDestroy(i) { this.destroyCbs.push(i) } } class Lb extends v0 { constructor(i) { super(), this.moduleType = i } create(i) { return new Fb(this.moduleType, i, []) } } class b0 extends Tf { constructor(i) { super(), this.componentFactoryResolver = new lf(this), this.instance = null; const o = new Ms([...i.providers, { provide: Tf, useValue: this }, { provide: gc, useValue: this.componentFactoryResolver }], i.parent || Ah(), i.debugName, new Set(["environment"])); this.injector = o, i.runEnvironmentInitializers && o.resolveInjectorInitializers() } destroy() { this.injector.destroy() } onDestroy(i) { this.injector.onDestroy(i) } } function y0(n, i, o = null) { return new b0({ providers: n, parent: i, debugName: o, runEnvironmentInitializers: !0 }).injector } let CE = (() => { class n { constructor(o) { this._injector = o, this.cachedInjectors = new Map } getOrCreateStandaloneInjector(o) { if (!o.standalone) return null; if (!this.cachedInjectors.has(o.id)) { const l = lm(0, o.type), d = l.length > 0 ? y0([l], this._injector, `Standalone[${o.type.name}]`) : null; this.cachedInjectors.set(o.id, d) } return this.cachedInjectors.get(o.id) } ngOnDestroy() { try { for (const o of this.cachedInjectors.values()) null !== o && o.destroy() } finally { this.cachedInjectors.clear() } } } return n.\u0275prov = Ae({ token: n, providedIn: "environment", factory: () => new n(de(Wl)) }), n })(); function w0(n) { n.getStandaloneInjector = i => i.get(CE).getOrCreateStandaloneInjector(n) } function M0(n, i, o) { const l = Ri() + n, d = vn(); return d[l] === Gi ? Uo(d, l, o ? i.call(o) : i()) : function Fa(n, i) { return n[i] }(d, l) } function S0(n, i, o, l) { return function k0(n, i, o, l, d, p) { const E = i + o; return da(n, E, d) ? Uo(n, E + 1, p ? l.call(p, d) : l(d)) : Up(n, E + 1) }(vn(), Ri(), n, i, o, l) } function A0(n, i, o, l, d) { return R0(vn(), Ri(), n, i, o, l, d) } function Up(n, i) { const o = n[i]; return o === Gi ? void 0 : o } function R0(n, i, o, l, d, p, E) { const A = i + o; return sd(n, A, d, p) ? Uo(n, A + 2, E ? l.call(E, d, p) : l(d, p)) : Up(n, A + 2) } function F0(n, i) { const o = $i(); let l; const d = n + Mi; o.firstCreatePass ? (l = function VE(n, i) { if (i) for (let o = i.length - 1; o >= 0; o--) { const l = i[o]; if (n === l.name) return l } }(i, o.pipeRegistry), o.data[d] = l, l.onDestroy && (o.destroyHooks ??= []).push(d, l.onDestroy)) : l = o.data[d]; const p = l.factory || (l.factory = kt(l.type)), E = Xe(wc); try { const A = bi(!1), N = p(); return bi(A), function cb(n, i, o, l) { o >= n.data.length && (n.data[o] = null, n.blueprint[o] = null), i[o] = l }(o, vn(), d, N), N } finally { Xe(E) } } function L0(n, i, o, l) { const d = n + Mi, p = vn(), E = Je(p, d); return function Vp(n, i) { return n[Sn].data[i].pure }(p, d) ? R0(p, Ri(), i, E.transform, o, l, E) : E.transform(o, l) } function Ub(n) { return i => { setTimeout(n, void 0, i) } } const Oc = class GE extends a.x { constructor(i = !1) { super(), this.__isAsync = i } emit(i) { super.next(i) } subscribe(i, o, l) { let d = i, p = o || (() => null), E = l; if (i && "object" == typeof i) { const N = i; d = N.next?.bind(N), p = N.error?.bind(N), E = N.complete?.bind(N) } this.__isAsync && (p = Ub(p), d && (d = Ub(d)), E && (E = Ub(E))); const A = super.subscribe({ next: d, error: p, complete: E }); return i instanceof y.w0 && i.add(A), A } }; function WE() { return this._results[Symbol.iterator]() } class K_ { get changes() { return this._changes || (this._changes = new Oc) } constructor(i = !1) { this._emitDistinctChangesOnly = i, this.dirty = !0, this._results = [], this._changesDetected = !1, this._changes = null, this.length = 0, this.first = void 0, this.last = void 0; const o = K_.prototype; o[Symbol.iterator] || (o[Symbol.iterator] = WE) } get(i) { return this._results[i] } map(i) { return this._results.map(i) } filter(i) { return this._results.filter(i) } find(i) { return this._results.find(i) } reduce(i, o) { return this._results.reduce(i, o) } forEach(i) { this._results.forEach(i) } some(i) { return this._results.some(i) } toArray() { return this._results.slice() } toString() { return this._results.toString() } reset(i, o) { const l = this; l.dirty = !1; const d = function js(n) { return n.flat(Number.POSITIVE_INFINITY) }(i); (this._changesDetected = !function fl(n, i, o) { if (n.length !== i.length) return !1; for (let l = 0; l < n.length; l++) { let d = n[l], p = i[l]; if (o && (d = o(d), p = o(p)), p !== d) return !1 } return !0 }(l._results, d, o)) && (l._results = d, l.length = d.length, l.last = d[this.length - 1], l.first = d[0]) } notifyOnChanges() { this._changes && (this._changesDetected || !this._emitDistinctChangesOnly) && this._changes.emit(this) } setDirty() { this.dirty = !0 } destroy() { this.changes.complete(), this.changes.unsubscribe() } } let Hp = (() => { class n { } return n.__NG_ELEMENT_ID__ = YE, n })(); const KE = Hp, ZE = class extends KE { constructor(i, o, l) { super(), this._declarationLView = i, this._declarationTContainer = o, this.elementRef = l } get ssrId() { return this._declarationTContainer.tView?.ssrId || null } createEmbeddedView(i, o) { return this.createEmbeddedViewImpl(i, o, null) } createEmbeddedViewImpl(i, o, l) { const E = this._declarationTContainer.tView, A = Nd(this._declarationLView, E, i, 4096 & this._declarationLView[ci] ? 4096 : 16, null, E.declTNode, null, null, null, o || null, l || null); A[Zo] = this._declarationLView[this._declarationTContainer.index]; const q = this._declarationLView[oo]; return null !== q && (A[oo] = q.createEmbeddedView(E)), Xm(E, A, i), new Ec(A) } }; function YE() { return Z_(xo(), vn()) } function Z_(n, i) { return 4 & n.type ? new ZE(i, n, _c(n, i)) : null } let Y_ = (() => { class n { } return n.__NG_ELEMENT_ID__ = nC, n })(); function nC() { return j0(xo(), vn()) } const iC = Y_, H0 = class extends iC { constructor(i, o, l) { super(), this._lContainer = i, this._hostTNode = o, this._hostLView = l } get element() { return _c(this._hostTNode, this._hostLView) } get injector() { return new xa(this._hostTNode, this._hostLView) } get parentInjector() { const i = Is(this._hostTNode, this._hostLView); if (ya(i)) { const o = oi(i, this._hostLView), l = el(i); return new xa(o[Sn].data[l + 8], o) } return new xa(null, this._hostLView) } clear() { for (; this.length > 0;)this.remove(this.length - 1) } get(i) { const o = z0(this._lContainer); return null !== o && o[i] || null } get length() { return this._lContainer.length - Ki } createEmbeddedView(i, o, l) { let d, p; "number" == typeof l ? d = l : null != l && (d = l.index, p = l.injector); const A = i.createEmbeddedViewImpl(o || {}, p, null); return this.insertImpl(A, d, false), A } createComponent(i, o, l, d, p) { const E = i && !function Bo(n) { return "function" == typeof n }(i); let A; if (E) A = o; else { const Rn = o || {}; A = Rn.index, l = Rn.injector, d = Rn.projectableNodes, p = Rn.environmentInjector || Rn.ngModuleRef } const N = E ? i : new od(At(i)), q = l || this.parentInjector; if (!p && null == N.ngModule) { const Qn = (E ? q : this.parentInjector).get(Wl, null); Qn && (p = Qn) } At(N.componentType ?? {}); const Bt = N.create(q, d, null, p); return this.insertImpl(Bt.hostView, A, false), Bt } insert(i, o) { return this.insertImpl(i, o, !1) } insertImpl(i, o, l) { const d = i._lView, p = d[Sn]; if (function Ji(n) { return Gr(n[ki]) }(d)) { const N = this.indexOf(i); if (-1 !== N) this.detach(N); else { const q = d[ki], we = new H0(q, q[nr], q[ki]); we.detach(we.indexOf(i)) } } const E = this._adjustIndex(o), A = this._lContainer; if (function Gf(n, i, o, l) { const d = Ki + l, p = o.length; l > 0 && (o[d - 1][tr] = i), l < p - Ki ? (i[tr] = o[d], Qs(o, Ki + l, i)) : (o.push(i), i[tr] = null), i[ki] = o; const E = i[Zo]; null !== E && o !== E && function _u(n, i) { const o = n[Qo]; i[cr] !== i[ki][ki][cr] && (n[Ro] = !0), null === o ? n[Qo] = [i] : o.push(i) }(E, i); const A = i[oo]; null !== A && A.insertView(n), i[ci] |= 128 }(p, d, A, E), !l) { const N = _h(E, A), q = d[Xn], we = xd(q, A[yo]); null !== we && function av(n, i, o, l, d, p) { l[_i] = d, l[nr] = i, Cd(n, l, o, 1, d, p) }(p, A[nr], q, d, we, N) } return i.attachToViewContainerRef(), Qs(Hb(A), E, i), i } move(i, o) { return this.insert(i, o) } indexOf(i) { const o = z0(this._lContainer); return null !== o ? o.indexOf(i) : -1 } remove(i) { const o = this._adjustIndex(i, -1), l = zc(this._lContainer, o); l && (no(Hb(this._lContainer), o), vu(l[Sn], l)) } detach(i) { const o = this._adjustIndex(i, -1), l = zc(this._lContainer, o); return l && null != no(Hb(this._lContainer), o) ? new Ec(l) : null } _adjustIndex(i, o = 0) { return i ?? this.length + o } }; function z0(n) { return n[8] } function Hb(n) { return n[8] || (n[8] = []) } function j0(n, i) { let o; const l = i[n.index]; return Gr(l) ? o = l : (o = Jg(l, i, null, n), i[n.index] = o, Bd(i, o)), $0(o, i, n, l), new H0(o, n, i) } let $0 = function G0(n, i, o, l) { if (n[yo]) return; let d; d = 8 & o.type ? yr(l) : function rC(n, i) { const o = n[Xn], l = o.createComment(""), d = X(i, n); return sc(o, xd(o, d), l, function Ed(n, i) { return n.nextSibling(i) }(o, d), !1), l }(i, o), n[yo] = d }; class zb { constructor(i) { this.queryList = i, this.matches = null } clone() { return new zb(this.queryList) } setDirty() { this.queryList.setDirty() } } class jb { constructor(i = []) { this.queries = i } createEmbeddedView(i) { const o = i.queries; if (null !== o) { const l = null !== i.contentQueries ? i.contentQueries[0] : o.length, d = []; for (let p = 0; p < l; p++) { const E = o.getByIndex(p); d.push(this.queries[E.indexInDeclarationView].clone()) } return new jb(d) } return null } insertView(i) { this.dirtyQueriesWithMatches(i) } detachView(i) { this.dirtyQueriesWithMatches(i) } dirtyQueriesWithMatches(i) { for (let o = 0; o < this.queries.length; o++)null !== ew(i, o).matches && this.queries[o].setDirty() } } class W0 { constructor(i, o, l = null) { this.predicate = i, this.flags = o, this.read = l } } class $b { constructor(i = []) { this.queries = i } elementStart(i, o) { for (let l = 0; l < this.queries.length; l++)this.queries[l].elementStart(i, o) } elementEnd(i) { for (let o = 0; o < this.queries.length; o++)this.queries[o].elementEnd(i) } embeddedTView(i) { let o = null; for (let l = 0; l < this.length; l++) { const d = null !== o ? o.length : 0, p = this.getByIndex(l).embeddedTView(i, d); p && (p.indexInDeclarationView = l, null !== o ? o.push(p) : o = [p]) } return null !== o ? new $b(o) : null } template(i, o) { for (let l = 0; l < this.queries.length; l++)this.queries[l].template(i, o) } getByIndex(i) { return this.queries[i] } get length() { return this.queries.length } track(i) { this.queries.push(i) } } class Gb { constructor(i, o = -1) { this.metadata = i, this.matches = null, this.indexInDeclarationView = -1, this.crossesNgTemplate = !1, this._appliesToNextNode = !0, this._declarationNodeIndex = o } elementStart(i, o) { this.isApplyingToNode(o) && this.matchTNode(i, o) } elementEnd(i) { this._declarationNodeIndex === i.index && (this._appliesToNextNode = !1) } template(i, o) { this.elementStart(i, o) } embeddedTView(i, o) { return this.isApplyingToNode(i) ? (this.crossesNgTemplate = !0, this.addMatch(-i.index, o), new Gb(this.metadata)) : null } isApplyingToNode(i) { if (this._appliesToNextNode && 1 != (1 & this.metadata.flags)) { const o = this._declarationNodeIndex; let l = i.parent; for (; null !== l && 8 & l.type && l.index !== o;)l = l.parent; return o === (null !== l ? l.index : -1) } return this._appliesToNextNode } matchTNode(i, o) { const l = this.metadata.predicate; if (Array.isArray(l)) for (let d = 0; d < l.length; d++) { const p = l[d]; this.matchTNodeWithReadOption(i, o, aC(o, p)), this.matchTNodeWithReadOption(i, o, za(o, i, p, !1, !1)) } else l === Hp ? 4 & o.type && this.matchTNodeWithReadOption(i, o, -1) : this.matchTNodeWithReadOption(i, o, za(o, i, l, !1, !1)) } matchTNodeWithReadOption(i, o, l) { if (null !== l) { const d = this.metadata.read; if (null !== d) if (d === Sd || d === Y_ || d === Hp && 4 & o.type) this.addMatch(o.index, -2); else { const p = za(o, i, d, !1, !1); null !== p && this.addMatch(o.index, p) } else this.addMatch(o.index, l) } } addMatch(i, o) { null === this.matches ? this.matches = [i, o] : this.matches.push(i, o) } } function aC(n, i) { const o = n.localNames; if (null !== o) for (let l = 0; l < o.length; l += 2)if (o[l] === i) return o[l + 1]; return null } function cC(n, i, o, l) { return -1 === o ? function lC(n, i) { return 11 & n.type ? _c(n, i) : 4 & n.type ? Z_(n, i) : null }(i, n) : -2 === o ? function dC(n, i, o) { return o === Sd ? _c(i, n) : o === Hp ? Z_(i, n) : o === Y_ ? j0(i, n) : void 0 }(n, i, l) : Xo(n, n[Sn], o, i) } function K0(n, i, o, l) { const d = i[oo].queries[l]; if (null === d.matches) { const p = n.data, E = o.matches, A = []; for (let N = 0; N < E.length; N += 2) { const q = E[N]; A.push(q < 0 ? null : cC(i, p[q], E[N + 1], o.metadata.read)) } d.matches = A } return d.matches } function Wb(n, i, o, l) { const d = n.queries.getByIndex(o), p = d.matches; if (null !== p) { const E = K0(n, i, d, o); for (let A = 0; A < p.length; A += 2) { const N = p[A]; if (N > 0) l.push(E[A / 2]); else { const q = p[A + 1], we = i[-N]; for (let Ge = Ki; Ge < we.length; Ge++) { const Dt = we[Ge]; Dt[Zo] === Dt[ki] && Wb(Dt[Sn], Dt, q, l) } if (null !== we[Qo]) { const Ge = we[Qo]; for (let Dt = 0; Dt < Ge.length; Dt++) { const Bt = Ge[Dt]; Wb(Bt[Sn], Bt, q, l) } } } } } return l } function Z0(n) { const i = vn(), o = $i(), l = Ba(); Aa(l + 1); const d = ew(o, l); if (n.dirty && function en(n) { return 4 == (4 & n[ci]) }(i) === (2 == (2 & d.metadata.flags))) { if (null === d.matches) n.reset([]); else { const p = d.crossesNgTemplate ? Wb(o, i, l, []) : K0(o, i, d, l); n.reset(p, Mv), n.notifyOnChanges() } return !0 } return !1 } function Y0(n, i, o) { const l = $i(); l.firstCreatePass && (J0(l, new W0(n, i, o), -1), 2 == (2 & i) && (l.staticViewQueries = !0)), X0(l, vn(), i) } function q0(n, i, o, l) { const d = $i(); if (d.firstCreatePass) { const p = xo(); J0(d, new W0(i, o, l), p.index), function hC(n, i) { const o = n.contentQueries || (n.contentQueries = []); i !== (o.length ? o[o.length - 1] : -1) && o.push(n.queries.length - 1, i) }(d, n), 2 == (2 & o) && (d.staticContentQueries = !0) } X0(d, vn(), o) } function Q0() { return function uC(n, i) { return n[oo].queries[i].queryList }(vn(), Ba()) } function X0(n, i, o) { const l = new K_(4 == (4 & o)); (function Vm(n, i, o, l) { const d = n_(i); d.push(o), n.firstCreatePass && nf(n).push(l, d.length - 1) })(n, i, l, l.destroy), null === i[oo] && (i[oo] = new jb), i[oo].queries.push(new zb(l)) } function J0(n, i, o) { null === n.queries && (n.queries = new $b), n.queries.track(new Gb(i, o)) } function ew(n, i) { return n.queries.getByIndex(i) } function tw(n, i) { return Z_(n, i) } function Kb(n) { return !!wi(n) } const vw = new Cr("Application Initializer"); let Xb = (() => { class n { constructor() { this.initialized = !1, this.done = !1, this.donePromise = new Promise((o, l) => { this.resolve = o, this.reject = l }), this.appInits = Lt(vw, { optional: !0 }) ?? [] } runInitializers() { if (this.initialized) return; const o = []; for (const d of this.appInits) { const p = d(); if (wf(p)) o.push(p); else if (Ip(p)) { const E = new Promise((A, N) => { p.subscribe({ complete: A, error: N }) }); o.push(E) } } const l = () => { this.done = !0, this.resolve() }; Promise.all(o).then(() => { l() }).catch(d => { this.reject(d) }), 0 === o.length && l(), this.initialized = !0 } } return n.\u0275fac = function (o) { return new (o || n) }, n.\u0275prov = Ae({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(), bw = (() => { class n { log(o) { console.log(o) } warn(o) { console.warn(o) } } return n.\u0275fac = function (o) { return new (o || n) }, n.\u0275prov = Ae({ token: n, factory: n.\u0275fac, providedIn: "platform" }), n })(); const Q_ = new Cr("LocaleId", { providedIn: "root", factory: () => Lt(Q_, Ke.Optional | Ke.SkipSelf) || function OC() { return typeof $localize < "u" && $localize.locale || Df }() }), PC = new Cr("DefaultCurrencyCode", { providedIn: "root", factory: () => "USD" }); let yw = (() => { class n { constructor() { this.taskId = 0, this.pendingTasks = new Set, this.hasPendingTasks = new v.X(!1) } add() { this.hasPendingTasks.next(!0); const o = this.taskId++; return this.pendingTasks.add(o), o } remove(o) { this.pendingTasks.delete(o), 0 === this.pendingTasks.size && this.hasPendingTasks.next(!1) } ngOnDestroy() { this.pendingTasks.clear(), this.hasPendingTasks.next(!1) } } return n.\u0275fac = function (o) { return new (o || n) }, n.\u0275prov = Ae({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); class NC { constructor(i, o) { this.ngModuleFactory = i, this.componentFactories = o } } let FC = (() => { class n { compileModuleSync(o) { return new Lb(o) } compileModuleAsync(o) { return Promise.resolve(this.compileModuleSync(o)) } compileModuleAndAllComponentsSync(o) { const l = this.compileModuleSync(o), p = wl(wi(o).declarations).reduce((E, A) => { const N = At(A); return N && E.push(new od(N)), E }, []); return new NC(l, p) } compileModuleAndAllComponentsAsync(o) { return Promise.resolve(this.compileModuleAndAllComponentsSync(o)) } clearCache() { } clearCacheFor(o) { } getModuleId(o) { } } return n.\u0275fac = function (o) { return new (o || n) }, n.\u0275prov = Ae({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); function Ew(...n) { } class Wa { constructor({ enableLongStackTrace: i = !1, shouldCoalesceEventChangeDetection: o = !1, shouldCoalesceRunChangeDetection: l = !1 }) { if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new Oc(!1), this.onMicrotaskEmpty = new Oc(!1), this.onStable = new Oc(!1), this.onError = new Oc(!1), typeof Zone > "u") throw new ie(908, !1); Zone.assertZonePatched(); const d = this; d._nesting = 0, d._outer = d._inner = Zone.current, Zone.TaskTrackingZoneSpec && (d._inner = d._inner.fork(new Zone.TaskTrackingZoneSpec)), i && Zone.longStackTraceZoneSpec && (d._inner = d._inner.fork(Zone.longStackTraceZoneSpec)), d.shouldCoalesceEventChangeDetection = !l && o, d.shouldCoalesceRunChangeDetection = l, d.lastRequestAnimationFrameId = -1, d.nativeRequestAnimationFrame = function UC() { const n = "function" == typeof Ue.requestAnimationFrame; let i = Ue[n ? "requestAnimationFrame" : "setTimeout"], o = Ue[n ? "cancelAnimationFrame" : "clearTimeout"]; if (typeof Zone < "u" && i && o) { const l = i[Zone.__symbol__("OriginalDelegate")]; l && (i = l); const d = o[Zone.__symbol__("OriginalDelegate")]; d && (o = d) } return { nativeRequestAnimationFrame: i, nativeCancelAnimationFrame: o } }().nativeRequestAnimationFrame, function zC(n) { const i = () => { !function HC(n) { n.isCheckStableRunning || -1 !== n.lastRequestAnimationFrameId || (n.lastRequestAnimationFrameId = n.nativeRequestAnimationFrame.call(Ue, () => { n.fakeTopEventTask || (n.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", () => { n.lastRequestAnimationFrameId = -1, ey(n), n.isCheckStableRunning = !0, Jb(n), n.isCheckStableRunning = !1 }, void 0, () => { }, () => { })), n.fakeTopEventTask.invoke() }), ey(n)) }(n) }; n._inner = n._inner.fork({ name: "angular", properties: { isAngularZone: !0 }, onInvokeTask: (o, l, d, p, E, A) => { try { return Cw(n), o.invokeTask(d, p, E, A) } finally { (n.shouldCoalesceEventChangeDetection && "eventTask" === p.type || n.shouldCoalesceRunChangeDetection) && i(), Iw(n) } }, onInvoke: (o, l, d, p, E, A, N) => { try { return Cw(n), o.invoke(d, p, E, A, N) } finally { n.shouldCoalesceRunChangeDetection && i(), Iw(n) } }, onHasTask: (o, l, d, p) => { o.hasTask(d, p), l === d && ("microTask" == p.change ? (n._hasPendingMicrotasks = p.microTask, ey(n), Jb(n)) : "macroTask" == p.change && (n.hasPendingMacrotasks = p.macroTask)) }, onHandleError: (o, l, d, p) => (o.handleError(d, p), n.runOutsideAngular(() => n.onError.emit(p)), !1) }) }(d) } static isInAngularZone() { return typeof Zone < "u" && !0 === Zone.current.get("isAngularZone") } static assertInAngularZone() { if (!Wa.isInAngularZone()) throw new ie(909, !1) } static assertNotInAngularZone() { if (Wa.isInAngularZone()) throw new ie(909, !1) } run(i, o, l) { return this._inner.run(i, o, l) } runTask(i, o, l, d) { const p = this._inner, E = p.scheduleEventTask("NgZoneEvent: " + d, i, VC, Ew, Ew); try { return p.runTask(E, o, l) } finally { p.cancelTask(E) } } runGuarded(i, o, l) { return this._inner.runGuarded(i, o, l) } runOutsideAngular(i) { return this._outer.run(i) } } const VC = {}; function Jb(n) { if (0 == n._nesting && !n.hasPendingMicrotasks && !n.isStable) try { n._nesting++, n.onMicrotaskEmpty.emit(null) } finally { if (n._nesting--, !n.hasPendingMicrotasks) try { n.runOutsideAngular(() => n.onStable.emit(null)) } finally { n.isStable = !0 } } } function ey(n) { n.hasPendingMicrotasks = !!(n._hasPendingMicrotasks || (n.shouldCoalesceEventChangeDetection || n.shouldCoalesceRunChangeDetection) && -1 !== n.lastRequestAnimationFrameId) } function Cw(n) { n._nesting++, n.isStable && (n.isStable = !1, n.onUnstable.emit(null)) } function Iw(n) { n._nesting--, Jb(n) } class jC { constructor() { this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new Oc, this.onMicrotaskEmpty = new Oc, this.onStable = new Oc, this.onError = new Oc } run(i, o, l) { return i.apply(o, l) } runGuarded(i, o, l) { return i.apply(o, l) } runOutsideAngular(i) { return i() } runTask(i, o, l, d) { return i.apply(o, l) } } const Dw = new Cr("", { providedIn: "root", factory: Tw }); function Tw() { const n = Lt(Wa); let i = !0; const o = new Y.y(d => { i = n.isStable && !n.hasPendingMacrotasks && !n.hasPendingMicrotasks, n.runOutsideAngular(() => { d.next(i), d.complete() }) }), l = new Y.y(d => { let p; n.runOutsideAngular(() => { p = n.onStable.subscribe(() => { Wa.assertNotInAngularZone(), queueMicrotask(() => { !i && !n.hasPendingMacrotasks && !n.hasPendingMicrotasks && (i = !0, d.next(!0)) }) }) }); const E = n.onUnstable.subscribe(() => { Wa.assertInAngularZone(), i && (i = !1, n.runOutsideAngular(() => { d.next(!1) })) }); return () => { p.unsubscribe(), E.unsubscribe() } }); return (0, he.T)(o, l.pipe((0, ke.B)())) } const Mw = new Cr(""), Sw = new Cr(""); let ty, $C = (() => { class n { constructor(o, l, d) { this._ngZone = o, this.registry = l, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, ty || (function GC(n) { ty = n }(d), d.addToWindow(l)), this._watchAngularEvents(), o.run(() => { this.taskTrackingZone = typeof Zone > "u" ? null : Zone.current.get("TaskTrackingZone") }) } _watchAngularEvents() { this._ngZone.onUnstable.subscribe({ next: () => { this._didWork = !0, this._isZoneStable = !1 } }), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.subscribe({ next: () => { Wa.assertNotInAngularZone(), queueMicrotask(() => { this._isZoneStable = !0, this._runCallbacksIfReady() }) } }) }) } increasePendingRequestCount() { return this._pendingCount += 1, this._didWork = !0, this._pendingCount } decreasePendingRequestCount() { if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero"); return this._runCallbacksIfReady(), this._pendingCount } isStable() { return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks } _runCallbacksIfReady() { if (this.isStable()) queueMicrotask(() => { for (; 0 !== this._callbacks.length;) { let o = this._callbacks.pop(); clearTimeout(o.timeoutId), o.doneCb(this._didWork) } this._didWork = !1 }); else { let o = this.getPendingTasks(); this._callbacks = this._callbacks.filter(l => !l.updateCb || !l.updateCb(o) || (clearTimeout(l.timeoutId), !1)), this._didWork = !0 } } getPendingTasks() { return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map(o => ({ source: o.source, creationLocation: o.creationLocation, data: o.data })) : [] } addCallback(o, l, d) { let p = -1; l && l > 0 && (p = setTimeout(() => { this._callbacks = this._callbacks.filter(E => E.timeoutId !== p), o(this._didWork, this.getPendingTasks()) }, l)), this._callbacks.push({ doneCb: o, timeoutId: p, updateCb: d }) } whenStable(o, l, d) { if (d && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/plugins/task-tracking" loaded?'); this.addCallback(o, l, d), this._runCallbacksIfReady() } getPendingRequestCount() { return this._pendingCount } registerApplication(o) { this.registry.registerApplication(o, this) } unregisterApplication(o) { this.registry.unregisterApplication(o) } findProviders(o, l, d) { return [] } } return n.\u0275fac = function (o) { return new (o || n)(de(Wa), de(Aw), de(Sw)) }, n.\u0275prov = Ae({ token: n, factory: n.\u0275fac }), n })(), Aw = (() => { class n { constructor() { this._applications = new Map } registerApplication(o, l) { this._applications.set(o, l) } unregisterApplication(o) { this._applications.delete(o) } unregisterAllApplications() { this._applications.clear() } getTestability(o) { return this._applications.get(o) || null } getAllTestabilities() { return Array.from(this._applications.values()) } getAllRootElements() { return Array.from(this._applications.keys()) } findTestabilityInTree(o, l = !0) { return ty?.findTestabilityInTree(this, o, l) ?? null } } return n.\u0275fac = function (o) { return new (o || n) }, n.\u0275prov = Ae({ token: n, factory: n.\u0275fac, providedIn: "platform" }), n })(), Qd = null; const kw = new Cr("AllowMultipleToken"), ny = new Cr("PlatformDestroyListeners"), iy = new Cr("appBootstrapListener"); class ZC { constructor(i, o) { this.name = i, this.token = o } } function Pw(n, i, o = []) { const l = `Platform: ${i}`, d = new Cr(l); return (p = []) => { let E = ry(); if (!E || E.injector.get(kw, !1)) { const A = [...o, ...p, { provide: d, useValue: !0 }]; n ? n(A) : function YC(n) { if (Qd && !Qd.get(kw, !1)) throw new ie(400, !1); (function Rw() { !function Ka(n) { Jr = n }(() => { throw new ie(600, !1) }) })(), Qd = n; const i = n.get(Fw); (function Ow(n) { n.get(Oh, null)?.forEach(o => o()) })(n) }(function Nw(n = [], i) { return yc.create({ name: i, providers: [{ provide: Mh, useValue: "platform" }, { provide: ny, useValue: new Set([() => Qd = null]) }, ...n] }) }(A, l)) } return function QC(n) { const i = ry(); if (!i) throw new ie(401, !1); return i }() } } function ry() { return Qd?.get(Fw) ?? null } let Fw = (() => { class n { constructor(o) { this._injector = o, this._modules = [], this._destroyListeners = [], this._destroyed = !1 } bootstrapModuleFactory(o, l) { const d = function XC(n = "zone.js", i) { return "noop" === n ? new jC : "zone.js" === n ? new Wa(i) : n }(l?.ngZone, function Lw(n) { return { enableLongStackTrace: !1, shouldCoalesceEventChangeDetection: n?.eventCoalescing ?? !1, shouldCoalesceRunChangeDetection: n?.runCoalescing ?? !1 } }({ eventCoalescing: l?.ngZoneEventCoalescing, runCoalescing: l?.ngZoneRunCoalescing })); return d.run(() => { const p = function EE(n, i, o) { return new Fb(n, i, o) }(o.moduleType, this.injector, function zw(n) { return [{ provide: Wa, useFactory: n }, { provide: Td, multi: !0, useFactory: () => { const i = Lt(eI, { optional: !0 }); return () => i.initialize() } }, { provide: Hw, useFactory: JC }, { provide: Dw, useFactory: Tw }] }(() => d)), E = p.injector.get(Sl, null); return d.runOutsideAngular(() => { const A = d.onError.subscribe({ next: N => { E.handleError(N) } }); p.onDestroy(() => { X_(this._modules, p), A.unsubscribe() }) }), function Bw(n, i, o) { try { const l = o(); return wf(l) ? l.catch(d => { throw i.runOutsideAngular(() => n.handleError(d)), d }) : l } catch (l) { throw i.runOutsideAngular(() => n.handleError(l)), l } }(E, d, () => { const A = p.injector.get(Xb); return A.runInitializers(), A.donePromise.then(() => (function Gy(n) { rn(n, "Expected localeId to be defined"), "string" == typeof n && ($y = n.toLowerCase().replace(/_/g, "-")) }(p.injector.get(Q_, Df) || Df), this._moduleDoBootstrap(p), p)) }) }) } bootstrapModule(o, l = []) { const d = Uw({}, l); return function WC(n, i, o) { const l = new Lb(o); return Promise.resolve(l) }(0, 0, o).then(p => this.bootstrapModuleFactory(p, d)) } _moduleDoBootstrap(o) { const l = o.injector.get(Af); if (o._bootstrapComponents.length > 0) o._bootstrapComponents.forEach(d => l.bootstrap(d)); else { if (!o.instance.ngDoBootstrap) throw new ie(-403, !1); o.instance.ngDoBootstrap(l) } this._modules.push(o) } onDestroy(o) { this._destroyListeners.push(o) } get injector() { return this._injector } destroy() { if (this._destroyed) throw new ie(404, !1); this._modules.slice().forEach(l => l.destroy()), this._destroyListeners.forEach(l => l()); const o = this._injector.get(ny, null); o && (o.forEach(l => l()), o.clear()), this._destroyed = !0 } get destroyed() { return this._destroyed } } return n.\u0275fac = function (o) { return new (o || n)(de(yc)) }, n.\u0275prov = Ae({ token: n, factory: n.\u0275fac, providedIn: "platform" }), n })(); function Uw(n, i) { return Array.isArray(i) ? i.reduce(Uw, n) : { ...n, ...i } } let Af = (() => { class n { constructor() { this._bootstrapListeners = [], this._runningTick = !1, this._destroyed = !1, this._destroyListeners = [], this._views = [], this.internalErrorHandler = Lt(Hw), this.zoneIsStable = Lt(Dw), this.componentTypes = [], this.components = [], this.isStable = Lt(yw).hasPendingTasks.pipe((0, re.w)(o => o ? (0, Se.of)(!1) : this.zoneIsStable), (0, Ie.x)(), (0, ke.B)()), this._injector = Lt(Wl) } get destroyed() { return this._destroyed } get injector() { return this._injector } bootstrap(o, l) { const d = o instanceof Sg; if (!this._injector.get(Xb).done) throw !d && ii(o), new ie(405, !1); let E; E = d ? o : this._injector.get(gc).resolveComponentFactory(o), this.componentTypes.push(E.componentType); const A = function KC(n) { return n.isBoundToModule }(E) ? void 0 : this._injector.get(Tf), q = E.create(yc.NULL, [], l || E.selector, A), we = q.location.nativeElement, Ge = q.injector.get(Mw, null); return Ge?.registerApplication(we), q.onDestroy(() => { this.detachView(q.hostView), X_(this.components, q), Ge?.unregisterApplication(we) }), this._loadComponent(q), q } tick() { if (this._runningTick) throw new ie(101, !1); try { this._runningTick = !0; for (let o of this._views) o.detectChanges() } catch (o) { this.internalErrorHandler(o) } finally { this._runningTick = !1 } } attachView(o) { const l = o; this._views.push(l), l.attachToAppRef(this) } detachView(o) { const l = o; X_(this._views, l), l.detachFromAppRef() } _loadComponent(o) { this.attachView(o.hostView), this.tick(), this.components.push(o); const l = this._injector.get(iy, []); l.push(...this._bootstrapListeners), l.forEach(d => d(o)) } ngOnDestroy() { if (!this._destroyed) try { this._destroyListeners.forEach(o => o()), this._views.slice().forEach(o => o.destroy()) } finally { this._destroyed = !0, this._views = [], this._bootstrapListeners = [], this._destroyListeners = [] } } onDestroy(o) { return this._destroyListeners.push(o), () => X_(this._destroyListeners, o) } destroy() { if (this._destroyed) throw new ie(406, !1); const o = this._injector; o.destroy && !o.destroyed && o.destroy() } get viewCount() { return this._views.length } warnIfDestroyed() { } } return n.\u0275fac = function (o) { return new (o || n) }, n.\u0275prov = Ae({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); function X_(n, i) { const o = n.indexOf(i); o > -1 && n.splice(o, 1) } const Hw = new Cr("", { providedIn: "root", factory: () => Lt(Sl).handleError.bind(void 0) }); function JC() { const n = Lt(Wa), i = Lt(Sl); return o => n.runOutsideAngular(() => i.handleError(o)) } let eI = (() => { class n { constructor() { this.zone = Lt(Wa), this.applicationRef = Lt(Af) } initialize() { this._onMicrotaskEmptySubscription || (this._onMicrotaskEmptySubscription = this.zone.onMicrotaskEmpty.subscribe({ next: () => { this.zone.run(() => { this.applicationRef.tick() }) } })) } ngOnDestroy() { this._onMicrotaskEmptySubscription?.unsubscribe() } } return n.\u0275fac = function (o) { return new (o || n) }, n.\u0275prov = Ae({ token: n, factory: n.\u0275fac, providedIn: "root" }), n })(); function nI() { return !1 } let iI = (() => { class n { } return n.__NG_ELEMENT_ID__ = rI, n })(); function rI(n) { return function oI(n, i, o) { if (dr(n) && !o) { const l = $t(n.index, i); return new Ec(l, l) } return 47 & n.type ? new Ec(i[cr], i) : null }(xo(), vn(), 16 == (16 & n)) } class Ww { constructor() { } supports(i) { return Gu(i) } create(i) { return new uI(i) } } const dI = (n, i) => i; class uI { constructor(i) { this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = i || dI } forEachItem(i) { let o; for (o = this._itHead; null !== o; o = o._next)i(o) } forEachOperation(i) { let o = this._itHead, l = this._removalsHead, d = 0, p = null; for (; o || l;) { const E = !l || o && o.currentIndex < Zw(l, d, p) ? o : l, A = Zw(E, d, p), N = E.currentIndex; if (E === l) d--, l = l._nextRemoved; else if (o = o._next, null == E.previousIndex) d++; else { p || (p = []); const q = A - d, we = N - d; if (q != we) { for (let Dt = 0; Dt < q; Dt++) { const Bt = Dt < p.length ? p[Dt] : p[Dt] = 0, hn = Bt + Dt; we <= hn && hn < q && (p[Dt] = Bt + 1) } p[E.previousIndex] = we - q } } A !== N && i(E, A, N) } } forEachPreviousItem(i) { let o; for (o = this._previousItHead; null !== o; o = o._nextPrevious)i(o) } forEachAddedItem(i) { let o; for (o = this._additionsHead; null !== o; o = o._nextAdded)i(o) } forEachMovedItem(i) { let o; for (o = this._movesHead; null !== o; o = o._nextMoved)i(o) } forEachRemovedItem(i) { let o; for (o = this._removalsHead; null !== o; o = o._nextRemoved)i(o) } forEachIdentityChange(i) { let o; for (o = this._identityChangesHead; null !== o; o = o._nextIdentityChange)i(o) } diff(i) { if (null == i && (i = []), !Gu(i)) throw new ie(900, !1); return this.check(i) ? this : null } onDestroy() { } check(i) { this._reset(); let d, p, E, o = this._itHead, l = !1; if (Array.isArray(i)) { this.length = i.length; for (let A = 0; A < this.length; A++)p = i[A], E = this._trackByFn(A, p), null !== o && Object.is(o.trackById, E) ? (l && (o = this._verifyReinsertion(o, p, E, A)), Object.is(o.item, p) || this._addIdentityChange(o, p)) : (o = this._mismatch(o, p, E, A), l = !0), o = o._next } else d = 0, function Wu(n, i) { if (Array.isArray(n)) for (let o = 0; o < n.length; o++)i(n[o]); else { const o = n[Symbol.iterator](); let l; for (; !(l = o.next()).done;)i(l.value) } }(i, A => { E = this._trackByFn(d, A), null !== o && Object.is(o.trackById, E) ? (l && (o = this._verifyReinsertion(o, A, E, d)), Object.is(o.item, A) || this._addIdentityChange(o, A)) : (o = this._mismatch(o, A, E, d), l = !0), o = o._next, d++ }), this.length = d; return this._truncate(o), this.collection = i, this.isDirty } get isDirty() { return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead } _reset() { if (this.isDirty) { let i; for (i = this._previousItHead = this._itHead; null !== i; i = i._next)i._nextPrevious = i._next; for (i = this._additionsHead; null !== i; i = i._nextAdded)i.previousIndex = i.currentIndex; for (this._additionsHead = this._additionsTail = null, i = this._movesHead; null !== i; i = i._nextMoved)i.previousIndex = i.currentIndex; this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null } } _mismatch(i, o, l, d) { let p; return null === i ? p = this._itTail : (p = i._prev, this._remove(i)), null !== (i = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(l, null)) ? (Object.is(i.item, o) || this._addIdentityChange(i, o), this._reinsertAfter(i, p, d)) : null !== (i = null === this._linkedRecords ? null : this._linkedRecords.get(l, d)) ? (Object.is(i.item, o) || this._addIdentityChange(i, o), this._moveAfter(i, p, d)) : i = this._addAfter(new hI(o, l), p, d), i } _verifyReinsertion(i, o, l, d) { let p = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(l, null); return null !== p ? i = this._reinsertAfter(p, i._prev, d) : i.currentIndex != d && (i.currentIndex = d, this._addToMoves(i, d)), i } _truncate(i) { for (; null !== i;) { const o = i._next; this._addToRemovals(this._unlink(i)), i = o } null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null) } _reinsertAfter(i, o, l) { null !== this._unlinkedRecords && this._unlinkedRecords.remove(i); const d = i._prevRemoved, p = i._nextRemoved; return null === d ? this._removalsHead = p : d._nextRemoved = p, null === p ? this._removalsTail = d : p._prevRemoved = d, this._insertAfter(i, o, l), this._addToMoves(i, l), i } _moveAfter(i, o, l) { return this._unlink(i), this._insertAfter(i, o, l), this._addToMoves(i, l), i } _addAfter(i, o, l) { return this._insertAfter(i, o, l), this._additionsTail = null === this._additionsTail ? this._additionsHead = i : this._additionsTail._nextAdded = i, i } _insertAfter(i, o, l) { const d = null === o ? this._itHead : o._next; return i._next = d, i._prev = o, null === d ? this._itTail = i : d._prev = i, null === o ? this._itHead = i : o._next = i, null === this._linkedRecords && (this._linkedRecords = new Kw), this._linkedRecords.put(i), i.currentIndex = l, i } _remove(i) { return this._addToRemovals(this._unlink(i)) } _unlink(i) { null !== this._linkedRecords && this._linkedRecords.remove(i); const o = i._prev, l = i._next; return null === o ? this._itHead = l : o._next = l, null === l ? this._itTail = o : l._prev = o, i } _addToMoves(i, o) { return i.previousIndex === o || (this._movesTail = null === this._movesTail ? this._movesHead = i : this._movesTail._nextMoved = i), i } _addToRemovals(i) { return null === this._unlinkedRecords && (this._unlinkedRecords = new Kw), this._unlinkedRecords.put(i), i.currentIndex = null, i._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = i, i._prevRemoved = null) : (i._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = i), i } _addIdentityChange(i, o) { return i.item = o, this._identityChangesTail = null === this._identityChangesTail ? this._identityChangesHead = i : this._identityChangesTail._nextIdentityChange = i, i } } class hI { constructor(i, o) { this.item = i, this.trackById = o, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null } } class fI { constructor() { this._head = null, this._tail = null } add(i) { null === this._head ? (this._head = this._tail = i, i._nextDup = null, i._prevDup = null) : (this._tail._nextDup = i, i._prevDup = this._tail, i._nextDup = null, this._tail = i) } get(i, o) { let l; for (l = this._head; null !== l; l = l._nextDup)if ((null === o || o <= l.currentIndex) && Object.is(l.trackById, i)) return l; return null } remove(i) { const o = i._prevDup, l = i._nextDup; return null === o ? this._head = l : o._nextDup = l, null === l ? this._tail = o : l._prevDup = o, null === this._head } } class Kw { constructor() { this.map = new Map } put(i) { const o = i.trackById; let l = this.map.get(o); l || (l = new fI, this.map.set(o, l)), l.add(i) } get(i, o) { const d = this.map.get(i); return d ? d.get(i, o) : null } remove(i) { const o = i.trackById; return this.map.get(o).remove(i) && this.map.delete(o), i } get isEmpty() { return 0 === this.map.size } clear() { this.map.clear() } } function Zw(n, i, o) { const l = n.previousIndex; if (null === l) return l; let d = 0; return o && l < o.length && (d = o[l]), l + i + d } class Yw { constructor() { } supports(i) { return i instanceof Map || ff(i) } create() { return new mI } } class mI { constructor() { this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null } get isDirty() { return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead } forEachItem(i) { let o; for (o = this._mapHead; null !== o; o = o._next)i(o) } forEachPreviousItem(i) { let o; for (o = this._previousMapHead; null !== o; o = o._nextPrevious)i(o) } forEachChangedItem(i) { let o; for (o = this._changesHead; null !== o; o = o._nextChanged)i(o) } forEachAddedItem(i) { let o; for (o = this._additionsHead; null !== o; o = o._nextAdded)i(o) } forEachRemovedItem(i) { let o; for (o = this._removalsHead; null !== o; o = o._nextRemoved)i(o) } diff(i) { if (i) { if (!(i instanceof Map || ff(i))) throw new ie(900, !1) } else i = new Map; return this.check(i) ? this : null } onDestroy() { } check(i) { this._reset(); let o = this._mapHead; if (this._appendAfter = null, this._forEach(i, (l, d) => { if (o && o.key === d) this._maybeAddToChanges(o, l), this._appendAfter = o, o = o._next; else { const p = this._getOrCreateRecordForKey(d, l); o = this._insertBeforeOrAppend(o, p) } }), o) { o._prev && (o._prev._next = null), this._removalsHead = o; for (let l = o; null !== l; l = l._nextRemoved)l === this._mapHead && (this._mapHead = null), this._records.delete(l.key), l._nextRemoved = l._next, l.previousValue = l.currentValue, l.currentValue = null, l._prev = null, l._next = null } return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty } _insertBeforeOrAppend(i, o) { if (i) { const l = i._prev; return o._next = i, o._prev = l, i._prev = o, l && (l._next = o), i === this._mapHead && (this._mapHead = o), this._appendAfter = i, i } return this._appendAfter ? (this._appendAfter._next = o, o._prev = this._appendAfter) : this._mapHead = o, this._appendAfter = o, null } _getOrCreateRecordForKey(i, o) { if (this._records.has(i)) { const d = this._records.get(i); this._maybeAddToChanges(d, o); const p = d._prev, E = d._next; return p && (p._next = E), E && (E._prev = p), d._next = null, d._prev = null, d } const l = new pI(i); return this._records.set(i, l), l.currentValue = o, this._addToAdditions(l), l } _reset() { if (this.isDirty) { let i; for (this._previousMapHead = this._mapHead, i = this._previousMapHead; null !== i; i = i._next)i._nextPrevious = i._next; for (i = this._changesHead; null !== i; i = i._nextChanged)i.previousValue = i.currentValue; for (i = this._additionsHead; null != i; i = i._nextAdded)i.previousValue = i.currentValue; this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null } } _maybeAddToChanges(i, o) { Object.is(o, i.currentValue) || (i.previousValue = i.currentValue, i.currentValue = o, this._addToChanges(i)) } _addToAdditions(i) { null === this._additionsHead ? this._additionsHead = this._additionsTail = i : (this._additionsTail._nextAdded = i, this._additionsTail = i) } _addToChanges(i) { null === this._changesHead ? this._changesHead = this._changesTail = i : (this._changesTail._nextChanged = i, this._changesTail = i) } _forEach(i, o) { i instanceof Map ? i.forEach(o) : Object.keys(i).forEach(l => o(i[l], l)) } } class pI { constructor(i) { this.key = i, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null } } function qw() { return new cy([new Ww]) } let cy = (() => { class n { constructor(o) { this.factories = o } static create(o, l) { if (null != l) { const d = l.factories.slice(); o = o.concat(d) } return new n(o) } static extend(o) { return { provide: n, useFactory: l => n.create(o, l || qw()), deps: [[n, new nc, new tc]] } } find(o) { const l = this.factories.find(d => d.supports(o)); if (null != l) return l; throw new ie(901, !1) } } return n.\u0275prov = Ae({ token: n, providedIn: "root", factory: qw }), n })(); function Qw() { return new dy([new Yw]) } let dy = (() => { class n { constructor(o) { this.factories = o } static create(o, l) { if (l) { const d = l.factories.slice(); o = o.concat(d) } return new n(o) } static extend(o) { return { provide: n, useFactory: l => n.create(o, l || Qw()), deps: [[n, new nc, new tc]] } } find(o) { const l = this.factories.find(d => d.supports(o)); if (l) return l; throw new ie(901, !1) } } return n.\u0275prov = Ae({ token: n, providedIn: "root", factory: Qw }), n })(); const vI = Pw(null, "core", []); let bI = (() => { class n { constructor(o) { } } return n.\u0275fac = function (o) { return new (o || n)(de(Af)) }, n.\u0275mod = dt({ type: n }), n.\u0275inj = qt({}), n })(); function MI(n) { return "boolean" == typeof n ? n : null != n && "false" !== n } function AI(n) { const i = At(n); if (!i) return null; const o = new od(i); return { get selector() { return o.selector }, get type() { return o.componentType }, get inputs() { return o.inputs }, get outputs() { return o.outputs }, get ngContentSelectors() { return o.ngContentSelectors }, get isStandalone() { return i.standalone }, get isSignal() { return i.signals } } } }, 6223: (nn, Qe, C) => { C.d(Qe, { Cf: () => Ve, F: () => Vi, Fj: () => Oe, JJ: () => Nt, JL: () => on, JU: () => re, NI: () => Jo, On: () => At, Q7: () => Ki, UX: () => jo, _Y: () => cn, a5: () => qt, cw: () => ae, kI: () => ut, sg: () => Lr, u: () => vs, u5: () => Ks, wO: () => dr, wV: () => ii }); var a = C(5879), y = C(6814), v = C(2459), Y = C(9315), he = C(7398); let Se = (() => { class K { constructor(w, D) { this._renderer = w, this._elementRef = D, this.onChange = ne => { }, this.onTouched = () => { } } setProperty(w, D) { this._renderer.setProperty(this._elementRef.nativeElement, w, D) } registerOnTouched(w) { this.onTouched = w } registerOnChange(w) { this.onChange = w } setDisabledState(w) { this.setProperty("disabled", w) } } return K.\u0275fac = function (w) { return new (w || K)(a.Y36(a.Qsj), a.Y36(a.SBq)) }, K.\u0275dir = a.lG2({ type: K }), K })(), ke = (() => { class K extends Se { } return K.\u0275fac = function () { let V; return function (D) { return (V || (V = a.n5z(K)))(D || K) } }(), K.\u0275dir = a.lG2({ type: K, features: [a.qOj] }), K })(); const re = new a.OlP("NgValueAccessor"), _e = { provide: re, useExisting: (0, a.Gpc)(() => Oe), multi: !0 }, ze = new a.OlP("CompositionEventMode"); let Oe = (() => { class K extends Se { constructor(w, D, ne) { super(w, D), this._compositionMode = ne, this._composing = !1, null == this._compositionMode && (this._compositionMode = !function xe() { const K = (0, y.q)() ? (0, y.q)().getUserAgent() : ""; return /android (\d+)/.test(K.toLowerCase()) }()) } writeValue(w) { this.setProperty("value", w ?? "") } _handleInput(w) { (!this._compositionMode || this._compositionMode && !this._composing) && this.onChange(w) } _compositionStart() { this._composing = !0 } _compositionEnd(w) { this._composing = !1, this._compositionMode && this.onChange(w) } } return K.\u0275fac = function (w) { return new (w || K)(a.Y36(a.Qsj), a.Y36(a.SBq), a.Y36(ze, 8)) }, K.\u0275dir = a.lG2({ type: K, selectors: [["input", "formControlName", "", 3, "type", "checkbox"], ["textarea", "formControlName", ""], ["input", "formControl", "", 3, "type", "checkbox"], ["textarea", "formControl", ""], ["input", "ngModel", "", 3, "type", "checkbox"], ["textarea", "ngModel", ""], ["", "ngDefaultControl", ""]], hostBindings: function (w, D) { 1 & w && a.NdJ("input", function (Re) { return D._handleInput(Re.target.value) })("blur", function () { return D.onTouched() })("compositionstart", function () { return D._compositionStart() })("compositionend", function (Re) { return D._compositionEnd(Re.target.value) }) }, features: [a._Bn([_e]), a.qOj] }), K })(); function We(K) { return null == K || ("string" == typeof K || Array.isArray(K)) && 0 === K.length } function Pe(K) { return null != K && "number" == typeof K.length } const Ve = new a.OlP("NgValidators"), tt = new a.OlP("NgAsyncValidators"), Ye = /^(?=.{1,254}$)(?=.{1,64}@)[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-zA-Z0-9!#$%&'*+/=?^_`{|}~-]+)*@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/; class ut { static min(V) { return function ie(K) { return V => { if (We(V.value) || We(K)) return null; const w = parseFloat(V.value); return !isNaN(w) && w < K ? { min: { min: K, actual: V.value } } : null } }(V) } static max(V) { return function Le(K) { return V => { if (We(V.value) || We(K)) return null; const w = parseFloat(V.value); return !isNaN(w) && w > K ? { max: { max: K, actual: V.value } } : null } }(V) } static required(V) { return le(V) } static requiredTrue(V) { return function ge(K) { return !0 === K.value ? null : { required: !0 } }(V) } static email(V) { return function ue(K) { return We(K.value) || Ye.test(K.value) ? null : { email: !0 } }(V) } static minLength(V) { return ee(V) } static maxLength(V) { return function $e(K) { return V => Pe(V.value) && V.value.length > K ? { maxlength: { requiredLength: K, actualLength: V.value.length } } : null }(V) } static pattern(V) { return function rt(K) { if (!K) return Kt; let V, w; return "string" == typeof K ? (w = "", "^" !== K.charAt(0) && (w += "^"), w += K, "$" !== K.charAt(K.length - 1) && (w += "$"), V = new RegExp(w)) : (w = K.toString(), V = K), D => { if (We(D.value)) return null; const ne = D.value; return V.test(ne) ? null : { pattern: { requiredPattern: w, actualValue: ne } } } }(V) } static nullValidator(V) { return null } static compose(V) { return at(V) } static composeAsync(V) { return xt(V) } } function le(K) { return We(K.value) ? { required: !0 } : null } function ee(K) { return V => We(V.value) || !Pe(V.value) ? null : V.value.length < K ? { minlength: { requiredLength: K, actualLength: V.value.length } } : null } function Kt(K) { return null } function bn(K) { return null != K } function Dn(K) { return (0, a.QGY)(K) ? (0, v.D)(K) : K } function Mn(K) { let V = {}; return K.forEach(w => { V = null != w ? { ...V, ...w } : V }), 0 === Object.keys(V).length ? null : V } function On(K, V) { return V.map(w => w(K)) } function Hn(K) { return K.map(V => function Wn(K) { return !K.validate }(V) ? V : w => V.validate(w)) } function at(K) { if (!K) return null; const V = K.filter(bn); return 0 == V.length ? null : function (w) { return Mn(On(w, V)) } } function vt(K) { return null != K ? at(Hn(K)) : null } function xt(K) { if (!K) return null; const V = K.filter(bn); return 0 == V.length ? null : function (w) { const D = On(w, V).map(Dn); return (0, Y.D)(D).pipe((0, he.U)(Mn)) } } function it(K) { return null != K ? xt(Hn(K)) : null } function Ft(K, V) { return null === K ? [V] : Array.isArray(K) ? [...K, V] : [K, V] } function Wt(K) { return K._rawValidators } function rn(K) { return K._rawAsyncValidators } function Jt(K) { return K ? Array.isArray(K) ? K : [K] : [] } function tn(K, V) { return Array.isArray(K) ? K.includes(V) : K === V } function St(K, V) { const w = Jt(V); return Jt(K).forEach(ne => { tn(w, ne) || w.push(ne) }), w } function ht(K, V) { return Jt(V).filter(w => !tn(K, w)) } class Ae { constructor() { this._rawValidators = [], this._rawAsyncValidators = [], this._onDestroyCallbacks = [] } get value() { return this.control ? this.control.value : null } get valid() { return this.control ? this.control.valid : null } get invalid() { return this.control ? this.control.invalid : null } get pending() { return this.control ? this.control.pending : null } get disabled() { return this.control ? this.control.disabled : null } get enabled() { return this.control ? this.control.enabled : null } get errors() { return this.control ? this.control.errors : null } get pristine() { return this.control ? this.control.pristine : null } get dirty() { return this.control ? this.control.dirty : null } get touched() { return this.control ? this.control.touched : null } get status() { return this.control ? this.control.status : null } get untouched() { return this.control ? this.control.untouched : null } get statusChanges() { return this.control ? this.control.statusChanges : null } get valueChanges() { return this.control ? this.control.valueChanges : null } get path() { return null } _setValidators(V) { this._rawValidators = V || [], this._composedValidatorFn = vt(this._rawValidators) } _setAsyncValidators(V) { this._rawAsyncValidators = V || [], this._composedAsyncValidatorFn = it(this._rawAsyncValidators) } get validator() { return this._composedValidatorFn || null } get asyncValidator() { return this._composedAsyncValidatorFn || null } _registerOnDestroy(V) { this._onDestroyCallbacks.push(V) } _invokeOnDestroyCallbacks() { this._onDestroyCallbacks.forEach(V => V()), this._onDestroyCallbacks = [] } reset(V = void 0) { this.control && this.control.reset(V) } hasError(V, w) { return !!this.control && this.control.hasError(V, w) } getError(V, w) { return this.control ? this.control.getError(V, w) : null } } class nt extends Ae { get formDirective() { return null } get path() { return null } } class qt extends Ae { constructor() { super(...arguments), this._parent = null, this.name = null, this.valueAccessor = null } } class jt { constructor(V) { this._cd = V } get isTouched() { return !!this._cd?.control?.touched } get isUntouched() { return !!this._cd?.control?.untouched } get isPristine() { return !!this._cd?.control?.pristine } get isDirty() { return !!this._cd?.control?.dirty } get isValid() { return !!this._cd?.control?.valid } get isInvalid() { return !!this._cd?.control?.invalid } get isPending() { return !!this._cd?.control?.pending } get isSubmitted() { return !!this._cd?.submitted } } let Nt = (() => { class K extends jt { constructor(w) { super(w) } } return K.\u0275fac = function (w) { return new (w || K)(a.Y36(qt, 2)) }, K.\u0275dir = a.lG2({ type: K, selectors: [["", "formControlName", ""], ["", "ngModel", ""], ["", "formControl", ""]], hostVars: 14, hostBindings: function (w, D) { 2 & w && a.ekj("ng-untouched", D.isUntouched)("ng-touched", D.isTouched)("ng-pristine", D.isPristine)("ng-dirty", D.isDirty)("ng-valid", D.isValid)("ng-invalid", D.isInvalid)("ng-pending", D.isPending) }, features: [a.qOj] }), K })(), on = (() => { class K extends jt { constructor(w) { super(w) } } return K.\u0275fac = function (w) { return new (w || K)(a.Y36(nt, 10)) }, K.\u0275dir = a.lG2({ type: K, selectors: [["", "formGroupName", ""], ["", "formArrayName", ""], ["", "ngModelGroup", ""], ["", "formGroup", ""], ["form", 3, "ngNoForm", ""], ["", "ngForm", ""]], hostVars: 16, hostBindings: function (w, D) { 2 & w && a.ekj("ng-untouched", D.isUntouched)("ng-touched", D.isTouched)("ng-pristine", D.isPristine)("ng-dirty", D.isDirty)("ng-valid", D.isValid)("ng-invalid", D.isInvalid)("ng-pending", D.isPending)("ng-submitted", D.isSubmitted) }, features: [a.qOj] }), K })(); const En = "VALID", Ln = "INVALID", In = "PENDING", Et = "DISABLED"; function _t(K) { return (de(K) ? K.validators : K) || null } function W(K, V) { return (de(V) ? V.asyncValidators : K) || null } function de(K) { return null != K && !Array.isArray(K) && "object" == typeof K } class He { constructor(V, w) { this._pendingDirty = !1, this._hasOwnPendingAsyncValidator = !1, this._pendingTouched = !1, this._onCollectionChange = () => { }, this._parent = null, this.pristine = !0, this.touched = !1, this._onDisabledChange = [], this._assignValidators(V), this._assignAsyncValidators(w) } get validator() { return this._composedValidatorFn } set validator(V) { this._rawValidators = this._composedValidatorFn = V } get asyncValidator() { return this._composedAsyncValidatorFn } set asyncValidator(V) { this._rawAsyncValidators = this._composedAsyncValidatorFn = V } get parent() { return this._parent } get valid() { return this.status === En } get invalid() { return this.status === Ln } get pending() { return this.status == In } get disabled() { return this.status === Et } get enabled() { return this.status !== Et } get dirty() { return !this.pristine } get untouched() { return !this.touched } get updateOn() { return this._updateOn ? this._updateOn : this.parent ? this.parent.updateOn : "change" } setValidators(V) { this._assignValidators(V) } setAsyncValidators(V) { this._assignAsyncValidators(V) } addValidators(V) { this.setValidators(St(V, this._rawValidators)) } addAsyncValidators(V) { this.setAsyncValidators(St(V, this._rawAsyncValidators)) } removeValidators(V) { this.setValidators(ht(V, this._rawValidators)) } removeAsyncValidators(V) { this.setAsyncValidators(ht(V, this._rawAsyncValidators)) } hasValidator(V) { return tn(this._rawValidators, V) } hasAsyncValidator(V) { return tn(this._rawAsyncValidators, V) } clearValidators() { this.validator = null } clearAsyncValidators() { this.asyncValidator = null } markAsTouched(V = {}) { this.touched = !0, this._parent && !V.onlySelf && this._parent.markAsTouched(V) } markAllAsTouched() { this.markAsTouched({ onlySelf: !0 }), this._forEachChild(V => V.markAllAsTouched()) } markAsUntouched(V = {}) { this.touched = !1, this._pendingTouched = !1, this._forEachChild(w => { w.markAsUntouched({ onlySelf: !0 }) }), this._parent && !V.onlySelf && this._parent._updateTouched(V) } markAsDirty(V = {}) { this.pristine = !1, this._parent && !V.onlySelf && this._parent.markAsDirty(V) } markAsPristine(V = {}) { this.pristine = !0, this._pendingDirty = !1, this._forEachChild(w => { w.markAsPristine({ onlySelf: !0 }) }), this._parent && !V.onlySelf && this._parent._updatePristine(V) } markAsPending(V = {}) { this.status = In, !1 !== V.emitEvent && this.statusChanges.emit(this.status), this._parent && !V.onlySelf && this._parent.markAsPending(V) } disable(V = {}) { const w = this._parentMarkedDirty(V.onlySelf); this.status = Et, this.errors = null, this._forEachChild(D => { D.disable({ ...V, onlySelf: !0 }) }), this._updateValue(), !1 !== V.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._updateAncestors({ ...V, skipPristineCheck: w }), this._onDisabledChange.forEach(D => D(!0)) } enable(V = {}) { const w = this._parentMarkedDirty(V.onlySelf); this.status = En, this._forEachChild(D => { D.enable({ ...V, onlySelf: !0 }) }), this.updateValueAndValidity({ onlySelf: !0, emitEvent: V.emitEvent }), this._updateAncestors({ ...V, skipPristineCheck: w }), this._onDisabledChange.forEach(D => D(!1)) } _updateAncestors(V) { this._parent && !V.onlySelf && (this._parent.updateValueAndValidity(V), V.skipPristineCheck || this._parent._updatePristine(), this._parent._updateTouched()) } setParent(V) { this._parent = V } getRawValue() { return this.value } updateValueAndValidity(V = {}) { this._setInitialStatus(), this._updateValue(), this.enabled && (this._cancelExistingSubscription(), this.errors = this._runValidator(), this.status = this._calculateStatus(), (this.status === En || this.status === In) && this._runAsyncValidator(V.emitEvent)), !1 !== V.emitEvent && (this.valueChanges.emit(this.value), this.statusChanges.emit(this.status)), this._parent && !V.onlySelf && this._parent.updateValueAndValidity(V) } _updateTreeValidity(V = { emitEvent: !0 }) { this._forEachChild(w => w._updateTreeValidity(V)), this.updateValueAndValidity({ onlySelf: !0, emitEvent: V.emitEvent }) } _setInitialStatus() { this.status = this._allControlsDisabled() ? Et : En } _runValidator() { return this.validator ? this.validator(this) : null } _runAsyncValidator(V) { if (this.asyncValidator) { this.status = In, this._hasOwnPendingAsyncValidator = !0; const w = Dn(this.asyncValidator(this)); this._asyncValidationSubscription = w.subscribe(D => { this._hasOwnPendingAsyncValidator = !1, this.setErrors(D, { emitEvent: V }) }) } } _cancelExistingSubscription() { this._asyncValidationSubscription && (this._asyncValidationSubscription.unsubscribe(), this._hasOwnPendingAsyncValidator = !1) } setErrors(V, w = {}) { this.errors = V, this._updateControlsErrors(!1 !== w.emitEvent) } get(V) { let w = V; return null == w || (Array.isArray(w) || (w = w.split(".")), 0 === w.length) ? null : w.reduce((D, ne) => D && D._find(ne), this) } getError(V, w) { const D = w ? this.get(w) : this; return D && D.errors ? D.errors[V] : null } hasError(V, w) { return !!this.getError(V, w) } get root() { let V = this; for (; V._parent;)V = V._parent; return V } _updateControlsErrors(V) { this.status = this._calculateStatus(), V && this.statusChanges.emit(this.status), this._parent && this._parent._updateControlsErrors(V) } _initObservables() { this.valueChanges = new a.vpe, this.statusChanges = new a.vpe } _calculateStatus() { return this._allControlsDisabled() ? Et : this.errors ? Ln : this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(In) ? In : this._anyControlsHaveStatus(Ln) ? Ln : En } _anyControlsHaveStatus(V) { return this._anyControls(w => w.status === V) } _anyControlsDirty() { return this._anyControls(V => V.dirty) } _anyControlsTouched() { return this._anyControls(V => V.touched) } _updatePristine(V = {}) { this.pristine = !this._anyControlsDirty(), this._parent && !V.onlySelf && this._parent._updatePristine(V) } _updateTouched(V = {}) { this.touched = this._anyControlsTouched(), this._parent && !V.onlySelf && this._parent._updateTouched(V) } _registerOnCollectionChange(V) { this._onCollectionChange = V } _setUpdateStrategy(V) { de(V) && null != V.updateOn && (this._updateOn = V.updateOn) } _parentMarkedDirty(V) { return !V && !(!this._parent || !this._parent.dirty) && !this._parent._anyControlsDirty() } _find(V) { return null } _assignValidators(V) { this._rawValidators = Array.isArray(V) ? V.slice() : V, this._composedValidatorFn = function G(K) { return Array.isArray(K) ? vt(K) : K || null }(this._rawValidators) } _assignAsyncValidators(V) { this._rawAsyncValidators = Array.isArray(V) ? V.slice() : V, this._composedAsyncValidatorFn = function me(K) { return Array.isArray(K) ? it(K) : K || null }(this._rawAsyncValidators) } } class ae extends He { constructor(V, w, D) { super(_t(w), W(D, w)), this.controls = V, this._initObservables(), this._setUpdateStrategy(w), this._setUpControls(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }) } registerControl(V, w) { return this.controls[V] ? this.controls[V] : (this.controls[V] = w, w.setParent(this), w._registerOnCollectionChange(this._onCollectionChange), w) } addControl(V, w, D = {}) { this.registerControl(V, w), this.updateValueAndValidity({ emitEvent: D.emitEvent }), this._onCollectionChange() } removeControl(V, w = {}) { this.controls[V] && this.controls[V]._registerOnCollectionChange(() => { }), delete this.controls[V], this.updateValueAndValidity({ emitEvent: w.emitEvent }), this._onCollectionChange() } setControl(V, w, D = {}) { this.controls[V] && this.controls[V]._registerOnCollectionChange(() => { }), delete this.controls[V], w && this.registerControl(V, w), this.updateValueAndValidity({ emitEvent: D.emitEvent }), this._onCollectionChange() } contains(V) { return this.controls.hasOwnProperty(V) && this.controls[V].enabled } setValue(V, w = {}) { (function Lt(K, V, w) { K._forEachChild((D, ne) => { if (void 0 === w[ne]) throw new a.vHH(1002, "") }) })(this, 0, V), Object.keys(V).forEach(D => { (function st(K, V, w) { const D = K.controls; if (!(V ? Object.keys(D) : D).length) throw new a.vHH(1e3, ""); if (!D[w]) throw new a.vHH(1001, "") })(this, !0, D), this.controls[D].setValue(V[D], { onlySelf: !0, emitEvent: w.emitEvent }) }), this.updateValueAndValidity(w) } patchValue(V, w = {}) { null != V && (Object.keys(V).forEach(D => { const ne = this.controls[D]; ne && ne.patchValue(V[D], { onlySelf: !0, emitEvent: w.emitEvent }) }), this.updateValueAndValidity(w)) } reset(V = {}, w = {}) { this._forEachChild((D, ne) => { D.reset(V[ne], { onlySelf: !0, emitEvent: w.emitEvent }) }), this._updatePristine(w), this._updateTouched(w), this.updateValueAndValidity(w) } getRawValue() { return this._reduceChildren({}, (V, w, D) => (V[D] = w.getRawValue(), V)) } _syncPendingControls() { let V = this._reduceChildren(!1, (w, D) => !!D._syncPendingControls() || w); return V && this.updateValueAndValidity({ onlySelf: !0 }), V } _forEachChild(V) { Object.keys(this.controls).forEach(w => { const D = this.controls[w]; D && V(D, w) }) } _setUpControls() { this._forEachChild(V => { V.setParent(this), V._registerOnCollectionChange(this._onCollectionChange) }) } _updateValue() { this.value = this._reduceValue() } _anyControls(V) { for (const [w, D] of Object.entries(this.controls)) if (this.contains(w) && V(D)) return !0; return !1 } _reduceValue() { return this._reduceChildren({}, (w, D, ne) => ((D.enabled || this.disabled) && (w[ne] = D.value), w)) } _reduceChildren(V, w) { let D = V; return this._forEachChild((ne, Re) => { D = w(D, ne, Re) }), D } _allControlsDisabled() { for (const V of Object.keys(this.controls)) if (this.controls[V].enabled) return !1; return Object.keys(this.controls).length > 0 || this.disabled } _find(V) { return this.controls.hasOwnProperty(V) ? this.controls[V] : null } } const pt = new a.OlP("CallSetDisabledState", { providedIn: "root", factory: () => pe }), pe = "always"; function fe(K, V) { return [...V.path, K] } function F(K, V, w = pe) { gt(K, V), V.valueAccessor.writeValue(K.value), (K.disabled || "always" === w) && V.valueAccessor.setDisabledState?.(K.disabled), function un(K, V) { V.valueAccessor.registerOnChange(w => { K._pendingValue = w, K._pendingChange = !0, K._pendingDirty = !0, "change" === K.updateOn && It(K, V) }) }(K, V), function dn(K, V) { const w = (D, ne) => { V.valueAccessor.writeValue(D), ne && V.viewToModelUpdate(D) }; K.registerOnChange(w), V._registerOnDestroy(() => { K._unregisterOnChange(w) }) }(K, V), function yt(K, V) { V.valueAccessor.registerOnTouched(() => { K._pendingTouched = !0, "blur" === K.updateOn && K._pendingChange && It(K, V), "submit" !== K.updateOn && K.markAsTouched() }) }(K, V), function lt(K, V) { if (V.valueAccessor.setDisabledState) { const w = D => { V.valueAccessor.setDisabledState(D) }; K.registerOnDisabledChange(w), V._registerOnDestroy(() => { K._unregisterOnDisabledChange(w) }) } }(K, V) } function J(K, V, w = !0) { const D = () => { }; V.valueAccessor && (V.valueAccessor.registerOnChange(D), V.valueAccessor.registerOnTouched(D)), Ht(K, V), K && (V._invokeOnDestroyCallbacks(), K._registerOnCollectionChange(() => { })) } function Te(K, V) { K.forEach(w => { w.registerOnValidatorChange && w.registerOnValidatorChange(V) }) } function gt(K, V) { const w = Wt(K); null !== V.validator ? K.setValidators(Ft(w, V.validator)) : "function" == typeof w && K.setValidators([w]); const D = rn(K); null !== V.asyncValidator ? K.setAsyncValidators(Ft(D, V.asyncValidator)) : "function" == typeof D && K.setAsyncValidators([D]); const ne = () => K.updateValueAndValidity(); Te(V._rawValidators, ne), Te(V._rawAsyncValidators, ne) } function Ht(K, V) { let w = !1; if (null !== K) { if (null !== V.validator) { const ne = Wt(K); if (Array.isArray(ne) && ne.length > 0) { const Re = ne.filter(mt => mt !== V.validator); Re.length !== ne.length && (w = !0, K.setValidators(Re)) } } if (null !== V.asyncValidator) { const ne = rn(K); if (Array.isArray(ne) && ne.length > 0) { const Re = ne.filter(mt => mt !== V.asyncValidator); Re.length !== ne.length && (w = !0, K.setAsyncValidators(Re)) } } } const D = () => { }; return Te(V._rawValidators, D), Te(V._rawAsyncValidators, D), w } function It(K, V) { K._pendingDirty && K.markAsDirty(), K.setValue(K._pendingValue, { emitModelToViewChange: !1 }), V.viewToModelUpdate(K._pendingValue), K._pendingChange = !1 } function Pn(K, V) { gt(K, V) } function $r(K, V) { if (!K.hasOwnProperty("model")) return !1; const w = K.model; return !!w.isFirstChange() || !Object.is(V, w.currentValue) } function zi(K, V) { K._syncPendingControls(), V.forEach(w => { const D = w.control; "submit" === D.updateOn && D._pendingChange && (w.viewToModelUpdate(D._pendingValue), D._pendingChange = !1) }) } function Ti(K, V) { if (!V) return null; let w, D, ne; return Array.isArray(V), V.forEach(Re => { Re.constructor === Oe ? w = Re : function Io(K) { return Object.getPrototypeOf(K.constructor) === ke }(Re) ? D = Re : ne = Re }), ne || D || w || null } const bo = { provide: nt, useExisting: (0, a.Gpc)(() => Vi) }, Nr = (() => Promise.resolve())(); let Vi = (() => { class K extends nt { constructor(w, D, ne) { super(), this.callSetDisabledState = ne, this.submitted = !1, this._directives = new Set, this.ngSubmit = new a.vpe, this.form = new ae({}, vt(w), it(D)) } ngAfterViewInit() { this._setUpdateStrategy() } get formDirective() { return this } get control() { return this.form } get path() { return [] } get controls() { return this.form.controls } addControl(w) { Nr.then(() => { const D = this._findContainer(w.path); w.control = D.registerControl(w.name, w.control), F(w.control, w, this.callSetDisabledState), w.control.updateValueAndValidity({ emitEvent: !1 }), this._directives.add(w) }) } getControl(w) { return this.form.get(w.path) } removeControl(w) { Nr.then(() => { const D = this._findContainer(w.path); D && D.removeControl(w.name), this._directives.delete(w) }) } addFormGroup(w) { Nr.then(() => { const D = this._findContainer(w.path), ne = new ae({}); Pn(ne, w), D.registerControl(w.name, ne), ne.updateValueAndValidity({ emitEvent: !1 }) }) } removeFormGroup(w) { Nr.then(() => { const D = this._findContainer(w.path); D && D.removeControl(w.name) }) } getFormGroup(w) { return this.form.get(w.path) } updateModel(w, D) { Nr.then(() => { this.form.get(w.path).setValue(D) }) } setValue(w) { this.control.setValue(w) } onSubmit(w) { return this.submitted = !0, zi(this.form, this._directives), this.ngSubmit.emit(w), "dialog" === w?.target?.method } onReset() { this.resetForm() } resetForm(w = void 0) { this.form.reset(w), this.submitted = !1 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.form._updateOn = this.options.updateOn) } _findContainer(w) { return w.pop(), w.length ? this.form.get(w) : this.form } } return K.\u0275fac = function (w) { return new (w || K)(a.Y36(Ve, 10), a.Y36(tt, 10), a.Y36(pt, 8)) }, K.\u0275dir = a.lG2({ type: K, selectors: [["form", 3, "ngNoForm", "", 3, "formGroup", ""], ["ng-form"], ["", "ngForm", ""]], hostBindings: function (w, D) { 1 & w && a.NdJ("submit", function (Re) { return D.onSubmit(Re) })("reset", function () { return D.onReset() }) }, inputs: { options: ["ngFormOptions", "options"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [a._Bn([bo]), a.qOj] }), K })(); function cs(K, V) { const w = K.indexOf(V); w > -1 && K.splice(w, 1) } function fo(K) { return "object" == typeof K && null !== K && 2 === Object.keys(K).length && "value" in K && "disabled" in K } const Jo = class extends He { constructor(V = null, w, D) { super(_t(w), W(D, w)), this.defaultValue = null, this._onChange = [], this._pendingChange = !1, this._applyFormState(V), this._setUpdateStrategy(w), this._initObservables(), this.updateValueAndValidity({ onlySelf: !0, emitEvent: !!this.asyncValidator }), de(w) && (w.nonNullable || w.initialValueIsDefault) && (this.defaultValue = fo(V) ? V.value : V) } setValue(V, w = {}) { this.value = this._pendingValue = V, this._onChange.length && !1 !== w.emitModelToViewChange && this._onChange.forEach(D => D(this.value, !1 !== w.emitViewToModelChange)), this.updateValueAndValidity(w) } patchValue(V, w = {}) { this.setValue(V, w) } reset(V = this.defaultValue, w = {}) { this._applyFormState(V), this.markAsPristine(w), this.markAsUntouched(w), this.setValue(this.value, w), this._pendingChange = !1 } _updateValue() { } _anyControls(V) { return !1 } _allControlsDisabled() { return this.disabled } registerOnChange(V) { this._onChange.push(V) } _unregisterOnChange(V) { cs(this._onChange, V) } registerOnDisabledChange(V) { this._onDisabledChange.push(V) } _unregisterOnDisabledChange(V) { cs(this._onDisabledChange, V) } _forEachChild(V) { } _syncPendingControls() { return !("submit" !== this.updateOn || (this._pendingDirty && this.markAsDirty(), this._pendingTouched && this.markAsTouched(), !this._pendingChange) || (this.setValue(this._pendingValue, { onlySelf: !0, emitModelToViewChange: !1 }), 0)) } _applyFormState(V) { fo(V) ? (this.value = this._pendingValue = V.value, V.disabled ? this.disable({ onlySelf: !0, emitEvent: !1 }) : this.enable({ onlySelf: !0, emitEvent: !1 })) : this.value = this._pendingValue = V } }, et = { provide: qt, useExisting: (0, a.Gpc)(() => At) }, Vt = (() => Promise.resolve())(); let At = (() => { class K extends qt { constructor(w, D, ne, Re, mt, kt) { super(), this._changeDetectorRef = mt, this.callSetDisabledState = kt, this.control = new Jo, this._registered = !1, this.name = "", this.update = new a.vpe, this._parent = w, this._setValidators(D), this._setAsyncValidators(ne), this.valueAccessor = Ti(0, Re) } ngOnChanges(w) { if (this._checkForErrors(), !this._registered || "name" in w) { if (this._registered && (this._checkName(), this.formDirective)) { const D = w.name.previousValue; this.formDirective.removeControl({ name: D, path: this._getPath(D) }) } this._setUpControl() } "isDisabled" in w && this._updateDisabled(w), $r(w, this.viewModel) && (this._updateValue(this.model), this.viewModel = this.model) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } get path() { return this._getPath(this.name) } get formDirective() { return this._parent ? this._parent.formDirective : null } viewToModelUpdate(w) { this.viewModel = w, this.update.emit(w) } _setUpControl() { this._setUpdateStrategy(), this._isStandalone() ? this._setUpStandalone() : this.formDirective.addControl(this), this._registered = !0 } _setUpdateStrategy() { this.options && null != this.options.updateOn && (this.control._updateOn = this.options.updateOn) } _isStandalone() { return !this._parent || !(!this.options || !this.options.standalone) } _setUpStandalone() { F(this.control, this, this.callSetDisabledState), this.control.updateValueAndValidity({ emitEvent: !1 }) } _checkForErrors() { this._isStandalone() || this._checkParentType(), this._checkName() } _checkParentType() { } _checkName() { this.options && this.options.name && (this.name = this.options.name), this._isStandalone() } _updateValue(w) { Vt.then(() => { this.control.setValue(w, { emitViewToModelChange: !1 }), this._changeDetectorRef?.markForCheck() }) } _updateDisabled(w) { const D = w.isDisabled.currentValue, ne = 0 !== D && (0, a.VuI)(D); Vt.then(() => { ne && !this.control.disabled ? this.control.disable() : !ne && this.control.disabled && this.control.enable(), this._changeDetectorRef?.markForCheck() }) } _getPath(w) { return this._parent ? fe(w, this._parent) : [w] } } return K.\u0275fac = function (w) { return new (w || K)(a.Y36(nt, 9), a.Y36(Ve, 10), a.Y36(tt, 10), a.Y36(re, 10), a.Y36(a.sBO, 8), a.Y36(pt, 8)) }, K.\u0275dir = a.lG2({ type: K, selectors: [["", "ngModel", "", 3, "formControlName", "", 3, "formControl", ""]], inputs: { name: "name", isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"], options: ["ngModelOptions", "options"] }, outputs: { update: "ngModelChange" }, exportAs: ["ngModel"], features: [a._Bn([et]), a.qOj, a.TTD] }), K })(), cn = (() => { class K { } return K.\u0275fac = function (w) { return new (w || K) }, K.\u0275dir = a.lG2({ type: K, selectors: [["form", 3, "ngNoForm", "", 3, "ngNativeValidate", ""]], hostAttrs: ["novalidate", ""] }), K })(); const Tn = { provide: re, useExisting: (0, a.Gpc)(() => ii), multi: !0 }; let ii = (() => { class K extends ke { writeValue(w) { this.setProperty("value", w ?? "") } registerOnChange(w) { this.onChange = D => { w("" == D ? null : parseFloat(D)) } } } return K.\u0275fac = function () { let V; return function (D) { return (V || (V = a.n5z(K)))(D || K) } }(), K.\u0275dir = a.lG2({ type: K, selectors: [["input", "type", "number", "formControlName", ""], ["input", "type", "number", "formControl", ""], ["input", "type", "number", "ngModel", ""]], hostBindings: function (w, D) { 1 & w && a.NdJ("input", function (Re) { return D.onChange(Re.target.value) })("blur", function () { return D.onTouched() }) }, features: [a._Bn([Tn]), a.qOj] }), K })(), Dr = (() => { class K { } return K.\u0275fac = function (w) { return new (w || K) }, K.\u0275mod = a.oAB({ type: K }), K.\u0275inj = a.cJS({}), K })(); const Sn = new a.OlP("NgModelWithFormControlWarning"), tr = { provide: nt, useExisting: (0, a.Gpc)(() => Lr) }; let Lr = (() => { class K extends nt { constructor(w, D, ne) { super(), this.callSetDisabledState = ne, this.submitted = !1, this._onCollectionChange = () => this._updateDomValue(), this.directives = [], this.form = null, this.ngSubmit = new a.vpe, this._setValidators(w), this._setAsyncValidators(D) } ngOnChanges(w) { this._checkFormPresent(), w.hasOwnProperty("form") && (this._updateValidators(), this._updateDomValue(), this._updateRegistrations(), this._oldForm = this.form) } ngOnDestroy() { this.form && (Ht(this.form, this), this.form._onCollectionChange === this._onCollectionChange && this.form._registerOnCollectionChange(() => { })) } get formDirective() { return this } get control() { return this.form } get path() { return [] } addControl(w) { const D = this.form.get(w.path); return F(D, w, this.callSetDisabledState), D.updateValueAndValidity({ emitEvent: !1 }), this.directives.push(w), D } getControl(w) { return this.form.get(w.path) } removeControl(w) { J(w.control || null, w, !1), function Pr(K, V) { const w = K.indexOf(V); w > -1 && K.splice(w, 1) }(this.directives, w) } addFormGroup(w) { this._setUpFormContainer(w) } removeFormGroup(w) { this._cleanUpFormContainer(w) } getFormGroup(w) { return this.form.get(w.path) } addFormArray(w) { this._setUpFormContainer(w) } removeFormArray(w) { this._cleanUpFormContainer(w) } getFormArray(w) { return this.form.get(w.path) } updateModel(w, D) { this.form.get(w.path).setValue(D) } onSubmit(w) { return this.submitted = !0, zi(this.form, this.directives), this.ngSubmit.emit(w), "dialog" === w?.target?.method } onReset() { this.resetForm() } resetForm(w = void 0) { this.form.reset(w), this.submitted = !1 } _updateDomValue() { this.directives.forEach(w => { const D = w.control, ne = this.form.get(w.path); D !== ne && (J(D || null, w), (K => K instanceof Jo)(ne) && (F(ne, w, this.callSetDisabledState), w.control = ne)) }), this.form._updateTreeValidity({ emitEvent: !1 }) } _setUpFormContainer(w) { const D = this.form.get(w.path); Pn(D, w), D.updateValueAndValidity({ emitEvent: !1 }) } _cleanUpFormContainer(w) { if (this.form) { const D = this.form.get(w.path); D && function qn(K, V) { return Ht(K, V) }(D, w) && D.updateValueAndValidity({ emitEvent: !1 }) } } _updateRegistrations() { this.form._registerOnCollectionChange(this._onCollectionChange), this._oldForm && this._oldForm._registerOnCollectionChange(() => { }) } _updateValidators() { gt(this.form, this), this._oldForm && Ht(this._oldForm, this) } _checkFormPresent() { } } return K.\u0275fac = function (w) { return new (w || K)(a.Y36(Ve, 10), a.Y36(tt, 10), a.Y36(pt, 8)) }, K.\u0275dir = a.lG2({ type: K, selectors: [["", "formGroup", ""]], hostBindings: function (w, D) { 1 & w && a.NdJ("submit", function (Re) { return D.onSubmit(Re) })("reset", function () { return D.onReset() }) }, inputs: { form: ["formGroup", "form"] }, outputs: { ngSubmit: "ngSubmit" }, exportAs: ["ngForm"], features: [a._Bn([tr]), a.qOj, a.TTD] }), K })(); const Xn = { provide: qt, useExisting: (0, a.Gpc)(() => vs) }; let vs = (() => { class K extends qt { set isDisabled(w) { } constructor(w, D, ne, Re, mt) { super(), this._ngModelWarningConfig = mt, this._added = !1, this.name = null, this.update = new a.vpe, this._ngModelWarningSent = !1, this._parent = w, this._setValidators(D), this._setAsyncValidators(ne), this.valueAccessor = Ti(0, Re) } ngOnChanges(w) { this._added || this._setUpControl(), $r(w, this.viewModel) && (this.viewModel = this.model, this.formDirective.updateModel(this, this.model)) } ngOnDestroy() { this.formDirective && this.formDirective.removeControl(this) } viewToModelUpdate(w) { this.viewModel = w, this.update.emit(w) } get path() { return fe(null == this.name ? this.name : this.name.toString(), this._parent) } get formDirective() { return this._parent ? this._parent.formDirective : null } _checkParentType() { } _setUpControl() { this._checkParentType(), this.control = this.formDirective.addControl(this), this._added = !0 } } return K._ngModelWarningSentOnce = !1, K.\u0275fac = function (w) { return new (w || K)(a.Y36(nt, 13), a.Y36(Ve, 10), a.Y36(tt, 10), a.Y36(re, 10), a.Y36(Sn, 8)) }, K.\u0275dir = a.lG2({ type: K, selectors: [["", "formControlName", ""]], inputs: { name: ["formControlName", "name"], isDisabled: ["disabled", "isDisabled"], model: ["ngModel", "model"] }, outputs: { update: "ngModelChange" }, features: [a._Bn([Xn]), a.qOj, a.TTD] }), K })(); let qo = (() => { class K { constructor() { this._validator = Kt } ngOnChanges(w) { if (this.inputName in w) { const D = this.normalizeInput(w[this.inputName].currentValue); this._enabled = this.enabled(D), this._validator = this._enabled ? this.createValidator(D) : Kt, this._onChange && this._onChange() } } validate(w) { return this._validator(w) } registerOnValidatorChange(w) { this._onChange = w } enabled(w) { return null != w } } return K.\u0275fac = function (w) { return new (w || K) }, K.\u0275dir = a.lG2({ type: K, features: [a.TTD] }), K })(); const Qo = { provide: Ve, useExisting: (0, a.Gpc)(() => Ki), multi: !0 }; let Ki = (() => { class K extends qo { constructor() { super(...arguments), this.inputName = "required", this.normalizeInput = a.VuI, this.createValidator = w => le } enabled(w) { return w } } return K.\u0275fac = function () { let V; return function (D) { return (V || (V = a.n5z(K)))(D || K) } }(), K.\u0275dir = a.lG2({ type: K, selectors: [["", "required", "", "formControlName", "", 3, "type", "checkbox"], ["", "required", "", "formControl", "", 3, "type", "checkbox"], ["", "required", "", "ngModel", "", 3, "type", "checkbox"]], hostVars: 1, hostBindings: function (w, D) { 2 & w && a.uIk("required", D._enabled ? "" : null) }, inputs: { required: "required" }, features: [a._Bn([Qo]), a.qOj] }), K })(); const us = { provide: Ve, useExisting: (0, a.Gpc)(() => dr), multi: !0 }; let dr = (() => { class K extends qo { constructor() { super(...arguments), this.inputName = "minlength", this.normalizeInput = w => function so(K) { return "number" == typeof K ? K : parseInt(K, 10) }(w), this.createValidator = w => ee(w) } } return K.\u0275fac = function () { let V; return function (D) { return (V || (V = a.n5z(K)))(D || K) } }(), K.\u0275dir = a.lG2({ type: K, selectors: [["", "minlength", "", "formControlName", ""], ["", "minlength", "", "formControl", ""], ["", "minlength", "", "ngModel", ""]], hostVars: 1, hostBindings: function (w, D) { 2 & w && a.uIk("minlength", D._enabled ? D.minlength : null) }, inputs: { minlength: "minlength" }, features: [a._Bn([us]), a.qOj] }), K })(), Ci = (() => { class K { } return K.\u0275fac = function (w) { return new (w || K) }, K.\u0275mod = a.oAB({ type: K }), K.\u0275inj = a.cJS({ imports: [Dr] }), K })(), Ks = (() => { class K { static withConfig(w) { return { ngModule: K, providers: [{ provide: pt, useValue: w.callSetDisabledState ?? pe }] } } } return K.\u0275fac = function (w) { return new (w || K) }, K.\u0275mod = a.oAB({ type: K }), K.\u0275inj = a.cJS({ imports: [Ci] }), K })(), jo = (() => { class K { static withConfig(w) { return { ngModule: K, providers: [{ provide: Sn, useValue: w.warnOnNgModelWithFormControl ?? "always" }, { provide: pt, useValue: w.callSetDisabledState ?? pe }] } } } return K.\u0275fac = function (w) { return new (w || K) }, K.\u0275mod = a.oAB({ type: K }), K.\u0275inj = a.cJS({ imports: [Ci] }), K })() }, 2296: (nn, Qe, C) => { C.d(Qe, { RK: () => Wt, cs: () => vt, lW: () => Dn, nh: () => xt, ot: () => Jt, zs: () => Mn }); var a = C(2831), y = C(5879), v = C(4191), Y = C(3680), he = C(6814), Se = C(2495); const ke = ["mat-button", ""], re = [[["", 8, "material-icons", 3, "iconPositionEnd", ""], ["mat-icon", 3, "iconPositionEnd", ""], ["", "matButtonIcon", "", 3, "iconPositionEnd", ""]], "*", [["", "iconPositionEnd", "", 8, "material-icons"], ["mat-icon", "iconPositionEnd", ""], ["", "matButtonIcon", "", "iconPositionEnd", ""]]], Ie = [".material-icons:not([iconPositionEnd]), mat-icon:not([iconPositionEnd]), [matButtonIcon]:not([iconPositionEnd])", "*", ".material-icons[iconPositionEnd], mat-icon[iconPositionEnd], [matButtonIcon][iconPositionEnd]"], _e = ".cdk-high-contrast-active .mat-mdc-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-unelevated-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-raised-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-outlined-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-icon-button{outline:solid 1px}", xe = ["mat-fab", ""], ze = ["mat-mini-fab", ""], We = ["mat-icon-button", ""], Pe = ["*"], tt = { capture: !0 }, Ye = ["focus", "click", "mouseenter", "touchstart"], ut = "mat-button-ripple-uninitialized"; let ie = (() => { class tn { constructor() { this._document = (0, y.f3M)(he.K0, { optional: !0 }), this._animationMode = (0, y.f3M)(y.QbO, { optional: !0 }), this._globalRippleOptions = (0, y.f3M)(Y.Y2, { optional: !0 }), this._platform = (0, y.f3M)(a.t4), this._ngZone = (0, y.f3M)(y.R0b), this._onInteraction = ht => { if (ht.target === this._document) return; const nt = ht.target.closest(`[${ut}]`); nt && (nt.removeAttribute(ut), this._appendRipple(nt)) }, this._ngZone.runOutsideAngular(() => { for (const ht of Ye) this._document?.addEventListener(ht, this._onInteraction, tt) }) } ngOnDestroy() { for (const ht of Ye) this._document?.removeEventListener(ht, this._onInteraction, tt) } _appendRipple(ht) { if (!this._document) return; const Ae = this._document.createElement("span"); Ae.classList.add("mat-mdc-button-ripple"); const nt = new Le(ht, this._globalRippleOptions ? this._globalRippleOptions : void 0, this._animationMode ? this._animationMode : void 0); nt.rippleConfig.centered = ht.hasAttribute("mat-icon-button"), new Y.IR(nt, this._ngZone, Ae, this._platform).setupTriggerEvents(ht), ht.append(Ae) } _createMatRipple(ht) { if (!this._document) return; ht.querySelector(".mat-mdc-button-ripple")?.remove(), ht.removeAttribute(ut); const Ae = this._document.createElement("span"); Ae.classList.add("mat-mdc-button-ripple"); const nt = new Y.wG(new y.SBq(Ae), this._ngZone, this._platform, this._globalRippleOptions ? this._globalRippleOptions : void 0, this._animationMode ? this._animationMode : void 0); return nt._isInitialized = !0, nt.trigger = ht, ht.append(Ae), nt } } return tn.\u0275fac = function (ht) { return new (ht || tn) }, tn.\u0275prov = y.Yz7({ token: tn, factory: tn.\u0275fac, providedIn: "root" }), tn })(); class Le { constructor(St, ht, Ae) { this._button = St, this._globalRippleOptions = ht, this._setRippleConfig(ht, Ae) } _setRippleConfig(St, ht) { this.rippleConfig = St || {}, "NoopAnimations" === ht && (this.rippleConfig.animation = { enterDuration: 0, exitDuration: 0 }) } get rippleDisabled() { return this._button.hasAttribute("disabled") || !!this._globalRippleOptions?.disabled } } const ue = [{ selector: "mat-button", mdcClasses: ["mdc-button", "mat-mdc-button"] }, { selector: "mat-flat-button", mdcClasses: ["mdc-button", "mdc-button--unelevated", "mat-mdc-unelevated-button"] }, { selector: "mat-raised-button", mdcClasses: ["mdc-button", "mdc-button--raised", "mat-mdc-raised-button"] }, { selector: "mat-stroked-button", mdcClasses: ["mdc-button", "mdc-button--outlined", "mat-mdc-outlined-button"] }, { selector: "mat-fab", mdcClasses: ["mdc-fab", "mat-mdc-fab"] }, { selector: "mat-mini-fab", mdcClasses: ["mdc-fab", "mdc-fab--mini", "mat-mdc-mini-fab"] }, { selector: "mat-icon-button", mdcClasses: ["mdc-icon-button", "mat-mdc-icon-button"] }], ee = (0, Y.pj)((0, Y.Id)((0, Y.Kr)(class { constructor(tn) { this._elementRef = tn } }))); let $e = (() => { class tn extends ee { get ripple() { return !this._ripple && this._rippleLoader && (this._ripple = this._rippleLoader._createMatRipple(this._elementRef.nativeElement)), this._ripple } set ripple(ht) { this._ripple = ht } constructor(ht, Ae, nt, qt) { super(ht), this._platform = Ae, this._ngZone = nt, this._animationMode = qt, this._focusMonitor = (0, y.f3M)(v.tE), this._rippleLoader = (0, y.f3M)(ie), this._isFab = !1; const jt = ht.nativeElement.classList; for (const Pt of ue) this._hasHostAttributes(Pt.selector) && Pt.mdcClasses.forEach(qe => { jt.add(qe) }) } ngAfterViewInit() { this._focusMonitor.monitor(this._elementRef, !0) } ngOnChanges() { this._ripple && (this._ripple.disabled = this.disableRipple || this.disabled) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef) } focus(ht = "program", Ae) { ht ? this._focusMonitor.focusVia(this._elementRef.nativeElement, ht, Ae) : this._elementRef.nativeElement.focus(Ae) } _hasHostAttributes(...ht) { return ht.some(Ae => this._elementRef.nativeElement.hasAttribute(Ae)) } } return tn.\u0275fac = function (ht) { y.$Z() }, tn.\u0275dir = y.lG2({ type: tn, features: [y.qOj, y.TTD] }), tn })(), bn = (() => { class tn extends $e { constructor(ht, Ae, nt, qt) { super(ht, Ae, nt, qt), this._haltDisabledEvents = jt => { this.disabled && (jt.preventDefault(), jt.stopImmediatePropagation()) } } ngOnInit() { this._ngZone.runOutsideAngular(() => { this._elementRef.nativeElement.addEventListener("click", this._haltDisabledEvents) }) } ngOnDestroy() { super.ngOnDestroy(), this._elementRef.nativeElement.removeEventListener("click", this._haltDisabledEvents) } } return tn.\u0275fac = function (ht) { y.$Z() }, tn.\u0275dir = y.lG2({ type: tn, features: [y.qOj] }), tn })(), Dn = (() => { class tn extends $e { constructor(ht, Ae, nt, qt) { super(ht, Ae, nt, qt) } } return tn.\u0275fac = function (ht) { return new (ht || tn)(y.Y36(y.SBq), y.Y36(a.t4), y.Y36(y.R0b), y.Y36(y.QbO, 8)) }, tn.\u0275cmp = y.Xpm({ type: tn, selectors: [["button", "mat-button", ""], ["button", "mat-raised-button", ""], ["button", "mat-flat-button", ""], ["button", "mat-stroked-button", ""]], hostAttrs: ["mat-button-ripple-uninitialized", ""], hostVars: 7, hostBindings: function (ht, Ae) { 2 & ht && (y.uIk("disabled", Ae.disabled || null), y.ekj("_mat-animation-noopable", "NoopAnimations" === Ae._animationMode)("mat-unthemed", !Ae.color)("mat-mdc-button-base", !0)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color" }, exportAs: ["matButton"], features: [y.qOj], attrs: ke, ngContentSelectors: Ie, decls: 7, vars: 4, consts: [[1, "mat-mdc-button-persistent-ripple"], [1, "mdc-button__label"], [1, "mat-mdc-focus-indicator"], [1, "mat-mdc-button-touch-target"]], template: function (ht, Ae) { 1 & ht && (y.F$t(re), y._UZ(0, "span", 0), y.Hsn(1), y.TgZ(2, "span", 1), y.Hsn(3, 1), y.qZA(), y.Hsn(4, 2), y._UZ(5, "span", 2)(6, "span", 3)), 2 & ht && y.ekj("mdc-button__ripple", !Ae._isFab)("mdc-fab__ripple", Ae._isFab) }, styles: ['.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button{position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;user-select:none;-webkit-appearance:none;overflow:visible;vertical-align:middle;background:rgba(0,0,0,0)}.mdc-button .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button[hidden]{display:none}.mdc-button .mdc-button__icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top}[dir=rtl] .mdc-button .mdc-button__icon,.mdc-button .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:0}.mdc-button .mdc-button__progress-indicator{font-size:0;position:absolute;transform:translate(-50%, -50%);top:50%;left:50%;line-height:initial}.mdc-button .mdc-button__label{position:relative}.mdc-button .mdc-button__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    );display:none}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring{border-color:CanvasText}}.mdc-button .mdc-button__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring::after{border-color:CanvasText}}@media screen and (forced-colors: active){.mdc-button.mdc-ripple-upgraded--background-focused .mdc-button__focus-ring,.mdc-button:not(.mdc-ripple-upgraded):focus .mdc-button__focus-ring{display:block}}.mdc-button .mdc-button__touch{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mdc-button__label+.mdc-button__icon{margin-left:8px;margin-right:0}[dir=rtl] .mdc-button__label+.mdc-button__icon,.mdc-button__label+.mdc-button__icon[dir=rtl]{margin-left:0;margin-right:8px}svg.mdc-button__icon{fill:currentColor}.mdc-button--touch{margin-top:6px;margin-bottom:6px}.mdc-button{padding:0 8px 0 8px}.mdc-button--unelevated{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--unelevated.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--unelevated.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--raised{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--raised.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--raised.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--outlined{border-style:solid;transition:border 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button--outlined .mdc-button__ripple{border-style:solid;border-color:rgba(0,0,0,0)}.mat-mdc-button{height:var(--mdc-text-button-container-height, 36px);border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-button:not(:disabled){color:var(--mdc-text-button-label-text-color, inherit)}.mat-mdc-button:disabled{color:var(--mdc-text-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-button .mdc-button__ripple{border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button{height:var(--mdc-filled-button-container-height, 36px);border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button:not(:disabled){background-color:var(--mdc-filled-button-container-color, transparent)}.mat-mdc-unelevated-button:disabled{background-color:var(--mdc-filled-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-unelevated-button:not(:disabled){color:var(--mdc-filled-button-label-text-color, inherit)}.mat-mdc-unelevated-button:disabled{color:var(--mdc-filled-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-unelevated-button .mdc-button__ripple{border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button{height:var(--mdc-protected-button-container-height, 36px);border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px));box-shadow:var(--mdc-protected-button-container-elevation, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){background-color:var(--mdc-protected-button-container-color, transparent)}.mat-mdc-raised-button:disabled{background-color:var(--mdc-protected-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){color:var(--mdc-protected-button-label-text-color, inherit)}.mat-mdc-raised-button:disabled{color:var(--mdc-protected-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-raised-button .mdc-button__ripple{border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button.mdc-ripple-upgraded--background-focused,.mat-mdc-raised-button:not(.mdc-ripple-upgraded):focus{box-shadow:var(--mdc-protected-button-focus-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:hover{box-shadow:var(--mdc-protected-button-hover-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled):active{box-shadow:var(--mdc-protected-button-pressed-container-elevation, 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:disabled{box-shadow:var(--mdc-protected-button-disabled-container-elevation, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button{height:var(--mdc-outlined-button-container-height, 36px);border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px));padding:0 15px 0 15px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button:not(:disabled){color:var(--mdc-outlined-button-label-text-color, inherit)}.mat-mdc-outlined-button:disabled{color:var(--mdc-outlined-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-outlined-button .mdc-button__ripple{border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-outlined-button:not(:disabled){border-color:var(--mdc-outlined-button-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button:disabled{border-color:var(--mdc-outlined-button-disabled-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button.mdc-button--icon-trailing{padding:0 11px 0 15px}.mat-mdc-outlined-button.mdc-button--icon-leading{padding:0 15px 0 11px}.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button .mdc-button__touch{left:calc(-1 * var(--mdc-outlined-button-outline-width, 1px));width:calc(100% + 2 * var(--mdc-outlined-button-outline-width, 1px))}.mat-mdc-button,.mat-mdc-unelevated-button,.mat-mdc-raised-button,.mat-mdc-outlined-button{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-button .mat-ripple-element,.mat-mdc-unelevated-button .mat-ripple-element,.mat-mdc-raised-button .mat-ripple-element,.mat-mdc-outlined-button .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-button .mdc-button__label,.mat-mdc-unelevated-button .mdc-button__label,.mat-mdc-raised-button .mdc-button__label,.mat-mdc-outlined-button .mdc-button__label{z-index:1}.mat-mdc-button .mat-mdc-focus-indicator,.mat-mdc-unelevated-button .mat-mdc-focus-indicator,.mat-mdc-raised-button .mat-mdc-focus-indicator,.mat-mdc-outlined-button .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-unelevated-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-raised-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-outlined-button:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-button[disabled],.mat-mdc-unelevated-button[disabled],.mat-mdc-raised-button[disabled],.mat-mdc-outlined-button[disabled]{cursor:default;pointer-events:none}.mat-mdc-button .mat-mdc-button-touch-target,.mat-mdc-unelevated-button .mat-mdc-button-touch-target,.mat-mdc-raised-button .mat-mdc-button-touch-target,.mat-mdc-outlined-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mat-mdc-button._mat-animation-noopable,.mat-mdc-unelevated-button._mat-animation-noopable,.mat-mdc-raised-button._mat-animation-noopable,.mat-mdc-outlined-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem}[dir=rtl] .mat-mdc-button>.mat-icon,.mat-mdc-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}.mat-mdc-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-button .mdc-button__label+.mat-icon,.mat-mdc-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:0;margin-right:8px}.mat-mdc-unelevated-button>.mat-icon,.mat-mdc-raised-button>.mat-icon,.mat-mdc-outlined-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem;margin-left:-4px;margin-right:8px}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:-4px}.mat-mdc-unelevated-button .mdc-button__label+.mat-icon,.mat-mdc-raised-button .mdc-button__label+.mat-icon,.mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:-4px}[dir=rtl] .mat-mdc-unelevated-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-raised-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-outlined-button .mdc-button__label+.mat-icon,.mat-mdc-unelevated-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-raised-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-outlined-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:-4px;margin-right:8px}.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:-1px}.mat-mdc-unelevated-button .mat-mdc-focus-indicator::before,.mat-mdc-raised-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-outlined-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 3px) * -1)}', ".cdk-high-contrast-active .mat-mdc-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-unelevated-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-raised-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-outlined-button:not(.mdc-button--outlined),.cdk-high-contrast-active .mat-mdc-icon-button{outline:solid 1px}"], encapsulation: 2, changeDetection: 0 }), tn })(), Mn = (() => { class tn extends bn { constructor(ht, Ae, nt, qt) { super(ht, Ae, nt, qt) } } return tn.\u0275fac = function (ht) { return new (ht || tn)(y.Y36(y.SBq), y.Y36(a.t4), y.Y36(y.R0b), y.Y36(y.QbO, 8)) }, tn.\u0275cmp = y.Xpm({ type: tn, selectors: [["a", "mat-button", ""], ["a", "mat-raised-button", ""], ["a", "mat-flat-button", ""], ["a", "mat-stroked-button", ""]], hostAttrs: ["mat-button-ripple-uninitialized", ""], hostVars: 9, hostBindings: function (ht, Ae) { 2 & ht && (y.uIk("disabled", Ae.disabled || null)("tabindex", Ae.disabled ? -1 : Ae.tabIndex)("aria-disabled", Ae.disabled.toString()), y.ekj("_mat-animation-noopable", "NoopAnimations" === Ae._animationMode)("mat-unthemed", !Ae.color)("mat-mdc-button-base", !0)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color", tabIndex: "tabIndex" }, exportAs: ["matButton", "matAnchor"], features: [y.qOj], attrs: ke, ngContentSelectors: Ie, decls: 7, vars: 4, consts: [[1, "mat-mdc-button-persistent-ripple"], [1, "mdc-button__label"], [1, "mat-mdc-focus-indicator"], [1, "mat-mdc-button-touch-target"]], template: function (ht, Ae) { 1 & ht && (y.F$t(re), y._UZ(0, "span", 0), y.Hsn(1), y.TgZ(2, "span", 1), y.Hsn(3, 1), y.qZA(), y.Hsn(4, 2), y._UZ(5, "span", 2)(6, "span", 3)), 2 & ht && y.ekj("mdc-button__ripple", !Ae._isFab)("mdc-fab__ripple", Ae._isFab) }, styles: ['.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button{position:relative;display:inline-flex;align-items:center;justify-content:center;box-sizing:border-box;min-width:64px;border:none;outline:none;line-height:inherit;user-select:none;-webkit-appearance:none;overflow:visible;vertical-align:middle;background:rgba(0,0,0,0)}.mdc-button .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-button::-moz-focus-inner{padding:0;border:0}.mdc-button:active{outline:none}.mdc-button:hover{cursor:pointer}.mdc-button:disabled{cursor:default;pointer-events:none}.mdc-button[hidden]{display:none}.mdc-button .mdc-button__icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top}[dir=rtl] .mdc-button .mdc-button__icon,.mdc-button .mdc-button__icon[dir=rtl]{margin-left:8px;margin-right:0}.mdc-button .mdc-button__progress-indicator{font-size:0;position:absolute;transform:translate(-50%, -50%);top:50%;left:50%;line-height:initial}.mdc-button .mdc-button__label{position:relative}.mdc-button .mdc-button__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    );display:none}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring{border-color:CanvasText}}.mdc-button .mdc-button__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-button .mdc-button__focus-ring::after{border-color:CanvasText}}@media screen and (forced-colors: active){.mdc-button.mdc-ripple-upgraded--background-focused .mdc-button__focus-ring,.mdc-button:not(.mdc-ripple-upgraded):focus .mdc-button__focus-ring{display:block}}.mdc-button .mdc-button__touch{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mdc-button__label+.mdc-button__icon{margin-left:8px;margin-right:0}[dir=rtl] .mdc-button__label+.mdc-button__icon,.mdc-button__label+.mdc-button__icon[dir=rtl]{margin-left:0;margin-right:8px}svg.mdc-button__icon{fill:currentColor}.mdc-button--touch{margin-top:6px;margin-bottom:6px}.mdc-button{padding:0 8px 0 8px}.mdc-button--unelevated{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--unelevated.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--unelevated.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--raised{transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1);padding:0 16px 0 16px}.mdc-button--raised.mdc-button--icon-trailing{padding:0 12px 0 16px}.mdc-button--raised.mdc-button--icon-leading{padding:0 16px 0 12px}.mdc-button--outlined{border-style:solid;transition:border 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-button--outlined .mdc-button__ripple{border-style:solid;border-color:rgba(0,0,0,0)}.mat-mdc-button{height:var(--mdc-text-button-container-height, 36px);border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-button:not(:disabled){color:var(--mdc-text-button-label-text-color, inherit)}.mat-mdc-button:disabled{color:var(--mdc-text-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-button .mdc-button__ripple{border-radius:var(--mdc-text-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button{height:var(--mdc-filled-button-container-height, 36px);border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-unelevated-button:not(:disabled){background-color:var(--mdc-filled-button-container-color, transparent)}.mat-mdc-unelevated-button:disabled{background-color:var(--mdc-filled-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-unelevated-button:not(:disabled){color:var(--mdc-filled-button-label-text-color, inherit)}.mat-mdc-unelevated-button:disabled{color:var(--mdc-filled-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-unelevated-button .mdc-button__ripple{border-radius:var(--mdc-filled-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button{height:var(--mdc-protected-button-container-height, 36px);border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px));box-shadow:var(--mdc-protected-button-container-elevation, 0px 3px 1px -2px rgba(0, 0, 0, 0.2), 0px 2px 2px 0px rgba(0, 0, 0, 0.14), 0px 1px 5px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){background-color:var(--mdc-protected-button-container-color, transparent)}.mat-mdc-raised-button:disabled{background-color:var(--mdc-protected-button-disabled-container-color, rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled){color:var(--mdc-protected-button-label-text-color, inherit)}.mat-mdc-raised-button:disabled{color:var(--mdc-protected-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-raised-button .mdc-button__ripple{border-radius:var(--mdc-protected-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-raised-button.mdc-ripple-upgraded--background-focused,.mat-mdc-raised-button:not(.mdc-ripple-upgraded):focus{box-shadow:var(--mdc-protected-button-focus-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:hover{box-shadow:var(--mdc-protected-button-hover-container-elevation, 0px 2px 4px -1px rgba(0, 0, 0, 0.2), 0px 4px 5px 0px rgba(0, 0, 0, 0.14), 0px 1px 10px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:not(:disabled):active{box-shadow:var(--mdc-protected-button-pressed-container-elevation, 0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12))}.mat-mdc-raised-button:disabled{box-shadow:var(--mdc-protected-button-disabled-container-elevation, 0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button{height:var(--mdc-outlined-button-container-height, 36px);border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px));padding:0 15px 0 15px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button:not(:disabled){color:var(--mdc-outlined-button-label-text-color, inherit)}.mat-mdc-outlined-button:disabled{color:var(--mdc-outlined-button-disabled-label-text-color, rgba(0, 0, 0, 0.38))}.mat-mdc-outlined-button .mdc-button__ripple{border-radius:var(--mdc-outlined-button-container-shape, var(--mdc-shape-small, 4px))}.mat-mdc-outlined-button:not(:disabled){border-color:var(--mdc-outlined-button-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button:disabled{border-color:var(--mdc-outlined-button-disabled-outline-color, rgba(0, 0, 0, 0.12))}.mat-mdc-outlined-button.mdc-button--icon-trailing{padding:0 11px 0 15px}.mat-mdc-outlined-button.mdc-button--icon-leading{padding:0 15px 0 11px}.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:var(--mdc-outlined-button-outline-width, 1px)}.mat-mdc-outlined-button .mdc-button__touch{left:calc(-1 * var(--mdc-outlined-button-outline-width, 1px));width:calc(100% + 2 * var(--mdc-outlined-button-outline-width, 1px))}.mat-mdc-button,.mat-mdc-unelevated-button,.mat-mdc-raised-button,.mat-mdc-outlined-button{-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple,.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-button .mat-mdc-button-ripple,.mat-mdc-unelevated-button .mat-mdc-button-ripple,.mat-mdc-raised-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-unelevated-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-raised-button .mat-mdc-button-persistent-ripple::before,.mat-mdc-outlined-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-button .mat-ripple-element,.mat-mdc-unelevated-button .mat-ripple-element,.mat-mdc-raised-button .mat-ripple-element,.mat-mdc-outlined-button .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-button .mdc-button__label,.mat-mdc-unelevated-button .mdc-button__label,.mat-mdc-raised-button .mdc-button__label,.mat-mdc-outlined-button .mdc-button__label{z-index:1}.mat-mdc-button .mat-mdc-focus-indicator,.mat-mdc-unelevated-button .mat-mdc-focus-indicator,.mat-mdc-raised-button .mat-mdc-focus-indicator,.mat-mdc-outlined-button .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-unelevated-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-raised-button:focus .mat-mdc-focus-indicator::before,.mat-mdc-outlined-button:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-button[disabled],.mat-mdc-unelevated-button[disabled],.mat-mdc-raised-button[disabled],.mat-mdc-outlined-button[disabled]{cursor:default;pointer-events:none}.mat-mdc-button .mat-mdc-button-touch-target,.mat-mdc-unelevated-button .mat-mdc-button-touch-target,.mat-mdc-raised-button .mat-mdc-button-touch-target,.mat-mdc-outlined-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:0;right:0;transform:translateY(-50%)}.mat-mdc-button._mat-animation-noopable,.mat-mdc-unelevated-button._mat-animation-noopable,.mat-mdc-raised-button._mat-animation-noopable,.mat-mdc-outlined-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem}[dir=rtl] .mat-mdc-button>.mat-icon,.mat-mdc-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}.mat-mdc-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-button .mdc-button__label+.mat-icon,.mat-mdc-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:0;margin-right:8px}.mat-mdc-unelevated-button>.mat-icon,.mat-mdc-raised-button>.mat-icon,.mat-mdc-outlined-button>.mat-icon{margin-left:0;margin-right:8px;display:inline-block;position:relative;vertical-align:top;font-size:1.125rem;height:1.125rem;width:1.125rem;margin-left:-4px;margin-right:8px}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:0}[dir=rtl] .mat-mdc-unelevated-button>.mat-icon,[dir=rtl] .mat-mdc-raised-button>.mat-icon,[dir=rtl] .mat-mdc-outlined-button>.mat-icon,.mat-mdc-unelevated-button>.mat-icon[dir=rtl],.mat-mdc-raised-button>.mat-icon[dir=rtl],.mat-mdc-outlined-button>.mat-icon[dir=rtl]{margin-left:8px;margin-right:-4px}.mat-mdc-unelevated-button .mdc-button__label+.mat-icon,.mat-mdc-raised-button .mdc-button__label+.mat-icon,.mat-mdc-outlined-button .mdc-button__label+.mat-icon{margin-left:8px;margin-right:-4px}[dir=rtl] .mat-mdc-unelevated-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-raised-button .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-outlined-button .mdc-button__label+.mat-icon,.mat-mdc-unelevated-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-raised-button .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-outlined-button .mdc-button__label+.mat-icon[dir=rtl]{margin-left:-4px;margin-right:8px}.mat-mdc-outlined-button .mat-mdc-button-ripple,.mat-mdc-outlined-button .mdc-button__ripple{top:-1px;left:-1px;bottom:-1px;right:-1px;border-width:-1px}.mat-mdc-unelevated-button .mat-mdc-focus-indicator::before,.mat-mdc-raised-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-outlined-button .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 3px) * -1)}', _e], encapsulation: 2, changeDetection: 0 }), tn })(); const On = new y.OlP("mat-mdc-fab-default-options", { providedIn: "root", factory: Wn }); function Wn() { return { color: "accent" } } const Hn = Wn(); let vt = (() => { class tn extends $e { get extended() { return this._extended } set extended(ht) { this._extended = (0, Se.Ig)(ht) } constructor(ht, Ae, nt, qt, jt) { super(ht, Ae, nt, qt), this._options = jt, this._isFab = !0, this._options = this._options || Hn, this.color = this.defaultColor = this._options.color || Hn.color } } return tn.\u0275fac = function (ht) { return new (ht || tn)(y.Y36(y.SBq), y.Y36(a.t4), y.Y36(y.R0b), y.Y36(y.QbO, 8), y.Y36(On, 8)) }, tn.\u0275cmp = y.Xpm({ type: tn, selectors: [["button", "mat-fab", ""]], hostAttrs: ["mat-button-ripple-uninitialized", ""], hostVars: 11, hostBindings: function (ht, Ae) { 2 & ht && (y.uIk("disabled", Ae.disabled || null), y.ekj("_mat-animation-noopable", "NoopAnimations" === Ae._animationMode)("mat-unthemed", !Ae.color)("mat-mdc-button-base", !0)("mdc-fab--extended", Ae.extended)("mat-mdc-extended-fab", Ae.extended)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color", tabIndex: "tabIndex", extended: "extended" }, exportAs: ["matButton"], features: [y.qOj], attrs: xe, ngContentSelectors: Ie, decls: 7, vars: 4, consts: [[1, "mat-mdc-button-persistent-ripple"], [1, "mdc-button__label"], [1, "mat-mdc-focus-indicator"], [1, "mat-mdc-button-touch-target"]], template: function (ht, Ae) { 1 & ht && (y.F$t(re), y._UZ(0, "span", 0), y.Hsn(1), y.TgZ(2, "span", 1), y.Hsn(3, 1), y.qZA(), y.Hsn(4, 2), y._UZ(5, "span", 2)(6, "span", 3)), 2 & ht && y.ekj("mdc-button__ripple", !Ae._isFab)("mdc-fab__ripple", Ae._isFab) }, styles: ['.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-fab{position:relative;display:inline-flex;position:relative;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;user-select:none;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-fab .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-fab[hidden]{display:none}.mdc-fab::-moz-focus-inner{padding:0;border:0}.mdc-fab .mdc-fab__focus-ring{position:absolute}.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    )}@media screen and (forced-colors: active){.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{border-color:CanvasText}}.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{border-color:CanvasText}}.mdc-fab:active,.mdc-fab:focus{outline:none}.mdc-fab:hover{cursor:pointer}.mdc-fab>svg{width:100%}.mdc-fab--mini{width:40px;height:40px}.mdc-fab--extended{border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;height:48px;line-height:normal}.mdc-fab--extended .mdc-fab__ripple{border-radius:24px}.mdc-fab--extended .mdc-fab__icon{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mdc-fab--extended .mdc-fab__icon,.mdc-fab--extended .mdc-fab__icon[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mdc-fab--extended .mdc-fab__label+.mdc-fab__icon,.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mdc-fab--touch{margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}.mdc-fab--touch .mdc-fab__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mdc-fab::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-fab::before{border-color:CanvasText}}.mdc-fab__label{justify-content:flex-start;text-overflow:ellipsis;white-space:nowrap;overflow-x:hidden;overflow-y:visible}.mdc-fab__icon{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mdc-fab .mdc-fab__icon{display:inline-flex;align-items:center;justify-content:center}.mdc-fab--exited{transform:scale(0);opacity:0;transition:opacity 15ms linear 150ms,transform 180ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-fab--exited .mdc-fab__icon{transform:scale(0);transition:transform 135ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-fab .mdc-fab__icon{width:24px;height:24px;font-size:24px}.mdc-fab:not(.mdc-fab--extended){border-radius:50%}.mdc-fab:not(.mdc-fab--extended) .mdc-fab__ripple{border-radius:50%}.mat-mdc-fab,.mat-mdc-mini-fab{-webkit-tap-highlight-color:rgba(0,0,0,0);background-color:var(--mdc-fab-container-color, transparent);box-shadow:0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12);color:var(--mat-mdc-fab-color, inherit);flex-shrink:0}.mat-mdc-fab .mat-mdc-button-ripple,.mat-mdc-fab .mat-mdc-button-persistent-ripple,.mat-mdc-fab .mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab .mat-mdc-button-ripple,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-fab .mat-mdc-button-ripple,.mat-mdc-mini-fab .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-fab .mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-fab .mat-ripple-element,.mat-mdc-mini-fab .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-fab .mdc-button__label,.mat-mdc-mini-fab .mdc-button__label{z-index:1}.mat-mdc-fab .mat-mdc-focus-indicator,.mat-mdc-mini-fab .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-fab:focus .mat-mdc-focus-indicator::before,.mat-mdc-mini-fab:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-fab .mat-mdc-button-touch-target,.mat-mdc-mini-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mat-mdc-fab._mat-animation-noopable,.mat-mdc-mini-fab._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-fab:not(:disabled) .mdc-fab__icon,.mat-mdc-mini-fab:not(:disabled) .mdc-fab__icon{color:var(--mdc-fab-icon-color, inherit)}.mat-mdc-fab:not(.mdc-fab--extended),.mat-mdc-mini-fab:not(.mdc-fab--extended){border-radius:var(--mdc-fab-container-shape, 50%)}.mat-mdc-fab:not(.mdc-fab--extended) .mdc-fab__ripple,.mat-mdc-mini-fab:not(.mdc-fab--extended) .mdc-fab__ripple{border-radius:var(--mdc-fab-container-shape, 50%)}.mat-mdc-fab:hover,.mat-mdc-fab:focus,.mat-mdc-mini-fab:hover,.mat-mdc-mini-fab:focus{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12)}.mat-mdc-fab:active,.mat-mdc-fab:focus:active,.mat-mdc-mini-fab:active,.mat-mdc-mini-fab:focus:active{box-shadow:0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 12px 17px 2px rgba(0, 0, 0, 0.14), 0px 5px 22px 4px rgba(0, 0, 0, 0.12)}.mat-mdc-fab[disabled],.mat-mdc-mini-fab[disabled]{cursor:default;pointer-events:none;box-shadow:0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12)}.mat-mdc-fab:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-mini-fab:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}.mat-mdc-fab .mat-icon,.mat-mdc-fab .material-icons,.mat-mdc-mini-fab .mat-icon,.mat-mdc-mini-fab .material-icons{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mat-mdc-fab .mat-mdc-focus-indicator::before,.mat-mdc-mini-fab .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-extended-fab{border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;height:48px;line-height:normal}.mat-mdc-extended-fab .mdc-fab__ripple{border-radius:24px}.mat-mdc-extended-fab .mdc-fab__icon{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mat-mdc-extended-fab .mdc-fab__icon,.mat-mdc-extended-fab .mdc-fab__icon[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mat-mdc-extended-fab .mdc-fab__label+.mdc-fab__icon{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mat-mdc-extended-fab .mdc-fab__label+.mdc-fab__icon,.mat-mdc-extended-fab .mdc-fab__label+.mdc-fab__icon[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mat-mdc-extended-fab>.mat-icon,.mat-mdc-extended-fab>.material-icons{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mat-mdc-extended-fab>.mat-icon,[dir=rtl] .mat-mdc-extended-fab>.material-icons,.mat-mdc-extended-fab>.mat-icon[dir=rtl],.mat-mdc-extended-fab>.material-icons[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mat-mdc-extended-fab .mdc-button__label+.mat-icon,.mat-mdc-extended-fab .mdc-button__label+.material-icons{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.material-icons,.mat-mdc-extended-fab .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-extended-fab .mdc-button__label+.material-icons[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mat-mdc-extended-fab .mat-mdc-button-touch-target{width:100%}'], encapsulation: 2, changeDetection: 0 }), tn })(), xt = (() => { class tn extends $e { constructor(ht, Ae, nt, qt, jt) { super(ht, Ae, nt, qt), this._options = jt, this._isFab = !0, this._options = this._options || Hn, this.color = this.defaultColor = this._options.color || Hn.color } } return tn.\u0275fac = function (ht) { return new (ht || tn)(y.Y36(y.SBq), y.Y36(a.t4), y.Y36(y.R0b), y.Y36(y.QbO, 8), y.Y36(On, 8)) }, tn.\u0275cmp = y.Xpm({ type: tn, selectors: [["button", "mat-mini-fab", ""]], hostAttrs: ["mat-button-ripple-uninitialized", ""], hostVars: 7, hostBindings: function (ht, Ae) { 2 & ht && (y.uIk("disabled", Ae.disabled || null), y.ekj("_mat-animation-noopable", "NoopAnimations" === Ae._animationMode)("mat-unthemed", !Ae.color)("mat-mdc-button-base", !0)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color" }, exportAs: ["matButton"], features: [y.qOj], attrs: ze, ngContentSelectors: Ie, decls: 7, vars: 4, consts: [[1, "mat-mdc-button-persistent-ripple"], [1, "mdc-button__label"], [1, "mat-mdc-focus-indicator"], [1, "mat-mdc-button-touch-target"]], template: function (ht, Ae) { 1 & ht && (y.F$t(re), y._UZ(0, "span", 0), y.Hsn(1), y.TgZ(2, "span", 1), y.Hsn(3, 1), y.qZA(), y.Hsn(4, 2), y._UZ(5, "span", 2)(6, "span", 3)), 2 & ht && y.ekj("mdc-button__ripple", !Ae._isFab)("mdc-fab__ripple", Ae._isFab) }, styles: ['.mdc-touch-target-wrapper{display:inline}.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-fab{position:relative;display:inline-flex;position:relative;align-items:center;justify-content:center;box-sizing:border-box;width:56px;height:56px;padding:0;border:none;fill:currentColor;text-decoration:none;cursor:pointer;user-select:none;-moz-appearance:none;-webkit-appearance:none;overflow:visible;transition:box-shadow 280ms cubic-bezier(0.4, 0, 0.2, 1),opacity 15ms linear 30ms,transform 270ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-fab .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}.mdc-fab[hidden]{display:none}.mdc-fab::-moz-focus-inner{padding:0;border:0}.mdc-fab .mdc-fab__focus-ring{position:absolute}.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(\n      100% + 4px\n    );width:calc(\n      100% + 4px\n    )}@media screen and (forced-colors: active){.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring{border-color:CanvasText}}.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-fab.mdc-ripple-upgraded--background-focused .mdc-fab__focus-ring::after,.mdc-fab:not(.mdc-ripple-upgraded):focus .mdc-fab__focus-ring::after{border-color:CanvasText}}.mdc-fab:active,.mdc-fab:focus{outline:none}.mdc-fab:hover{cursor:pointer}.mdc-fab>svg{width:100%}.mdc-fab--mini{width:40px;height:40px}.mdc-fab--extended{border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;height:48px;line-height:normal}.mdc-fab--extended .mdc-fab__ripple{border-radius:24px}.mdc-fab--extended .mdc-fab__icon{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mdc-fab--extended .mdc-fab__icon,.mdc-fab--extended .mdc-fab__icon[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mdc-fab--extended .mdc-fab__label+.mdc-fab__icon,.mdc-fab--extended .mdc-fab__label+.mdc-fab__icon[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mdc-fab--touch{margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}.mdc-fab--touch .mdc-fab__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mdc-fab::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-fab::before{border-color:CanvasText}}.mdc-fab__label{justify-content:flex-start;text-overflow:ellipsis;white-space:nowrap;overflow-x:hidden;overflow-y:visible}.mdc-fab__icon{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mdc-fab .mdc-fab__icon{display:inline-flex;align-items:center;justify-content:center}.mdc-fab--exited{transform:scale(0);opacity:0;transition:opacity 15ms linear 150ms,transform 180ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-fab--exited .mdc-fab__icon{transform:scale(0);transition:transform 135ms 0ms cubic-bezier(0.4, 0, 1, 1)}.mdc-fab .mdc-fab__icon{width:24px;height:24px;font-size:24px}.mdc-fab:not(.mdc-fab--extended){border-radius:50%}.mdc-fab:not(.mdc-fab--extended) .mdc-fab__ripple{border-radius:50%}.mat-mdc-fab,.mat-mdc-mini-fab{-webkit-tap-highlight-color:rgba(0,0,0,0);background-color:var(--mdc-fab-container-color, transparent);box-shadow:0px 3px 5px -1px rgba(0, 0, 0, 0.2), 0px 6px 10px 0px rgba(0, 0, 0, 0.14), 0px 1px 18px 0px rgba(0, 0, 0, 0.12);color:var(--mat-mdc-fab-color, inherit);flex-shrink:0}.mat-mdc-fab .mat-mdc-button-ripple,.mat-mdc-fab .mat-mdc-button-persistent-ripple,.mat-mdc-fab .mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab .mat-mdc-button-ripple,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-fab .mat-mdc-button-ripple,.mat-mdc-mini-fab .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-fab .mat-mdc-button-persistent-ripple::before,.mat-mdc-mini-fab .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-fab .mat-ripple-element,.mat-mdc-mini-fab .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-fab .mdc-button__label,.mat-mdc-mini-fab .mdc-button__label{z-index:1}.mat-mdc-fab .mat-mdc-focus-indicator,.mat-mdc-mini-fab .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-fab:focus .mat-mdc-focus-indicator::before,.mat-mdc-mini-fab:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-fab .mat-mdc-button-touch-target,.mat-mdc-mini-fab .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mat-mdc-fab._mat-animation-noopable,.mat-mdc-mini-fab._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-fab:not(:disabled) .mdc-fab__icon,.mat-mdc-mini-fab:not(:disabled) .mdc-fab__icon{color:var(--mdc-fab-icon-color, inherit)}.mat-mdc-fab:not(.mdc-fab--extended),.mat-mdc-mini-fab:not(.mdc-fab--extended){border-radius:var(--mdc-fab-container-shape, 50%)}.mat-mdc-fab:not(.mdc-fab--extended) .mdc-fab__ripple,.mat-mdc-mini-fab:not(.mdc-fab--extended) .mdc-fab__ripple{border-radius:var(--mdc-fab-container-shape, 50%)}.mat-mdc-fab:hover,.mat-mdc-fab:focus,.mat-mdc-mini-fab:hover,.mat-mdc-mini-fab:focus{box-shadow:0px 5px 5px -3px rgba(0, 0, 0, 0.2), 0px 8px 10px 1px rgba(0, 0, 0, 0.14), 0px 3px 14px 2px rgba(0, 0, 0, 0.12)}.mat-mdc-fab:active,.mat-mdc-fab:focus:active,.mat-mdc-mini-fab:active,.mat-mdc-mini-fab:focus:active{box-shadow:0px 7px 8px -4px rgba(0, 0, 0, 0.2), 0px 12px 17px 2px rgba(0, 0, 0, 0.14), 0px 5px 22px 4px rgba(0, 0, 0, 0.12)}.mat-mdc-fab[disabled],.mat-mdc-mini-fab[disabled]{cursor:default;pointer-events:none;box-shadow:0px 0px 0px 0px rgba(0, 0, 0, 0.2), 0px 0px 0px 0px rgba(0, 0, 0, 0.14), 0px 0px 0px 0px rgba(0, 0, 0, 0.12)}.mat-mdc-fab:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-mini-fab:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}.mat-mdc-fab .mat-icon,.mat-mdc-fab .material-icons,.mat-mdc-mini-fab .mat-icon,.mat-mdc-mini-fab .material-icons{transition:transform 180ms 90ms cubic-bezier(0, 0, 0.2, 1);fill:currentColor;will-change:transform}.mat-mdc-fab .mat-mdc-focus-indicator::before,.mat-mdc-mini-fab .mat-mdc-focus-indicator::before{margin:calc(calc(var(--mat-mdc-focus-indicator-border-width, 3px) + 2px) * -1)}.mat-mdc-extended-fab{border-radius:24px;padding-left:20px;padding-right:20px;width:auto;max-width:100%;height:48px;line-height:normal}.mat-mdc-extended-fab .mdc-fab__ripple{border-radius:24px}.mat-mdc-extended-fab .mdc-fab__icon{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mat-mdc-extended-fab .mdc-fab__icon,.mat-mdc-extended-fab .mdc-fab__icon[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mat-mdc-extended-fab .mdc-fab__label+.mdc-fab__icon{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mat-mdc-extended-fab .mdc-fab__label+.mdc-fab__icon,.mat-mdc-extended-fab .mdc-fab__label+.mdc-fab__icon[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mat-mdc-extended-fab>.mat-icon,.mat-mdc-extended-fab>.material-icons{margin-left:calc(12px - 20px);margin-right:12px}[dir=rtl] .mat-mdc-extended-fab>.mat-icon,[dir=rtl] .mat-mdc-extended-fab>.material-icons,.mat-mdc-extended-fab>.mat-icon[dir=rtl],.mat-mdc-extended-fab>.material-icons[dir=rtl]{margin-left:12px;margin-right:calc(12px - 20px)}.mat-mdc-extended-fab .mdc-button__label+.mat-icon,.mat-mdc-extended-fab .mdc-button__label+.material-icons{margin-left:12px;margin-right:calc(12px - 20px)}[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.mat-icon,[dir=rtl] .mat-mdc-extended-fab .mdc-button__label+.material-icons,.mat-mdc-extended-fab .mdc-button__label+.mat-icon[dir=rtl],.mat-mdc-extended-fab .mdc-button__label+.material-icons[dir=rtl]{margin-left:calc(12px - 20px);margin-right:12px}.mat-mdc-extended-fab .mat-mdc-button-touch-target{width:100%}'], encapsulation: 2, changeDetection: 0 }), tn })(), Wt = (() => { class tn extends $e { get ripple() { return !this._ripple && this._rippleLoader && (this._ripple = this._rippleLoader._createMatRipple(this._elementRef.nativeElement), this._ripple.centered = !0), this._ripple } constructor(ht, Ae, nt, qt) { super(ht, Ae, nt, qt) } } return tn.\u0275fac = function (ht) { return new (ht || tn)(y.Y36(y.SBq), y.Y36(a.t4), y.Y36(y.R0b), y.Y36(y.QbO, 8)) }, tn.\u0275cmp = y.Xpm({ type: tn, selectors: [["button", "mat-icon-button", ""]], hostAttrs: ["mat-button-ripple-uninitialized", ""], hostVars: 7, hostBindings: function (ht, Ae) { 2 & ht && (y.uIk("disabled", Ae.disabled || null), y.ekj("_mat-animation-noopable", "NoopAnimations" === Ae._animationMode)("mat-unthemed", !Ae.color)("mat-mdc-button-base", !0)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", color: "color" }, exportAs: ["matButton"], features: [y.qOj], attrs: We, ngContentSelectors: Pe, decls: 4, vars: 0, consts: [[1, "mat-mdc-button-persistent-ripple", "mdc-icon-button__ripple"], [1, "mat-mdc-focus-indicator"], [1, "mat-mdc-button-touch-target"]], template: function (ht, Ae) { 1 & ht && (y.F$t(), y._UZ(0, "span", 0), y.Hsn(1), y._UZ(2, "span", 1)(3, "span", 2)) }, styles: ['.mdc-icon-button{display:inline-block;position:relative;box-sizing:border-box;border:none;outline:none;background-color:rgba(0,0,0,0);fill:currentColor;color:inherit;text-decoration:none;cursor:pointer;user-select:none;z-index:0;overflow:visible}.mdc-icon-button .mdc-icon-button__touch{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}@media screen and (forced-colors: active){.mdc-icon-button.mdc-ripple-upgraded--background-focused .mdc-icon-button__focus-ring,.mdc-icon-button:not(.mdc-ripple-upgraded):focus .mdc-icon-button__focus-ring{display:block}}.mdc-icon-button:disabled{cursor:default;pointer-events:none}.mdc-icon-button[hidden]{display:none}.mdc-icon-button--display-flex{align-items:center;display:inline-flex;justify-content:center}.mdc-icon-button__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:100%;width:100%;display:none}@media screen and (forced-colors: active){.mdc-icon-button__focus-ring{border-color:CanvasText}}.mdc-icon-button__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-icon-button__focus-ring::after{border-color:CanvasText}}.mdc-icon-button__icon{display:inline-block}.mdc-icon-button__icon.mdc-icon-button__icon--on{display:none}.mdc-icon-button--on .mdc-icon-button__icon{display:none}.mdc-icon-button--on .mdc-icon-button__icon.mdc-icon-button__icon--on{display:inline-block}.mdc-icon-button__link{height:100%;left:0;outline:none;position:absolute;top:0;width:100%}.mat-mdc-icon-button{height:var(--mdc-icon-button-state-layer-size);width:var(--mdc-icon-button-state-layer-size);color:var(--mdc-icon-button-icon-color);--mdc-icon-button-state-layer-size:48px;--mdc-icon-button-icon-size:24px;--mdc-icon-button-disabled-icon-color:black;--mdc-icon-button-disabled-icon-opacity:0.38}.mat-mdc-icon-button .mdc-button__icon{font-size:var(--mdc-icon-button-icon-size)}.mat-mdc-icon-button svg,.mat-mdc-icon-button img{width:var(--mdc-icon-button-icon-size);height:var(--mdc-icon-button-icon-size)}.mat-mdc-icon-button:disabled{opacity:var(--mdc-icon-button-disabled-icon-opacity)}.mat-mdc-icon-button:disabled{color:var(--mdc-icon-button-disabled-icon-color)}.mat-mdc-icon-button{padding:12px;font-size:var(--mdc-icon-button-icon-size);border-radius:50%;flex-shrink:0;text-align:center;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-icon-button svg{vertical-align:baseline}.mat-mdc-icon-button[disabled]{cursor:default;pointer-events:none;opacity:1}.mat-mdc-icon-button .mat-mdc-button-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple,.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:inherit}.mat-mdc-icon-button .mat-mdc-button-ripple{overflow:hidden}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple::before{content:"";opacity:0;background-color:var(--mat-mdc-button-persistent-ripple-color)}.mat-mdc-icon-button .mat-ripple-element{background-color:var(--mat-mdc-button-ripple-color)}.mat-mdc-icon-button .mdc-button__label{z-index:1}.mat-mdc-icon-button .mat-mdc-focus-indicator{top:0;left:0;right:0;bottom:0;position:absolute}.mat-mdc-icon-button:focus .mat-mdc-focus-indicator::before{content:""}.mat-mdc-icon-button .mat-mdc-button-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}.mat-mdc-icon-button._mat-animation-noopable{transition:none !important;animation:none !important}.mat-mdc-icon-button .mat-mdc-button-persistent-ripple{border-radius:50%}.mat-mdc-icon-button.mat-unthemed:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-primary:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-accent:not(.mdc-ripple-upgraded):focus::before,.mat-mdc-icon-button.mat-warn:not(.mdc-ripple-upgraded):focus::before{background:rgba(0,0,0,0);opacity:1}', _e], encapsulation: 2, changeDetection: 0 }), tn })(), Jt = (() => { class tn { } return tn.\u0275fac = function (ht) { return new (ht || tn) }, tn.\u0275mod = y.oAB({ type: tn }), tn.\u0275inj = y.cJS({ imports: [Y.BQ, Y.si, Y.BQ] }), tn })() }, 5195: (nn, Qe, C) => { C.d(Qe, { $j: () => Oe, G2: () => tt, QW: () => ue, a8: () => Q, dk: () => Pe, dn: () => ze, n5: () => _e }); var a = C(5879), y = C(6814), v = C(3680); const Y = ["*"], ke = [[["", "mat-card-avatar", ""], ["", "matCardAvatar", ""]], [["mat-card-title"], ["mat-card-subtitle"], ["", "mat-card-title", ""], ["", "mat-card-subtitle", ""], ["", "matCardTitle", ""], ["", "matCardSubtitle", ""]], "*"], re = ["[mat-card-avatar], [matCardAvatar]", "mat-card-title, mat-card-subtitle,\n      [mat-card-title], [mat-card-subtitle],\n      [matCardTitle], [matCardSubtitle]", "*"], Ie = new a.OlP("MAT_CARD_CONFIG"); let Q = (() => { class ee { constructor(rt) { this.appearance = rt?.appearance || "raised" } } return ee.\u0275fac = function (rt) { return new (rt || ee)(a.Y36(Ie, 8)) }, ee.\u0275cmp = a.Xpm({ type: ee, selectors: [["mat-card"]], hostAttrs: [1, "mat-mdc-card", "mdc-card"], hostVars: 4, hostBindings: function (rt, Kt) { 2 & rt && a.ekj("mat-mdc-card-outlined", "outlined" === Kt.appearance)("mdc-card--outlined", "outlined" === Kt.appearance) }, inputs: { appearance: "appearance" }, exportAs: ["matCard"], ngContentSelectors: Y, decls: 1, vars: 0, template: function (rt, Kt) { 1 & rt && (a.F$t(), a.Hsn(0)) }, styles: ['.mdc-card{display:flex;flex-direction:column;box-sizing:border-box}.mdc-card::after{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:1px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none;pointer-events:none}@media screen and (forced-colors: active){.mdc-card::after{border-color:CanvasText}}.mdc-card--outlined::after{border:none}.mdc-card__content{border-radius:inherit;height:100%}.mdc-card__media{position:relative;box-sizing:border-box;background-repeat:no-repeat;background-position:center;background-size:cover}.mdc-card__media::before{display:block;content:""}.mdc-card__media:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.mdc-card__media:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.mdc-card__media--square::before{margin-top:100%}.mdc-card__media--16-9::before{margin-top:56.25%}.mdc-card__media-content{position:absolute;top:0;right:0;bottom:0;left:0;box-sizing:border-box}.mdc-card__primary-action{display:flex;flex-direction:column;box-sizing:border-box;position:relative;outline:none;color:inherit;text-decoration:none;cursor:pointer;overflow:hidden}.mdc-card__primary-action:first-child{border-top-left-radius:inherit;border-top-right-radius:inherit}.mdc-card__primary-action:last-child{border-bottom-left-radius:inherit;border-bottom-right-radius:inherit}.mdc-card__actions{display:flex;flex-direction:row;align-items:center;box-sizing:border-box;min-height:52px;padding:8px}.mdc-card__actions--full-bleed{padding:0}.mdc-card__action-buttons,.mdc-card__action-icons{display:flex;flex-direction:row;align-items:center;box-sizing:border-box}.mdc-card__action-icons{color:rgba(0, 0, 0, 0.6);flex-grow:1;justify-content:flex-end}.mdc-card__action-buttons+.mdc-card__action-icons{margin-left:16px;margin-right:0}[dir=rtl] .mdc-card__action-buttons+.mdc-card__action-icons,.mdc-card__action-buttons+.mdc-card__action-icons[dir=rtl]{margin-left:0;margin-right:16px}.mdc-card__action{display:inline-flex;flex-direction:row;align-items:center;box-sizing:border-box;justify-content:center;cursor:pointer;user-select:none}.mdc-card__action:focus{outline:none}.mdc-card__action--button{margin-left:0;margin-right:8px;padding:0 8px}[dir=rtl] .mdc-card__action--button,.mdc-card__action--button[dir=rtl]{margin-left:8px;margin-right:0}.mdc-card__action--button:last-child{margin-left:0;margin-right:0}[dir=rtl] .mdc-card__action--button:last-child,.mdc-card__action--button:last-child[dir=rtl]{margin-left:0;margin-right:0}.mdc-card__actions--full-bleed .mdc-card__action--button{justify-content:space-between;width:100%;height:auto;max-height:none;margin:0;padding:8px 16px;text-align:left}[dir=rtl] .mdc-card__actions--full-bleed .mdc-card__action--button,.mdc-card__actions--full-bleed .mdc-card__action--button[dir=rtl]{text-align:right}.mdc-card__action--icon{margin:-6px 0;padding:12px}.mdc-card__action--icon:not(:disabled){color:rgba(0, 0, 0, 0.6)}.mat-mdc-card{border-radius:var(--mdc-elevated-card-container-shape);background-color:var(--mdc-elevated-card-container-color);border-width:0;border-style:solid;border-color:var(--mdc-elevated-card-container-color);box-shadow:var(--mdc-elevated-card-container-elevation);--mdc-elevated-card-container-shape:4px;--mdc-outlined-card-container-shape:4px;--mdc-outlined-card-outline-width:1px}.mat-mdc-card .mdc-card::after{border-radius:var(--mdc-elevated-card-container-shape)}.mat-mdc-card-outlined{border-width:var(--mdc-outlined-card-outline-width);border-style:solid;border-color:var(--mdc-outlined-card-outline-color);border-radius:var(--mdc-outlined-card-container-shape);background-color:var(--mdc-outlined-card-container-color);box-shadow:var(--mdc-outlined-card-container-elevation)}.mat-mdc-card-outlined .mdc-card::after{border-radius:var(--mdc-outlined-card-container-shape)}.mat-mdc-card-title{font-family:var(--mat-card-title-text-font);line-height:var(--mat-card-title-text-line-height);font-size:var(--mat-card-title-text-size);letter-spacing:var(--mat-card-title-text-tracking);font-weight:var(--mat-card-title-text-weight)}.mat-mdc-card-subtitle{color:var(--mat-card-subtitle-text-color);font-family:var(--mat-card-subtitle-text-font);line-height:var(--mat-card-subtitle-text-line-height);font-size:var(--mat-card-subtitle-text-size);letter-spacing:var(--mat-card-subtitle-text-tracking);font-weight:var(--mat-card-subtitle-text-weight)}.mat-mdc-card{position:relative}.mat-mdc-card-title,.mat-mdc-card-subtitle{display:block;margin:0}.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-title,.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-subtitle{padding:16px 16px 0}.mat-mdc-card-header{display:flex;padding:16px 16px 0}.mat-mdc-card-content{display:block;padding:0 16px}.mat-mdc-card-content:first-child{padding-top:16px}.mat-mdc-card-content:last-child{padding-bottom:16px}.mat-mdc-card-title-group{display:flex;justify-content:space-between;width:100%}.mat-mdc-card-avatar{height:40px;width:40px;border-radius:50%;flex-shrink:0;margin-bottom:16px;object-fit:cover}.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-subtitle,.mat-mdc-card-avatar~.mat-mdc-card-header-text .mat-mdc-card-title{line-height:normal}.mat-mdc-card-sm-image{width:80px;height:80px}.mat-mdc-card-md-image{width:112px;height:112px}.mat-mdc-card-lg-image{width:152px;height:152px}.mat-mdc-card-xl-image{width:240px;height:240px}.mat-mdc-card-subtitle~.mat-mdc-card-title,.mat-mdc-card-title~.mat-mdc-card-subtitle,.mat-mdc-card-header .mat-mdc-card-header-text .mat-mdc-card-title,.mat-mdc-card-header .mat-mdc-card-header-text .mat-mdc-card-subtitle,.mat-mdc-card-title-group .mat-mdc-card-title,.mat-mdc-card-title-group .mat-mdc-card-subtitle{padding-top:0}.mat-mdc-card-content>:last-child:not(.mat-mdc-card-footer){margin-bottom:0}.mat-mdc-card-actions-align-end{justify-content:flex-end}'], encapsulation: 2, changeDetection: 0 }), ee })(), _e = (() => { class ee { } return ee.\u0275fac = function (rt) { return new (rt || ee) }, ee.\u0275dir = a.lG2({ type: ee, selectors: [["mat-card-title"], ["", "mat-card-title", ""], ["", "matCardTitle", ""]], hostAttrs: [1, "mat-mdc-card-title"] }), ee })(), ze = (() => { class ee { } return ee.\u0275fac = function (rt) { return new (rt || ee) }, ee.\u0275dir = a.lG2({ type: ee, selectors: [["mat-card-content"]], hostAttrs: [1, "mat-mdc-card-content"] }), ee })(), Oe = (() => { class ee { } return ee.\u0275fac = function (rt) { return new (rt || ee) }, ee.\u0275dir = a.lG2({ type: ee, selectors: [["mat-card-subtitle"], ["", "mat-card-subtitle", ""], ["", "matCardSubtitle", ""]], hostAttrs: [1, "mat-mdc-card-subtitle"] }), ee })(), Pe = (() => { class ee { } return ee.\u0275fac = function (rt) { return new (rt || ee) }, ee.\u0275cmp = a.Xpm({ type: ee, selectors: [["mat-card-header"]], hostAttrs: [1, "mat-mdc-card-header"], ngContentSelectors: re, decls: 4, vars: 0, consts: [[1, "mat-mdc-card-header-text"]], template: function (rt, Kt) { 1 & rt && (a.F$t(ke), a.Hsn(0), a.TgZ(1, "div", 0), a.Hsn(2, 1), a.qZA(), a.Hsn(3, 2)) }, encapsulation: 2, changeDetection: 0 }), ee })(), tt = (() => { class ee { } return ee.\u0275fac = function (rt) { return new (rt || ee) }, ee.\u0275dir = a.lG2({ type: ee, selectors: [["", "mat-card-image", ""], ["", "matCardImage", ""]], hostAttrs: [1, "mat-mdc-card-image", "mdc-card__media"] }), ee })(), ue = (() => { class ee { } return ee.\u0275fac = function (rt) { return new (rt || ee) }, ee.\u0275mod = a.oAB({ type: ee }), ee.\u0275inj = a.cJS({ imports: [v.BQ, y.ez, v.BQ] }), ee })() }, 3680: (nn, Qe, C) => { C.d(Qe, { yN: () => ut, mZ: () => ie, _A: () => at, rD: () => St, sG: () => vt, K7: () => Mt, HF: () => Ue, Y2: () => se, BQ: () => ge, uc: () => qt, XK: () => Jt, ey: () => In, Ng: () => G, us: () => ve, wG: () => Me, si: () => Xe, IR: () => Fn, CB: () => Et, jH: () => _t, pj: () => Kt, Kr: () => bn, Id: () => rt, FD: () => Mn, dB: () => On, sb: () => Dn }); var a = C(5879), y = C(4191), v = C(9388), he = C(6814), Se = C(2831), ke = C(2495), re = C(5592), Ie = C(8645), Q = C(6028); const ze = ["text"]; function Oe(W, me) { if (1 & W && a._UZ(0, "mat-pseudo-checkbox", 6), 2 & W) { const de = a.oxw(); a.Q6J("disabled", de.disabled)("state", de.selected ? "checked" : "unchecked") } } function We(W, me) { if (1 & W && a._UZ(0, "mat-pseudo-checkbox", 7), 2 & W) { const de = a.oxw(); a.Q6J("disabled", de.disabled) } } function Pe(W, me) { if (1 & W && (a.TgZ(0, "span", 8), a._uU(1), a.qZA()), 2 & W) { const de = a.oxw(); a.xp6(1), a.hij("(", de.group.label, ")") } } const Ve = [[["mat-icon"]], "*"], tt = ["mat-icon", "*"]; let ut = (() => { class W { } return W.STANDARD_CURVE = "cubic-bezier(0.4,0.0,0.2,1)", W.DECELERATION_CURVE = "cubic-bezier(0.0,0.0,0.2,1)", W.ACCELERATION_CURVE = "cubic-bezier(0.4,0.0,1,1)", W.SHARP_CURVE = "cubic-bezier(0.4,0.0,0.6,1)", W })(), ie = (() => { class W { } return W.COMPLEX = "375ms", W.ENTERING = "225ms", W.EXITING = "195ms", W })(); const le = new a.OlP("mat-sanity-checks", { providedIn: "root", factory: function Le() { return !0 } }); let ge = (() => { class W { constructor(de, st, Lt) { this._sanityChecks = st, this._document = Lt, this._hasDoneGlobalChecks = !1, de._applyBodyHighContrastModeCssClasses(), this._hasDoneGlobalChecks || (this._hasDoneGlobalChecks = !0) } _checkIsEnabled(de) { return !(0, Se.Oy)() && ("boolean" == typeof this._sanityChecks ? this._sanityChecks : !!this._sanityChecks[de]) } } return W.\u0275fac = function (de) { return new (de || W)(a.LFG(y.qm), a.LFG(le, 8), a.LFG(he.K0)) }, W.\u0275mod = a.oAB({ type: W }), W.\u0275inj = a.cJS({ imports: [v.vT, v.vT] }), W })(); function rt(W) { return class extends W { get disabled() { return this._disabled } set disabled(me) { this._disabled = (0, ke.Ig)(me) } constructor(...me) { super(...me), this._disabled = !1 } } } function Kt(W, me) { return class extends W { get color() { return this._color } set color(de) { const st = de || this.defaultColor; st !== this._color && (this._color && this._elementRef.nativeElement.classList.remove(`mat-${this._color}`), st && this._elementRef.nativeElement.classList.add(`mat-${st}`), this._color = st) } constructor(...de) { super(...de), this.defaultColor = me, this.color = me } } } function bn(W) { return class extends W { get disableRipple() { return this._disableRipple } set disableRipple(me) { this._disableRipple = (0, ke.Ig)(me) } constructor(...me) { super(...me), this._disableRipple = !1 } } } function Dn(W, me = 0) { return class extends W { get tabIndex() { return this.disabled ? -1 : this._tabIndex } set tabIndex(de) { this._tabIndex = null != de ? (0, ke.su)(de) : this.defaultTabIndex } constructor(...de) { super(...de), this._tabIndex = me, this.defaultTabIndex = me } } } function Mn(W) { return class extends W { updateErrorState() { const me = this.errorState, He = (this.errorStateMatcher || this._defaultErrorStateMatcher).isErrorState(this.ngControl ? this.ngControl.control : null, this._parentFormGroup || this._parentForm); He !== me && (this.errorState = He, this.stateChanges.next()) } constructor(...me) { super(...me), this.errorState = !1 } } } function On(W) { return class extends W { constructor(...me) { super(...me), this._isInitialized = !1, this._pendingSubscribers = [], this.initialized = new re.y(de => { this._isInitialized ? this._notifySubscriber(de) : this._pendingSubscribers.push(de) }) } _markInitialized() { this._isInitialized = !0, this._pendingSubscribers.forEach(this._notifySubscriber), this._pendingSubscribers = null } _notifySubscriber(me) { me.next(), me.complete() } } } const Wn = new a.OlP("MAT_DATE_LOCALE", { providedIn: "root", factory: function Hn() { return (0, a.f3M)(a.soG) } }); class at { constructor() { this._localeChanges = new Ie.x, this.localeChanges = this._localeChanges } getValidDateOrNull(me) { return this.isDateInstance(me) && this.isValid(me) ? me : null } deserialize(me) { return null == me || this.isDateInstance(me) && this.isValid(me) ? me : this.invalid() } setLocale(me) { this.locale = me, this._localeChanges.next() } compareDate(me, de) { return this.getYear(me) - this.getYear(de) || this.getMonth(me) - this.getMonth(de) || this.getDate(me) - this.getDate(de) } sameDate(me, de) { if (me && de) { let st = this.isValid(me), Lt = this.isValid(de); return st && Lt ? !this.compareDate(me, de) : st == Lt } return me == de } clampDate(me, de, st) { return de && this.compareDate(me, de) < 0 ? de : st && this.compareDate(me, st) > 0 ? st : me } } const vt = new a.OlP("mat-date-formats"), xt = /^\d{4}-\d{2}-\d{2}(?:T\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|(?:(?:\+|-)\d{2}:\d{2}))?)?$/; function it(W, me) { const de = Array(W); for (let st = 0; st < W; st++)de[st] = me(st); return de } let Ft = (() => { class W extends at { constructor(de, st) { super(), this.useUtcForDisplay = !1, super.setLocale(de) } getYear(de) { return de.getFullYear() } getMonth(de) { return de.getMonth() } getDate(de) { return de.getDate() } getDayOfWeek(de) { return de.getDay() } getMonthNames(de) { const st = new Intl.DateTimeFormat(this.locale, { month: de, timeZone: "utc" }); return it(12, Lt => this._format(st, new Date(2017, Lt, 1))) } getDateNames() { const de = new Intl.DateTimeFormat(this.locale, { day: "numeric", timeZone: "utc" }); return it(31, st => this._format(de, new Date(2017, 0, st + 1))) } getDayOfWeekNames(de) { const st = new Intl.DateTimeFormat(this.locale, { weekday: de, timeZone: "utc" }); return it(7, Lt => this._format(st, new Date(2017, 0, Lt + 1))) } getYearName(de) { const st = new Intl.DateTimeFormat(this.locale, { year: "numeric", timeZone: "utc" }); return this._format(st, de) } getFirstDayOfWeek() { return 0 } getNumDaysInMonth(de) { return this.getDate(this._createDateWithOverflow(this.getYear(de), this.getMonth(de) + 1, 0)) } clone(de) { return new Date(de.getTime()) } createDate(de, st, Lt) { let He = this._createDateWithOverflow(de, st, Lt); return He.getMonth(), He } today() { return new Date } parse(de, st) { return "number" == typeof de ? new Date(de) : de ? new Date(Date.parse(de)) : null } format(de, st) { if (!this.isValid(de)) throw Error("NativeDateAdapter: Cannot format invalid date."); const Lt = new Intl.DateTimeFormat(this.locale, { ...st, timeZone: "utc" }); return this._format(Lt, de) } addCalendarYears(de, st) { return this.addCalendarMonths(de, 12 * st) } addCalendarMonths(de, st) { let Lt = this._createDateWithOverflow(this.getYear(de), this.getMonth(de) + st, this.getDate(de)); return this.getMonth(Lt) != ((this.getMonth(de) + st) % 12 + 12) % 12 && (Lt = this._createDateWithOverflow(this.getYear(Lt), this.getMonth(Lt), 0)), Lt } addCalendarDays(de, st) { return this._createDateWithOverflow(this.getYear(de), this.getMonth(de), this.getDate(de) + st) } toIso8601(de) { return [de.getUTCFullYear(), this._2digit(de.getUTCMonth() + 1), this._2digit(de.getUTCDate())].join("-") } deserialize(de) { if ("string" == typeof de) { if (!de) return null; if (xt.test(de)) { let st = new Date(de); if (this.isValid(st)) return st } } return super.deserialize(de) } isDateInstance(de) { return de instanceof Date } isValid(de) { return !isNaN(de.getTime()) } invalid() { return new Date(NaN) } _createDateWithOverflow(de, st, Lt) { const He = new Date; return He.setFullYear(de, st, Lt), He.setHours(0, 0, 0, 0), He } _2digit(de) { return ("00" + de).slice(-2) } _format(de, st) { const Lt = new Date; return Lt.setUTCFullYear(st.getFullYear(), st.getMonth(), st.getDate()), Lt.setUTCHours(st.getHours(), st.getMinutes(), st.getSeconds(), st.getMilliseconds()), de.format(Lt) } } return W.\u0275fac = function (de) { return new (de || W)(a.LFG(Wn, 8), a.LFG(Se.t4)) }, W.\u0275prov = a.Yz7({ token: W, factory: W.\u0275fac }), W })(); const Wt = { parse: { dateInput: null }, display: { dateInput: { year: "numeric", month: "numeric", day: "numeric" }, monthYearLabel: { year: "numeric", month: "short" }, dateA11yLabel: { year: "numeric", month: "long", day: "numeric" }, monthYearA11yLabel: { year: "numeric", month: "long" } } }; let rn = (() => { class W { } return W.\u0275fac = function (de) { return new (de || W) }, W.\u0275mod = a.oAB({ type: W }), W.\u0275inj = a.cJS({ providers: [{ provide: at, useClass: Ft }] }), W })(), Jt = (() => { class W { } return W.\u0275fac = function (de) { return new (de || W) }, W.\u0275mod = a.oAB({ type: W }), W.\u0275inj = a.cJS({ providers: [{ provide: vt, useValue: Wt }], imports: [rn] }), W })(), St = (() => { class W { isErrorState(de, st) { return !!(de && de.invalid && (de.touched || st && st.submitted)) } } return W.\u0275fac = function (de) { return new (de || W) }, W.\u0275prov = a.Yz7({ token: W, factory: W.\u0275fac, providedIn: "root" }), W })(), qt = (() => { class W { } return W.\u0275fac = function (de) { return new (de || W) }, W.\u0275mod = a.oAB({ type: W }), W.\u0275inj = a.cJS({ imports: [ge, ge] }), W })(); class jt { constructor(me, de, st, Lt = !1) { this._renderer = me, this.element = de, this.config = st, this._animationForciblyDisabledThroughCss = Lt, this.state = 3 } fadeOut() { this._renderer.fadeOutRipple(this) } } const Pt = (0, Se.i$)({ passive: !0, capture: !0 }); class qe { constructor() { this._events = new Map, this._delegateEventHandler = me => { const de = (0, Se.sA)(me); de && this._events.get(me.type)?.forEach((st, Lt) => { (Lt === de || Lt.contains(de)) && st.forEach(He => He.handleEvent(me)) }) } } addHandler(me, de, st, Lt) { const He = this._events.get(de); if (He) { const ae = He.get(st); ae ? ae.add(Lt) : He.set(st, new Set([Lt])) } else this._events.set(de, new Map([[st, new Set([Lt])]])), me.runOutsideAngular(() => { document.addEventListener(de, this._delegateEventHandler, Pt) }) } removeHandler(me, de, st) { const Lt = this._events.get(me); if (!Lt) return; const He = Lt.get(de); He && (He.delete(st), 0 === He.size && Lt.delete(de), 0 === Lt.size && (this._events.delete(me), document.removeEventListener(me, this._delegateEventHandler, Pt))) } } const Nt = { enterDuration: 225, exitDuration: 150 }, Zt = (0, Se.i$)({ passive: !0, capture: !0 }), gn = ["mousedown", "touchstart"], $n = ["mouseup", "mouseleave", "touchend", "touchcancel"]; class Fn { constructor(me, de, st, Lt) { this._target = me, this._ngZone = de, this._platform = Lt, this._isPointerDown = !1, this._activeRipples = new Map, this._pointerUpEventsRegistered = !1, Lt.isBrowser && (this._containerElement = (0, ke.fI)(st)) } fadeInRipple(me, de, st = {}) { const Lt = this._containerRect = this._containerRect || this._containerElement.getBoundingClientRect(), He = { ...Nt, ...st.animation }; st.centered && (me = Lt.left + Lt.width / 2, de = Lt.top + Lt.height / 2); const ae = st.radius || function Ke(W, me, de) { const st = Math.max(Math.abs(W - de.left), Math.abs(W - de.right)), Lt = Math.max(Math.abs(me - de.top), Math.abs(me - de.bottom)); return Math.sqrt(st * st + Lt * Lt) }(me, de, Lt), z = me - Lt.left, L = de - Lt.top, H = He.enterDuration, Ne = document.createElement("div"); Ne.classList.add("mat-ripple-element"), Ne.style.left = z - ae + "px", Ne.style.top = L - ae + "px", Ne.style.height = 2 * ae + "px", Ne.style.width = 2 * ae + "px", null != st.color && (Ne.style.backgroundColor = st.color), Ne.style.transitionDuration = `${H}ms`, this._containerElement.appendChild(Ne); const pt = window.getComputedStyle(Ne), fe = pt.transitionDuration, F = "none" === pt.transitionProperty || "0s" === fe || "0s, 0s" === fe || 0 === Lt.width && 0 === Lt.height, J = new jt(this, Ne, st, F); Ne.style.transform = "scale3d(1, 1, 1)", J.state = 0, st.persistent || (this._mostRecentTransientRipple = J); let Te = null; return !F && (H || He.exitDuration) && this._ngZone.runOutsideAngular(() => { const lt = () => this._finishRippleTransition(J), gt = () => this._destroyRipple(J); Ne.addEventListener("transitionend", lt), Ne.addEventListener("transitioncancel", gt), Te = { onTransitionEnd: lt, onTransitionCancel: gt } }), this._activeRipples.set(J, Te), (F || !H) && this._finishRippleTransition(J), J } fadeOutRipple(me) { if (2 === me.state || 3 === me.state) return; const de = me.element, st = { ...Nt, ...me.config.animation }; de.style.transitionDuration = `${st.exitDuration}ms`, de.style.opacity = "0", me.state = 2, (me._animationForciblyDisabledThroughCss || !st.exitDuration) && this._finishRippleTransition(me) } fadeOutAll() { this._getActiveRipples().forEach(me => me.fadeOut()) } fadeOutAllNonPersistent() { this._getActiveRipples().forEach(me => { me.config.persistent || me.fadeOut() }) } setupTriggerEvents(me) { const de = (0, ke.fI)(me); !this._platform.isBrowser || !de || de === this._triggerElement || (this._removeTriggerEvents(), this._triggerElement = de, gn.forEach(st => { Fn._eventManager.addHandler(this._ngZone, st, de, this) })) } handleEvent(me) { "mousedown" === me.type ? this._onMousedown(me) : "touchstart" === me.type ? this._onTouchStart(me) : this._onPointerUp(), this._pointerUpEventsRegistered || (this._ngZone.runOutsideAngular(() => { $n.forEach(de => { this._triggerElement.addEventListener(de, this, Zt) }) }), this._pointerUpEventsRegistered = !0) } _finishRippleTransition(me) { 0 === me.state ? this._startFadeOutTransition(me) : 2 === me.state && this._destroyRipple(me) } _startFadeOutTransition(me) { const de = me === this._mostRecentTransientRipple, { persistent: st } = me.config; me.state = 1, !st && (!de || !this._isPointerDown) && me.fadeOut() } _destroyRipple(me) { const de = this._activeRipples.get(me) ?? null; this._activeRipples.delete(me), this._activeRipples.size || (this._containerRect = null), me === this._mostRecentTransientRipple && (this._mostRecentTransientRipple = null), me.state = 3, null !== de && (me.element.removeEventListener("transitionend", de.onTransitionEnd), me.element.removeEventListener("transitioncancel", de.onTransitionCancel)), me.element.remove() } _onMousedown(me) { const de = (0, y.X6)(me), st = this._lastTouchStartEvent && Date.now() < this._lastTouchStartEvent + 800; !this._target.rippleDisabled && !de && !st && (this._isPointerDown = !0, this.fadeInRipple(me.clientX, me.clientY, this._target.rippleConfig)) } _onTouchStart(me) { if (!this._target.rippleDisabled && !(0, y.yG)(me)) { this._lastTouchStartEvent = Date.now(), this._isPointerDown = !0; const de = me.changedTouches; if (de) for (let st = 0; st < de.length; st++)this.fadeInRipple(de[st].clientX, de[st].clientY, this._target.rippleConfig) } } _onPointerUp() { this._isPointerDown && (this._isPointerDown = !1, this._getActiveRipples().forEach(me => { !me.config.persistent && (1 === me.state || me.config.terminateOnPointerUp && 0 === me.state) && me.fadeOut() })) } _getActiveRipples() { return Array.from(this._activeRipples.keys()) } _removeTriggerEvents() { const me = this._triggerElement; me && (gn.forEach(de => Fn._eventManager.removeHandler(de, me, this)), this._pointerUpEventsRegistered && $n.forEach(de => me.removeEventListener(de, this, Zt))) } } Fn._eventManager = new qe; const se = new a.OlP("mat-ripple-global-options"); let Me = (() => { class W { get disabled() { return this._disabled } set disabled(de) { de && this.fadeOutAllNonPersistent(), this._disabled = de, this._setupTriggerEventsIfEnabled() } get trigger() { return this._trigger || this._elementRef.nativeElement } set trigger(de) { this._trigger = de, this._setupTriggerEventsIfEnabled() } constructor(de, st, Lt, He, ae) { this._elementRef = de, this._animationMode = ae, this.radius = 0, this._disabled = !1, this._isInitialized = !1, this._globalOptions = He || {}, this._rippleRenderer = new Fn(this, st, de, Lt) } ngOnInit() { this._isInitialized = !0, this._setupTriggerEventsIfEnabled() } ngOnDestroy() { this._rippleRenderer._removeTriggerEvents() } fadeOutAll() { this._rippleRenderer.fadeOutAll() } fadeOutAllNonPersistent() { this._rippleRenderer.fadeOutAllNonPersistent() } get rippleConfig() { return { centered: this.centered, radius: this.radius, color: this.color, animation: { ...this._globalOptions.animation, ..."NoopAnimations" === this._animationMode ? { enterDuration: 0, exitDuration: 0 } : {}, ...this.animation }, terminateOnPointerUp: this._globalOptions.terminateOnPointerUp } } get rippleDisabled() { return this.disabled || !!this._globalOptions.disabled } _setupTriggerEventsIfEnabled() { !this.disabled && this._isInitialized && this._rippleRenderer.setupTriggerEvents(this.trigger) } launch(de, st = 0, Lt) { return "number" == typeof de ? this._rippleRenderer.fadeInRipple(de, st, { ...this.rippleConfig, ...Lt }) : this._rippleRenderer.fadeInRipple(0, 0, { ...this.rippleConfig, ...de }) } } return W.\u0275fac = function (de) { return new (de || W)(a.Y36(a.SBq), a.Y36(a.R0b), a.Y36(Se.t4), a.Y36(se, 8), a.Y36(a.QbO, 8)) }, W.\u0275dir = a.lG2({ type: W, selectors: [["", "mat-ripple", ""], ["", "matRipple", ""]], hostAttrs: [1, "mat-ripple"], hostVars: 2, hostBindings: function (de, st) { 2 & de && a.ekj("mat-ripple-unbounded", st.unbounded) }, inputs: { color: ["matRippleColor", "color"], unbounded: ["matRippleUnbounded", "unbounded"], centered: ["matRippleCentered", "centered"], radius: ["matRippleRadius", "radius"], animation: ["matRippleAnimation", "animation"], disabled: ["matRippleDisabled", "disabled"], trigger: ["matRippleTrigger", "trigger"] }, exportAs: ["matRipple"] }), W })(), Xe = (() => { class W { } return W.\u0275fac = function (de) { return new (de || W) }, W.\u0275mod = a.oAB({ type: W }), W.\u0275inj = a.cJS({ imports: [ge, ge] }), W })(), Ot = (() => { class W { constructor(de) { this._animationMode = de, this.state = "unchecked", this.disabled = !1, this.appearance = "full" } } return W.\u0275fac = function (de) { return new (de || W)(a.Y36(a.QbO, 8)) }, W.\u0275cmp = a.Xpm({ type: W, selectors: [["mat-pseudo-checkbox"]], hostAttrs: [1, "mat-pseudo-checkbox"], hostVars: 12, hostBindings: function (de, st) { 2 & de && a.ekj("mat-pseudo-checkbox-indeterminate", "indeterminate" === st.state)("mat-pseudo-checkbox-checked", "checked" === st.state)("mat-pseudo-checkbox-disabled", st.disabled)("mat-pseudo-checkbox-minimal", "minimal" === st.appearance)("mat-pseudo-checkbox-full", "full" === st.appearance)("_mat-animation-noopable", "NoopAnimations" === st._animationMode) }, inputs: { state: "state", disabled: "disabled", appearance: "appearance" }, decls: 0, vars: 0, template: function (de, st) { }, styles: ['.mat-pseudo-checkbox{border-radius:2px;cursor:pointer;display:inline-block;vertical-align:middle;box-sizing:border-box;position:relative;flex-shrink:0;transition:border-color 90ms cubic-bezier(0, 0, 0.2, 0.1),background-color 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox::after{position:absolute;opacity:0;content:"";border-bottom:2px solid currentColor;transition:opacity 90ms cubic-bezier(0, 0, 0.2, 0.1)}.mat-pseudo-checkbox._mat-animation-noopable{transition:none !important;animation:none !important}.mat-pseudo-checkbox._mat-animation-noopable::after{transition:none}.mat-pseudo-checkbox-disabled{cursor:default}.mat-pseudo-checkbox-indeterminate::after{left:1px;opacity:1;border-radius:2px}.mat-pseudo-checkbox-checked::after{left:1px;border-left:2px solid currentColor;transform:rotate(-45deg);opacity:1;box-sizing:content-box}.mat-pseudo-checkbox-full{border:2px solid}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked,.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate{border-color:rgba(0,0,0,0)}.mat-pseudo-checkbox{width:18px;height:18px}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-checked::after{width:14px;height:6px;transform-origin:center;top:-4.2426406871px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-minimal.mat-pseudo-checkbox-indeterminate::after{top:8px;width:16px}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-checked::after{width:10px;height:4px;transform-origin:center;top:-2.8284271247px;left:0;bottom:0;right:0;margin:auto}.mat-pseudo-checkbox-full.mat-pseudo-checkbox-indeterminate::after{top:6px;width:12px}'], encapsulation: 2, changeDetection: 0 }), W })(), ve = (() => { class W { } return W.\u0275fac = function (de) { return new (de || W) }, W.\u0275mod = a.oAB({ type: W }), W.\u0275inj = a.cJS({ imports: [ge] }), W })(); const Ue = new a.OlP("MAT_OPTION_PARENT_COMPONENT"), Mt = new a.OlP("MatOptgroup"); let fn = 0; class En { constructor(me, de = !1) { this.source = me, this.isUserInput = de } } let Ln = (() => { class W { get multiple() { return this._parent && this._parent.multiple } get selected() { return this._selected } get disabled() { return this.group && this.group.disabled || this._disabled } set disabled(de) { this._disabled = (0, ke.Ig)(de) } get disableRipple() { return !(!this._parent || !this._parent.disableRipple) } get hideSingleSelectionIndicator() { return !(!this._parent || !this._parent.hideSingleSelectionIndicator) } constructor(de, st, Lt, He) { this._element = de, this._changeDetectorRef = st, this._parent = Lt, this.group = He, this._selected = !1, this._active = !1, this._disabled = !1, this._mostRecentViewValue = "", this.id = "mat-option-" + fn++, this.onSelectionChange = new a.vpe, this._stateChanges = new Ie.x } get active() { return this._active } get viewValue() { return (this._text?.nativeElement.textContent || "").trim() } select(de = !0) { this._selected || (this._selected = !0, this._changeDetectorRef.markForCheck(), de && this._emitSelectionChangeEvent()) } deselect(de = !0) { this._selected && (this._selected = !1, this._changeDetectorRef.markForCheck(), de && this._emitSelectionChangeEvent()) } focus(de, st) { const Lt = this._getHostElement(); "function" == typeof Lt.focus && Lt.focus(st) } setActiveStyles() { this._active || (this._active = !0, this._changeDetectorRef.markForCheck()) } setInactiveStyles() { this._active && (this._active = !1, this._changeDetectorRef.markForCheck()) } getLabel() { return this.viewValue } _handleKeydown(de) { (de.keyCode === Q.K5 || de.keyCode === Q.L_) && !(0, Q.Vb)(de) && (this._selectViaInteraction(), de.preventDefault()) } _selectViaInteraction() { this.disabled || (this._selected = !this.multiple || !this._selected, this._changeDetectorRef.markForCheck(), this._emitSelectionChangeEvent(!0)) } _getTabIndex() { return this.disabled ? "-1" : "0" } _getHostElement() { return this._element.nativeElement } ngAfterViewChecked() { if (this._selected) { const de = this.viewValue; de !== this._mostRecentViewValue && (this._mostRecentViewValue && this._stateChanges.next(), this._mostRecentViewValue = de) } } ngOnDestroy() { this._stateChanges.complete() } _emitSelectionChangeEvent(de = !1) { this.onSelectionChange.emit(new En(this, de)) } } return W.\u0275fac = function (de) { a.$Z() }, W.\u0275dir = a.lG2({ type: W, viewQuery: function (de, st) { if (1 & de && a.Gf(ze, 7), 2 & de) { let Lt; a.iGM(Lt = a.CRH()) && (st._text = Lt.first) } }, inputs: { value: "value", id: "id", disabled: "disabled" }, outputs: { onSelectionChange: "onSelectionChange" } }), W })(), In = (() => { class W extends Ln { constructor(de, st, Lt, He) { super(de, st, Lt, He) } } return W.\u0275fac = function (de) { return new (de || W)(a.Y36(a.SBq), a.Y36(a.sBO), a.Y36(Ue, 8), a.Y36(Mt, 8)) }, W.\u0275cmp = a.Xpm({ type: W, selectors: [["mat-option"]], hostAttrs: ["role", "option", 1, "mat-mdc-option", "mdc-list-item"], hostVars: 11, hostBindings: function (de, st) { 1 & de && a.NdJ("click", function () { return st._selectViaInteraction() })("keydown", function (He) { return st._handleKeydown(He) }), 2 & de && (a.Ikx("id", st.id), a.uIk("aria-selected", st.selected)("aria-disabled", st.disabled.toString()), a.ekj("mdc-list-item--selected", st.selected)("mat-mdc-option-multiple", st.multiple)("mat-mdc-option-active", st.active)("mdc-list-item--disabled", st.disabled)) }, exportAs: ["matOption"], features: [a.qOj], ngContentSelectors: tt, decls: 8, vars: 5, consts: [["class", "mat-mdc-option-pseudo-checkbox", "aria-hidden", "true", 3, "disabled", "state", 4, "ngIf"], [1, "mdc-list-item__primary-text"], ["text", ""], ["class", "mat-mdc-option-pseudo-checkbox", "state", "checked", "aria-hidden", "true", "appearance", "minimal", 3, "disabled", 4, "ngIf"], ["class", "cdk-visually-hidden", 4, "ngIf"], ["aria-hidden", "true", "mat-ripple", "", 1, "mat-mdc-option-ripple", "mat-mdc-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled"], ["aria-hidden", "true", 1, "mat-mdc-option-pseudo-checkbox", 3, "disabled", "state"], ["state", "checked", "aria-hidden", "true", "appearance", "minimal", 1, "mat-mdc-option-pseudo-checkbox", 3, "disabled"], [1, "cdk-visually-hidden"]], template: function (de, st) { 1 & de && (a.F$t(Ve), a.YNc(0, Oe, 1, 2, "mat-pseudo-checkbox", 0), a.Hsn(1), a.TgZ(2, "span", 1, 2), a.Hsn(4, 1), a.qZA(), a.YNc(5, We, 1, 1, "mat-pseudo-checkbox", 3), a.YNc(6, Pe, 2, 1, "span", 4), a._UZ(7, "div", 5)), 2 & de && (a.Q6J("ngIf", st.multiple), a.xp6(5), a.Q6J("ngIf", !st.multiple && st.selected && !st.hideSingleSelectionIndicator), a.xp6(1), a.Q6J("ngIf", st.group && st.group._inert), a.xp6(1), a.Q6J("matRippleTrigger", st._getHostElement())("matRippleDisabled", st.disabled || st.disableRipple)) }, dependencies: [Me, he.O5, Ot], styles: ['.mat-mdc-option{display:flex;position:relative;align-items:center;justify-content:flex-start;overflow:hidden;padding:0;padding-left:16px;padding-right:16px;-webkit-user-select:none;user-select:none;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased;cursor:pointer;-webkit-tap-highlight-color:rgba(0,0,0,0);color:var(--mat-option-label-text-color);font-family:var(--mat-option-label-text-font);line-height:var(--mat-option-label-text-line-height);font-size:var(--mat-option-label-text-size);letter-spacing:var(--mat-option-label-text-tracking);font-weight:var(--mat-option-label-text-weight);min-height:48px}.mat-mdc-option:focus{outline:none}[dir=rtl] .mat-mdc-option,.mat-mdc-option[dir=rtl]{padding-left:16px;padding-right:16px}.mat-mdc-option:hover:not(.mdc-list-item--disabled){background-color:var(--mat-option-hover-state-layer-color)}.mat-mdc-option:focus.mdc-list-item,.mat-mdc-option.mat-mdc-option-active.mdc-list-item{background-color:var(--mat-option-focus-state-layer-color)}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled) .mdc-list-item__primary-text{color:var(--mat-option-selected-state-label-text-color)}.mat-mdc-option.mdc-list-item--selected:not(.mdc-list-item--disabled):not(.mat-mdc-option-multiple){background-color:var(--mat-option-selected-state-layer-color)}.mat-mdc-option.mdc-list-item{align-items:center}.mat-mdc-option.mdc-list-item--disabled{cursor:default;pointer-events:none}.mat-mdc-option.mdc-list-item--disabled .mat-mdc-option-pseudo-checkbox,.mat-mdc-option.mdc-list-item--disabled .mdc-list-item__primary-text,.mat-mdc-option.mdc-list-item--disabled>mat-icon{opacity:.38}.mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:32px}[dir=rtl] .mat-mdc-optgroup .mat-mdc-option:not(.mat-mdc-option-multiple){padding-left:16px;padding-right:32px}.mat-mdc-option .mat-icon,.mat-mdc-option .mat-pseudo-checkbox-full{margin-right:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-icon,[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-full{margin-right:0;margin-left:16px}.mat-mdc-option .mat-pseudo-checkbox-minimal{margin-left:16px;flex-shrink:0}[dir=rtl] .mat-mdc-option .mat-pseudo-checkbox-minimal{margin-right:16px;margin-left:0}.mat-mdc-option .mat-mdc-option-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none}.mat-mdc-option .mdc-list-item__primary-text{white-space:normal;font-size:inherit;font-weight:inherit;letter-spacing:inherit;line-height:inherit;font-family:inherit;text-decoration:inherit;text-transform:inherit;margin-right:auto}[dir=rtl] .mat-mdc-option .mdc-list-item__primary-text{margin-right:0;margin-left:auto}.cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{content:"";position:absolute;top:50%;right:16px;transform:translateY(-50%);width:10px;height:0;border-bottom:solid 10px;border-radius:10px}[dir=rtl] .cdk-high-contrast-active .mat-mdc-option.mdc-list-item--selected:not(.mat-mdc-option-multiple)::after{right:auto;left:16px}.mat-mdc-option-active .mat-mdc-focus-indicator::before{content:""}'], encapsulation: 2, changeDetection: 0 }), W })(); function Et(W, me, de) { if (de.length) { let st = me.toArray(), Lt = de.toArray(), He = 0; for (let ae = 0; ae < W + 1; ae++)st[ae].group && st[ae].group === Lt[He] && He++; return He } return 0 } function _t(W, me, de, st) { return W < de ? W : W + me > de + st ? Math.max(0, W - st + me) : de } let G = (() => { class W { } return W.\u0275fac = function (de) { return new (de || W) }, W.\u0275mod = a.oAB({ type: W }), W.\u0275inj = a.cJS({ imports: [Xe, he.ez, ge, ve] }), W })() }, 7700: (nn, Qe, C) => { C.d(Qe, { WI: () => ht, uw: () => on, H8: () => Ke, ZT: () => gn, xY: () => Fn, Is: () => Me, so: () => tn, uh: () => $n }); var a = C(3651), y = C(6814), v = C(5879), Y = C(4191), he = C(2831), Se = C(8484), ke = C(6028), re = C(8645), Ie = C(4911), Q = C(2096), _e = C(9388), xe = C(7921); function ze(ve, Ue) { } class Oe { constructor() { this.role = "dialog", this.panelClass = "", this.hasBackdrop = !0, this.backdropClass = "", this.disableClose = !1, this.width = "", this.height = "", this.data = null, this.ariaDescribedBy = null, this.ariaLabelledBy = null, this.ariaLabel = null, this.ariaModal = !0, this.autoFocus = "first-tabbable", this.restoreFocus = !0, this.closeOnNavigation = !0, this.closeOnDestroy = !0, this.closeOnOverlayDetachments = !0 } } let Pe = (() => { class ve extends Se.en { constructor(Z, Fe, ct, Mt, Qt, fn, En, Ln) { super(), this._elementRef = Z, this._focusTrapFactory = Fe, this._config = Mt, this._interactivityChecker = Qt, this._ngZone = fn, this._overlayRef = En, this._focusMonitor = Ln, this._elementFocusedBeforeDialogWasOpened = null, this._closeInteractionType = null, this.attachDomPortal = In => { this._portalOutlet.hasAttached(); const Et = this._portalOutlet.attachDomPortal(In); return this._contentAttached(), Et }, this._ariaLabelledBy = this._config.ariaLabelledBy || null, this._document = ct } _contentAttached() { this._initializeFocusTrap(), this._handleBackdropClicks(), this._captureInitialFocus() } _captureInitialFocus() { this._trapFocus() } ngOnDestroy() { this._restoreFocus() } attachComponentPortal(Z) { this._portalOutlet.hasAttached(); const Fe = this._portalOutlet.attachComponentPortal(Z); return this._contentAttached(), Fe } attachTemplatePortal(Z) { this._portalOutlet.hasAttached(); const Fe = this._portalOutlet.attachTemplatePortal(Z); return this._contentAttached(), Fe } _recaptureFocus() { this._containsFocus() || this._trapFocus() } _forceFocus(Z, Fe) { this._interactivityChecker.isFocusable(Z) || (Z.tabIndex = -1, this._ngZone.runOutsideAngular(() => { const ct = () => { Z.removeEventListener("blur", ct), Z.removeEventListener("mousedown", ct), Z.removeAttribute("tabindex") }; Z.addEventListener("blur", ct), Z.addEventListener("mousedown", ct) })), Z.focus(Fe) } _focusByCssSelector(Z, Fe) { let ct = this._elementRef.nativeElement.querySelector(Z); ct && this._forceFocus(ct, Fe) } _trapFocus() { const Z = this._elementRef.nativeElement; switch (this._config.autoFocus) { case !1: case "dialog": this._containsFocus() || Z.focus(); break; case !0: case "first-tabbable": this._focusTrap.focusInitialElementWhenReady().then(Fe => { Fe || this._focusDialogContainer() }); break; case "first-heading": this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]'); break; default: this._focusByCssSelector(this._config.autoFocus) } } _restoreFocus() { const Z = this._config.restoreFocus; let Fe = null; if ("string" == typeof Z ? Fe = this._document.querySelector(Z) : "boolean" == typeof Z ? Fe = Z ? this._elementFocusedBeforeDialogWasOpened : null : Z && (Fe = Z), this._config.restoreFocus && Fe && "function" == typeof Fe.focus) { const ct = (0, he.ht)(), Mt = this._elementRef.nativeElement; (!ct || ct === this._document.body || ct === Mt || Mt.contains(ct)) && (this._focusMonitor ? (this._focusMonitor.focusVia(Fe, this._closeInteractionType), this._closeInteractionType = null) : Fe.focus()) } this._focusTrap && this._focusTrap.destroy() } _focusDialogContainer() { this._elementRef.nativeElement.focus && this._elementRef.nativeElement.focus() } _containsFocus() { const Z = this._elementRef.nativeElement, Fe = (0, he.ht)(); return Z === Fe || Z.contains(Fe) } _initializeFocusTrap() { this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement), this._document && (this._elementFocusedBeforeDialogWasOpened = (0, he.ht)()) } _handleBackdropClicks() { this._overlayRef.backdropClick().subscribe(() => { this._config.disableClose && this._recaptureFocus() }) } } return ve.\u0275fac = function (Z) { return new (Z || ve)(v.Y36(v.SBq), v.Y36(Y.qV), v.Y36(y.K0, 8), v.Y36(Oe), v.Y36(Y.ic), v.Y36(v.R0b), v.Y36(a.Iu), v.Y36(Y.tE)) }, ve.\u0275cmp = v.Xpm({ type: ve, selectors: [["cdk-dialog-container"]], viewQuery: function (Z, Fe) { if (1 & Z && v.Gf(Se.Pl, 7), 2 & Z) { let ct; v.iGM(ct = v.CRH()) && (Fe._portalOutlet = ct.first) } }, hostAttrs: ["tabindex", "-1", 1, "cdk-dialog-container"], hostVars: 6, hostBindings: function (Z, Fe) { 2 & Z && v.uIk("id", Fe._config.id || null)("role", Fe._config.role)("aria-modal", Fe._config.ariaModal)("aria-labelledby", Fe._config.ariaLabel ? null : Fe._ariaLabelledBy)("aria-label", Fe._config.ariaLabel)("aria-describedby", Fe._config.ariaDescribedBy || null) }, features: [v.qOj], decls: 1, vars: 0, consts: [["cdkPortalOutlet", ""]], template: function (Z, Fe) { 1 & Z && v.YNc(0, ze, 0, 0, "ng-template", 0) }, dependencies: [Se.Pl], styles: [".cdk-dialog-container{display:block;width:100%;height:100%;min-height:inherit;max-height:inherit}"], encapsulation: 2 }), ve })(); class Ve { constructor(Ue, Z) { this.overlayRef = Ue, this.config = Z, this.closed = new re.x, this.disableClose = Z.disableClose, this.backdropClick = Ue.backdropClick(), this.keydownEvents = Ue.keydownEvents(), this.outsidePointerEvents = Ue.outsidePointerEvents(), this.id = Z.id, this.keydownEvents.subscribe(Fe => { Fe.keyCode === ke.hY && !this.disableClose && !(0, ke.Vb)(Fe) && (Fe.preventDefault(), this.close(void 0, { focusOrigin: "keyboard" })) }), this.backdropClick.subscribe(() => { this.disableClose || this.close(void 0, { focusOrigin: "mouse" }) }), this._detachSubscription = Ue.detachments().subscribe(() => { !1 !== Z.closeOnOverlayDetachments && this.close() }) } close(Ue, Z) { if (this.containerInstance) { const Fe = this.closed; this.containerInstance._closeInteractionType = Z?.focusOrigin || "program", this._detachSubscription.unsubscribe(), this.overlayRef.dispose(), Fe.next(Ue), Fe.complete(), this.componentInstance = this.containerInstance = null } } updatePosition() { return this.overlayRef.updatePosition(), this } updateSize(Ue = "", Z = "") { return this.overlayRef.updateSize({ width: Ue, height: Z }), this } addPanelClass(Ue) { return this.overlayRef.addPanelClass(Ue), this } removePanelClass(Ue) { return this.overlayRef.removePanelClass(Ue), this } } const tt = new v.OlP("DialogScrollStrategy"), Ye = new v.OlP("DialogData"), ut = new v.OlP("DefaultDialogConfig"), Le = { provide: tt, deps: [a.aV], useFactory: function ie(ve) { return () => ve.scrollStrategies.block() } }; let le = 0, ge = (() => { class ve { get openDialogs() { return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel } get afterOpened() { return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel } constructor(Z, Fe, ct, Mt, Qt, fn) { this._overlay = Z, this._injector = Fe, this._defaultOptions = ct, this._parentDialog = Mt, this._overlayContainer = Qt, this._openDialogsAtThisLevel = [], this._afterAllClosedAtThisLevel = new re.x, this._afterOpenedAtThisLevel = new re.x, this._ariaHiddenElements = new Map, this.afterAllClosed = (0, Ie.P)(() => this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe((0, xe.O)(void 0))), this._scrollStrategy = fn } open(Z, Fe) { (Fe = { ...this._defaultOptions || new Oe, ...Fe }).id = Fe.id || "cdk-dialog-" + le++, Fe.id && this.getDialogById(Fe.id); const Mt = this._getOverlayConfig(Fe), Qt = this._overlay.create(Mt), fn = new Ve(Qt, Fe), En = this._attachContainer(Qt, fn, Fe); return fn.containerInstance = En, this._attachDialogContent(Z, fn, En, Fe), this.openDialogs.length || this._hideNonDialogContentFromAssistiveTechnology(), this.openDialogs.push(fn), fn.closed.subscribe(() => this._removeOpenDialog(fn, !0)), this.afterOpened.next(fn), fn } closeAll() { ue(this.openDialogs, Z => Z.close()) } getDialogById(Z) { return this.openDialogs.find(Fe => Fe.id === Z) } ngOnDestroy() { ue(this._openDialogsAtThisLevel, Z => { !1 === Z.config.closeOnDestroy && this._removeOpenDialog(Z, !1) }), ue(this._openDialogsAtThisLevel, Z => Z.close()), this._afterAllClosedAtThisLevel.complete(), this._afterOpenedAtThisLevel.complete(), this._openDialogsAtThisLevel = [] } _getOverlayConfig(Z) { const Fe = new a.X_({ positionStrategy: Z.positionStrategy || this._overlay.position().global().centerHorizontally().centerVertically(), scrollStrategy: Z.scrollStrategy || this._scrollStrategy(), panelClass: Z.panelClass, hasBackdrop: Z.hasBackdrop, direction: Z.direction, minWidth: Z.minWidth, minHeight: Z.minHeight, maxWidth: Z.maxWidth, maxHeight: Z.maxHeight, width: Z.width, height: Z.height, disposeOnNavigation: Z.closeOnNavigation }); return Z.backdropClass && (Fe.backdropClass = Z.backdropClass), Fe } _attachContainer(Z, Fe, ct) { const Mt = ct.injector || ct.viewContainerRef?.injector, Qt = [{ provide: Oe, useValue: ct }, { provide: Ve, useValue: Fe }, { provide: a.Iu, useValue: Z }]; let fn; ct.container ? "function" == typeof ct.container ? fn = ct.container : (fn = ct.container.type, Qt.push(...ct.container.providers(ct))) : fn = Pe; const En = new Se.C5(fn, ct.viewContainerRef, v.zs3.create({ parent: Mt || this._injector, providers: Qt }), ct.componentFactoryResolver); return Z.attach(En).instance } _attachDialogContent(Z, Fe, ct, Mt) { if (Z instanceof v.Rgc) { const Qt = this._createInjector(Mt, Fe, ct, void 0); let fn = { $implicit: Mt.data, dialogRef: Fe }; Mt.templateContext && (fn = { ...fn, ..."function" == typeof Mt.templateContext ? Mt.templateContext() : Mt.templateContext }), ct.attachTemplatePortal(new Se.UE(Z, null, fn, Qt)) } else { const Qt = this._createInjector(Mt, Fe, ct, this._injector), fn = ct.attachComponentPortal(new Se.C5(Z, Mt.viewContainerRef, Qt, Mt.componentFactoryResolver)); Fe.componentInstance = fn.instance } } _createInjector(Z, Fe, ct, Mt) { const Qt = Z.injector || Z.viewContainerRef?.injector, fn = [{ provide: Ye, useValue: Z.data }, { provide: Ve, useValue: Fe }]; return Z.providers && ("function" == typeof Z.providers ? fn.push(...Z.providers(Fe, Z, ct)) : fn.push(...Z.providers)), Z.direction && (!Qt || !Qt.get(_e.Is, null, { optional: !0 })) && fn.push({ provide: _e.Is, useValue: { value: Z.direction, change: (0, Q.of)() } }), v.zs3.create({ parent: Qt || Mt, providers: fn }) } _removeOpenDialog(Z, Fe) { const ct = this.openDialogs.indexOf(Z); ct > -1 && (this.openDialogs.splice(ct, 1), this.openDialogs.length || (this._ariaHiddenElements.forEach((Mt, Qt) => { Mt ? Qt.setAttribute("aria-hidden", Mt) : Qt.removeAttribute("aria-hidden") }), this._ariaHiddenElements.clear(), Fe && this._getAfterAllClosed().next())) } _hideNonDialogContentFromAssistiveTechnology() { const Z = this._overlayContainer.getContainerElement(); if (Z.parentElement) { const Fe = Z.parentElement.children; for (let ct = Fe.length - 1; ct > -1; ct--) { const Mt = Fe[ct]; Mt !== Z && "SCRIPT" !== Mt.nodeName && "STYLE" !== Mt.nodeName && !Mt.hasAttribute("aria-live") && (this._ariaHiddenElements.set(Mt, Mt.getAttribute("aria-hidden")), Mt.setAttribute("aria-hidden", "true")) } } } _getAfterAllClosed() { const Z = this._parentDialog; return Z ? Z._getAfterAllClosed() : this._afterAllClosedAtThisLevel } } return ve.\u0275fac = function (Z) { return new (Z || ve)(v.LFG(a.aV), v.LFG(v.zs3), v.LFG(ut, 8), v.LFG(ve, 12), v.LFG(a.Xj), v.LFG(tt)) }, ve.\u0275prov = v.Yz7({ token: ve, factory: ve.\u0275fac }), ve })(); function ue(ve, Ue) { let Z = ve.length; for (; Z--;)Ue(ve[Z]) } let ee = (() => { class ve { } return ve.\u0275fac = function (Z) { return new (Z || ve) }, ve.\u0275mod = v.oAB({ type: ve }), ve.\u0275inj = v.cJS({ providers: [ge, Le], imports: [a.U8, Se.eL, Y.rt, Se.eL] }), ve })(); var $e = C(2495), rt = C(3019), Kt = C(2181), bn = C(8180), Dn = C(3680); function On(ve, Ue) { } C(6825); class Wn { constructor() { this.role = "dialog", this.panelClass = "", this.hasBackdrop = !0, this.backdropClass = "", this.disableClose = !1, this.width = "", this.height = "", this.maxWidth = "80vw", this.data = null, this.ariaDescribedBy = null, this.ariaLabelledBy = null, this.ariaLabel = null, this.ariaModal = !0, this.autoFocus = "first-tabbable", this.restoreFocus = !0, this.delayFocusTrap = !0, this.closeOnNavigation = !0 } } const Hn = "mdc-dialog--open", at = "mdc-dialog--opening", vt = "mdc-dialog--closing"; let Ft = (() => { class ve extends Pe { constructor(Z, Fe, ct, Mt, Qt, fn, En, Ln) { super(Z, Fe, ct, Mt, Qt, fn, En, Ln), this._animationStateChanged = new v.vpe } _captureInitialFocus() { this._config.delayFocusTrap || this._trapFocus() } _openAnimationDone(Z) { this._config.delayFocusTrap && this._trapFocus(), this._animationStateChanged.next({ state: "opened", totalTime: Z }) } } return ve.\u0275fac = function (Z) { return new (Z || ve)(v.Y36(v.SBq), v.Y36(Y.qV), v.Y36(y.K0, 8), v.Y36(Wn), v.Y36(Y.ic), v.Y36(v.R0b), v.Y36(a.Iu), v.Y36(Y.tE)) }, ve.\u0275cmp = v.Xpm({ type: ve, selectors: [["ng-component"]], features: [v.qOj], decls: 0, vars: 0, template: function (Z, Fe) { }, encapsulation: 2 }), ve })(); const Wt = "--mat-dialog-transition-duration"; function rn(ve) { return null == ve ? null : "number" == typeof ve ? ve : ve.endsWith("ms") ? (0, $e.su)(ve.substring(0, ve.length - 2)) : ve.endsWith("s") ? 1e3 * (0, $e.su)(ve.substring(0, ve.length - 1)) : "0" === ve ? 0 : null } let Jt = (() => { class ve extends Ft { constructor(Z, Fe, ct, Mt, Qt, fn, En, Ln, In) { super(Z, Fe, ct, Mt, Qt, fn, En, In), this._animationMode = Ln, this._animationsEnabled = "NoopAnimations" !== this._animationMode, this._hostElement = this._elementRef.nativeElement, this._enterAnimationDuration = this._animationsEnabled ? rn(this._config.enterAnimationDuration) ?? 150 : 0, this._exitAnimationDuration = this._animationsEnabled ? rn(this._config.exitAnimationDuration) ?? 75 : 0, this._animationTimer = null, this._finishDialogOpen = () => { this._clearAnimationClasses(), this._openAnimationDone(this._enterAnimationDuration) }, this._finishDialogClose = () => { this._clearAnimationClasses(), this._animationStateChanged.emit({ state: "closed", totalTime: this._exitAnimationDuration }) } } _contentAttached() { super._contentAttached(), this._startOpenAnimation() } ngOnDestroy() { super.ngOnDestroy(), null !== this._animationTimer && clearTimeout(this._animationTimer) } _startOpenAnimation() { this._animationStateChanged.emit({ state: "opening", totalTime: this._enterAnimationDuration }), this._animationsEnabled ? (this._hostElement.style.setProperty(Wt, `${this._enterAnimationDuration}ms`), this._requestAnimationFrame(() => this._hostElement.classList.add(at, Hn)), this._waitForAnimationToComplete(this._enterAnimationDuration, this._finishDialogOpen)) : (this._hostElement.classList.add(Hn), Promise.resolve().then(() => this._finishDialogOpen())) } _startExitAnimation() { this._animationStateChanged.emit({ state: "closing", totalTime: this._exitAnimationDuration }), this._hostElement.classList.remove(Hn), this._animationsEnabled ? (this._hostElement.style.setProperty(Wt, `${this._exitAnimationDuration}ms`), this._requestAnimationFrame(() => this._hostElement.classList.add(vt)), this._waitForAnimationToComplete(this._exitAnimationDuration, this._finishDialogClose)) : Promise.resolve().then(() => this._finishDialogClose()) } _clearAnimationClasses() { this._hostElement.classList.remove(at, vt) } _waitForAnimationToComplete(Z, Fe) { null !== this._animationTimer && clearTimeout(this._animationTimer), this._animationTimer = setTimeout(Fe, Z) } _requestAnimationFrame(Z) { this._ngZone.runOutsideAngular(() => { "function" == typeof requestAnimationFrame ? requestAnimationFrame(Z) : Z() }) } } return ve.\u0275fac = function (Z) { return new (Z || ve)(v.Y36(v.SBq), v.Y36(Y.qV), v.Y36(y.K0, 8), v.Y36(Wn), v.Y36(Y.ic), v.Y36(v.R0b), v.Y36(a.Iu), v.Y36(v.QbO, 8), v.Y36(Y.tE)) }, ve.\u0275cmp = v.Xpm({ type: ve, selectors: [["mat-dialog-container"]], hostAttrs: ["tabindex", "-1", 1, "mat-mdc-dialog-container", "mdc-dialog"], hostVars: 8, hostBindings: function (Z, Fe) { 2 & Z && (v.Ikx("id", Fe._config.id), v.uIk("aria-modal", Fe._config.ariaModal)("role", Fe._config.role)("aria-labelledby", Fe._config.ariaLabel ? null : Fe._ariaLabelledBy)("aria-label", Fe._config.ariaLabel)("aria-describedby", Fe._config.ariaDescribedBy || null), v.ekj("_mat-animation-noopable", !Fe._animationsEnabled)) }, features: [v.qOj], decls: 3, vars: 0, consts: [[1, "mdc-dialog__container"], [1, "mat-mdc-dialog-surface", "mdc-dialog__surface"], ["cdkPortalOutlet", ""]], template: function (Z, Fe) { 1 & Z && (v.TgZ(0, "div", 0)(1, "div", 1), v.YNc(2, On, 0, 0, "ng-template", 2), v.qZA()()) }, dependencies: [Se.Pl], styles: ['.mdc-elevation-overlay{position:absolute;border-radius:inherit;pointer-events:none;opacity:var(--mdc-elevation-overlay-opacity, 0);transition:opacity 280ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-dialog,.mdc-dialog__scrim{position:fixed;top:0;left:0;align-items:center;justify-content:center;box-sizing:border-box;width:100%;height:100%}.mdc-dialog{display:none;z-index:var(--mdc-dialog-z-index, 7)}.mdc-dialog .mdc-dialog__content{padding:20px 24px 20px 24px}.mdc-dialog .mdc-dialog__surface{min-width:280px}@media(max-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:calc(100vw - 32px)}}@media(min-width: 592px){.mdc-dialog .mdc-dialog__surface{max-width:560px}}.mdc-dialog .mdc-dialog__surface{max-height:calc(100% - 32px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-width:none}@media(max-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px;width:560px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 112px)}}@media(max-width: 720px)and (min-width: 672px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:560px}}@media(max-width: 720px)and (max-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:calc(100vh - 160px)}}@media(max-width: 720px)and (min-height: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{max-height:560px}}@media(max-width: 720px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}@media(max-width: 720px)and (max-height: 400px),(max-width: 600px),(min-width: 720px)and (max-height: 400px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{height:100%;max-height:100vh;max-width:100vw;width:100vw;border-radius:0}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{order:-1;left:-12px}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__header{padding:0 16px 9px;justify-content:flex-start}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__title{margin-left:calc(16px - 2 * 12px)}}@media(min-width: 960px){.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface{width:calc(100vw - 400px)}.mdc-dialog.mdc-dialog--fullscreen .mdc-dialog__surface .mdc-dialog__close{right:-12px}}.mdc-dialog.mdc-dialog__scrim--hidden .mdc-dialog__scrim{opacity:0}.mdc-dialog__scrim{opacity:0;z-index:-1}.mdc-dialog__container{display:flex;flex-direction:row;align-items:center;justify-content:space-around;box-sizing:border-box;height:100%;transform:scale(0.8);opacity:0;pointer-events:none}.mdc-dialog__surface{position:relative;display:flex;flex-direction:column;flex-grow:0;flex-shrink:0;box-sizing:border-box;max-width:100%;max-height:100%;pointer-events:auto;overflow-y:auto;outline:0}.mdc-dialog__surface .mdc-elevation-overlay{width:100%;height:100%;top:0;left:0}[dir=rtl] .mdc-dialog__surface,.mdc-dialog__surface[dir=rtl]{text-align:right}@media screen and (forced-colors: active),(-ms-high-contrast: active){.mdc-dialog__surface{outline:2px solid windowText}}.mdc-dialog__surface::before{position:absolute;box-sizing:border-box;width:100%;height:100%;top:0;left:0;border:2px solid rgba(0,0,0,0);border-radius:inherit;content:"";pointer-events:none}@media screen and (forced-colors: active){.mdc-dialog__surface::before{border-color:CanvasText}}@media screen and (-ms-high-contrast: active),screen and (-ms-high-contrast: none){.mdc-dialog__surface::before{content:none}}.mdc-dialog__title{display:block;margin-top:0;position:relative;flex-shrink:0;box-sizing:border-box;margin:0 0 1px;padding:0 24px 9px}.mdc-dialog__title::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}[dir=rtl] .mdc-dialog__title,.mdc-dialog__title[dir=rtl]{text-align:right}.mdc-dialog--scrollable .mdc-dialog__title{margin-bottom:1px;padding-bottom:15px}.mdc-dialog--fullscreen .mdc-dialog__header{align-items:baseline;border-bottom:1px solid rgba(0,0,0,0);display:inline-flex;justify-content:space-between;padding:0 24px 9px;z-index:1}@media screen and (forced-colors: active){.mdc-dialog--fullscreen .mdc-dialog__header{border-bottom-color:CanvasText}}.mdc-dialog--fullscreen .mdc-dialog__header .mdc-dialog__close{right:-12px}.mdc-dialog--fullscreen .mdc-dialog__title{margin-bottom:0;padding:0;border-bottom:0}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__title{border-bottom:0;margin-bottom:0}.mdc-dialog--fullscreen .mdc-dialog__close{top:5px}.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog--fullscreen.mdc-dialog--scrollable .mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--fullscreen--titleless .mdc-dialog__close{margin-top:4px}.mdc-dialog--fullscreen--titleless.mdc-dialog--scrollable .mdc-dialog__close{margin-top:0}.mdc-dialog__content{flex-grow:1;box-sizing:border-box;margin:0;overflow:auto}.mdc-dialog__content>:first-child{margin-top:0}.mdc-dialog__content>:last-child{margin-bottom:0}.mdc-dialog__title+.mdc-dialog__content,.mdc-dialog__header+.mdc-dialog__content{padding-top:0}.mdc-dialog--scrollable .mdc-dialog__title+.mdc-dialog__content{padding-top:8px;padding-bottom:8px}.mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:6px 0 0}.mdc-dialog--scrollable .mdc-dialog__content .mdc-deprecated-list:first-child:last-child{padding:0}.mdc-dialog__actions{display:flex;position:relative;flex-shrink:0;flex-wrap:wrap;align-items:center;justify-content:flex-end;box-sizing:border-box;min-height:52px;margin:0;padding:8px;border-top:1px solid rgba(0,0,0,0)}@media screen and (forced-colors: active){.mdc-dialog__actions{border-top-color:CanvasText}}.mdc-dialog--stacked .mdc-dialog__actions{flex-direction:column;align-items:flex-end}.mdc-dialog__button{margin-left:8px;margin-right:0;max-width:100%;text-align:right}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{margin-left:0;margin-right:8px}.mdc-dialog__button:first-child{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button:first-child,.mdc-dialog__button:first-child[dir=rtl]{margin-left:0;margin-right:0}[dir=rtl] .mdc-dialog__button,.mdc-dialog__button[dir=rtl]{text-align:left}.mdc-dialog--stacked .mdc-dialog__button:not(:first-child){margin-top:12px}.mdc-dialog--open,.mdc-dialog--opening,.mdc-dialog--closing{display:flex}.mdc-dialog--opening .mdc-dialog__scrim{transition:opacity 150ms linear}.mdc-dialog--opening .mdc-dialog__container{transition:opacity 75ms linear,transform 150ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-dialog--closing .mdc-dialog__scrim,.mdc-dialog--closing .mdc-dialog__container{transition:opacity 75ms linear}.mdc-dialog--closing .mdc-dialog__container{transform:none}.mdc-dialog--open .mdc-dialog__scrim{opacity:1}.mdc-dialog--open .mdc-dialog__container{transform:none;opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim{opacity:1}.mdc-dialog--open.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{transition:opacity 75ms linear}.mdc-dialog--open.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim{transition:opacity 150ms linear}.mdc-dialog__surface-scrim{display:none;opacity:0;position:absolute;width:100%;height:100%;z-index:1}.mdc-dialog__surface-scrim--shown .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--showing .mdc-dialog__surface-scrim,.mdc-dialog__surface-scrim--hiding .mdc-dialog__surface-scrim{display:block}.mdc-dialog-scroll-lock{overflow:hidden}.mdc-dialog--no-content-padding .mdc-dialog__content{padding:0}.mdc-dialog--sheet .mdc-dialog__container .mdc-dialog__close{right:12px;top:9px;position:absolute;z-index:1}.mdc-dialog__scrim--removed{pointer-events:none}.mdc-dialog__scrim--removed .mdc-dialog__scrim,.mdc-dialog__scrim--removed .mdc-dialog__surface-scrim{display:none}.mat-mdc-dialog-content{max-height:65vh}.mat-mdc-dialog-container{position:static;display:block}.mat-mdc-dialog-container,.mat-mdc-dialog-container .mdc-dialog__container,.mat-mdc-dialog-container .mdc-dialog__surface{max-height:inherit;min-height:inherit;min-width:inherit;max-width:inherit}.mat-mdc-dialog-container .mdc-dialog__surface{display:block;width:100%;height:100%}.mat-mdc-dialog-container{--mdc-dialog-container-elevation-shadow:0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12);--mdc-dialog-container-shadow-color:#000;--mdc-dialog-container-shape:4px;--mdc-dialog-container-elevation: var(--mdc-dialog-container-elevation-shadow);outline:0}.mat-mdc-dialog-container .mdc-dialog__surface{background-color:var(--mdc-dialog-container-color, white)}.mat-mdc-dialog-container .mdc-dialog__surface{box-shadow:var(--mdc-dialog-container-elevation, 0px 11px 15px -7px rgba(0, 0, 0, 0.2), 0px 24px 38px 3px rgba(0, 0, 0, 0.14), 0px 9px 46px 8px rgba(0, 0, 0, 0.12))}.mat-mdc-dialog-container .mdc-dialog__surface{border-radius:var(--mdc-dialog-container-shape, 4px)}.mat-mdc-dialog-container .mdc-dialog__title{font-family:var(--mdc-dialog-subhead-font, Roboto, sans-serif);line-height:var(--mdc-dialog-subhead-line-height, 1.5rem);font-size:var(--mdc-dialog-subhead-size, 1rem);font-weight:var(--mdc-dialog-subhead-weight, 400);letter-spacing:var(--mdc-dialog-subhead-tracking, 0.03125em)}.mat-mdc-dialog-container .mdc-dialog__title{color:var(--mdc-dialog-subhead-color, rgba(0, 0, 0, 0.87))}.mat-mdc-dialog-container .mdc-dialog__content{font-family:var(--mdc-dialog-supporting-text-font, Roboto, sans-serif);line-height:var(--mdc-dialog-supporting-text-line-height, 1.5rem);font-size:var(--mdc-dialog-supporting-text-size, 1rem);font-weight:var(--mdc-dialog-supporting-text-weight, 400);letter-spacing:var(--mdc-dialog-supporting-text-tracking, 0.03125em)}.mat-mdc-dialog-container .mdc-dialog__content{color:var(--mdc-dialog-supporting-text-color, rgba(0, 0, 0, 0.6))}.mat-mdc-dialog-container .mdc-dialog__container{transition-duration:var(--mat-dialog-transition-duration, 0ms)}.mat-mdc-dialog-container._mat-animation-noopable .mdc-dialog__container{transition:none}.mat-mdc-dialog-content{display:block}.mat-mdc-dialog-actions{justify-content:start}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-center,.mat-mdc-dialog-actions[align=center]{justify-content:center}.mat-mdc-dialog-actions.mat-mdc-dialog-actions-align-end,.mat-mdc-dialog-actions[align=end]{justify-content:flex-end}.mat-mdc-dialog-actions .mat-button-base+.mat-button-base,.mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:8px}[dir=rtl] .mat-mdc-dialog-actions .mat-button-base+.mat-button-base,[dir=rtl] .mat-mdc-dialog-actions .mat-mdc-button-base+.mat-mdc-button-base{margin-left:0;margin-right:8px}'], encapsulation: 2 }), ve })(); class tn { constructor(Ue, Z, Fe) { this._ref = Ue, this._containerInstance = Fe, this._afterOpened = new re.x, this._beforeClosed = new re.x, this._state = 0, this.disableClose = Z.disableClose, this.id = Ue.id, Fe._animationStateChanged.pipe((0, Kt.h)(ct => "opened" === ct.state), (0, bn.q)(1)).subscribe(() => { this._afterOpened.next(), this._afterOpened.complete() }), Fe._animationStateChanged.pipe((0, Kt.h)(ct => "closed" === ct.state), (0, bn.q)(1)).subscribe(() => { clearTimeout(this._closeFallbackTimeout), this._finishDialogClose() }), Ue.overlayRef.detachments().subscribe(() => { this._beforeClosed.next(this._result), this._beforeClosed.complete(), this._finishDialogClose() }), (0, rt.T)(this.backdropClick(), this.keydownEvents().pipe((0, Kt.h)(ct => ct.keyCode === ke.hY && !this.disableClose && !(0, ke.Vb)(ct)))).subscribe(ct => { this.disableClose || (ct.preventDefault(), St(this, "keydown" === ct.type ? "keyboard" : "mouse")) }) } close(Ue) { this._result = Ue, this._containerInstance._animationStateChanged.pipe((0, Kt.h)(Z => "closing" === Z.state), (0, bn.q)(1)).subscribe(Z => { this._beforeClosed.next(Ue), this._beforeClosed.complete(), this._ref.overlayRef.detachBackdrop(), this._closeFallbackTimeout = setTimeout(() => this._finishDialogClose(), Z.totalTime + 100) }), this._state = 1, this._containerInstance._startExitAnimation() } afterOpened() { return this._afterOpened } afterClosed() { return this._ref.closed } beforeClosed() { return this._beforeClosed } backdropClick() { return this._ref.backdropClick } keydownEvents() { return this._ref.keydownEvents } updatePosition(Ue) { let Z = this._ref.config.positionStrategy; return Ue && (Ue.left || Ue.right) ? Ue.left ? Z.left(Ue.left) : Z.right(Ue.right) : Z.centerHorizontally(), Ue && (Ue.top || Ue.bottom) ? Ue.top ? Z.top(Ue.top) : Z.bottom(Ue.bottom) : Z.centerVertically(), this._ref.updatePosition(), this } updateSize(Ue = "", Z = "") { return this._ref.updateSize(Ue, Z), this } addPanelClass(Ue) { return this._ref.addPanelClass(Ue), this } removePanelClass(Ue) { return this._ref.removePanelClass(Ue), this } getState() { return this._state } _finishDialogClose() { this._state = 2, this._ref.close(this._result, { focusOrigin: this._closeInteractionType }), this.componentInstance = null } } function St(ve, Ue, Z) { return ve._closeInteractionType = Ue, ve.close(Z) } const ht = new v.OlP("MatMdcDialogData"), Ae = new v.OlP("mat-mdc-dialog-default-options"), nt = new v.OlP("mat-mdc-dialog-scroll-strategy"), jt = { provide: nt, deps: [a.aV], useFactory: function qt(ve) { return () => ve.scrollStrategies.block() } }; let qe = 0, Nt = (() => { class ve { get openDialogs() { return this._parentDialog ? this._parentDialog.openDialogs : this._openDialogsAtThisLevel } get afterOpened() { return this._parentDialog ? this._parentDialog.afterOpened : this._afterOpenedAtThisLevel } _getAfterAllClosed() { const Z = this._parentDialog; return Z ? Z._getAfterAllClosed() : this._afterAllClosedAtThisLevel } constructor(Z, Fe, ct, Mt, Qt, fn, En, Ln, In, Et) { this._overlay = Z, this._defaultOptions = ct, this._parentDialog = Mt, this._dialogRefConstructor = En, this._dialogContainerType = Ln, this._dialogDataToken = In, this._openDialogsAtThisLevel = [], this._afterAllClosedAtThisLevel = new re.x, this._afterOpenedAtThisLevel = new re.x, this._idPrefix = "mat-dialog-", this.dialogConfigClass = Wn, this.afterAllClosed = (0, Ie.P)(() => this.openDialogs.length ? this._getAfterAllClosed() : this._getAfterAllClosed().pipe((0, xe.O)(void 0))), this._scrollStrategy = fn, this._dialog = Fe.get(ge) } open(Z, Fe) { let ct; (Fe = { ...this._defaultOptions || new Wn, ...Fe }).id = Fe.id || `${this._idPrefix}${qe++}`, Fe.scrollStrategy = Fe.scrollStrategy || this._scrollStrategy(); const Mt = this._dialog.open(Z, { ...Fe, positionStrategy: this._overlay.position().global().centerHorizontally().centerVertically(), disableClose: !0, closeOnDestroy: !1, closeOnOverlayDetachments: !1, container: { type: this._dialogContainerType, providers: () => [{ provide: this.dialogConfigClass, useValue: Fe }, { provide: Oe, useValue: Fe }] }, templateContext: () => ({ dialogRef: ct }), providers: (Qt, fn, En) => (ct = new this._dialogRefConstructor(Qt, Fe, En), ct.updatePosition(Fe?.position), [{ provide: this._dialogContainerType, useValue: En }, { provide: this._dialogDataToken, useValue: fn.data }, { provide: this._dialogRefConstructor, useValue: ct }]) }); return ct.componentInstance = Mt.componentInstance, this.openDialogs.push(ct), this.afterOpened.next(ct), ct.afterClosed().subscribe(() => { const Qt = this.openDialogs.indexOf(ct); Qt > -1 && (this.openDialogs.splice(Qt, 1), this.openDialogs.length || this._getAfterAllClosed().next()) }), ct } closeAll() { this._closeDialogs(this.openDialogs) } getDialogById(Z) { return this.openDialogs.find(Fe => Fe.id === Z) } ngOnDestroy() { this._closeDialogs(this._openDialogsAtThisLevel), this._afterAllClosedAtThisLevel.complete(), this._afterOpenedAtThisLevel.complete() } _closeDialogs(Z) { let Fe = Z.length; for (; Fe--;)Z[Fe].close() } } return ve.\u0275fac = function (Z) { v.$Z() }, ve.\u0275prov = v.Yz7({ token: ve, factory: ve.\u0275fac }), ve })(), on = (() => { class ve extends Nt { constructor(Z, Fe, ct, Mt, Qt, fn, En, Ln) { super(Z, Fe, Mt, fn, En, Qt, tn, Jt, ht, Ln), this._idPrefix = "mat-mdc-dialog-" } } return ve.\u0275fac = function (Z) { return new (Z || ve)(v.LFG(a.aV), v.LFG(v.zs3), v.LFG(y.Ye, 8), v.LFG(Ae, 8), v.LFG(nt), v.LFG(ve, 12), v.LFG(a.Xj), v.LFG(v.QbO, 8)) }, ve.\u0275prov = v.Yz7({ token: ve, factory: ve.\u0275fac }), ve })(), Zt = 0, gn = (() => { class ve { constructor(Z, Fe, ct) { this.dialogRef = Z, this._elementRef = Fe, this._dialog = ct, this.type = "button" } ngOnInit() { this.dialogRef || (this.dialogRef = se(this._elementRef, this._dialog.openDialogs)) } ngOnChanges(Z) { const Fe = Z._matDialogClose || Z._matDialogCloseResult; Fe && (this.dialogResult = Fe.currentValue) } _onButtonClick(Z) { St(this.dialogRef, 0 === Z.screenX && 0 === Z.screenY ? "keyboard" : "mouse", this.dialogResult) } } return ve.\u0275fac = function (Z) { return new (Z || ve)(v.Y36(tn, 8), v.Y36(v.SBq), v.Y36(on)) }, ve.\u0275dir = v.lG2({ type: ve, selectors: [["", "mat-dialog-close", ""], ["", "matDialogClose", ""]], hostVars: 2, hostBindings: function (Z, Fe) { 1 & Z && v.NdJ("click", function (Mt) { return Fe._onButtonClick(Mt) }), 2 & Z && v.uIk("aria-label", Fe.ariaLabel || null)("type", Fe.type) }, inputs: { ariaLabel: ["aria-label", "ariaLabel"], type: "type", dialogResult: ["mat-dialog-close", "dialogResult"], _matDialogClose: ["matDialogClose", "_matDialogClose"] }, exportAs: ["matDialogClose"], features: [v.TTD] }), ve })(), $n = (() => { class ve { constructor(Z, Fe, ct) { this._dialogRef = Z, this._elementRef = Fe, this._dialog = ct, this.id = "mat-mdc-dialog-title-" + Zt++ } ngOnInit() { this._dialogRef || (this._dialogRef = se(this._elementRef, this._dialog.openDialogs)), this._dialogRef && Promise.resolve().then(() => { const Z = this._dialogRef._containerInstance; Z && !Z._ariaLabelledBy && (Z._ariaLabelledBy = this.id) }) } } return ve.\u0275fac = function (Z) { return new (Z || ve)(v.Y36(tn, 8), v.Y36(v.SBq), v.Y36(on)) }, ve.\u0275dir = v.lG2({ type: ve, selectors: [["", "mat-dialog-title", ""], ["", "matDialogTitle", ""]], hostAttrs: [1, "mat-mdc-dialog-title", "mdc-dialog__title"], hostVars: 1, hostBindings: function (Z, Fe) { 2 & Z && v.Ikx("id", Fe.id) }, inputs: { id: "id" }, exportAs: ["matDialogTitle"] }), ve })(), Fn = (() => { class ve { } return ve.\u0275fac = function (Z) { return new (Z || ve) }, ve.\u0275dir = v.lG2({ type: ve, selectors: [["", "mat-dialog-content", ""], ["mat-dialog-content"], ["", "matDialogContent", ""]], hostAttrs: [1, "mat-mdc-dialog-content", "mdc-dialog__content"] }), ve })(), Ke = (() => { class ve { constructor() { this.align = "start" } } return ve.\u0275fac = function (Z) { return new (Z || ve) }, ve.\u0275dir = v.lG2({ type: ve, selectors: [["", "mat-dialog-actions", ""], ["mat-dialog-actions"], ["", "matDialogActions", ""]], hostAttrs: [1, "mat-mdc-dialog-actions", "mdc-dialog__actions"], hostVars: 4, hostBindings: function (Z, Fe) { 2 & Z && v.ekj("mat-mdc-dialog-actions-align-center", "center" === Fe.align)("mat-mdc-dialog-actions-align-end", "end" === Fe.align) }, inputs: { align: "align" } }), ve })(); function se(ve, Ue) { let Z = ve.nativeElement.parentElement; for (; Z && !Z.classList.contains("mat-mdc-dialog-container");)Z = Z.parentElement; return Z ? Ue.find(Fe => Fe.id === Z.id) : null } let Me = (() => { class ve { } return ve.\u0275fac = function (Z) { return new (Z || ve) }, ve.\u0275mod = v.oAB({ type: ve }), ve.\u0275inj = v.cJS({ providers: [on, jt], imports: [ee, a.U8, Se.eL, Dn.BQ, Dn.BQ] }), ve })() }, 4170: (nn, Qe, C) => { C.d(Qe, { G_: () => Z, TO: () => Ae, KE: () => Ln, Eo: () => Xe, lN: () => In, hX: () => tn, R9: () => Nt }); var a = C(5879), y = C(9388), v = C(2831), Y = C(7394), he = C(8645), Se = C(3019), ke = C(9773), re = C(5592), Ie = C(2181), Q = C(7081); class xe { constructor(_t) { this._box = _t, this._destroyed = new he.x, this._resizeSubject = new he.x, this._elementObservables = new Map, typeof ResizeObserver < "u" && (this._resizeObserver = new ResizeObserver(G => this._resizeSubject.next(G))) } observe(_t) { return this._elementObservables.has(_t) || this._elementObservables.set(_t, new re.y(G => { const W = this._resizeSubject.subscribe(G); return this._resizeObserver?.observe(_t, { box: this._box }), () => { this._resizeObserver?.unobserve(_t), W.unsubscribe(), this._elementObservables.delete(_t) } }).pipe((0, Ie.h)(G => G.some(W => W.target === _t)), (0, Q.d)({ bufferSize: 1, refCount: !0 }), (0, ke.R)(this._destroyed))), this._elementObservables.get(_t) } destroy() { this._destroyed.next(), this._destroyed.complete(), this._resizeSubject.complete(), this._elementObservables.clear() } } let ze = (() => { class Et { constructor() { this._observers = new Map, this._ngZone = (0, a.f3M)(a.R0b) } ngOnDestroy() { for (const [, G] of this._observers) G.destroy(); this._observers.clear() } observe(G, W) { const me = W?.box || "content-box"; return this._observers.has(me) || this._observers.set(me, new xe(me)), this._observers.get(me).observe(G) } } return Et.\u0275fac = function (G) { return new (G || Et) }, Et.\u0275prov = a.Yz7({ token: Et, factory: Et.\u0275fac, providedIn: "root" }), Et })(); var Oe = C(2495), We = C(6825), Pe = C(6814), Ve = C(7131), tt = C(3680); const Ye = ["notch"], ut = ["matFormFieldNotchedOutline", ""], ie = ["*"], Le = ["textField"], le = ["iconPrefixContainer"], ge = ["textPrefixContainer"]; function ue(Et, _t) { 1 & Et && a._UZ(0, "span", 19) } function ee(Et, _t) { if (1 & Et && (a.TgZ(0, "label", 17), a.Hsn(1, 1), a.YNc(2, ue, 1, 0, "span", 18), a.qZA()), 2 & Et) { const G = a.oxw(2); a.Q6J("floating", G._shouldLabelFloat())("monitorResize", G._hasOutline())("id", G._labelId), a.uIk("for", G._control.id)("aria-owns", G._control.id), a.xp6(2), a.Q6J("ngIf", !G.hideRequiredMarker && G._control.required) } } function $e(Et, _t) { if (1 & Et && a.YNc(0, ee, 3, 6, "label", 16), 2 & Et) { const G = a.oxw(); a.Q6J("ngIf", G._hasFloatingLabel()) } } function rt(Et, _t) { 1 & Et && a._UZ(0, "div", 20) } function Kt(Et, _t) { } function bn(Et, _t) { if (1 & Et && a.YNc(0, Kt, 0, 0, "ng-template", 22), 2 & Et) { a.oxw(2); const G = a.MAs(1); a.Q6J("ngTemplateOutlet", G) } } function Dn(Et, _t) { if (1 & Et && (a.TgZ(0, "div", 21), a.YNc(1, bn, 1, 1, "ng-template", 9), a.qZA()), 2 & Et) { const G = a.oxw(); a.Q6J("matFormFieldNotchedOutlineOpen", G._shouldLabelFloat()), a.xp6(1), a.Q6J("ngIf", !G._forceDisplayInfixLabel()) } } function Mn(Et, _t) { 1 & Et && (a.TgZ(0, "div", 23, 24), a.Hsn(2, 2), a.qZA()) } function On(Et, _t) { 1 & Et && (a.TgZ(0, "div", 25, 26), a.Hsn(2, 3), a.qZA()) } function Wn(Et, _t) { } function Hn(Et, _t) { if (1 & Et && a.YNc(0, Wn, 0, 0, "ng-template", 22), 2 & Et) { a.oxw(); const G = a.MAs(1); a.Q6J("ngTemplateOutlet", G) } } function at(Et, _t) { 1 & Et && (a.TgZ(0, "div", 27), a.Hsn(1, 4), a.qZA()) } function vt(Et, _t) { 1 & Et && (a.TgZ(0, "div", 28), a.Hsn(1, 5), a.qZA()) } function xt(Et, _t) { 1 & Et && a._UZ(0, "div", 29) } function it(Et, _t) { if (1 & Et && (a.TgZ(0, "div", 30), a.Hsn(1, 6), a.qZA()), 2 & Et) { const G = a.oxw(); a.Q6J("@transitionMessages", G._subscriptAnimationState) } } function Ft(Et, _t) { if (1 & Et && (a.TgZ(0, "mat-hint", 34), a._uU(1), a.qZA()), 2 & Et) { const G = a.oxw(2); a.Q6J("id", G._hintLabelId), a.xp6(1), a.Oqu(G.hintLabel) } } function Wt(Et, _t) { if (1 & Et && (a.TgZ(0, "div", 31), a.YNc(1, Ft, 2, 2, "mat-hint", 32), a.Hsn(2, 7), a._UZ(3, "div", 33), a.Hsn(4, 8), a.qZA()), 2 & Et) { const G = a.oxw(); a.Q6J("@transitionMessages", G._subscriptAnimationState), a.xp6(1), a.Q6J("ngIf", G.hintLabel) } } const rn = ["*", [["mat-label"]], [["", "matPrefix", ""], ["", "matIconPrefix", ""]], [["", "matTextPrefix", ""]], [["", "matTextSuffix", ""]], [["", "matSuffix", ""], ["", "matIconSuffix", ""]], [["mat-error"], ["", "matError", ""]], [["mat-hint", 3, "align", "end"]], [["mat-hint", "align", "end"]]], Jt = ["*", "mat-label", "[matPrefix], [matIconPrefix]", "[matTextPrefix]", "[matTextSuffix]", "[matSuffix], [matIconSuffix]", "mat-error, [matError]", "mat-hint:not([align='end'])", "mat-hint[align='end']"]; let tn = (() => { class Et { } return Et.\u0275fac = function (G) { return new (G || Et) }, Et.\u0275dir = a.lG2({ type: Et, selectors: [["mat-label"]] }), Et })(), St = 0; const ht = new a.OlP("MatError"); let Ae = (() => { class Et { constructor(G, W) { this.id = "mat-mdc-error-" + St++, G || W.nativeElement.setAttribute("aria-live", "polite") } } return Et.\u0275fac = function (G) { return new (G || Et)(a.$8M("aria-live"), a.Y36(a.SBq)) }, Et.\u0275dir = a.lG2({ type: Et, selectors: [["mat-error"], ["", "matError", ""]], hostAttrs: ["aria-atomic", "true", 1, "mat-mdc-form-field-error", "mat-mdc-form-field-bottom-align"], hostVars: 1, hostBindings: function (G, W) { 2 & G && a.Ikx("id", W.id) }, inputs: { id: "id" }, features: [a._Bn([{ provide: ht, useExisting: Et }])] }), Et })(), nt = 0, qt = (() => { class Et { constructor() { this.align = "start", this.id = "mat-mdc-hint-" + nt++ } } return Et.\u0275fac = function (G) { return new (G || Et) }, Et.\u0275dir = a.lG2({ type: Et, selectors: [["mat-hint"]], hostAttrs: [1, "mat-mdc-form-field-hint", "mat-mdc-form-field-bottom-align"], hostVars: 4, hostBindings: function (G, W) { 2 & G && (a.Ikx("id", W.id), a.uIk("align", null), a.ekj("mat-mdc-form-field-hint-end", "end" === W.align)) }, inputs: { align: "align", id: "id" } }), Et })(); const jt = new a.OlP("MatPrefix"), qe = new a.OlP("MatSuffix"); let Nt = (() => { class Et { constructor() { this._isText = !1 } set _isTextSelector(G) { this._isText = !0 } } return Et.\u0275fac = function (G) { return new (G || Et) }, Et.\u0275dir = a.lG2({ type: Et, selectors: [["", "matSuffix", ""], ["", "matIconSuffix", ""], ["", "matTextSuffix", ""]], inputs: { _isTextSelector: ["matTextSuffix", "_isTextSelector"] }, features: [a._Bn([{ provide: qe, useExisting: Et }])] }), Et })(); const on = new a.OlP("FloatingLabelParent"); let Zt = (() => { class Et { get floating() { return this._floating } set floating(G) { this._floating = G, this.monitorResize && this._handleResize() } get monitorResize() { return this._monitorResize } set monitorResize(G) { this._monitorResize = G, this._monitorResize ? this._subscribeToResize() : this._resizeSubscription.unsubscribe() } constructor(G) { this._elementRef = G, this._floating = !1, this._monitorResize = !1, this._resizeObserver = (0, a.f3M)(ze), this._ngZone = (0, a.f3M)(a.R0b), this._parent = (0, a.f3M)(on), this._resizeSubscription = new Y.w0 } ngOnDestroy() { this._resizeSubscription.unsubscribe() } getWidth() { return function gn(Et) { if (null !== Et.offsetParent) return Et.scrollWidth; const G = Et.cloneNode(!0); G.style.setProperty("position", "absolute"), G.style.setProperty("transform", "translate(-9999px, -9999px)"), document.documentElement.appendChild(G); const W = G.scrollWidth; return G.remove(), W }(this._elementRef.nativeElement) } get element() { return this._elementRef.nativeElement } _handleResize() { setTimeout(() => this._parent._handleLabelResized()) } _subscribeToResize() { this._resizeSubscription.unsubscribe(), this._ngZone.runOutsideAngular(() => { this._resizeSubscription = this._resizeObserver.observe(this._elementRef.nativeElement, { box: "border-box" }).subscribe(() => this._handleResize()) }) } } return Et.\u0275fac = function (G) { return new (G || Et)(a.Y36(a.SBq)) }, Et.\u0275dir = a.lG2({ type: Et, selectors: [["label", "matFormFieldFloatingLabel", ""]], hostAttrs: [1, "mdc-floating-label", "mat-mdc-floating-label"], hostVars: 2, hostBindings: function (G, W) { 2 & G && a.ekj("mdc-floating-label--float-above", W.floating) }, inputs: { floating: "floating", monitorResize: "monitorResize" } }), Et })(); const $n = "mdc-line-ripple--active", Fn = "mdc-line-ripple--deactivating"; let Ke = (() => { class Et { constructor(G, W) { this._elementRef = G, this._handleTransitionEnd = me => { const de = this._elementRef.nativeElement.classList, st = de.contains(Fn); "opacity" === me.propertyName && st && de.remove($n, Fn) }, W.runOutsideAngular(() => { G.nativeElement.addEventListener("transitionend", this._handleTransitionEnd) }) } activate() { const G = this._elementRef.nativeElement.classList; G.remove(Fn), G.add($n) } deactivate() { this._elementRef.nativeElement.classList.add(Fn) } ngOnDestroy() { this._elementRef.nativeElement.removeEventListener("transitionend", this._handleTransitionEnd) } } return Et.\u0275fac = function (G) { return new (G || Et)(a.Y36(a.SBq), a.Y36(a.R0b)) }, Et.\u0275dir = a.lG2({ type: Et, selectors: [["div", "matFormFieldLineRipple", ""]], hostAttrs: [1, "mdc-line-ripple"] }), Et })(), se = (() => { class Et { constructor(G, W) { this._elementRef = G, this._ngZone = W, this.open = !1 } ngAfterViewInit() { const G = this._elementRef.nativeElement.querySelector(".mdc-floating-label"); G ? (this._elementRef.nativeElement.classList.add("mdc-notched-outline--upgraded"), "function" == typeof requestAnimationFrame && (G.style.transitionDuration = "0s", this._ngZone.runOutsideAngular(() => { requestAnimationFrame(() => G.style.transitionDuration = "") }))) : this._elementRef.nativeElement.classList.add("mdc-notched-outline--no-label") } _setNotchWidth(G) { this._notch.nativeElement.style.width = this.open && G ? `calc(${G}px * var(--mat-mdc-form-field-floating-label-scale, 0.75) + 9px)` : "" } } return Et.\u0275fac = function (G) { return new (G || Et)(a.Y36(a.SBq), a.Y36(a.R0b)) }, Et.\u0275cmp = a.Xpm({ type: Et, selectors: [["div", "matFormFieldNotchedOutline", ""]], viewQuery: function (G, W) { if (1 & G && a.Gf(Ye, 5), 2 & G) { let me; a.iGM(me = a.CRH()) && (W._notch = me.first) } }, hostAttrs: [1, "mdc-notched-outline"], hostVars: 2, hostBindings: function (G, W) { 2 & G && a.ekj("mdc-notched-outline--notched", W.open) }, inputs: { open: ["matFormFieldNotchedOutlineOpen", "open"] }, attrs: ut, ngContentSelectors: ie, decls: 5, vars: 0, consts: [[1, "mdc-notched-outline__leading"], [1, "mdc-notched-outline__notch"], ["notch", ""], [1, "mdc-notched-outline__trailing"]], template: function (G, W) { 1 & G && (a.F$t(), a._UZ(0, "div", 0), a.TgZ(1, "div", 1, 2), a.Hsn(3), a.qZA(), a._UZ(4, "div", 3)) }, encapsulation: 2, changeDetection: 0 }), Et })(); const Me = { transitionMessages: (0, We.X$)("transitionMessages", [(0, We.SB)("enter", (0, We.oB)({ opacity: 1, transform: "translateY(0%)" })), (0, We.eR)("void => enter", [(0, We.oB)({ opacity: 0, transform: "translateY(-5px)" }), (0, We.jt)("300ms cubic-bezier(0.55, 0, 0.55, 0.2)")])]) }; let Xe = (() => { class Et { } return Et.\u0275fac = function (G) { return new (G || Et) }, Et.\u0275dir = a.lG2({ type: Et }), Et })(); const Z = new a.OlP("MatFormField"), Fe = new a.OlP("MAT_FORM_FIELD_DEFAULT_OPTIONS"); let ct = 0, Ln = (() => { class Et { get hideRequiredMarker() { return this._hideRequiredMarker } set hideRequiredMarker(G) { this._hideRequiredMarker = (0, Oe.Ig)(G) } get floatLabel() { return this._floatLabel || this._defaults?.floatLabel || "auto" } set floatLabel(G) { G !== this._floatLabel && (this._floatLabel = G, this._changeDetectorRef.markForCheck()) } get appearance() { return this._appearance } set appearance(G) { const W = this._appearance; this._appearance = G || this._defaults?.appearance || "fill", "outline" === this._appearance && this._appearance !== W && (this._needsOutlineLabelOffsetUpdateOnStable = !0) } get subscriptSizing() { return this._subscriptSizing || this._defaults?.subscriptSizing || "fixed" } set subscriptSizing(G) { this._subscriptSizing = G || this._defaults?.subscriptSizing || "fixed" } get hintLabel() { return this._hintLabel } set hintLabel(G) { this._hintLabel = G, this._processHints() } get _control() { return this._explicitFormFieldControl || this._formFieldControl } set _control(G) { this._explicitFormFieldControl = G } constructor(G, W, me, de, st, Lt, He, ae) { this._elementRef = G, this._changeDetectorRef = W, this._ngZone = me, this._dir = de, this._platform = st, this._defaults = Lt, this._animationMode = He, this._hideRequiredMarker = !1, this.color = "primary", this._appearance = "fill", this._subscriptSizing = null, this._hintLabel = "", this._hasIconPrefix = !1, this._hasTextPrefix = !1, this._hasIconSuffix = !1, this._hasTextSuffix = !1, this._labelId = "mat-mdc-form-field-label-" + ct++, this._hintLabelId = "mat-mdc-hint-" + ct++, this._subscriptAnimationState = "", this._destroyed = new he.x, this._isFocused = null, this._needsOutlineLabelOffsetUpdateOnStable = !1, Lt && (Lt.appearance && (this.appearance = Lt.appearance), this._hideRequiredMarker = !!Lt?.hideRequiredMarker, Lt.color && (this.color = Lt.color)) } ngAfterViewInit() { this._updateFocusState(), this._subscriptAnimationState = "enter", this._changeDetectorRef.detectChanges() } ngAfterContentInit() { this._assertFormFieldControl(), this._initializeControl(), this._initializeSubscript(), this._initializePrefixAndSuffix(), this._initializeOutlineLabelOffsetSubscriptions() } ngAfterContentChecked() { this._assertFormFieldControl() } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete() } getLabelId() { return this._hasFloatingLabel() ? this._labelId : null } getConnectedOverlayOrigin() { return this._textField || this._elementRef } _animateAndLockLabel() { this._hasFloatingLabel() && (this.floatLabel = "always") } _initializeControl() { const G = this._control; G.controlType && this._elementRef.nativeElement.classList.add(`mat-mdc-form-field-type-${G.controlType}`), G.stateChanges.subscribe(() => { this._updateFocusState(), this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), G.ngControl && G.ngControl.valueChanges && G.ngControl.valueChanges.pipe((0, ke.R)(this._destroyed)).subscribe(() => this._changeDetectorRef.markForCheck()) } _checkPrefixAndSuffixTypes() { this._hasIconPrefix = !!this._prefixChildren.find(G => !G._isText), this._hasTextPrefix = !!this._prefixChildren.find(G => G._isText), this._hasIconSuffix = !!this._suffixChildren.find(G => !G._isText), this._hasTextSuffix = !!this._suffixChildren.find(G => G._isText) } _initializePrefixAndSuffix() { this._checkPrefixAndSuffixTypes(), (0, Se.T)(this._prefixChildren.changes, this._suffixChildren.changes).subscribe(() => { this._checkPrefixAndSuffixTypes(), this._changeDetectorRef.markForCheck() }) } _initializeSubscript() { this._hintChildren.changes.subscribe(() => { this._processHints(), this._changeDetectorRef.markForCheck() }), this._errorChildren.changes.subscribe(() => { this._syncDescribedByIds(), this._changeDetectorRef.markForCheck() }), this._validateHints(), this._syncDescribedByIds() } _assertFormFieldControl() { } _updateFocusState() { this._control.focused && !this._isFocused ? (this._isFocused = !0, this._lineRipple?.activate()) : !this._control.focused && (this._isFocused || null === this._isFocused) && (this._isFocused = !1, this._lineRipple?.deactivate()), this._textField?.nativeElement.classList.toggle("mdc-text-field--focused", this._control.focused) } _initializeOutlineLabelOffsetSubscriptions() { this._prefixChildren.changes.subscribe(() => this._needsOutlineLabelOffsetUpdateOnStable = !0), this._ngZone.runOutsideAngular(() => { this._ngZone.onStable.pipe((0, ke.R)(this._destroyed)).subscribe(() => { this._needsOutlineLabelOffsetUpdateOnStable && (this._needsOutlineLabelOffsetUpdateOnStable = !1, this._updateOutlineLabelOffset()) }) }), this._dir.change.pipe((0, ke.R)(this._destroyed)).subscribe(() => this._needsOutlineLabelOffsetUpdateOnStable = !0) } _shouldAlwaysFloat() { return "always" === this.floatLabel } _hasOutline() { return "outline" === this.appearance } _forceDisplayInfixLabel() { return !this._platform.isBrowser && this._prefixChildren.length && !this._shouldLabelFloat() } _hasFloatingLabel() { return !!this._labelChildNonStatic || !!this._labelChildStatic } _shouldLabelFloat() { return this._control.shouldLabelFloat || this._shouldAlwaysFloat() } _shouldForward(G) { const W = this._control ? this._control.ngControl : null; return W && W[G] } _getDisplayedMessages() { return this._errorChildren && this._errorChildren.length > 0 && this._control.errorState ? "error" : "hint" } _handleLabelResized() { this._refreshOutlineNotchWidth() } _refreshOutlineNotchWidth() { this._hasOutline() && this._floatingLabel && this._shouldLabelFloat() ? this._notchedOutline?._setNotchWidth(this._floatingLabel.getWidth()) : this._notchedOutline?._setNotchWidth(0) } _processHints() { this._validateHints(), this._syncDescribedByIds() } _validateHints() { } _syncDescribedByIds() { if (this._control) { let G = []; if (this._control.userAriaDescribedBy && "string" == typeof this._control.userAriaDescribedBy && G.push(...this._control.userAriaDescribedBy.split(" ")), "hint" === this._getDisplayedMessages()) { const W = this._hintChildren ? this._hintChildren.find(de => "start" === de.align) : null, me = this._hintChildren ? this._hintChildren.find(de => "end" === de.align) : null; W ? G.push(W.id) : this._hintLabel && G.push(this._hintLabelId), me && G.push(me.id) } else this._errorChildren && G.push(...this._errorChildren.map(W => W.id)); this._control.setDescribedByIds(G) } } _updateOutlineLabelOffset() { if (!this._platform.isBrowser || !this._hasOutline() || !this._floatingLabel) return; const G = this._floatingLabel.element; if (!this._iconPrefixContainer && !this._textPrefixContainer) return void (G.style.transform = ""); if (!this._isAttachedToDom()) return void (this._needsOutlineLabelOffsetUpdateOnStable = !0); const W = this._iconPrefixContainer?.nativeElement, me = this._textPrefixContainer?.nativeElement, de = W?.getBoundingClientRect().width ?? 0, st = me?.getBoundingClientRect().width ?? 0; G.style.transform = `var(\n        --mat-mdc-form-field-label-transform,\n        translateY(-50%) translateX(calc(${"rtl" === this._dir.value ? "-1" : "1"} * (${de + st}px + var(--mat-mdc-form-field-label-offset-x, 0px))))\n    )` } _isAttachedToDom() { const G = this._elementRef.nativeElement; if (G.getRootNode) { const W = G.getRootNode(); return W && W !== G } return document.documentElement.contains(G) } } return Et.\u0275fac = function (G) { return new (G || Et)(a.Y36(a.SBq), a.Y36(a.sBO), a.Y36(a.R0b), a.Y36(y.Is), a.Y36(v.t4), a.Y36(Fe, 8), a.Y36(a.QbO, 8), a.Y36(Pe.K0)) }, Et.\u0275cmp = a.Xpm({ type: Et, selectors: [["mat-form-field"]], contentQueries: function (G, W, me) { if (1 & G && (a.Suo(me, tn, 5), a.Suo(me, tn, 7), a.Suo(me, Xe, 5), a.Suo(me, jt, 5), a.Suo(me, qe, 5), a.Suo(me, ht, 5), a.Suo(me, qt, 5)), 2 & G) { let de; a.iGM(de = a.CRH()) && (W._labelChildNonStatic = de.first), a.iGM(de = a.CRH()) && (W._labelChildStatic = de.first), a.iGM(de = a.CRH()) && (W._formFieldControl = de.first), a.iGM(de = a.CRH()) && (W._prefixChildren = de), a.iGM(de = a.CRH()) && (W._suffixChildren = de), a.iGM(de = a.CRH()) && (W._errorChildren = de), a.iGM(de = a.CRH()) && (W._hintChildren = de) } }, viewQuery: function (G, W) { if (1 & G && (a.Gf(Le, 5), a.Gf(le, 5), a.Gf(ge, 5), a.Gf(Zt, 5), a.Gf(se, 5), a.Gf(Ke, 5)), 2 & G) { let me; a.iGM(me = a.CRH()) && (W._textField = me.first), a.iGM(me = a.CRH()) && (W._iconPrefixContainer = me.first), a.iGM(me = a.CRH()) && (W._textPrefixContainer = me.first), a.iGM(me = a.CRH()) && (W._floatingLabel = me.first), a.iGM(me = a.CRH()) && (W._notchedOutline = me.first), a.iGM(me = a.CRH()) && (W._lineRipple = me.first) } }, hostAttrs: [1, "mat-mdc-form-field"], hostVars: 42, hostBindings: function (G, W) { 2 & G && a.ekj("mat-mdc-form-field-label-always-float", W._shouldAlwaysFloat())("mat-mdc-form-field-has-icon-prefix", W._hasIconPrefix)("mat-mdc-form-field-has-icon-suffix", W._hasIconSuffix)("mat-form-field-invalid", W._control.errorState)("mat-form-field-disabled", W._control.disabled)("mat-form-field-autofilled", W._control.autofilled)("mat-form-field-no-animations", "NoopAnimations" === W._animationMode)("mat-form-field-appearance-fill", "fill" == W.appearance)("mat-form-field-appearance-outline", "outline" == W.appearance)("mat-form-field-hide-placeholder", W._hasFloatingLabel() && !W._shouldLabelFloat())("mat-focused", W._control.focused)("mat-primary", "accent" !== W.color && "warn" !== W.color)("mat-accent", "accent" === W.color)("mat-warn", "warn" === W.color)("ng-untouched", W._shouldForward("untouched"))("ng-touched", W._shouldForward("touched"))("ng-pristine", W._shouldForward("pristine"))("ng-dirty", W._shouldForward("dirty"))("ng-valid", W._shouldForward("valid"))("ng-invalid", W._shouldForward("invalid"))("ng-pending", W._shouldForward("pending")) }, inputs: { hideRequiredMarker: "hideRequiredMarker", color: "color", floatLabel: "floatLabel", appearance: "appearance", subscriptSizing: "subscriptSizing", hintLabel: "hintLabel" }, exportAs: ["matFormField"], features: [a._Bn([{ provide: Z, useExisting: Et }, { provide: on, useExisting: Et }])], ngContentSelectors: Jt, decls: 18, vars: 23, consts: [["labelTemplate", ""], [1, "mat-mdc-text-field-wrapper", "mdc-text-field", 3, "click"], ["textField", ""], ["class", "mat-mdc-form-field-focus-overlay", 4, "ngIf"], [1, "mat-mdc-form-field-flex"], ["matFormFieldNotchedOutline", "", 3, "matFormFieldNotchedOutlineOpen", 4, "ngIf"], ["class", "mat-mdc-form-field-icon-prefix", 4, "ngIf"], ["class", "mat-mdc-form-field-text-prefix", 4, "ngIf"], [1, "mat-mdc-form-field-infix"], [3, "ngIf"], ["class", "mat-mdc-form-field-text-suffix", 4, "ngIf"], ["class", "mat-mdc-form-field-icon-suffix", 4, "ngIf"], ["matFormFieldLineRipple", "", 4, "ngIf"], [1, "mat-mdc-form-field-subscript-wrapper", "mat-mdc-form-field-bottom-align", 3, "ngSwitch"], ["class", "mat-mdc-form-field-error-wrapper", 4, "ngSwitchCase"], ["class", "mat-mdc-form-field-hint-wrapper", 4, "ngSwitchCase"], ["matFormFieldFloatingLabel", "", 3, "floating", "monitorResize", "id", 4, "ngIf"], ["matFormFieldFloatingLabel", "", 3, "floating", "monitorResize", "id"], ["aria-hidden", "true", "class", "mat-mdc-form-field-required-marker mdc-floating-label--required", 4, "ngIf"], ["aria-hidden", "true", 1, "mat-mdc-form-field-required-marker", "mdc-floating-label--required"], [1, "mat-mdc-form-field-focus-overlay"], ["matFormFieldNotchedOutline", "", 3, "matFormFieldNotchedOutlineOpen"], [3, "ngTemplateOutlet"], [1, "mat-mdc-form-field-icon-prefix"], ["iconPrefixContainer", ""], [1, "mat-mdc-form-field-text-prefix"], ["textPrefixContainer", ""], [1, "mat-mdc-form-field-text-suffix"], [1, "mat-mdc-form-field-icon-suffix"], ["matFormFieldLineRipple", ""], [1, "mat-mdc-form-field-error-wrapper"], [1, "mat-mdc-form-field-hint-wrapper"], [3, "id", 4, "ngIf"], [1, "mat-mdc-form-field-hint-spacer"], [3, "id"]], template: function (G, W) { 1 & G && (a.F$t(rn), a.YNc(0, $e, 1, 1, "ng-template", null, 0, a.W1O), a.TgZ(2, "div", 1, 2), a.NdJ("click", function (de) { return W._control.onContainerClick(de) }), a.YNc(4, rt, 1, 0, "div", 3), a.TgZ(5, "div", 4), a.YNc(6, Dn, 2, 2, "div", 5), a.YNc(7, Mn, 3, 0, "div", 6), a.YNc(8, On, 3, 0, "div", 7), a.TgZ(9, "div", 8), a.YNc(10, Hn, 1, 1, "ng-template", 9), a.Hsn(11), a.qZA(), a.YNc(12, at, 2, 0, "div", 10), a.YNc(13, vt, 2, 0, "div", 11), a.qZA(), a.YNc(14, xt, 1, 0, "div", 12), a.qZA(), a.TgZ(15, "div", 13), a.YNc(16, it, 2, 1, "div", 14), a.YNc(17, Wt, 5, 2, "div", 15), a.qZA()), 2 & G && (a.xp6(2), a.ekj("mdc-text-field--filled", !W._hasOutline())("mdc-text-field--outlined", W._hasOutline())("mdc-text-field--no-label", !W._hasFloatingLabel())("mdc-text-field--disabled", W._control.disabled)("mdc-text-field--invalid", W._control.errorState), a.xp6(2), a.Q6J("ngIf", !W._hasOutline() && !W._control.disabled), a.xp6(2), a.Q6J("ngIf", W._hasOutline()), a.xp6(1), a.Q6J("ngIf", W._hasIconPrefix), a.xp6(1), a.Q6J("ngIf", W._hasTextPrefix), a.xp6(2), a.Q6J("ngIf", !W._hasOutline() || W._forceDisplayInfixLabel()), a.xp6(2), a.Q6J("ngIf", W._hasTextSuffix), a.xp6(1), a.Q6J("ngIf", W._hasIconSuffix), a.xp6(1), a.Q6J("ngIf", !W._hasOutline()), a.xp6(1), a.ekj("mat-mdc-form-field-subscript-dynamic-size", "dynamic" === W.subscriptSizing), a.Q6J("ngSwitch", W._getDisplayedMessages()), a.xp6(1), a.Q6J("ngSwitchCase", "error"), a.xp6(1), a.Q6J("ngSwitchCase", "hint")) }, dependencies: [Pe.O5, Pe.tP, Pe.RF, Pe.n9, qt, Zt, se, Ke], styles: ['.mdc-text-field{border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:0;border-bottom-left-radius:0;display:inline-flex;align-items:baseline;padding:0 16px;position:relative;box-sizing:border-box;overflow:hidden;will-change:opacity,transform,color}.mdc-text-field .mdc-floating-label{top:50%;transform:translateY(-50%);pointer-events:none}.mdc-text-field__input{height:28px;width:100%;min-width:0;border:none;border-radius:0;background:none;appearance:none;padding:0}.mdc-text-field__input::-ms-clear{display:none}.mdc-text-field__input::-webkit-calendar-picker-indicator{display:none}.mdc-text-field__input:focus{outline:none}.mdc-text-field__input:invalid{box-shadow:none}@media all{.mdc-text-field__input::placeholder{opacity:0}}@media all{.mdc-text-field__input:-ms-input-placeholder{opacity:0}}@media all{.mdc-text-field--no-label .mdc-text-field__input::placeholder,.mdc-text-field--focused .mdc-text-field__input::placeholder{opacity:1}}@media all{.mdc-text-field--no-label .mdc-text-field__input:-ms-input-placeholder,.mdc-text-field--focused .mdc-text-field__input:-ms-input-placeholder{opacity:1}}.mdc-text-field__affix{height:28px;opacity:0;white-space:nowrap}.mdc-text-field--label-floating .mdc-text-field__affix,.mdc-text-field--no-label .mdc-text-field__affix{opacity:1}@supports(-webkit-hyphens: none){.mdc-text-field--outlined .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}[dir=rtl] .mdc-text-field__affix--prefix,.mdc-text-field__affix--prefix[dir=rtl]{padding-left:2px;padding-right:0}.mdc-text-field--end-aligned .mdc-text-field__affix--prefix{padding-left:0;padding-right:12px}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--prefix,.mdc-text-field--end-aligned .mdc-text-field__affix--prefix[dir=rtl]{padding-left:12px;padding-right:0}.mdc-text-field__affix--suffix{padding-left:12px;padding-right:0}[dir=rtl] .mdc-text-field__affix--suffix,.mdc-text-field__affix--suffix[dir=rtl]{padding-left:0;padding-right:12px}.mdc-text-field--end-aligned .mdc-text-field__affix--suffix{padding-left:2px;padding-right:0}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__affix--suffix,.mdc-text-field--end-aligned .mdc-text-field__affix--suffix[dir=rtl]{padding-left:0;padding-right:2px}.mdc-text-field--filled{height:56px}.mdc-text-field--filled::before{display:inline-block;width:0;height:40px;content:"";vertical-align:0}.mdc-text-field--filled .mdc-floating-label{left:16px;right:initial}[dir=rtl] .mdc-text-field--filled .mdc-floating-label,.mdc-text-field--filled .mdc-floating-label[dir=rtl]{left:initial;right:16px}.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{height:100%}.mdc-text-field--filled.mdc-text-field--no-label .mdc-floating-label{display:none}.mdc-text-field--filled.mdc-text-field--no-label::before{display:none}@supports(-webkit-hyphens: none){.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__affix{align-items:center;align-self:center;display:inline-flex;height:100%}}.mdc-text-field--outlined{height:56px;overflow:visible}.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) scale(1)}.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) scale(0.75)}.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--outlined .mdc-text-field__input{height:100%}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:var(--mdc-shape-small, 4px)}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading[dir=rtl]{border-top-left-radius:0;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:var(--mdc-shape-small, 4px);border-bottom-left-radius:0}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__leading{width:max(12px, var(--mdc-shape-small, 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__notch{max-width:calc(100% - max(12px, var(--mdc-shape-small, 4px))*2)}}.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing{border-top-left-radius:0;border-top-right-radius:var(--mdc-shape-small, 4px);border-bottom-right-radius:var(--mdc-shape-small, 4px);border-bottom-left-radius:0}[dir=rtl] .mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing,.mdc-text-field--outlined .mdc-notched-outline .mdc-notched-outline__trailing[dir=rtl]{border-top-left-radius:var(--mdc-shape-small, 4px);border-top-right-radius:0;border-bottom-right-radius:0;border-bottom-left-radius:var(--mdc-shape-small, 4px)}@supports(top: max(0%)){.mdc-text-field--outlined{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined{padding-right:max(16px, var(--mdc-shape-small, 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}@supports(top: max(0%)){.mdc-text-field--outlined+.mdc-text-field-helper-line{padding-right:max(16px, var(--mdc-shape-small, 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-left:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-leading-icon{padding-right:max(16px, var(--mdc-shape-small, 4px))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-right:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-leading-icon,.mdc-text-field--outlined.mdc-text-field--with-leading-icon[dir=rtl]{padding-left:max(16px, var(--mdc-shape-small, 4px))}}.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-right:0}@supports(top: max(0%)){.mdc-text-field--outlined.mdc-text-field--with-trailing-icon{padding-left:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-left:0}@supports(top: max(0%)){[dir=rtl] .mdc-text-field--outlined.mdc-text-field--with-trailing-icon,.mdc-text-field--outlined.mdc-text-field--with-trailing-icon[dir=rtl]{padding-right:max(16px, calc(var(--mdc-shape-small, 4px) + 4px))}}.mdc-text-field--outlined.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:1px}.mdc-text-field--outlined .mdc-floating-label{left:4px;right:initial}[dir=rtl] .mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:4px}.mdc-text-field--outlined .mdc-text-field__input{display:flex;border:none !important;background-color:rgba(0,0,0,0)}.mdc-text-field--outlined .mdc-notched-outline{z-index:1}.mdc-text-field--textarea{flex-direction:column;align-items:center;width:auto;height:auto;padding:0}.mdc-text-field--textarea .mdc-floating-label{top:19px}.mdc-text-field--textarea .mdc-floating-label:not(.mdc-floating-label--float-above){transform:none}.mdc-text-field--textarea .mdc-text-field__input{flex-grow:1;height:auto;min-height:1.5rem;overflow-x:hidden;overflow-y:auto;box-sizing:border-box;resize:none;padding:0 16px}.mdc-text-field--textarea.mdc-text-field--filled::before{display:none}.mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--float-above{transform:translateY(-10.25px) scale(0.75)}.mdc-text-field--textarea.mdc-text-field--filled .mdc-text-field__input{margin-top:23px;margin-bottom:9px}.mdc-text-field--textarea.mdc-text-field--filled.mdc-text-field--no-label .mdc-text-field__input{margin-top:16px;margin-bottom:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-27.25px) scale(1)}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--textarea.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-24.75px) scale(0.75)}.mdc-text-field--textarea.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--textarea.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-text-field__input{margin-top:16px;margin-bottom:16px}.mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label{top:18px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field__input{margin-bottom:2px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter{align-self:flex-end;padding:0 16px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter::after{display:inline-block;width:0;height:16px;content:"";vertical-align:-16px}.mdc-text-field--textarea.mdc-text-field--with-internal-counter .mdc-text-field-character-counter::before{display:none}.mdc-text-field__resizer{align-self:stretch;display:inline-flex;flex-direction:column;flex-grow:1;max-height:100%;max-width:100%;min-height:56px;min-width:fit-content;min-width:-moz-available;min-width:-webkit-fill-available;overflow:hidden;resize:both}.mdc-text-field--filled .mdc-text-field__resizer{transform:translateY(-1px)}.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field__input,.mdc-text-field--filled .mdc-text-field__resizer .mdc-text-field-character-counter{transform:translateY(1px)}.mdc-text-field--outlined .mdc-text-field__resizer{transform:translateX(-1px) translateY(-1px)}[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer,.mdc-text-field--outlined .mdc-text-field__resizer[dir=rtl]{transform:translateX(1px) translateY(-1px)}.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input,.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter{transform:translateX(1px) translateY(1px)}[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input,[dir=rtl] .mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter,.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field__input[dir=rtl],.mdc-text-field--outlined .mdc-text-field__resizer .mdc-text-field-character-counter[dir=rtl]{transform:translateX(-1px) translateY(1px)}.mdc-text-field--with-leading-icon{padding-left:0;padding-right:16px}[dir=rtl] .mdc-text-field--with-leading-icon,.mdc-text-field--with-leading-icon[dir=rtl]{padding-left:16px;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 48px);left:48px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label[dir=rtl]{left:initial;right:48px}.mdc-text-field--with-leading-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 64px / 0.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label{left:36px;right:initial}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label[dir=rtl]{left:initial;right:36px}.mdc-text-field--with-leading-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{transform:translateY(-37.25px) translateX(-32px) scale(1)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-37.25px) translateX(32px) scale(1)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--float-above{font-size:.75rem}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{transform:translateY(-34.75px) translateX(-32px) scale(0.75)}[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,[dir=rtl] .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl],.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above[dir=rtl]{transform:translateY(-34.75px) translateX(32px) scale(0.75)}.mdc-text-field--with-leading-icon.mdc-text-field--outlined.mdc-notched-outline--upgraded .mdc-floating-label--float-above,.mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-notched-outline--upgraded .mdc-floating-label--float-above{font-size:1rem}.mdc-text-field--with-trailing-icon{padding-left:16px;padding-right:0}[dir=rtl] .mdc-text-field--with-trailing-icon,.mdc-text-field--with-trailing-icon[dir=rtl]{padding-left:0;padding-right:16px}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 64px)}.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 64px / 0.75)}.mdc-text-field--with-trailing-icon.mdc-text-field--outlined :not(.mdc-notched-outline--notched) .mdc-notched-outline__notch{max-width:calc(100% - 60px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon{padding-left:0;padding-right:0}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label{max-width:calc(100% - 96px)}.mdc-text-field--with-leading-icon.mdc-text-field--with-trailing-icon.mdc-text-field--filled .mdc-floating-label--float-above{max-width:calc(100% / 0.75 - 96px / 0.75)}.mdc-text-field-helper-line{display:flex;justify-content:space-between;box-sizing:border-box}.mdc-text-field+.mdc-text-field-helper-line{padding-right:16px;padding-left:16px}.mdc-form-field>.mdc-text-field+label{align-self:flex-start}.mdc-text-field--focused .mdc-notched-outline__leading,.mdc-text-field--focused .mdc-notched-outline__notch,.mdc-text-field--focused .mdc-notched-outline__trailing{border-width:2px}.mdc-text-field--focused+.mdc-text-field-helper-line .mdc-text-field-helper-text:not(.mdc-text-field-helper-text--validation-msg){opacity:1}.mdc-text-field--focused.mdc-text-field--outlined .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:2px}.mdc-text-field--focused.mdc-text-field--outlined.mdc-text-field--textarea .mdc-notched-outline--notched .mdc-notched-outline__notch{padding-top:0}.mdc-text-field--invalid+.mdc-text-field-helper-line .mdc-text-field-helper-text--validation-msg{opacity:1}.mdc-text-field--disabled{pointer-events:none}@media screen and (forced-colors: active){.mdc-text-field--disabled .mdc-text-field__input{background-color:Window}.mdc-text-field--disabled .mdc-floating-label{z-index:1}}.mdc-text-field--disabled .mdc-floating-label{cursor:default}.mdc-text-field--disabled.mdc-text-field--filled .mdc-text-field__ripple{display:none}.mdc-text-field--disabled .mdc-text-field__input{pointer-events:auto}.mdc-text-field--end-aligned .mdc-text-field__input{text-align:right}[dir=rtl] .mdc-text-field--end-aligned .mdc-text-field__input,.mdc-text-field--end-aligned .mdc-text-field__input[dir=rtl]{text-align:left}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input,[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix{direction:ltr}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix{padding-left:0;padding-right:2px}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix{padding-left:12px;padding-right:0}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--leading,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--leading{order:1}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--suffix{order:2}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__input,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__input{order:3}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__affix--prefix{order:4}[dir=rtl] .mdc-text-field--ltr-text .mdc-text-field__icon--trailing,.mdc-text-field--ltr-text[dir=rtl] .mdc-text-field__icon--trailing{order:5}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__input,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__input{text-align:right}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--prefix,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--prefix{padding-right:12px}[dir=rtl] .mdc-text-field--ltr-text.mdc-text-field--end-aligned .mdc-text-field__affix--suffix,.mdc-text-field--ltr-text.mdc-text-field--end-aligned[dir=rtl] .mdc-text-field__affix--suffix{padding-left:2px}.mdc-floating-label{position:absolute;left:0;-webkit-transform-origin:left top;transform-origin:left top;line-height:1.15rem;text-align:left;text-overflow:ellipsis;white-space:nowrap;cursor:text;overflow:hidden;will-change:transform}[dir=rtl] .mdc-floating-label,.mdc-floating-label[dir=rtl]{right:0;left:auto;-webkit-transform-origin:right top;transform-origin:right top;text-align:right}.mdc-floating-label--float-above{cursor:auto}.mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)::after{margin-left:1px;margin-right:0px;content:"*"}[dir=rtl] .mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)::after,.mdc-floating-label--required:not(.mdc-floating-label--hide-required-marker)[dir=rtl]::after{margin-left:0;margin-right:1px}.mdc-floating-label--float-above{transform:translateY(-106%) scale(0.75)}.mdc-notched-outline{display:flex;position:absolute;top:0;right:0;left:0;box-sizing:border-box;width:100%;max-width:100%;height:100%;text-align:left;pointer-events:none}[dir=rtl] .mdc-notched-outline,.mdc-notched-outline[dir=rtl]{text-align:right}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{box-sizing:border-box;height:100%;pointer-events:none}.mdc-notched-outline__trailing{flex-grow:1}.mdc-notched-outline__notch{flex:0 0 auto;width:auto}.mdc-notched-outline .mdc-floating-label{display:inline-block;position:relative;max-width:100%}.mdc-notched-outline .mdc-floating-label--float-above{text-overflow:clip}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:133.3333333333%}.mdc-notched-outline--notched .mdc-notched-outline__notch{padding-left:0;padding-right:8px;border-top:none}[dir=rtl] .mdc-notched-outline--notched .mdc-notched-outline__notch,.mdc-notched-outline--notched .mdc-notched-outline__notch[dir=rtl]{padding-left:8px;padding-right:0}.mdc-notched-outline--no-label .mdc-notched-outline__notch{display:none}.mdc-notched-outline__leading,.mdc-notched-outline__notch,.mdc-notched-outline__trailing{border-top:1px solid;border-bottom:1px solid}.mdc-notched-outline__leading{border-left:1px solid;border-right:none;width:12px}[dir=rtl] .mdc-notched-outline__leading,.mdc-notched-outline__leading[dir=rtl]{border-left:none;border-right:1px solid}.mdc-notched-outline__trailing{border-left:none;border-right:1px solid}[dir=rtl] .mdc-notched-outline__trailing,.mdc-notched-outline__trailing[dir=rtl]{border-left:1px solid;border-right:none}.mdc-notched-outline__notch{max-width:calc(100% - 12px * 2)}.mdc-line-ripple::before,.mdc-line-ripple::after{position:absolute;bottom:0;left:0;width:100%;border-bottom-style:solid;content:""}.mdc-line-ripple::before{z-index:1}.mdc-line-ripple::after{transform:scaleX(0);opacity:0;z-index:2}.mdc-line-ripple--active::after{transform:scaleX(1);opacity:1}.mdc-line-ripple--deactivating::after{opacity:0}.mdc-line-ripple::before{border-bottom-width:1px}.mdc-line-ripple::after{border-bottom-width:2px}.mat-mdc-form-field-textarea-control{vertical-align:middle;resize:vertical;box-sizing:border-box;height:auto;margin:0;padding:0;border:none;overflow:auto}.mat-mdc-form-field-input-control.mat-mdc-form-field-input-control{font:inherit;letter-spacing:inherit;text-decoration:inherit;text-transform:inherit;border:none}.mat-mdc-form-field .mat-mdc-floating-label.mdc-floating-label{line-height:normal;pointer-events:all}.mdc-text-field--no-label:not(.mdc-text-field--textarea) .mat-mdc-form-field-input-control.mdc-text-field__input,.mat-mdc-text-field-wrapper .mat-mdc-form-field-input-control{height:auto}.mat-mdc-text-field-wrapper .mat-mdc-form-field-input-control.mdc-text-field__input[type=color]{height:23px}.mat-mdc-text-field-wrapper{height:auto;flex:auto}.mat-mdc-form-field-has-icon-prefix .mat-mdc-text-field-wrapper{padding-left:0;--mat-mdc-form-field-label-offset-x: -16px}.mat-mdc-form-field-has-icon-suffix .mat-mdc-text-field-wrapper{padding-right:0}[dir=rtl] .mat-mdc-text-field-wrapper{padding-left:16px;padding-right:16px}[dir=rtl] .mat-mdc-form-field-has-icon-suffix .mat-mdc-text-field-wrapper{padding-left:0}[dir=rtl] .mat-mdc-form-field-has-icon-prefix .mat-mdc-text-field-wrapper{padding-right:0}.mat-mdc-form-field-label-always-float .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms;opacity:1}.mat-mdc-text-field-wrapper .mat-mdc-form-field-infix .mat-mdc-floating-label{left:auto;right:auto}.mat-mdc-text-field-wrapper.mdc-text-field--outlined .mdc-text-field__input{display:inline-block}.mat-mdc-form-field .mat-mdc-text-field-wrapper.mdc-text-field .mdc-notched-outline__notch{padding-top:0}.mat-mdc-text-field-wrapper::before{content:none}.mat-mdc-form-field-subscript-wrapper{box-sizing:border-box;width:100%;position:relative}.mat-mdc-form-field-hint-wrapper,.mat-mdc-form-field-error-wrapper{position:absolute;top:0;left:0;right:0;padding:0 16px}.mat-mdc-form-field-subscript-dynamic-size .mat-mdc-form-field-hint-wrapper,.mat-mdc-form-field-subscript-dynamic-size .mat-mdc-form-field-error-wrapper{position:static}.mat-mdc-form-field-bottom-align::before{content:"";display:inline-block;height:16px}.mat-mdc-form-field-bottom-align.mat-mdc-form-field-subscript-dynamic-size::before{content:unset}.mat-mdc-form-field-hint-end{order:1}.mat-mdc-form-field-hint-wrapper{display:flex}.mat-mdc-form-field-hint-spacer{flex:1 0 1em}.mat-mdc-form-field-error{display:block}.mat-mdc-form-field-focus-overlay{top:0;left:0;right:0;bottom:0;position:absolute;opacity:0;pointer-events:none}select.mat-mdc-form-field-input-control{-moz-appearance:none;-webkit-appearance:none;background-color:rgba(0,0,0,0);display:inline-flex;box-sizing:border-box}select.mat-mdc-form-field-input-control:not(:disabled){cursor:pointer}.mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-infix::after{content:"";width:0;height:0;border-left:5px solid rgba(0,0,0,0);border-right:5px solid rgba(0,0,0,0);border-top:5px solid;position:absolute;right:0;top:50%;margin-top:-2.5px;pointer-events:none}[dir=rtl] .mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-infix::after{right:auto;left:0}.mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-input-control{padding-right:15px}[dir=rtl] .mat-mdc-form-field-type-mat-native-select .mat-mdc-form-field-input-control{padding-right:0;padding-left:15px}.cdk-high-contrast-active .mat-form-field-appearance-fill .mat-mdc-text-field-wrapper{outline:solid 1px}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-form-field-disabled .mat-mdc-text-field-wrapper{outline-color:GrayText}.cdk-high-contrast-active .mat-form-field-appearance-fill.mat-focused .mat-mdc-text-field-wrapper{outline:dashed 3px}.cdk-high-contrast-active .mat-mdc-form-field.mat-focused .mdc-notched-outline{border:dashed 3px}.mat-mdc-form-field-input-control[type=date],.mat-mdc-form-field-input-control[type=datetime],.mat-mdc-form-field-input-control[type=datetime-local],.mat-mdc-form-field-input-control[type=month],.mat-mdc-form-field-input-control[type=week],.mat-mdc-form-field-input-control[type=time]{line-height:1}.mat-mdc-form-field-input-control::-webkit-datetime-edit{line-height:1;padding:0;margin-bottom:-2px}.mat-mdc-form-field{--mat-mdc-form-field-floating-label-scale: 0.75;display:inline-flex;flex-direction:column;min-width:0;text-align:left}[dir=rtl] .mat-mdc-form-field{text-align:right}.mat-mdc-form-field-flex{display:inline-flex;align-items:baseline;box-sizing:border-box;width:100%}.mat-mdc-text-field-wrapper{width:100%}.mat-mdc-form-field-icon-prefix,.mat-mdc-form-field-icon-suffix{align-self:center;line-height:0;pointer-events:auto;position:relative;z-index:1}.mat-mdc-form-field-icon-prefix,[dir=rtl] .mat-mdc-form-field-icon-suffix{padding:0 4px 0 0}.mat-mdc-form-field-icon-suffix,[dir=rtl] .mat-mdc-form-field-icon-prefix{padding:0 0 0 4px}.mat-mdc-form-field-icon-prefix>.mat-icon,.mat-mdc-form-field-icon-suffix>.mat-icon{padding:12px;box-sizing:content-box}.mat-mdc-form-field-subscript-wrapper .mat-icon,.mat-mdc-form-field label .mat-icon{width:1em;height:1em;font-size:inherit}.mat-mdc-form-field-infix{flex:auto;min-width:0;width:180px;position:relative;box-sizing:border-box}.mat-mdc-form-field .mdc-notched-outline__notch{margin-left:-1px;-webkit-clip-path:inset(-9em -999em -9em 1px);clip-path:inset(-9em -999em -9em 1px)}[dir=rtl] .mat-mdc-form-field .mdc-notched-outline__notch{margin-left:0;margin-right:-1px;-webkit-clip-path:inset(-9em 1px -9em -999em);clip-path:inset(-9em 1px -9em -999em)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input{transition:opacity 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}@media all{.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder{transition:opacity 67ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}}@media all{.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder{transition:opacity 67ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}}@media all{.mdc-text-field--no-label .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder,.mdc-text-field--focused .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input::placeholder{transition-delay:40ms;transition-duration:110ms}}@media all{.mdc-text-field--no-label .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder,.mdc-text-field--focused .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__input:-ms-input-placeholder{transition-delay:40ms;transition-duration:110ms}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field__affix{transition:opacity 150ms 0ms cubic-bezier(0.4, 0, 0.2, 1)}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--filled.mdc-ripple-upgraded--background-focused .mdc-text-field__ripple::before,.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--filled:not(.mdc-ripple-upgraded):focus .mdc-text-field__ripple::before{transition-duration:75ms}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 34.75px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--textarea{transition:none}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--textarea.mdc-text-field--filled .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-filled 250ms 1}@keyframes mdc-floating-label-shake-float-above-textarea-filled{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 10.25px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--textarea.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-textarea-outlined 250ms 1}@keyframes mdc-floating-label-shake-float-above-textarea-outlined{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 24.75px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon{0%{transform:translateX(calc(0% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}100%{transform:translateX(calc(0% - 32px)) translateY(calc(0% - 34.75px)) scale(0.75)}}[dir=rtl] .mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--with-leading-icon.mdc-text-field--outlined .mdc-floating-label--shake,.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-text-field--with-leading-icon.mdc-text-field--outlined[dir=rtl] .mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-text-field-outlined-leading-icon 250ms 1}@keyframes mdc-floating-label-shake-float-above-text-field-outlined-leading-icon-rtl{0%{transform:translateX(calc(0% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}100%{transform:translateX(calc(0% - -32px)) translateY(calc(0% - 34.75px)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-floating-label{transition:transform 150ms cubic-bezier(0.4, 0, 0.2, 1),color 150ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-floating-label--shake{animation:mdc-floating-label-shake-float-above-standard 250ms 1}@keyframes mdc-floating-label-shake-float-above-standard{0%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}33%{animation-timing-function:cubic-bezier(0.5, 0, 0.701732, 0.495819);transform:translateX(calc(4% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}66%{animation-timing-function:cubic-bezier(0.302435, 0.381352, 0.55, 0.956352);transform:translateX(calc(-4% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}100%{transform:translateX(calc(0% - 0%)) translateY(calc(0% - 106%)) scale(0.75)}}.mat-mdc-form-field:not(.mat-form-field-no-animations) .mdc-line-ripple::after{transition:transform 180ms cubic-bezier(0.4, 0, 0.2, 1),opacity 180ms cubic-bezier(0.4, 0, 0.2, 1)}.mdc-notched-outline .mdc-floating-label{max-width:calc(100% + 1px)}.mdc-notched-outline--upgraded .mdc-floating-label--float-above{max-width:calc(133.3333333333% + 1px)}'], encapsulation: 2, data: { animation: [Me.transitionMessages] }, changeDetection: 0 }), Et })(), In = (() => { class Et { } return Et.\u0275fac = function (G) { return new (G || Et) }, Et.\u0275mod = a.oAB({ type: Et }), Et.\u0275inj = a.cJS({ imports: [tt.BQ, Pe.ez, Ve.Q8, tt.BQ] }), Et })() }, 1175: (nn, Qe, C) => { C.d(Qe, { Hw: () => sn, Ps: () => wn }); var a = C(5879), y = C(3680), v = C(2495), Y = C(6814), he = C(2096), Se = C(8504), ke = C(9315), re = C(7394), Ie = C(9397), Q = C(7398), _e = C(6306), xe = C(4716), ze = C(3020), Oe = C(8180), We = C(6328), Pe = C(2181); class Ve { } class Ye { constructor(Be) { this.normalizedNames = new Map, this.lazyUpdate = null, Be ? "string" == typeof Be ? this.lazyInit = () => { this.headers = new Map, Be.split("\n").forEach(ye => { const et = ye.indexOf(":"); if (et > 0) { const Vt = ye.slice(0, et), At = Vt.toLowerCase(), cn = ye.slice(et + 1).trim(); this.maybeSetNormalizedName(Vt, At), this.headers.has(At) ? this.headers.get(At).push(cn) : this.headers.set(At, [cn]) } }) } : typeof Headers < "u" && Be instanceof Headers ? (this.headers = new Map, Be.forEach((ye, et) => { this.setHeaderEntries(et, ye) })) : this.lazyInit = () => { this.headers = new Map, Object.entries(Be).forEach(([ye, et]) => { this.setHeaderEntries(ye, et) }) } : this.headers = new Map } has(Be) { return this.init(), this.headers.has(Be.toLowerCase()) } get(Be) { this.init(); const ye = this.headers.get(Be.toLowerCase()); return ye && ye.length > 0 ? ye[0] : null } keys() { return this.init(), Array.from(this.normalizedNames.values()) } getAll(Be) { return this.init(), this.headers.get(Be.toLowerCase()) || null } append(Be, ye) { return this.clone({ name: Be, value: ye, op: "a" }) } set(Be, ye) { return this.clone({ name: Be, value: ye, op: "s" }) } delete(Be, ye) { return this.clone({ name: Be, value: ye, op: "d" }) } maybeSetNormalizedName(Be, ye) { this.normalizedNames.has(ye) || this.normalizedNames.set(ye, Be) } init() { this.lazyInit && (this.lazyInit instanceof Ye ? this.copyFrom(this.lazyInit) : this.lazyInit(), this.lazyInit = null, this.lazyUpdate && (this.lazyUpdate.forEach(Be => this.applyUpdate(Be)), this.lazyUpdate = null)) } copyFrom(Be) { Be.init(), Array.from(Be.headers.keys()).forEach(ye => { this.headers.set(ye, Be.headers.get(ye)), this.normalizedNames.set(ye, Be.normalizedNames.get(ye)) }) } clone(Be) { const ye = new Ye; return ye.lazyInit = this.lazyInit && this.lazyInit instanceof Ye ? this.lazyInit : this, ye.lazyUpdate = (this.lazyUpdate || []).concat([Be]), ye } applyUpdate(Be) { const ye = Be.name.toLowerCase(); switch (Be.op) { case "a": case "s": let et = Be.value; if ("string" == typeof et && (et = [et]), 0 === et.length) return; this.maybeSetNormalizedName(Be.name, ye); const Vt = ("a" === Be.op ? this.headers.get(ye) : void 0) || []; Vt.push(...et), this.headers.set(ye, Vt); break; case "d": const At = Be.value; if (At) { let cn = this.headers.get(ye); if (!cn) return; cn = cn.filter(Tn => -1 === At.indexOf(Tn)), 0 === cn.length ? (this.headers.delete(ye), this.normalizedNames.delete(ye)) : this.headers.set(ye, cn) } else this.headers.delete(ye), this.normalizedNames.delete(ye) } } setHeaderEntries(Be, ye) { const et = (Array.isArray(ye) ? ye : [ye]).map(At => At.toString()), Vt = Be.toLowerCase(); this.headers.set(Vt, et), this.maybeSetNormalizedName(Be, Vt) } forEach(Be) { this.init(), Array.from(this.normalizedNames.keys()).forEach(ye => Be(this.normalizedNames.get(ye), this.headers.get(ye))) } } class ie { encodeKey(Be) { return ue(Be) } encodeValue(Be) { return ue(Be) } decodeKey(Be) { return decodeURIComponent(Be) } decodeValue(Be) { return decodeURIComponent(Be) } } const le = /%(\d[a-f0-9])/gi, ge = { 40: "@", "3A": ":", 24: "$", "2C": ",", "3B": ";", "3D": "=", "3F": "?", "2F": "/" }; function ue(dt) { return encodeURIComponent(dt).replace(le, (Be, ye) => ge[ye] ?? Be) } function ee(dt) { return `${dt}` } class $e { constructor(Be = {}) { if (this.updates = null, this.cloneFrom = null, this.encoder = Be.encoder || new ie, Be.fromString) { if (Be.fromObject) throw new Error("Cannot specify both fromString and fromObject."); this.map = function Le(dt, Be) { const ye = new Map; return dt.length > 0 && dt.replace(/^\?/, "").split("&").forEach(Vt => { const At = Vt.indexOf("="), [cn, Tn] = -1 == At ? [Be.decodeKey(Vt), ""] : [Be.decodeKey(Vt.slice(0, At)), Be.decodeValue(Vt.slice(At + 1))], ii = ye.get(cn) || []; ii.push(Tn), ye.set(cn, ii) }), ye }(Be.fromString, this.encoder) } else Be.fromObject ? (this.map = new Map, Object.keys(Be.fromObject).forEach(ye => { const et = Be.fromObject[ye], Vt = Array.isArray(et) ? et.map(ee) : [ee(et)]; this.map.set(ye, Vt) })) : this.map = null } has(Be) { return this.init(), this.map.has(Be) } get(Be) { this.init(); const ye = this.map.get(Be); return ye ? ye[0] : null } getAll(Be) { return this.init(), this.map.get(Be) || null } keys() { return this.init(), Array.from(this.map.keys()) } append(Be, ye) { return this.clone({ param: Be, value: ye, op: "a" }) } appendAll(Be) { const ye = []; return Object.keys(Be).forEach(et => { const Vt = Be[et]; Array.isArray(Vt) ? Vt.forEach(At => { ye.push({ param: et, value: At, op: "a" }) }) : ye.push({ param: et, value: Vt, op: "a" }) }), this.clone(ye) } set(Be, ye) { return this.clone({ param: Be, value: ye, op: "s" }) } delete(Be, ye) { return this.clone({ param: Be, value: ye, op: "d" }) } toString() { return this.init(), this.keys().map(Be => { const ye = this.encoder.encodeKey(Be); return this.map.get(Be).map(et => ye + "=" + this.encoder.encodeValue(et)).join("&") }).filter(Be => "" !== Be).join("&") } clone(Be) { const ye = new $e({ encoder: this.encoder }); return ye.cloneFrom = this.cloneFrom || this, ye.updates = (this.updates || []).concat(Be), ye } init() { null === this.map && (this.map = new Map), null !== this.cloneFrom && (this.cloneFrom.init(), this.cloneFrom.keys().forEach(Be => this.map.set(Be, this.cloneFrom.map.get(Be))), this.updates.forEach(Be => { switch (Be.op) { case "a": case "s": const ye = ("a" === Be.op ? this.map.get(Be.param) : void 0) || []; ye.push(ee(Be.value)), this.map.set(Be.param, ye); break; case "d": if (void 0 === Be.value) { this.map.delete(Be.param); break } { let et = this.map.get(Be.param) || []; const Vt = et.indexOf(ee(Be.value)); -1 !== Vt && et.splice(Vt, 1), et.length > 0 ? this.map.set(Be.param, et) : this.map.delete(Be.param) } } }), this.cloneFrom = this.updates = null) } } class Kt { constructor() { this.map = new Map } set(Be, ye) { return this.map.set(Be, ye), this } get(Be) { return this.map.has(Be) || this.map.set(Be, Be.defaultValue()), this.map.get(Be) } delete(Be) { return this.map.delete(Be), this } has(Be) { return this.map.has(Be) } keys() { return this.map.keys() } } function Dn(dt) { return typeof ArrayBuffer < "u" && dt instanceof ArrayBuffer } function Mn(dt) { return typeof Blob < "u" && dt instanceof Blob } function On(dt) { return typeof FormData < "u" && dt instanceof FormData } class Hn { constructor(Be, ye, et, Vt) { let At; if (this.url = ye, this.body = null, this.reportProgress = !1, this.withCredentials = !1, this.responseType = "json", this.method = Be.toUpperCase(), function bn(dt) { switch (dt) { case "DELETE": case "GET": case "HEAD": case "OPTIONS": case "JSONP": return !1; default: return !0 } }(this.method) || Vt ? (this.body = void 0 !== et ? et : null, At = Vt) : At = et, At && (this.reportProgress = !!At.reportProgress, this.withCredentials = !!At.withCredentials, At.responseType && (this.responseType = At.responseType), At.headers && (this.headers = At.headers), At.context && (this.context = At.context), At.params && (this.params = At.params)), this.headers || (this.headers = new Ye), this.context || (this.context = new Kt), this.params) { const cn = this.params.toString(); if (0 === cn.length) this.urlWithParams = ye; else { const Tn = ye.indexOf("?"); this.urlWithParams = ye + (-1 === Tn ? "?" : Tn < ye.length - 1 ? "&" : "") + cn } } else this.params = new $e, this.urlWithParams = ye } serializeBody() { return null === this.body ? null : Dn(this.body) || Mn(this.body) || On(this.body) || function Wn(dt) { return typeof URLSearchParams < "u" && dt instanceof URLSearchParams }(this.body) || "string" == typeof this.body ? this.body : this.body instanceof $e ? this.body.toString() : "object" == typeof this.body || "boolean" == typeof this.body || Array.isArray(this.body) ? JSON.stringify(this.body) : this.body.toString() } detectContentTypeHeader() { return null === this.body || On(this.body) ? null : Mn(this.body) ? this.body.type || null : Dn(this.body) ? null : "string" == typeof this.body ? "text/plain" : this.body instanceof $e ? "application/x-www-form-urlencoded;charset=UTF-8" : "object" == typeof this.body || "number" == typeof this.body || "boolean" == typeof this.body ? "application/json" : null } clone(Be = {}) { const ye = Be.method || this.method, et = Be.url || this.url, Vt = Be.responseType || this.responseType, At = void 0 !== Be.body ? Be.body : this.body, cn = void 0 !== Be.withCredentials ? Be.withCredentials : this.withCredentials, Tn = void 0 !== Be.reportProgress ? Be.reportProgress : this.reportProgress; let ii = Be.headers || this.headers, wi = Be.params || this.params; const Xi = Be.context ?? this.context; return void 0 !== Be.setHeaders && (ii = Object.keys(Be.setHeaders).reduce((Dr, xr) => Dr.set(xr, Be.setHeaders[xr]), ii)), Be.setParams && (wi = Object.keys(Be.setParams).reduce((Dr, xr) => Dr.set(xr, Be.setParams[xr]), wi)), new Hn(ye, et, At, { params: wi, headers: ii, context: Xi, reportProgress: Tn, responseType: Vt, withCredentials: cn }) } } var at = (() => ((at = at || {})[at.Sent = 0] = "Sent", at[at.UploadProgress = 1] = "UploadProgress", at[at.ResponseHeader = 2] = "ResponseHeader", at[at.DownloadProgress = 3] = "DownloadProgress", at[at.Response = 4] = "Response", at[at.User = 5] = "User", at))(); class vt { constructor(Be, ye = 200, et = "OK") { this.headers = Be.headers || new Ye, this.status = void 0 !== Be.status ? Be.status : ye, this.statusText = Be.statusText || et, this.url = Be.url || null, this.ok = this.status >= 200 && this.status < 300 } } class it extends vt { constructor(Be = {}) { super(Be), this.type = at.Response, this.body = void 0 !== Be.body ? Be.body : null } clone(Be = {}) { return new it({ body: void 0 !== Be.body ? Be.body : this.body, headers: Be.headers || this.headers, status: void 0 !== Be.status ? Be.status : this.status, statusText: Be.statusText || this.statusText, url: Be.url || this.url || void 0 }) } } function Wt(dt, Be) { return { body: Be, headers: dt.headers, context: dt.context, observe: dt.observe, params: dt.params, reportProgress: dt.reportProgress, responseType: dt.responseType, withCredentials: dt.withCredentials } } let rn = (() => { class dt { constructor(ye) { this.handler = ye } request(ye, et, Vt = {}) { let At; if (ye instanceof Hn) At = ye; else { let ii, wi; ii = Vt.headers instanceof Ye ? Vt.headers : new Ye(Vt.headers), Vt.params && (wi = Vt.params instanceof $e ? Vt.params : new $e({ fromObject: Vt.params })), At = new Hn(ye, et, void 0 !== Vt.body ? Vt.body : null, { headers: ii, context: Vt.context, params: wi, reportProgress: Vt.reportProgress, responseType: Vt.responseType || "json", withCredentials: Vt.withCredentials }) } const cn = (0, he.of)(At).pipe((0, We.b)(ii => this.handler.handle(ii))); if (ye instanceof Hn || "events" === Vt.observe) return cn; const Tn = cn.pipe((0, Pe.h)(ii => ii instanceof it)); switch (Vt.observe || "body") { case "body": switch (At.responseType) { case "arraybuffer": return Tn.pipe((0, Q.U)(ii => { if (null !== ii.body && !(ii.body instanceof ArrayBuffer)) throw new Error("Response is not an ArrayBuffer."); return ii.body })); case "blob": return Tn.pipe((0, Q.U)(ii => { if (null !== ii.body && !(ii.body instanceof Blob)) throw new Error("Response is not a Blob."); return ii.body })); case "text": return Tn.pipe((0, Q.U)(ii => { if (null !== ii.body && "string" != typeof ii.body) throw new Error("Response is not a string."); return ii.body })); default: return Tn.pipe((0, Q.U)(ii => ii.body)) }case "response": return Tn; default: throw new Error(`Unreachable: unhandled observe type ${Vt.observe}}`) } } delete(ye, et = {}) { return this.request("DELETE", ye, et) } get(ye, et = {}) { return this.request("GET", ye, et) } head(ye, et = {}) { return this.request("HEAD", ye, et) } jsonp(ye, et) { return this.request("JSONP", ye, { params: (new $e).append(et, "JSONP_CALLBACK"), observe: "body", responseType: "json" }) } options(ye, et = {}) { return this.request("OPTIONS", ye, et) } patch(ye, et, Vt = {}) { return this.request("PATCH", ye, Wt(Vt, et)) } post(ye, et, Vt = {}) { return this.request("POST", ye, Wt(Vt, et)) } put(ye, et, Vt = {}) { return this.request("PUT", ye, Wt(Vt, et)) } } return dt.\u0275fac = function (ye) { return new (ye || dt)(a.LFG(Ve)) }, dt.\u0275prov = a.Yz7({ token: dt, factory: dt.\u0275fac }), dt })(); var Pn = C(6593); const qn = ["*"]; let ni; function Ai(dt) { return function si() { if (void 0 === ni && (ni = null, typeof window < "u")) { const dt = window; void 0 !== dt.trustedTypes && (ni = dt.trustedTypes.createPolicy("angular#components", { createHTML: Be => Be })) } return ni }()?.createHTML(dt) || dt } function Li(dt) { return Error(`Unable to find icon with the name "${dt}"`) } function $r(dt) { return Error(`The URL provided to MatIconRegistry was not trusted as a resource URL via Angular's DomSanitizer. Attempted URL was "${dt}".`) } function Io(dt) { return Error(`The literal provided to MatIconRegistry was not trusted as safe HTML by Angular's DomSanitizer. Attempted literal was "${dt}".`) } class zi { constructor(Be, ye, et) { this.url = Be, this.svgText = ye, this.options = et } } let Ti = (() => { class dt { constructor(ye, et, Vt, At) { this._httpClient = ye, this._sanitizer = et, this._errorHandler = At, this._svgIconConfigs = new Map, this._iconSetConfigs = new Map, this._cachedIconsByUrl = new Map, this._inProgressUrlFetches = new Map, this._fontCssClassesByAlias = new Map, this._resolvers = [], this._defaultFontSetClass = ["material-icons", "mat-ligature-font"], this._document = Vt } addSvgIcon(ye, et, Vt) { return this.addSvgIconInNamespace("", ye, et, Vt) } addSvgIconLiteral(ye, et, Vt) { return this.addSvgIconLiteralInNamespace("", ye, et, Vt) } addSvgIconInNamespace(ye, et, Vt, At) { return this._addSvgIconConfig(ye, et, new zi(Vt, null, At)) } addSvgIconResolver(ye) { return this._resolvers.push(ye), this } addSvgIconLiteralInNamespace(ye, et, Vt, At) { const cn = this._sanitizer.sanitize(a.q3G.HTML, Vt); if (!cn) throw Io(Vt); const Tn = Ai(cn); return this._addSvgIconConfig(ye, et, new zi("", Tn, At)) } addSvgIconSet(ye, et) { return this.addSvgIconSetInNamespace("", ye, et) } addSvgIconSetLiteral(ye, et) { return this.addSvgIconSetLiteralInNamespace("", ye, et) } addSvgIconSetInNamespace(ye, et, Vt) { return this._addSvgIconSetConfig(ye, new zi(et, null, Vt)) } addSvgIconSetLiteralInNamespace(ye, et, Vt) { const At = this._sanitizer.sanitize(a.q3G.HTML, et); if (!At) throw Io(et); const cn = Ai(At); return this._addSvgIconSetConfig(ye, new zi("", cn, Vt)) } registerFontClassAlias(ye, et = ye) { return this._fontCssClassesByAlias.set(ye, et), this } classNameForFontAlias(ye) { return this._fontCssClassesByAlias.get(ye) || ye } setDefaultFontSetClass(...ye) { return this._defaultFontSetClass = ye, this } getDefaultFontSetClass() { return this._defaultFontSetClass } getSvgIconFromUrl(ye) { const et = this._sanitizer.sanitize(a.q3G.RESOURCE_URL, ye); if (!et) throw $r(ye); const Vt = this._cachedIconsByUrl.get(et); return Vt ? (0, he.of)(bo(Vt)) : this._loadSvgIconFromConfig(new zi(ye, null)).pipe((0, Ie.b)(At => this._cachedIconsByUrl.set(et, At)), (0, Q.U)(At => bo(At))) } getNamedSvgIcon(ye, et = "") { const Vt = Nr(et, ye); let At = this._svgIconConfigs.get(Vt); if (At) return this._getSvgFromConfig(At); if (At = this._getIconConfigFromResolvers(et, ye), At) return this._svgIconConfigs.set(Vt, At), this._getSvgFromConfig(At); const cn = this._iconSetConfigs.get(et); return cn ? this._getSvgFromIconSetConfigs(ye, cn) : (0, Se._)(Li(Vt)) } ngOnDestroy() { this._resolvers = [], this._svgIconConfigs.clear(), this._iconSetConfigs.clear(), this._cachedIconsByUrl.clear() } _getSvgFromConfig(ye) { return ye.svgText ? (0, he.of)(bo(this._svgElementFromConfig(ye))) : this._loadSvgIconFromConfig(ye).pipe((0, Q.U)(et => bo(et))) } _getSvgFromIconSetConfigs(ye, et) { const Vt = this._extractIconWithNameFromAnySet(ye, et); if (Vt) return (0, he.of)(Vt); const At = et.filter(cn => !cn.svgText).map(cn => this._loadSvgIconSetFromConfig(cn).pipe((0, _e.K)(Tn => { const wi = `Loading icon set URL: ${this._sanitizer.sanitize(a.q3G.RESOURCE_URL, cn.url)} failed: ${Tn.message}`; return this._errorHandler.handleError(new Error(wi)), (0, he.of)(null) }))); return (0, ke.D)(At).pipe((0, Q.U)(() => { const cn = this._extractIconWithNameFromAnySet(ye, et); if (!cn) throw Li(ye); return cn })) } _extractIconWithNameFromAnySet(ye, et) { for (let Vt = et.length - 1; Vt >= 0; Vt--) { const At = et[Vt]; if (At.svgText && At.svgText.toString().indexOf(ye) > -1) { const cn = this._svgElementFromConfig(At), Tn = this._extractSvgIconFromSet(cn, ye, At.options); if (Tn) return Tn } } return null } _loadSvgIconFromConfig(ye) { return this._fetchIcon(ye).pipe((0, Ie.b)(et => ye.svgText = et), (0, Q.U)(() => this._svgElementFromConfig(ye))) } _loadSvgIconSetFromConfig(ye) { return ye.svgText ? (0, he.of)(null) : this._fetchIcon(ye).pipe((0, Ie.b)(et => ye.svgText = et)) } _extractSvgIconFromSet(ye, et, Vt) { const At = ye.querySelector(`[id="${et}"]`); if (!At) return null; const cn = At.cloneNode(!0); if (cn.removeAttribute("id"), "svg" === cn.nodeName.toLowerCase()) return this._setSvgAttributes(cn, Vt); if ("symbol" === cn.nodeName.toLowerCase()) return this._setSvgAttributes(this._toSvgElement(cn), Vt); const Tn = this._svgElementFromString(Ai("<svg></svg>")); return Tn.appendChild(cn), this._setSvgAttributes(Tn, Vt) } _svgElementFromString(ye) { const et = this._document.createElement("DIV"); et.innerHTML = ye; const Vt = et.querySelector("svg"); if (!Vt) throw Error("<svg> tag not found"); return Vt } _toSvgElement(ye) { const et = this._svgElementFromString(Ai("<svg></svg>")), Vt = ye.attributes; for (let At = 0; At < Vt.length; At++) { const { name: cn, value: Tn } = Vt[At]; "id" !== cn && et.setAttribute(cn, Tn) } for (let At = 0; At < ye.childNodes.length; At++)ye.childNodes[At].nodeType === this._document.ELEMENT_NODE && et.appendChild(ye.childNodes[At].cloneNode(!0)); return et } _setSvgAttributes(ye, et) { return ye.setAttribute("fit", ""), ye.setAttribute("height", "100%"), ye.setAttribute("width", "100%"), ye.setAttribute("preserveAspectRatio", "xMidYMid meet"), ye.setAttribute("focusable", "false"), et && et.viewBox && ye.setAttribute("viewBox", et.viewBox), ye } _fetchIcon(ye) { const { url: et, options: Vt } = ye, At = Vt?.withCredentials ?? !1; if (!this._httpClient) throw function ho() { return Error("Could not find HttpClient provider for use with Angular Material icons. Please include the HttpClientModule from @angular/common/http in your app imports.") }(); if (null == et) throw Error(`Cannot fetch icon from URL "${et}".`); const cn = this._sanitizer.sanitize(a.q3G.RESOURCE_URL, et); if (!cn) throw $r(et); const Tn = this._inProgressUrlFetches.get(cn); if (Tn) return Tn; const ii = this._httpClient.get(cn, { responseType: "text", withCredentials: At }).pipe((0, Q.U)(wi => Ai(wi)), (0, xe.x)(() => this._inProgressUrlFetches.delete(cn)), (0, ze.B)()); return this._inProgressUrlFetches.set(cn, ii), ii } _addSvgIconConfig(ye, et, Vt) { return this._svgIconConfigs.set(Nr(ye, et), Vt), this } _addSvgIconSetConfig(ye, et) { const Vt = this._iconSetConfigs.get(ye); return Vt ? Vt.push(et) : this._iconSetConfigs.set(ye, [et]), this } _svgElementFromConfig(ye) { if (!ye.svgElement) { const et = this._svgElementFromString(ye.svgText); this._setSvgAttributes(et, ye.options), ye.svgElement = et } return ye.svgElement } _getIconConfigFromResolvers(ye, et) { for (let Vt = 0; Vt < this._resolvers.length; Vt++) { const At = this._resolvers[Vt](et, ye); if (At) return Vi(At) ? new zi(At.url, null, At.options) : new zi(At, null) } } } return dt.\u0275fac = function (ye) { return new (ye || dt)(a.LFG(rn, 8), a.LFG(Pn.H7), a.LFG(Y.K0, 8), a.LFG(a.qLn)) }, dt.\u0275prov = a.Yz7({ token: dt, factory: dt.\u0275fac, providedIn: "root" }), dt })(); function bo(dt) { return dt.cloneNode(!0) } function Nr(dt, Be) { return dt + ":" + Be } function Vi(dt) { return !(!dt.url || !dt.options) } const cs = (0, y.pj)(class { constructor(dt) { this._elementRef = dt } }), fo = new a.OlP("MAT_ICON_DEFAULT_OPTIONS"), Jo = new a.OlP("mat-icon-location", { providedIn: "root", factory: function sr() { const dt = (0, a.f3M)(Y.K0), Be = dt ? dt.location : null; return { getPathname: () => Be ? Be.pathname + Be.search : "" } } }), wt = ["clip-path", "color-profile", "src", "cursor", "fill", "filter", "marker", "marker-start", "marker-mid", "marker-end", "mask", "stroke"], bt = wt.map(dt => `[${dt}]`).join(", "), Rt = /^url\(['"]?#(.*?)['"]?\)$/; let sn = (() => { class dt extends cs { get inline() { return this._inline } set inline(ye) { this._inline = (0, v.Ig)(ye) } get svgIcon() { return this._svgIcon } set svgIcon(ye) { ye !== this._svgIcon && (ye ? this._updateSvgIcon(ye) : this._svgIcon && this._clearSvgElement(), this._svgIcon = ye) } get fontSet() { return this._fontSet } set fontSet(ye) { const et = this._cleanupFontValue(ye); et !== this._fontSet && (this._fontSet = et, this._updateFontIconClasses()) } get fontIcon() { return this._fontIcon } set fontIcon(ye) { const et = this._cleanupFontValue(ye); et !== this._fontIcon && (this._fontIcon = et, this._updateFontIconClasses()) } constructor(ye, et, Vt, At, cn, Tn) { super(ye), this._iconRegistry = et, this._location = At, this._errorHandler = cn, this._inline = !1, this._previousFontSetClass = [], this._currentIconFetch = re.w0.EMPTY, Tn && (Tn.color && (this.color = this.defaultColor = Tn.color), Tn.fontSet && (this.fontSet = Tn.fontSet)), Vt || ye.nativeElement.setAttribute("aria-hidden", "true") } _splitIconName(ye) { if (!ye) return ["", ""]; const et = ye.split(":"); switch (et.length) { case 1: return ["", et[0]]; case 2: return et; default: throw Error(`Invalid icon name: "${ye}"`) } } ngOnInit() { this._updateFontIconClasses() } ngAfterViewChecked() { const ye = this._elementsWithExternalReferences; if (ye && ye.size) { const et = this._location.getPathname(); et !== this._previousPath && (this._previousPath = et, this._prependPathToReferences(et)) } } ngOnDestroy() { this._currentIconFetch.unsubscribe(), this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear() } _usingFontIcon() { return !this.svgIcon } _setSvgElement(ye) { this._clearSvgElement(); const et = this._location.getPathname(); this._previousPath = et, this._cacheChildrenWithExternalReferences(ye), this._prependPathToReferences(et), this._elementRef.nativeElement.appendChild(ye) } _clearSvgElement() { const ye = this._elementRef.nativeElement; let et = ye.childNodes.length; for (this._elementsWithExternalReferences && this._elementsWithExternalReferences.clear(); et--;) { const Vt = ye.childNodes[et]; (1 !== Vt.nodeType || "svg" === Vt.nodeName.toLowerCase()) && Vt.remove() } } _updateFontIconClasses() { if (!this._usingFontIcon()) return; const ye = this._elementRef.nativeElement, et = (this.fontSet ? this._iconRegistry.classNameForFontAlias(this.fontSet).split(/ +/) : this._iconRegistry.getDefaultFontSetClass()).filter(Vt => Vt.length > 0); this._previousFontSetClass.forEach(Vt => ye.classList.remove(Vt)), et.forEach(Vt => ye.classList.add(Vt)), this._previousFontSetClass = et, this.fontIcon !== this._previousFontIconClass && !et.includes("mat-ligature-font") && (this._previousFontIconClass && ye.classList.remove(this._previousFontIconClass), this.fontIcon && ye.classList.add(this.fontIcon), this._previousFontIconClass = this.fontIcon) } _cleanupFontValue(ye) { return "string" == typeof ye ? ye.trim().split(" ")[0] : ye } _prependPathToReferences(ye) { const et = this._elementsWithExternalReferences; et && et.forEach((Vt, At) => { Vt.forEach(cn => { At.setAttribute(cn.name, `url('${ye}#${cn.value}')`) }) }) } _cacheChildrenWithExternalReferences(ye) { const et = ye.querySelectorAll(bt), Vt = this._elementsWithExternalReferences = this._elementsWithExternalReferences || new Map; for (let At = 0; At < et.length; At++)wt.forEach(cn => { const Tn = et[At], ii = Tn.getAttribute(cn), wi = ii ? ii.match(Rt) : null; if (wi) { let Xi = Vt.get(Tn); Xi || (Xi = [], Vt.set(Tn, Xi)), Xi.push({ name: cn, value: wi[1] }) } }) } _updateSvgIcon(ye) { if (this._svgNamespace = null, this._svgName = null, this._currentIconFetch.unsubscribe(), ye) { const [et, Vt] = this._splitIconName(ye); et && (this._svgNamespace = et), Vt && (this._svgName = Vt), this._currentIconFetch = this._iconRegistry.getNamedSvgIcon(Vt, et).pipe((0, Oe.q)(1)).subscribe(At => this._setSvgElement(At), At => { this._errorHandler.handleError(new Error(`Error retrieving icon ${et}:${Vt}! ${At.message}`)) }) } } } return dt.\u0275fac = function (ye) { return new (ye || dt)(a.Y36(a.SBq), a.Y36(Ti), a.$8M("aria-hidden"), a.Y36(Jo), a.Y36(a.qLn), a.Y36(fo, 8)) }, dt.\u0275cmp = a.Xpm({ type: dt, selectors: [["mat-icon"]], hostAttrs: ["role", "img", 1, "mat-icon", "notranslate"], hostVars: 8, hostBindings: function (ye, et) { 2 & ye && (a.uIk("data-mat-icon-type", et._usingFontIcon() ? "font" : "svg")("data-mat-icon-name", et._svgName || et.fontIcon)("data-mat-icon-namespace", et._svgNamespace || et.fontSet)("fontIcon", et._usingFontIcon() ? et.fontIcon : null), a.ekj("mat-icon-inline", et.inline)("mat-icon-no-color", "primary" !== et.color && "accent" !== et.color && "warn" !== et.color)) }, inputs: { color: "color", inline: "inline", svgIcon: "svgIcon", fontSet: "fontSet", fontIcon: "fontIcon" }, exportAs: ["matIcon"], features: [a.qOj], ngContentSelectors: qn, decls: 1, vars: 0, template: function (ye, et) { 1 & ye && (a.F$t(), a.Hsn(0)) }, styles: [".mat-icon{-webkit-user-select:none;user-select:none;background-repeat:no-repeat;display:inline-block;fill:currentColor;height:24px;width:24px;overflow:hidden}.mat-icon.mat-icon-inline{font-size:inherit;height:inherit;line-height:inherit;width:inherit}.mat-icon.mat-ligature-font[fontIcon]::before{content:attr(fontIcon)}[dir=rtl] .mat-icon-rtl-mirror{transform:scale(-1, 1)}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon{display:block}.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-prefix .mat-icon-button .mat-icon,.mat-form-field:not(.mat-form-field-appearance-legacy) .mat-form-field-suffix .mat-icon-button .mat-icon{margin:auto}"], encapsulation: 2, changeDetection: 0 }), dt })(), wn = (() => { class dt { } return dt.\u0275fac = function (ye) { return new (ye || dt) }, dt.\u0275mod = a.oAB({ type: dt }), dt.\u0275inj = a.cJS({ imports: [y.BQ, y.BQ] }), dt })() }, 2032: (nn, Qe, C) => { C.d(Qe, { Jk: () => We, Nt: () => Ye, c: () => ut }); var a = C(2495), y = C(2831), v = C(5879), Y = C(6232), he = C(8645); const Se = (0, y.i$)({ passive: !0 }); let ke = (() => { class ie { constructor(le, ge) { this._platform = le, this._ngZone = ge, this._monitoredElements = new Map } monitor(le) { if (!this._platform.isBrowser) return Y.E; const ge = (0, a.fI)(le), ue = this._monitoredElements.get(ge); if (ue) return ue.subject; const ee = new he.x, $e = "cdk-text-field-autofilled", rt = Kt => { "cdk-text-field-autofill-start" !== Kt.animationName || ge.classList.contains($e) ? "cdk-text-field-autofill-end" === Kt.animationName && ge.classList.contains($e) && (ge.classList.remove($e), this._ngZone.run(() => ee.next({ target: Kt.target, isAutofilled: !1 }))) : (ge.classList.add($e), this._ngZone.run(() => ee.next({ target: Kt.target, isAutofilled: !0 }))) }; return this._ngZone.runOutsideAngular(() => { ge.addEventListener("animationstart", rt, Se), ge.classList.add("cdk-text-field-autofill-monitored") }), this._monitoredElements.set(ge, { subject: ee, unlisten: () => { ge.removeEventListener("animationstart", rt, Se) } }), ee } stopMonitoring(le) { const ge = (0, a.fI)(le), ue = this._monitoredElements.get(ge); ue && (ue.unlisten(), ue.subject.complete(), ge.classList.remove("cdk-text-field-autofill-monitored"), ge.classList.remove("cdk-text-field-autofilled"), this._monitoredElements.delete(ge)) } ngOnDestroy() { this._monitoredElements.forEach((le, ge) => this.stopMonitoring(ge)) } } return ie.\u0275fac = function (le) { return new (le || ie)(v.LFG(y.t4), v.LFG(v.R0b)) }, ie.\u0275prov = v.Yz7({ token: ie, factory: ie.\u0275fac, providedIn: "root" }), ie })(), Q = (() => { class ie { } return ie.\u0275fac = function (le) { return new (le || ie) }, ie.\u0275mod = v.oAB({ type: ie }), ie.\u0275inj = v.cJS({}), ie })(); var _e = C(6223), xe = C(3680), ze = C(4170); const We = new v.OlP("MAT_INPUT_VALUE_ACCESSOR"), Pe = ["button", "checkbox", "file", "hidden", "image", "radio", "range", "reset", "submit"]; let Ve = 0; const tt = (0, xe.FD)(class { constructor(ie, Le, le, ge) { this._defaultErrorStateMatcher = ie, this._parentForm = Le, this._parentFormGroup = le, this.ngControl = ge, this.stateChanges = new he.x } }); let Ye = (() => { class ie extends tt { get disabled() { return this._disabled } set disabled(le) { this._disabled = (0, a.Ig)(le), this.focused && (this.focused = !1, this.stateChanges.next()) } get id() { return this._id } set id(le) { this._id = le || this._uid } get required() { return this._required ?? this.ngControl?.control?.hasValidator(_e.kI.required) ?? !1 } set required(le) { this._required = (0, a.Ig)(le) } get type() { return this._type } set type(le) { this._type = le || "text", this._validateType(), !this._isTextarea && (0, y.qK)().has(this._type) && (this._elementRef.nativeElement.type = this._type) } get value() { return this._inputValueAccessor.value } set value(le) { le !== this.value && (this._inputValueAccessor.value = le, this.stateChanges.next()) } get readonly() { return this._readonly } set readonly(le) { this._readonly = (0, a.Ig)(le) } constructor(le, ge, ue, ee, $e, rt, Kt, bn, Dn, Mn) { super(rt, ee, $e, ue), this._elementRef = le, this._platform = ge, this._autofillMonitor = bn, this._formField = Mn, this._uid = "mat-input-" + Ve++, this.focused = !1, this.stateChanges = new he.x, this.controlType = "mat-input", this.autofilled = !1, this._disabled = !1, this._type = "text", this._readonly = !1, this._neverEmptyInputTypes = ["date", "datetime", "datetime-local", "month", "time", "week"].filter(Hn => (0, y.qK)().has(Hn)), this._iOSKeyupListener = Hn => { const at = Hn.target; !at.value && 0 === at.selectionStart && 0 === at.selectionEnd && (at.setSelectionRange(1, 1), at.setSelectionRange(0, 0)) }; const On = this._elementRef.nativeElement, Wn = On.nodeName.toLowerCase(); this._inputValueAccessor = Kt || On, this._previousNativeValue = this.value, this.id = this.id, ge.IOS && Dn.runOutsideAngular(() => { le.nativeElement.addEventListener("keyup", this._iOSKeyupListener) }), this._isServer = !this._platform.isBrowser, this._isNativeSelect = "select" === Wn, this._isTextarea = "textarea" === Wn, this._isInFormField = !!Mn, this._isNativeSelect && (this.controlType = On.multiple ? "mat-native-select-multiple" : "mat-native-select") } ngAfterViewInit() { this._platform.isBrowser && this._autofillMonitor.monitor(this._elementRef.nativeElement).subscribe(le => { this.autofilled = le.isAutofilled, this.stateChanges.next() }) } ngOnChanges() { this.stateChanges.next() } ngOnDestroy() { this.stateChanges.complete(), this._platform.isBrowser && this._autofillMonitor.stopMonitoring(this._elementRef.nativeElement), this._platform.IOS && this._elementRef.nativeElement.removeEventListener("keyup", this._iOSKeyupListener) } ngDoCheck() { this.ngControl && (this.updateErrorState(), null !== this.ngControl.disabled && this.ngControl.disabled !== this.disabled && (this.disabled = this.ngControl.disabled, this.stateChanges.next())), this._dirtyCheckNativeValue(), this._dirtyCheckPlaceholder() } focus(le) { this._elementRef.nativeElement.focus(le) } _focusChanged(le) { le !== this.focused && (this.focused = le, this.stateChanges.next()) } _onInput() { } _dirtyCheckNativeValue() { const le = this._elementRef.nativeElement.value; this._previousNativeValue !== le && (this._previousNativeValue = le, this.stateChanges.next()) } _dirtyCheckPlaceholder() { const le = this._getPlaceholder(); if (le !== this._previousPlaceholder) { const ge = this._elementRef.nativeElement; this._previousPlaceholder = le, le ? ge.setAttribute("placeholder", le) : ge.removeAttribute("placeholder") } } _getPlaceholder() { return this.placeholder || null } _validateType() { Pe.indexOf(this._type) } _isNeverEmpty() { return this._neverEmptyInputTypes.indexOf(this._type) > -1 } _isBadInput() { let le = this._elementRef.nativeElement.validity; return le && le.badInput } get empty() { return !(this._isNeverEmpty() || this._elementRef.nativeElement.value || this._isBadInput() || this.autofilled) } get shouldLabelFloat() { if (this._isNativeSelect) { const le = this._elementRef.nativeElement, ge = le.options[0]; return this.focused || le.multiple || !this.empty || !!(le.selectedIndex > -1 && ge && ge.label) } return this.focused || !this.empty } setDescribedByIds(le) { le.length ? this._elementRef.nativeElement.setAttribute("aria-describedby", le.join(" ")) : this._elementRef.nativeElement.removeAttribute("aria-describedby") } onContainerClick() { this.focused || this.focus() } _isInlineSelect() { const le = this._elementRef.nativeElement; return this._isNativeSelect && (le.multiple || le.size > 1) } } return ie.\u0275fac = function (le) { return new (le || ie)(v.Y36(v.SBq), v.Y36(y.t4), v.Y36(_e.a5, 10), v.Y36(_e.F, 8), v.Y36(_e.sg, 8), v.Y36(xe.rD), v.Y36(We, 10), v.Y36(ke), v.Y36(v.R0b), v.Y36(ze.G_, 8)) }, ie.\u0275dir = v.lG2({ type: ie, selectors: [["input", "matInput", ""], ["textarea", "matInput", ""], ["select", "matNativeControl", ""], ["input", "matNativeControl", ""], ["textarea", "matNativeControl", ""]], hostAttrs: [1, "mat-mdc-input-element"], hostVars: 18, hostBindings: function (le, ge) { 1 & le && v.NdJ("focus", function () { return ge._focusChanged(!0) })("blur", function () { return ge._focusChanged(!1) })("input", function () { return ge._onInput() }), 2 & le && (v.Ikx("id", ge.id)("disabled", ge.disabled)("required", ge.required), v.uIk("name", ge.name || null)("readonly", ge.readonly && !ge._isNativeSelect || null)("aria-invalid", ge.empty && ge.required ? null : ge.errorState)("aria-required", ge.required)("id", ge.id), v.ekj("mat-input-server", ge._isServer)("mat-mdc-form-field-textarea-control", ge._isInFormField && ge._isTextarea)("mat-mdc-form-field-input-control", ge._isInFormField)("mdc-text-field__input", ge._isInFormField)("mat-mdc-native-select-inline", ge._isInlineSelect())) }, inputs: { disabled: "disabled", id: "id", placeholder: "placeholder", name: "name", required: "required", type: "type", errorStateMatcher: "errorStateMatcher", userAriaDescribedBy: ["aria-describedby", "userAriaDescribedBy"], value: "value", readonly: "readonly" }, exportAs: ["matInput"], features: [v._Bn([{ provide: ze.Eo, useExisting: ie }]), v.qOj, v.TTD] }), ie })(), ut = (() => { class ie { } return ie.\u0275fac = function (le) { return new (le || ie) }, ie.\u0275mod = v.oAB({ type: ie }), ie.\u0275inj = v.cJS({ imports: [xe.BQ, ze.lN, ze.lN, Q, xe.BQ] }), ie })() }, 1919: (nn, Qe, C) => { C.d(Qe, { ie: () => Ot }); var a = C(5879), Y = (C(2495), C(2831), C(3680)), re = (C(7394), C(3019), C(8645), C(7131)), Ie = C(6814); let _e = (() => { class ve { } return ve.\u0275fac = function (Z) { return new (Z || ve) }, ve.\u0275mod = a.oAB({ type: ve }), ve.\u0275inj = a.cJS({ imports: [Y.BQ, Y.BQ] }), ve })(); C(4191), C(8337), C(6028), C(6223), C(9773); let Ot = (() => { class ve { } return ve.\u0275fac = function (Z) { return new (Z || ve) }, ve.\u0275mod = a.oAB({ type: ve }), ve.\u0275inj = a.cJS({ imports: [re.Q8, Ie.ez, Y.BQ, Y.si, Y.us, _e] }), ve })() }, 7466: (nn, Qe, C) => { C.d(Qe, { Fk: () => Le, U0: () => ie, VQ: () => ut }); var a = C(5879), y = C(3680), v = C(4191), Y = C(2495), he = C(8337), Se = C(6223), ke = C(6814); const re = ["input"], Ie = ["*"]; let Q = 0; class _e { constructor(ge, ue) { this.source = ge, this.value = ue } } const xe = { provide: Se.JU, useExisting: (0, a.Gpc)(() => ut), multi: !0 }, ze = new a.OlP("MatRadioGroup"), Oe = new a.OlP("mat-radio-default-options", { providedIn: "root", factory: function We() { return { color: "accent" } } }); let Pe = (() => { class le { get name() { return this._name } set name(ue) { this._name = ue, this._updateRadioButtonNames() } get labelPosition() { return this._labelPosition } set labelPosition(ue) { this._labelPosition = "before" === ue ? "before" : "after", this._markRadiosForCheck() } get value() { return this._value } set value(ue) { this._value !== ue && (this._value = ue, this._updateSelectedRadioFromValue(), this._checkSelectedRadioButton()) } _checkSelectedRadioButton() { this._selected && !this._selected.checked && (this._selected.checked = !0) } get selected() { return this._selected } set selected(ue) { this._selected = ue, this.value = ue ? ue.value : null, this._checkSelectedRadioButton() } get disabled() { return this._disabled } set disabled(ue) { this._disabled = (0, Y.Ig)(ue), this._markRadiosForCheck() } get required() { return this._required } set required(ue) { this._required = (0, Y.Ig)(ue), this._markRadiosForCheck() } constructor(ue) { this._changeDetector = ue, this._value = null, this._name = "mat-radio-group-" + Q++, this._selected = null, this._isInitialized = !1, this._labelPosition = "after", this._disabled = !1, this._required = !1, this._controlValueAccessorChangeFn = () => { }, this.onTouched = () => { }, this.change = new a.vpe } ngAfterContentInit() { this._isInitialized = !0 } _touch() { this.onTouched && this.onTouched() } _updateRadioButtonNames() { this._radios && this._radios.forEach(ue => { ue.name = this.name, ue._markForCheck() }) } _updateSelectedRadioFromValue() { this._radios && (null === this._selected || this._selected.value !== this._value) && (this._selected = null, this._radios.forEach(ee => { ee.checked = this.value === ee.value, ee.checked && (this._selected = ee) })) } _emitChangeEvent() { this._isInitialized && this.change.emit(new _e(this._selected, this._value)) } _markRadiosForCheck() { this._radios && this._radios.forEach(ue => ue._markForCheck()) } writeValue(ue) { this.value = ue, this._changeDetector.markForCheck() } registerOnChange(ue) { this._controlValueAccessorChangeFn = ue } registerOnTouched(ue) { this.onTouched = ue } setDisabledState(ue) { this.disabled = ue, this._changeDetector.markForCheck() } } return le.\u0275fac = function (ue) { return new (ue || le)(a.Y36(a.sBO)) }, le.\u0275dir = a.lG2({ type: le, inputs: { color: "color", name: "name", labelPosition: "labelPosition", value: "value", selected: "selected", disabled: "disabled", required: "required" }, outputs: { change: "change" } }), le })(); class Ve { constructor(ge) { this._elementRef = ge } } const tt = (0, y.Kr)((0, y.sb)(Ve)); let Ye = (() => { class le extends tt { get checked() { return this._checked } set checked(ue) { const ee = (0, Y.Ig)(ue); this._checked !== ee && (this._checked = ee, ee && this.radioGroup && this.radioGroup.value !== this.value ? this.radioGroup.selected = this : !ee && this.radioGroup && this.radioGroup.value === this.value && (this.radioGroup.selected = null), ee && this._radioDispatcher.notify(this.id, this.name), this._changeDetector.markForCheck()) } get value() { return this._value } set value(ue) { this._value !== ue && (this._value = ue, null !== this.radioGroup && (this.checked || (this.checked = this.radioGroup.value === ue), this.checked && (this.radioGroup.selected = this))) } get labelPosition() { return this._labelPosition || this.radioGroup && this.radioGroup.labelPosition || "after" } set labelPosition(ue) { this._labelPosition = ue } get disabled() { return this._disabled || null !== this.radioGroup && this.radioGroup.disabled } set disabled(ue) { this._setDisabled((0, Y.Ig)(ue)) } get required() { return this._required || this.radioGroup && this.radioGroup.required } set required(ue) { this._required = (0, Y.Ig)(ue) } get color() { return this._color || this.radioGroup && this.radioGroup.color || this._providerOverride && this._providerOverride.color || "accent" } set color(ue) { this._color = ue } get inputId() { return `${this.id || this._uniqueId}-input` } constructor(ue, ee, $e, rt, Kt, bn, Dn, Mn) { super(ee), this._changeDetector = $e, this._focusMonitor = rt, this._radioDispatcher = Kt, this._providerOverride = Dn, this._uniqueId = "mat-radio-" + ++Q, this.id = this._uniqueId, this.change = new a.vpe, this._checked = !1, this._value = null, this._removeUniqueSelectionListener = () => { }, this.radioGroup = ue, this._noopAnimations = "NoopAnimations" === bn, Mn && (this.tabIndex = (0, Y.su)(Mn, 0)) } focus(ue, ee) { ee ? this._focusMonitor.focusVia(this._inputElement, ee, ue) : this._inputElement.nativeElement.focus(ue) } _markForCheck() { this._changeDetector.markForCheck() } ngOnInit() { this.radioGroup && (this.checked = this.radioGroup.value === this._value, this.checked && (this.radioGroup.selected = this), this.name = this.radioGroup.name), this._removeUniqueSelectionListener = this._radioDispatcher.listen((ue, ee) => { ue !== this.id && ee === this.name && (this.checked = !1) }) } ngDoCheck() { this._updateTabIndex() } ngAfterViewInit() { this._updateTabIndex(), this._focusMonitor.monitor(this._elementRef, !0).subscribe(ue => { !ue && this.radioGroup && this.radioGroup._touch() }) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this._elementRef), this._removeUniqueSelectionListener() } _emitChangeEvent() { this.change.emit(new _e(this, this._value)) } _isRippleDisabled() { return this.disableRipple || this.disabled } _onInputClick(ue) { ue.stopPropagation() } _onInputInteraction(ue) { if (ue.stopPropagation(), !this.checked && !this.disabled) { const ee = this.radioGroup && this.value !== this.radioGroup.value; this.checked = !0, this._emitChangeEvent(), this.radioGroup && (this.radioGroup._controlValueAccessorChangeFn(this.value), ee && this.radioGroup._emitChangeEvent()) } } _onTouchTargetClick(ue) { this._onInputInteraction(ue), this.disabled || this._inputElement.nativeElement.focus() } _setDisabled(ue) { this._disabled !== ue && (this._disabled = ue, this._changeDetector.markForCheck()) } _updateTabIndex() { const ue = this.radioGroup; let ee; if (ee = ue && ue.selected && !this.disabled ? ue.selected === this ? this.tabIndex : -1 : this.tabIndex, ee !== this._previousTabIndex) { const $e = this._inputElement?.nativeElement; $e && ($e.setAttribute("tabindex", ee + ""), this._previousTabIndex = ee) } } } return le.\u0275fac = function (ue) { a.$Z() }, le.\u0275dir = a.lG2({ type: le, viewQuery: function (ue, ee) { if (1 & ue && a.Gf(re, 5), 2 & ue) { let $e; a.iGM($e = a.CRH()) && (ee._inputElement = $e.first) } }, inputs: { id: "id", name: "name", ariaLabel: ["aria-label", "ariaLabel"], ariaLabelledby: ["aria-labelledby", "ariaLabelledby"], ariaDescribedby: ["aria-describedby", "ariaDescribedby"], checked: "checked", value: "value", labelPosition: "labelPosition", disabled: "disabled", required: "required", color: "color" }, outputs: { change: "change" }, features: [a.qOj] }), le })(), ut = (() => { class le extends Pe { } return le.\u0275fac = function () { let ge; return function (ee) { return (ge || (ge = a.n5z(le)))(ee || le) } }(), le.\u0275dir = a.lG2({ type: le, selectors: [["mat-radio-group"]], contentQueries: function (ue, ee, $e) { if (1 & ue && a.Suo($e, ie, 5), 2 & ue) { let rt; a.iGM(rt = a.CRH()) && (ee._radios = rt) } }, hostAttrs: ["role", "radiogroup", 1, "mat-mdc-radio-group"], exportAs: ["matRadioGroup"], features: [a._Bn([xe, { provide: ze, useExisting: le }]), a.qOj] }), le })(), ie = (() => { class le extends Ye { constructor(ue, ee, $e, rt, Kt, bn, Dn, Mn) { super(ue, ee, $e, rt, Kt, bn, Dn, Mn) } } return le.\u0275fac = function (ue) { return new (ue || le)(a.Y36(ze, 8), a.Y36(a.SBq), a.Y36(a.sBO), a.Y36(v.tE), a.Y36(he.A8), a.Y36(a.QbO, 8), a.Y36(Oe, 8), a.$8M("tabindex")) }, le.\u0275cmp = a.Xpm({ type: le, selectors: [["mat-radio-button"]], hostAttrs: [1, "mat-mdc-radio-button"], hostVars: 15, hostBindings: function (ue, ee) { 1 & ue && a.NdJ("focus", function () { return ee._inputElement.nativeElement.focus() }), 2 & ue && (a.uIk("id", ee.id)("tabindex", null)("aria-label", null)("aria-labelledby", null)("aria-describedby", null), a.ekj("mat-primary", "primary" === ee.color)("mat-accent", "accent" === ee.color)("mat-warn", "warn" === ee.color)("mat-mdc-radio-checked", ee.checked)("_mat-animation-noopable", ee._noopAnimations)) }, inputs: { disableRipple: "disableRipple", tabIndex: "tabIndex" }, exportAs: ["matRadioButton"], features: [a.qOj], ngContentSelectors: Ie, decls: 13, vars: 17, consts: [[1, "mdc-form-field"], ["formField", ""], [1, "mdc-radio"], [1, "mat-mdc-radio-touch-target", 3, "click"], ["type", "radio", 1, "mdc-radio__native-control", 3, "id", "checked", "disabled", "required", "change"], ["input", ""], [1, "mdc-radio__background"], [1, "mdc-radio__outer-circle"], [1, "mdc-radio__inner-circle"], ["mat-ripple", "", 1, "mat-radio-ripple", "mat-mdc-focus-indicator", 3, "matRippleTrigger", "matRippleDisabled", "matRippleCentered"], [1, "mat-ripple-element", "mat-radio-persistent-ripple"], [1, "mdc-label", 3, "for"]], template: function (ue, ee) { if (1 & ue && (a.F$t(), a.TgZ(0, "div", 0, 1)(2, "div", 2)(3, "div", 3), a.NdJ("click", function (rt) { return ee._onTouchTargetClick(rt) }), a.qZA(), a.TgZ(4, "input", 4, 5), a.NdJ("change", function (rt) { return ee._onInputInteraction(rt) }), a.qZA(), a.TgZ(6, "div", 6), a._UZ(7, "div", 7)(8, "div", 8), a.qZA(), a.TgZ(9, "div", 9), a._UZ(10, "div", 10), a.qZA()(), a.TgZ(11, "label", 11), a.Hsn(12), a.qZA()()), 2 & ue) { const $e = a.MAs(1); a.ekj("mdc-form-field--align-end", "before" == ee.labelPosition), a.xp6(2), a.ekj("mdc-radio--disabled", ee.disabled), a.xp6(2), a.Q6J("id", ee.inputId)("checked", ee.checked)("disabled", ee.disabled)("required", ee.required), a.uIk("name", ee.name)("value", ee.value)("aria-label", ee.ariaLabel)("aria-labelledby", ee.ariaLabelledby)("aria-describedby", ee.ariaDescribedby), a.xp6(5), a.Q6J("matRippleTrigger", $e)("matRippleDisabled", ee._isRippleDisabled())("matRippleCentered", !0), a.xp6(2), a.Q6J("for", ee.inputId) } }, dependencies: [y.wG], styles: ['.mdc-radio{display:inline-block;position:relative;flex:0 0 auto;box-sizing:content-box;width:20px;height:20px;cursor:pointer;will-change:opacity,transform,border-color,color}.mdc-radio[hidden]{display:none}.mdc-radio__background{display:inline-block;position:relative;box-sizing:border-box;width:20px;height:20px}.mdc-radio__background::before{position:absolute;transform:scale(0, 0);border-radius:50%;opacity:0;pointer-events:none;content:"";transition:opacity 120ms 0ms cubic-bezier(0.4, 0, 0.6, 1),transform 120ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-radio__outer-circle{position:absolute;top:0;left:0;box-sizing:border-box;width:100%;height:100%;border-width:2px;border-style:solid;border-radius:50%;transition:border-color 120ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-radio__inner-circle{position:absolute;top:0;left:0;box-sizing:border-box;width:100%;height:100%;transform:scale(0, 0);border-width:10px;border-style:solid;border-radius:50%;transition:transform 120ms 0ms cubic-bezier(0.4, 0, 0.6, 1),border-color 120ms 0ms cubic-bezier(0.4, 0, 0.6, 1)}.mdc-radio__native-control{position:absolute;margin:0;padding:0;opacity:0;cursor:inherit;z-index:1}.mdc-radio--touch{margin-top:4px;margin-bottom:4px;margin-right:4px;margin-left:4px}.mdc-radio--touch .mdc-radio__native-control{top:calc((40px - 48px) / 2);right:calc((40px - 48px) / 2);left:calc((40px - 48px) / 2);width:48px;height:48px}.mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__focus-ring,.mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__focus-ring{pointer-events:none;border:2px solid rgba(0,0,0,0);border-radius:6px;box-sizing:content-box;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:100%;width:100%}@media screen and (forced-colors: active){.mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__focus-ring,.mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__focus-ring{border-color:CanvasText}}.mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__focus-ring::after,.mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__focus-ring::after{content:"";border:2px solid rgba(0,0,0,0);border-radius:8px;display:block;position:absolute;top:50%;left:50%;transform:translate(-50%, -50%);height:calc(100% + 4px);width:calc(100% + 4px)}@media screen and (forced-colors: active){.mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__focus-ring::after,.mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__focus-ring::after{border-color:CanvasText}}.mdc-radio__native-control:checked+.mdc-radio__background,.mdc-radio__native-control:disabled+.mdc-radio__background{transition:opacity 120ms 0ms cubic-bezier(0, 0, 0.2, 1),transform 120ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__outer-circle,.mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__outer-circle{transition:border-color 120ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__inner-circle,.mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__inner-circle{transition:transform 120ms 0ms cubic-bezier(0, 0, 0.2, 1),border-color 120ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-radio--disabled{cursor:default;pointer-events:none}.mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__inner-circle{transform:scale(0.5);transition:transform 120ms 0ms cubic-bezier(0, 0, 0.2, 1),border-color 120ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-radio__native-control:disabled+.mdc-radio__background,[aria-disabled=true] .mdc-radio__native-control+.mdc-radio__background{cursor:default}.mdc-radio__native-control:focus+.mdc-radio__background::before{transform:scale(1);opacity:.12;transition:opacity 120ms 0ms cubic-bezier(0, 0, 0.2, 1),transform 120ms 0ms cubic-bezier(0, 0, 0.2, 1)}.mdc-form-field{display:inline-flex;align-items:center;vertical-align:middle}.mdc-form-field[hidden]{display:none}.mdc-form-field>label{margin-left:0;margin-right:auto;padding-left:4px;padding-right:0;order:0}[dir=rtl] .mdc-form-field>label,.mdc-form-field>label[dir=rtl]{margin-left:auto;margin-right:0}[dir=rtl] .mdc-form-field>label,.mdc-form-field>label[dir=rtl]{padding-left:0;padding-right:4px}.mdc-form-field--nowrap>label{text-overflow:ellipsis;overflow:hidden;white-space:nowrap}.mdc-form-field--align-end>label{margin-left:auto;margin-right:0;padding-left:0;padding-right:4px;order:-1}[dir=rtl] .mdc-form-field--align-end>label,.mdc-form-field--align-end>label[dir=rtl]{margin-left:0;margin-right:auto}[dir=rtl] .mdc-form-field--align-end>label,.mdc-form-field--align-end>label[dir=rtl]{padding-left:4px;padding-right:0}.mdc-form-field--space-between{justify-content:space-between}.mdc-form-field--space-between>label{margin:0}[dir=rtl] .mdc-form-field--space-between>label,.mdc-form-field--space-between>label[dir=rtl]{margin:0}.mat-mdc-radio-button{--mdc-radio-disabled-selected-icon-opacity:0.38;--mdc-radio-disabled-unselected-icon-opacity:0.38;--mdc-radio-state-layer-size:40px;-webkit-tap-highlight-color:rgba(0,0,0,0)}.mat-mdc-radio-button .mdc-radio{padding:calc((var(--mdc-radio-state-layer-size) - 20px) / 2)}.mat-mdc-radio-button .mdc-radio [aria-disabled=true] .mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:disabled:checked+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-disabled-selected-icon-color)}.mat-mdc-radio-button .mdc-radio [aria-disabled=true] .mdc-radio__native-control+.mdc-radio__background .mdc-radio__inner-circle,.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__inner-circle{border-color:var(--mdc-radio-disabled-selected-icon-color)}.mat-mdc-radio-button .mdc-radio [aria-disabled=true] .mdc-radio__native-control:checked+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:disabled:checked+.mdc-radio__background .mdc-radio__outer-circle{opacity:var(--mdc-radio-disabled-selected-icon-opacity)}.mat-mdc-radio-button .mdc-radio [aria-disabled=true] .mdc-radio__native-control+.mdc-radio__background .mdc-radio__inner-circle,.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:disabled+.mdc-radio__background .mdc-radio__inner-circle{opacity:var(--mdc-radio-disabled-selected-icon-opacity)}.mat-mdc-radio-button .mdc-radio [aria-disabled=true] .mdc-radio__native-control:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:disabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-disabled-unselected-icon-color)}.mat-mdc-radio-button .mdc-radio [aria-disabled=true] .mdc-radio__native-control:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:disabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{opacity:var(--mdc-radio-disabled-unselected-icon-opacity)}.mat-mdc-radio-button .mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__outer-circle,.mat-mdc-radio-button .mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-selected-focus-icon-color)}.mat-mdc-radio-button .mdc-radio.mdc-ripple-upgraded--background-focused .mdc-radio__native-control:enabled+.mdc-radio__background .mdc-radio__inner-circle,.mat-mdc-radio-button .mdc-radio:not(.mdc-ripple-upgraded):focus .mdc-radio__native-control:enabled+.mdc-radio__background .mdc-radio__inner-circle{border-color:var(--mdc-radio-selected-focus-icon-color)}.mat-mdc-radio-button .mdc-radio:hover .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-selected-hover-icon-color)}.mat-mdc-radio-button .mdc-radio:hover .mdc-radio__native-control:enabled+.mdc-radio__background .mdc-radio__inner-circle{border-color:var(--mdc-radio-selected-hover-icon-color)}.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-selected-icon-color)}.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:enabled+.mdc-radio__background .mdc-radio__inner-circle{border-color:var(--mdc-radio-selected-icon-color)}.mat-mdc-radio-button .mdc-radio:not(:disabled):active .mdc-radio__native-control:enabled:checked+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-selected-pressed-icon-color)}.mat-mdc-radio-button .mdc-radio:not(:disabled):active .mdc-radio__native-control:enabled+.mdc-radio__background .mdc-radio__inner-circle{border-color:var(--mdc-radio-selected-pressed-icon-color)}.mat-mdc-radio-button .mdc-radio:hover .mdc-radio__native-control:enabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-unselected-hover-icon-color)}.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:enabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-unselected-icon-color)}.mat-mdc-radio-button .mdc-radio:not(:disabled):active .mdc-radio__native-control:enabled:not(:checked)+.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-unselected-pressed-icon-color)}.mat-mdc-radio-button .mdc-radio .mdc-radio__background::before{top:calc(-1 * (var(--mdc-radio-state-layer-size) - 20px) / 2);left:calc(-1 * (var(--mdc-radio-state-layer-size) - 20px) / 2);width:var(--mdc-radio-state-layer-size);height:var(--mdc-radio-state-layer-size)}.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control{top:calc((var(--mdc-radio-state-layer-size) - var(--mdc-radio-state-layer-size)) / 2);right:calc((var(--mdc-radio-state-layer-size) - var(--mdc-radio-state-layer-size)) / 2);left:calc((var(--mdc-radio-state-layer-size) - var(--mdc-radio-state-layer-size)) / 2);width:var(--mdc-radio-state-layer-size);height:var(--mdc-radio-state-layer-size)}.mat-mdc-radio-button .mdc-radio .mdc-radio__background::before{background-color:var(--mat-radio-ripple-color)}.mat-mdc-radio-button .mdc-radio:hover .mdc-radio__native-control:not([disabled]):not(:focus)~.mdc-radio__background::before{opacity:.04;transform:scale(1)}.mat-mdc-radio-button.mat-mdc-radio-checked .mdc-radio__background::before{background-color:var(--mat-radio-checked-ripple-color)}.mat-mdc-radio-button.mat-mdc-radio-checked .mat-ripple-element{background-color:var(--mat-radio-checked-ripple-color)}.mat-mdc-radio-button .mdc-radio--disabled+label{color:var(--mat-radio-disabled-label-color)}.mat-mdc-radio-button .mat-radio-ripple{top:0;left:0;right:0;bottom:0;position:absolute;pointer-events:none;border-radius:50%}.mat-mdc-radio-button .mat-radio-ripple .mat-ripple-element{opacity:.14}.mat-mdc-radio-button .mat-radio-ripple::before{border-radius:50%}.mat-mdc-radio-button._mat-animation-noopable .mdc-radio__background::before,.mat-mdc-radio-button._mat-animation-noopable .mdc-radio__outer-circle,.mat-mdc-radio-button._mat-animation-noopable .mdc-radio__inner-circle{transition:none !important}.mat-mdc-radio-button .mdc-radio .mdc-radio__native-control:focus:enabled:not(:checked)~.mdc-radio__background .mdc-radio__outer-circle{border-color:var(--mdc-radio-unselected-focus-icon-color, black)}.mat-mdc-radio-button.cdk-focused .mat-mdc-focus-indicator::before{content:""}.mat-mdc-radio-touch-target{position:absolute;top:50%;height:48px;left:50%;width:48px;transform:translate(-50%, -50%)}[dir=rtl] .mat-mdc-radio-touch-target{left:0;right:50%;transform:translate(50%, -50%)}'], encapsulation: 2, changeDetection: 0 }), le })(), Le = (() => { class le { } return le.\u0275fac = function (ue) { return new (ue || le) }, le.\u0275mod = a.oAB({ type: le }), le.\u0275inj = a.cJS({ imports: [y.BQ, ke.ez, y.si, y.BQ] }), le })() }, 2651: (nn, Qe, C) => { C.d(Qe, { LW: () => xt, SJ: () => tn, jA: () => it, kh: () => Ft }); var a = C(9829), y = C(6814), v = C(5879), Y = C(3680), he = C(4191), Se = C(9388), ke = C(2495), re = C(6028), Ie = C(2831), Q = C(8645), _e = C(2438), xe = C(3019), ze = C(2181), Oe = C(7398), We = C(975), Pe = C(9773), Ve = C(3997), tt = C(8180), Ye = C(7921), ut = C(3620), ie = C(6825); const Le = ["*"], le = ["content"]; function ge(St, ht) { if (1 & St) { const Ae = v.EpF(); v.TgZ(0, "div", 2), v.NdJ("click", function () { v.CHM(Ae); const qt = v.oxw(); return v.KtG(qt._onBackdropClicked()) }), v.qZA() } if (2 & St) { const Ae = v.oxw(); v.ekj("mat-drawer-shown", Ae._isShowingBackdrop()) } } function ue(St, ht) { 1 & St && (v.TgZ(0, "mat-drawer-content"), v.Hsn(1, 2), v.qZA()) } const ee = [[["mat-drawer"]], [["mat-drawer-content"]], "*"], $e = ["mat-drawer", "mat-drawer-content", "*"], On = { transformDrawer: (0, ie.X$)("transform", [(0, ie.SB)("open, open-instant", (0, ie.oB)({ transform: "none", visibility: "visible" })), (0, ie.SB)("void", (0, ie.oB)({ "box-shadow": "none", visibility: "hidden" })), (0, ie.eR)("void => open-instant", (0, ie.jt)("0ms")), (0, ie.eR)("void <=> open, open-instant => void", (0, ie.jt)("400ms cubic-bezier(0.25, 0.8, 0.25, 1)"))]) }, Hn = new v.OlP("MAT_DRAWER_DEFAULT_AUTOSIZE", { providedIn: "root", factory: function vt() { return !1 } }), at = new v.OlP("MAT_DRAWER_CONTAINER"); let xt = (() => { class St extends a.PQ { constructor(Ae, nt, qt, jt, Pt) { super(qt, jt, Pt), this._changeDetectorRef = Ae, this._container = nt } ngAfterContentInit() { this._container._contentMarginChanges.subscribe(() => { this._changeDetectorRef.markForCheck() }) } } return St.\u0275fac = function (Ae) { return new (Ae || St)(v.Y36(v.sBO), v.Y36((0, v.Gpc)(() => Ft)), v.Y36(v.SBq), v.Y36(a.mF), v.Y36(v.R0b)) }, St.\u0275cmp = v.Xpm({ type: St, selectors: [["mat-drawer-content"]], hostAttrs: ["ngSkipHydration", "", 1, "mat-drawer-content"], hostVars: 4, hostBindings: function (Ae, nt) { 2 & Ae && v.Udp("margin-left", nt._container._contentMargins.left, "px")("margin-right", nt._container._contentMargins.right, "px") }, features: [v._Bn([{ provide: a.PQ, useExisting: St }]), v.qOj], ngContentSelectors: Le, decls: 1, vars: 0, template: function (Ae, nt) { 1 & Ae && (v.F$t(), v.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), St })(), it = (() => { class St { get position() { return this._position } set position(Ae) { (Ae = "end" === Ae ? "end" : "start") !== this._position && (this._isAttached && this._updatePositionInParent(Ae), this._position = Ae, this.onPositionChanged.emit()) } get mode() { return this._mode } set mode(Ae) { this._mode = Ae, this._updateFocusTrapState(), this._modeChanged.next() } get disableClose() { return this._disableClose } set disableClose(Ae) { this._disableClose = (0, ke.Ig)(Ae) } get autoFocus() { return this._autoFocus ?? ("side" === this.mode ? "dialog" : "first-tabbable") } set autoFocus(Ae) { ("true" === Ae || "false" === Ae || null == Ae) && (Ae = (0, ke.Ig)(Ae)), this._autoFocus = Ae } get opened() { return this._opened } set opened(Ae) { this.toggle((0, ke.Ig)(Ae)) } constructor(Ae, nt, qt, jt, Pt, qe, Nt, on) { this._elementRef = Ae, this._focusTrapFactory = nt, this._focusMonitor = qt, this._platform = jt, this._ngZone = Pt, this._interactivityChecker = qe, this._doc = Nt, this._container = on, this._elementFocusedBeforeDrawerWasOpened = null, this._enableAnimations = !1, this._position = "start", this._mode = "over", this._disableClose = !1, this._opened = !1, this._animationStarted = new Q.x, this._animationEnd = new Q.x, this._animationState = "void", this.openedChange = new v.vpe(!0), this._openedStream = this.openedChange.pipe((0, ze.h)(Zt => Zt), (0, Oe.U)(() => { })), this.openedStart = this._animationStarted.pipe((0, ze.h)(Zt => Zt.fromState !== Zt.toState && 0 === Zt.toState.indexOf("open")), (0, We.h)(void 0)), this._closedStream = this.openedChange.pipe((0, ze.h)(Zt => !Zt), (0, Oe.U)(() => { })), this.closedStart = this._animationStarted.pipe((0, ze.h)(Zt => Zt.fromState !== Zt.toState && "void" === Zt.toState), (0, We.h)(void 0)), this._destroyed = new Q.x, this.onPositionChanged = new v.vpe, this._modeChanged = new Q.x, this.openedChange.subscribe(Zt => { Zt ? (this._doc && (this._elementFocusedBeforeDrawerWasOpened = this._doc.activeElement), this._takeFocus()) : this._isFocusWithinDrawer() && this._restoreFocus(this._openedVia || "program") }), this._ngZone.runOutsideAngular(() => { (0, _e.R)(this._elementRef.nativeElement, "keydown").pipe((0, ze.h)(Zt => Zt.keyCode === re.hY && !this.disableClose && !(0, re.Vb)(Zt)), (0, Pe.R)(this._destroyed)).subscribe(Zt => this._ngZone.run(() => { this.close(), Zt.stopPropagation(), Zt.preventDefault() })) }), this._animationEnd.pipe((0, Ve.x)((Zt, gn) => Zt.fromState === gn.fromState && Zt.toState === gn.toState)).subscribe(Zt => { const { fromState: gn, toState: $n } = Zt; (0 === $n.indexOf("open") && "void" === gn || "void" === $n && 0 === gn.indexOf("open")) && this.openedChange.emit(this._opened) }) } _forceFocus(Ae, nt) { this._interactivityChecker.isFocusable(Ae) || (Ae.tabIndex = -1, this._ngZone.runOutsideAngular(() => { const qt = () => { Ae.removeEventListener("blur", qt), Ae.removeEventListener("mousedown", qt), Ae.removeAttribute("tabindex") }; Ae.addEventListener("blur", qt), Ae.addEventListener("mousedown", qt) })), Ae.focus(nt) } _focusByCssSelector(Ae, nt) { let qt = this._elementRef.nativeElement.querySelector(Ae); qt && this._forceFocus(qt, nt) } _takeFocus() { if (!this._focusTrap) return; const Ae = this._elementRef.nativeElement; switch (this.autoFocus) { case !1: case "dialog": return; case !0: case "first-tabbable": this._focusTrap.focusInitialElementWhenReady().then(nt => { !nt && "function" == typeof this._elementRef.nativeElement.focus && Ae.focus() }); break; case "first-heading": this._focusByCssSelector('h1, h2, h3, h4, h5, h6, [role="heading"]'); break; default: this._focusByCssSelector(this.autoFocus) } } _restoreFocus(Ae) { "dialog" !== this.autoFocus && (this._elementFocusedBeforeDrawerWasOpened ? this._focusMonitor.focusVia(this._elementFocusedBeforeDrawerWasOpened, Ae) : this._elementRef.nativeElement.blur(), this._elementFocusedBeforeDrawerWasOpened = null) } _isFocusWithinDrawer() { const Ae = this._doc.activeElement; return !!Ae && this._elementRef.nativeElement.contains(Ae) } ngAfterViewInit() { this._isAttached = !0, this._focusTrap = this._focusTrapFactory.create(this._elementRef.nativeElement), this._updateFocusTrapState(), "end" === this._position && this._updatePositionInParent("end") } ngAfterContentChecked() { this._platform.isBrowser && (this._enableAnimations = !0) } ngOnDestroy() { this._focusTrap && this._focusTrap.destroy(), this._anchor?.remove(), this._anchor = null, this._animationStarted.complete(), this._animationEnd.complete(), this._modeChanged.complete(), this._destroyed.next(), this._destroyed.complete() } open(Ae) { return this.toggle(!0, Ae) } close() { return this.toggle(!1) } _closeViaBackdropClick() { return this._setOpen(!1, !0, "mouse") } toggle(Ae = !this.opened, nt) { Ae && nt && (this._openedVia = nt); const qt = this._setOpen(Ae, !Ae && this._isFocusWithinDrawer(), this._openedVia || "program"); return Ae || (this._openedVia = null), qt } _setOpen(Ae, nt, qt) { return this._opened = Ae, Ae ? this._animationState = this._enableAnimations ? "open" : "open-instant" : (this._animationState = "void", nt && this._restoreFocus(qt)), this._updateFocusTrapState(), new Promise(jt => { this.openedChange.pipe((0, tt.q)(1)).subscribe(Pt => jt(Pt ? "open" : "close")) }) } _getWidth() { return this._elementRef.nativeElement && this._elementRef.nativeElement.offsetWidth || 0 } _updateFocusTrapState() { this._focusTrap && (this._focusTrap.enabled = this.opened && "side" !== this.mode) } _updatePositionInParent(Ae) { const nt = this._elementRef.nativeElement, qt = nt.parentNode; "end" === Ae ? (this._anchor || (this._anchor = this._doc.createComment("mat-drawer-anchor"), qt.insertBefore(this._anchor, nt)), qt.appendChild(nt)) : this._anchor && this._anchor.parentNode.insertBefore(nt, this._anchor) } } return St.\u0275fac = function (Ae) { return new (Ae || St)(v.Y36(v.SBq), v.Y36(he.qV), v.Y36(he.tE), v.Y36(Ie.t4), v.Y36(v.R0b), v.Y36(he.ic), v.Y36(y.K0, 8), v.Y36(at, 8)) }, St.\u0275cmp = v.Xpm({ type: St, selectors: [["mat-drawer"]], viewQuery: function (Ae, nt) { if (1 & Ae && v.Gf(le, 5), 2 & Ae) { let qt; v.iGM(qt = v.CRH()) && (nt._content = qt.first) } }, hostAttrs: ["tabIndex", "-1", "ngSkipHydration", "", 1, "mat-drawer"], hostVars: 12, hostBindings: function (Ae, nt) { 1 & Ae && v.WFA("@transform.start", function (jt) { return nt._animationStarted.next(jt) })("@transform.done", function (jt) { return nt._animationEnd.next(jt) }), 2 & Ae && (v.uIk("align", null), v.d8E("@transform", nt._animationState), v.ekj("mat-drawer-end", "end" === nt.position)("mat-drawer-over", "over" === nt.mode)("mat-drawer-push", "push" === nt.mode)("mat-drawer-side", "side" === nt.mode)("mat-drawer-opened", nt.opened)) }, inputs: { position: "position", mode: "mode", disableClose: "disableClose", autoFocus: "autoFocus", opened: "opened" }, outputs: { openedChange: "openedChange", _openedStream: "opened", openedStart: "openedStart", _closedStream: "closed", closedStart: "closedStart", onPositionChanged: "positionChanged" }, exportAs: ["matDrawer"], ngContentSelectors: Le, decls: 3, vars: 0, consts: [["cdkScrollable", "", 1, "mat-drawer-inner-container"], ["content", ""]], template: function (Ae, nt) { 1 & Ae && (v.F$t(), v.TgZ(0, "div", 0, 1), v.Hsn(2), v.qZA()) }, dependencies: [a.PQ], encapsulation: 2, data: { animation: [On.transformDrawer] }, changeDetection: 0 }), St })(), Ft = (() => { class St { get start() { return this._start } get end() { return this._end } get autosize() { return this._autosize } set autosize(Ae) { this._autosize = (0, ke.Ig)(Ae) } get hasBackdrop() { return null == this._backdropOverride ? !this._start || "side" !== this._start.mode || !this._end || "side" !== this._end.mode : this._backdropOverride } set hasBackdrop(Ae) { this._backdropOverride = null == Ae ? null : (0, ke.Ig)(Ae) } get scrollable() { return this._userContent || this._content } constructor(Ae, nt, qt, jt, Pt, qe = !1, Nt) { this._dir = Ae, this._element = nt, this._ngZone = qt, this._changeDetectorRef = jt, this._animationMode = Nt, this._drawers = new v.n_E, this.backdropClick = new v.vpe, this._destroyed = new Q.x, this._doCheckSubject = new Q.x, this._contentMargins = { left: null, right: null }, this._contentMarginChanges = new Q.x, Ae && Ae.change.pipe((0, Pe.R)(this._destroyed)).subscribe(() => { this._validateDrawers(), this.updateContentMargins() }), Pt.change().pipe((0, Pe.R)(this._destroyed)).subscribe(() => this.updateContentMargins()), this._autosize = qe } ngAfterContentInit() { this._allDrawers.changes.pipe((0, Ye.O)(this._allDrawers), (0, Pe.R)(this._destroyed)).subscribe(Ae => { this._drawers.reset(Ae.filter(nt => !nt._container || nt._container === this)), this._drawers.notifyOnChanges() }), this._drawers.changes.pipe((0, Ye.O)(null)).subscribe(() => { this._validateDrawers(), this._drawers.forEach(Ae => { this._watchDrawerToggle(Ae), this._watchDrawerPosition(Ae), this._watchDrawerMode(Ae) }), (!this._drawers.length || this._isDrawerOpen(this._start) || this._isDrawerOpen(this._end)) && this.updateContentMargins(), this._changeDetectorRef.markForCheck() }), this._ngZone.runOutsideAngular(() => { this._doCheckSubject.pipe((0, ut.b)(10), (0, Pe.R)(this._destroyed)).subscribe(() => this.updateContentMargins()) }) } ngOnDestroy() { this._contentMarginChanges.complete(), this._doCheckSubject.complete(), this._drawers.destroy(), this._destroyed.next(), this._destroyed.complete() } open() { this._drawers.forEach(Ae => Ae.open()) } close() { this._drawers.forEach(Ae => Ae.close()) } updateContentMargins() { let Ae = 0, nt = 0; if (this._left && this._left.opened) if ("side" == this._left.mode) Ae += this._left._getWidth(); else if ("push" == this._left.mode) { const qt = this._left._getWidth(); Ae += qt, nt -= qt } if (this._right && this._right.opened) if ("side" == this._right.mode) nt += this._right._getWidth(); else if ("push" == this._right.mode) { const qt = this._right._getWidth(); nt += qt, Ae -= qt } Ae = Ae || null, nt = nt || null, (Ae !== this._contentMargins.left || nt !== this._contentMargins.right) && (this._contentMargins = { left: Ae, right: nt }, this._ngZone.run(() => this._contentMarginChanges.next(this._contentMargins))) } ngDoCheck() { this._autosize && this._isPushed() && this._ngZone.runOutsideAngular(() => this._doCheckSubject.next()) } _watchDrawerToggle(Ae) { Ae._animationStarted.pipe((0, ze.h)(nt => nt.fromState !== nt.toState), (0, Pe.R)(this._drawers.changes)).subscribe(nt => { "open-instant" !== nt.toState && "NoopAnimations" !== this._animationMode && this._element.nativeElement.classList.add("mat-drawer-transition"), this.updateContentMargins(), this._changeDetectorRef.markForCheck() }), "side" !== Ae.mode && Ae.openedChange.pipe((0, Pe.R)(this._drawers.changes)).subscribe(() => this._setContainerClass(Ae.opened)) } _watchDrawerPosition(Ae) { Ae && Ae.onPositionChanged.pipe((0, Pe.R)(this._drawers.changes)).subscribe(() => { this._ngZone.onMicrotaskEmpty.pipe((0, tt.q)(1)).subscribe(() => { this._validateDrawers() }) }) } _watchDrawerMode(Ae) { Ae && Ae._modeChanged.pipe((0, Pe.R)((0, xe.T)(this._drawers.changes, this._destroyed))).subscribe(() => { this.updateContentMargins(), this._changeDetectorRef.markForCheck() }) } _setContainerClass(Ae) { const nt = this._element.nativeElement.classList, qt = "mat-drawer-container-has-open"; Ae ? nt.add(qt) : nt.remove(qt) } _validateDrawers() { this._start = this._end = null, this._drawers.forEach(Ae => { "end" == Ae.position ? this._end = Ae : this._start = Ae }), this._right = this._left = null, this._dir && "rtl" === this._dir.value ? (this._left = this._end, this._right = this._start) : (this._left = this._start, this._right = this._end) } _isPushed() { return this._isDrawerOpen(this._start) && "over" != this._start.mode || this._isDrawerOpen(this._end) && "over" != this._end.mode } _onBackdropClicked() { this.backdropClick.emit(), this._closeModalDrawersViaBackdrop() } _closeModalDrawersViaBackdrop() { [this._start, this._end].filter(Ae => Ae && !Ae.disableClose && this._canHaveBackdrop(Ae)).forEach(Ae => Ae._closeViaBackdropClick()) } _isShowingBackdrop() { return this._isDrawerOpen(this._start) && this._canHaveBackdrop(this._start) || this._isDrawerOpen(this._end) && this._canHaveBackdrop(this._end) } _canHaveBackdrop(Ae) { return "side" !== Ae.mode || !!this._backdropOverride } _isDrawerOpen(Ae) { return null != Ae && Ae.opened } } return St.\u0275fac = function (Ae) { return new (Ae || St)(v.Y36(Se.Is, 8), v.Y36(v.SBq), v.Y36(v.R0b), v.Y36(v.sBO), v.Y36(a.rL), v.Y36(Hn), v.Y36(v.QbO, 8)) }, St.\u0275cmp = v.Xpm({ type: St, selectors: [["mat-drawer-container"]], contentQueries: function (Ae, nt, qt) { if (1 & Ae && (v.Suo(qt, xt, 5), v.Suo(qt, it, 5)), 2 & Ae) { let jt; v.iGM(jt = v.CRH()) && (nt._content = jt.first), v.iGM(jt = v.CRH()) && (nt._allDrawers = jt) } }, viewQuery: function (Ae, nt) { if (1 & Ae && v.Gf(xt, 5), 2 & Ae) { let qt; v.iGM(qt = v.CRH()) && (nt._userContent = qt.first) } }, hostAttrs: ["ngSkipHydration", "", 1, "mat-drawer-container"], hostVars: 2, hostBindings: function (Ae, nt) { 2 & Ae && v.ekj("mat-drawer-container-explicit-backdrop", nt._backdropOverride) }, inputs: { autosize: "autosize", hasBackdrop: "hasBackdrop" }, outputs: { backdropClick: "backdropClick" }, exportAs: ["matDrawerContainer"], features: [v._Bn([{ provide: at, useExisting: St }])], ngContentSelectors: $e, decls: 4, vars: 2, consts: [["class", "mat-drawer-backdrop", 3, "mat-drawer-shown", "click", 4, "ngIf"], [4, "ngIf"], [1, "mat-drawer-backdrop", 3, "click"]], template: function (Ae, nt) { 1 & Ae && (v.F$t(ee), v.YNc(0, ge, 1, 2, "div", 0), v.Hsn(1), v.Hsn(2, 1), v.YNc(3, ue, 2, 0, "mat-drawer-content", 1)), 2 & Ae && (v.Q6J("ngIf", nt.hasBackdrop), v.xp6(3), v.Q6J("ngIf", !nt._content)) }, dependencies: [y.O5, xt], styles: ['.mat-drawer-container{position:relative;z-index:1;box-sizing:border-box;-webkit-overflow-scrolling:touch;display:block;overflow:hidden}.mat-drawer-container[fullscreen]{top:0;left:0;right:0;bottom:0;position:absolute}.mat-drawer-container[fullscreen].mat-drawer-container-has-open{overflow:hidden}.mat-drawer-container.mat-drawer-container-explicit-backdrop .mat-drawer-side{z-index:3}.mat-drawer-container.ng-animate-disabled .mat-drawer-backdrop,.mat-drawer-container.ng-animate-disabled .mat-drawer-content,.ng-animate-disabled .mat-drawer-container .mat-drawer-backdrop,.ng-animate-disabled .mat-drawer-container .mat-drawer-content{transition:none}.mat-drawer-backdrop{top:0;left:0;right:0;bottom:0;position:absolute;display:block;z-index:3;visibility:hidden}.mat-drawer-backdrop.mat-drawer-shown{visibility:visible}.mat-drawer-transition .mat-drawer-backdrop{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:background-color,visibility}.cdk-high-contrast-active .mat-drawer-backdrop{opacity:.5}.mat-drawer-content{position:relative;z-index:1;display:block;height:100%;overflow:auto}.mat-drawer-transition .mat-drawer-content{transition-duration:400ms;transition-timing-function:cubic-bezier(0.25, 0.8, 0.25, 1);transition-property:transform,margin-left,margin-right}.mat-drawer{position:relative;z-index:4;display:block;position:absolute;top:0;bottom:0;z-index:3;outline:0;box-sizing:border-box;overflow-y:auto;transform:translate3d(-100%, 0, 0)}.cdk-high-contrast-active .mat-drawer,.cdk-high-contrast-active [dir=rtl] .mat-drawer.mat-drawer-end{border-right:solid 1px currentColor}.cdk-high-contrast-active [dir=rtl] .mat-drawer,.cdk-high-contrast-active .mat-drawer.mat-drawer-end{border-left:solid 1px currentColor;border-right:none}.mat-drawer.mat-drawer-side{z-index:2}.mat-drawer.mat-drawer-end{right:0;transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer{transform:translate3d(100%, 0, 0)}[dir=rtl] .mat-drawer.mat-drawer-end{left:0;right:auto;transform:translate3d(-100%, 0, 0)}.mat-drawer[style*="visibility: hidden"]{display:none}.mat-drawer-inner-container{width:100%;height:100%;overflow:auto;-webkit-overflow-scrolling:touch}.mat-sidenav-fixed{position:fixed}'], encapsulation: 2, changeDetection: 0 }), St })(), tn = (() => { class St { } return St.\u0275fac = function (Ae) { return new (Ae || St) }, St.\u0275mod = v.oAB({ type: St }), St.\u0275inj = v.cJS({ imports: [y.ez, Y.BQ, a.ZD, a.ZD, Y.BQ] }), St })() }, 4104: (nn, Qe, C) => { C.d(Qe, { BU: () => L, Nh: () => pt, Nj: () => H, sW: () => Ne }); var a = C(6814), y = C(5879), v = C(3680), Y = C(8484), he = C(7131), Se = C(4191), ke = C(9388), re = C(8645), Ie = C(2438), Q = C(2096), _e = C(3019), xe = C(6232), ze = C(5592), Oe = C(4825), We = C(5619), Pe = C(9773), Ve = C(8180), tt = C(7921), Ye = C(4664), ut = C(836), ie = C(2181), le = (C(6825), C(2495)), ge = C(9829), ue = C(2831), ee = C(6028); const Dn = ["*"], Mn = ["tabListContainer"], On = ["tabList"], Wn = ["tabListInner"], Hn = ["nextPaginator"], at = ["previousPaginator"], tn = ["mat-tab-nav-bar", ""], St = ["mat-tab-link", ""], Zt = "mdc-tab-indicator--active", gn = "mdc-tab-indicator--no-transition"; class $n { constructor(fe) { this._items = fe } hide() { this._items.forEach(fe => fe.deactivateInkBar()) } alignToElement(fe) { const F = this._items.find(Te => Te.elementRef.nativeElement === fe), J = this._currentItem; if (F !== J && (J?.deactivateInkBar(), F)) { const Te = J?.elementRef.nativeElement.getBoundingClientRect?.(); F.activateInkBar(Te), this._currentItem = F } } } function Fn(pe) { return class extends pe { constructor(...fe) { super(...fe), this._fitToContent = !1 } get fitInkBarToContent() { return this._fitToContent } set fitInkBarToContent(fe) { const F = (0, le.Ig)(fe); this._fitToContent !== F && (this._fitToContent = F, this._inkBarElement && this._appendInkBarElement()) } activateInkBar(fe) { const F = this.elementRef.nativeElement; if (!fe || !F.getBoundingClientRect || !this._inkBarContentElement) return void F.classList.add(Zt); const J = F.getBoundingClientRect(), Te = fe.width / J.width, lt = fe.left - J.left; F.classList.add(gn), this._inkBarContentElement.style.setProperty("transform", `translateX(${lt}px) scaleX(${Te})`), F.getBoundingClientRect(), F.classList.remove(gn), F.classList.add(Zt), this._inkBarContentElement.style.setProperty("transform", "") } deactivateInkBar() { this.elementRef.nativeElement.classList.remove(Zt) } ngOnInit() { this._createInkBarElement() } ngOnDestroy() { this._inkBarElement?.remove(), this._inkBarElement = this._inkBarContentElement = null } _createInkBarElement() { const fe = this.elementRef.nativeElement.ownerDocument || document; this._inkBarElement = fe.createElement("span"), this._inkBarContentElement = fe.createElement("span"), this._inkBarElement.className = "mdc-tab-indicator", this._inkBarContentElement.className = "mdc-tab-indicator__content mdc-tab-indicator__content--underline", this._inkBarElement.appendChild(this._inkBarContentElement), this._appendInkBarElement() } _appendInkBarElement() { (this._fitToContent ? this.elementRef.nativeElement.querySelector(".mdc-tab__content") : this.elementRef.nativeElement).appendChild(this._inkBarElement) } } } const Mt = (0, ue.i$)({ passive: !0 }); let En = (() => { class pe { get disablePagination() { return this._disablePagination } set disablePagination(F) { this._disablePagination = (0, le.Ig)(F) } get selectedIndex() { return this._selectedIndex } set selectedIndex(F) { F = (0, le.su)(F), this._selectedIndex != F && (this._selectedIndexChanged = !0, this._selectedIndex = F, this._keyManager && this._keyManager.updateActiveItem(F)) } constructor(F, J, Te, lt, gt, Ht, un) { this._elementRef = F, this._changeDetectorRef = J, this._viewportRuler = Te, this._dir = lt, this._ngZone = gt, this._platform = Ht, this._animationMode = un, this._scrollDistance = 0, this._selectedIndexChanged = !1, this._destroyed = new re.x, this._showPaginationControls = !1, this._disableScrollAfter = !0, this._disableScrollBefore = !0, this._stopScrolling = new re.x, this._disablePagination = !1, this._selectedIndex = 0, this.selectFocusedIndex = new y.vpe, this.indexFocused = new y.vpe, gt.runOutsideAngular(() => { (0, Ie.R)(F.nativeElement, "mouseleave").pipe((0, Pe.R)(this._destroyed)).subscribe(() => { this._stopInterval() }) }) } ngAfterViewInit() { (0, Ie.R)(this._previousPaginator.nativeElement, "touchstart", Mt).pipe((0, Pe.R)(this._destroyed)).subscribe(() => { this._handlePaginatorPress("before") }), (0, Ie.R)(this._nextPaginator.nativeElement, "touchstart", Mt).pipe((0, Pe.R)(this._destroyed)).subscribe(() => { this._handlePaginatorPress("after") }) } ngAfterContentInit() { const F = this._dir ? this._dir.change : (0, Q.of)("ltr"), J = this._viewportRuler.change(150), Te = () => { this.updatePagination(), this._alignInkBarToSelectedTab() }; this._keyManager = new Se.Em(this._items).withHorizontalOrientation(this._getLayoutDirection()).withHomeAndEnd().withWrap().skipPredicate(() => !1), this._keyManager.updateActiveItem(this._selectedIndex), this._ngZone.onStable.pipe((0, Ve.q)(1)).subscribe(Te), (0, _e.T)(F, J, this._items.changes, this._itemsResized()).pipe((0, Pe.R)(this._destroyed)).subscribe(() => { this._ngZone.run(() => { Promise.resolve().then(() => { this._scrollDistance = Math.max(0, Math.min(this._getMaxScrollDistance(), this._scrollDistance)), Te() }) }), this._keyManager.withHorizontalOrientation(this._getLayoutDirection()) }), this._keyManager.change.subscribe(lt => { this.indexFocused.emit(lt), this._setTabFocus(lt) }) } _itemsResized() { return "function" != typeof ResizeObserver ? xe.E : this._items.changes.pipe((0, tt.O)(this._items), (0, Ye.w)(F => new ze.y(J => this._ngZone.runOutsideAngular(() => { const Te = new ResizeObserver(lt => J.next(lt)); return F.forEach(lt => Te.observe(lt.elementRef.nativeElement)), () => { Te.disconnect() } }))), (0, ut.T)(1), (0, ie.h)(F => F.some(J => J.contentRect.width > 0 && J.contentRect.height > 0))) } ngAfterContentChecked() { this._tabLabelCount != this._items.length && (this.updatePagination(), this._tabLabelCount = this._items.length, this._changeDetectorRef.markForCheck()), this._selectedIndexChanged && (this._scrollToLabel(this._selectedIndex), this._checkScrollingControls(), this._alignInkBarToSelectedTab(), this._selectedIndexChanged = !1, this._changeDetectorRef.markForCheck()), this._scrollDistanceChanged && (this._updateTabScrollPosition(), this._scrollDistanceChanged = !1, this._changeDetectorRef.markForCheck()) } ngOnDestroy() { this._keyManager?.destroy(), this._destroyed.next(), this._destroyed.complete(), this._stopScrolling.complete() } _handleKeydown(F) { if (!(0, ee.Vb)(F)) switch (F.keyCode) { case ee.K5: case ee.L_: if (this.focusIndex !== this.selectedIndex) { const J = this._items.get(this.focusIndex); J && !J.disabled && (this.selectFocusedIndex.emit(this.focusIndex), this._itemSelected(F)) } break; default: this._keyManager.onKeydown(F) } } _onContentChanges() { const F = this._elementRef.nativeElement.textContent; F !== this._currentTextContent && (this._currentTextContent = F || "", this._ngZone.run(() => { this.updatePagination(), this._alignInkBarToSelectedTab(), this._changeDetectorRef.markForCheck() })) } updatePagination() { this._checkPaginationEnabled(), this._checkScrollingControls(), this._updateTabScrollPosition() } get focusIndex() { return this._keyManager ? this._keyManager.activeItemIndex : 0 } set focusIndex(F) { !this._isValidIndex(F) || this.focusIndex === F || !this._keyManager || this._keyManager.setActiveItem(F) } _isValidIndex(F) { return !this._items || !!this._items.toArray()[F] } _setTabFocus(F) { if (this._showPaginationControls && this._scrollToLabel(F), this._items && this._items.length) { this._items.toArray()[F].focus(); const J = this._tabListContainer.nativeElement; J.scrollLeft = "ltr" == this._getLayoutDirection() ? 0 : J.scrollWidth - J.offsetWidth } } _getLayoutDirection() { return this._dir && "rtl" === this._dir.value ? "rtl" : "ltr" } _updateTabScrollPosition() { if (this.disablePagination) return; const F = this.scrollDistance, J = "ltr" === this._getLayoutDirection() ? -F : F; this._tabList.nativeElement.style.transform = `translateX(${Math.round(J)}px)`, (this._platform.TRIDENT || this._platform.EDGE) && (this._tabListContainer.nativeElement.scrollLeft = 0) } get scrollDistance() { return this._scrollDistance } set scrollDistance(F) { this._scrollTo(F) } _scrollHeader(F) { return this._scrollTo(this._scrollDistance + ("before" == F ? -1 : 1) * this._tabListContainer.nativeElement.offsetWidth / 3) } _handlePaginatorClick(F) { this._stopInterval(), this._scrollHeader(F) } _scrollToLabel(F) { if (this.disablePagination) return; const J = this._items ? this._items.toArray()[F] : null; if (!J) return; const Te = this._tabListContainer.nativeElement.offsetWidth, { offsetLeft: lt, offsetWidth: gt } = J.elementRef.nativeElement; let Ht, un; "ltr" == this._getLayoutDirection() ? (Ht = lt, un = Ht + gt) : (un = this._tabListInner.nativeElement.offsetWidth - lt, Ht = un - gt); const yt = this.scrollDistance, It = this.scrollDistance + Te; Ht < yt ? this.scrollDistance -= yt - Ht : un > It && (this.scrollDistance += Math.min(un - It, Ht - yt)) } _checkPaginationEnabled() { if (this.disablePagination) this._showPaginationControls = !1; else { const F = this._tabListInner.nativeElement.scrollWidth > this._elementRef.nativeElement.offsetWidth; F || (this.scrollDistance = 0), F !== this._showPaginationControls && this._changeDetectorRef.markForCheck(), this._showPaginationControls = F } } _checkScrollingControls() { this.disablePagination ? this._disableScrollAfter = this._disableScrollBefore = !0 : (this._disableScrollBefore = 0 == this.scrollDistance, this._disableScrollAfter = this.scrollDistance == this._getMaxScrollDistance(), this._changeDetectorRef.markForCheck()) } _getMaxScrollDistance() { return this._tabListInner.nativeElement.scrollWidth - this._tabListContainer.nativeElement.offsetWidth || 0 } _alignInkBarToSelectedTab() { const F = this._items && this._items.length ? this._items.toArray()[this.selectedIndex] : null, J = F ? F.elementRef.nativeElement : null; J ? this._inkBar.alignToElement(J) : this._inkBar.hide() } _stopInterval() { this._stopScrolling.next() } _handlePaginatorPress(F, J) { J && null != J.button && 0 !== J.button || (this._stopInterval(), (0, Oe.H)(650, 100).pipe((0, Pe.R)((0, _e.T)(this._stopScrolling, this._destroyed))).subscribe(() => { const { maxScrollDistance: Te, distance: lt } = this._scrollHeader(F); (0 === lt || lt >= Te) && this._stopInterval() })) } _scrollTo(F) { if (this.disablePagination) return { maxScrollDistance: 0, distance: 0 }; const J = this._getMaxScrollDistance(); return this._scrollDistance = Math.max(0, Math.min(J, F)), this._scrollDistanceChanged = !0, this._checkScrollingControls(), { maxScrollDistance: J, distance: this._scrollDistance } } } return pe.\u0275fac = function (F) { return new (F || pe)(y.Y36(y.SBq), y.Y36(y.sBO), y.Y36(ge.rL), y.Y36(ke.Is, 8), y.Y36(y.R0b), y.Y36(ue.t4), y.Y36(y.QbO, 8)) }, pe.\u0275dir = y.lG2({ type: pe, inputs: { disablePagination: "disablePagination" } }), pe })(); const Et = new y.OlP("MAT_TABS_CONFIG"); let st = 0, Lt = (() => { class pe extends En { get backgroundColor() { return this._backgroundColor } set backgroundColor(F) { const J = this._elementRef.nativeElement.classList; J.remove("mat-tabs-with-background", `mat-background-${this.backgroundColor}`), F && J.add("mat-tabs-with-background", `mat-background-${F}`), this._backgroundColor = F } get disableRipple() { return this._disableRipple } set disableRipple(F) { this._disableRipple = (0, le.Ig)(F) } constructor(F, J, Te, lt, gt, Ht, un) { super(F, lt, gt, J, Te, Ht, un), this._disableRipple = !1, this.color = "primary" } _itemSelected() { } ngAfterContentInit() { this._items.changes.pipe((0, tt.O)(null), (0, Pe.R)(this._destroyed)).subscribe(() => { this.updateActiveLink() }), super.ngAfterContentInit() } updateActiveLink() { if (!this._items) return; const F = this._items.toArray(); for (let J = 0; J < F.length; J++)if (F[J].active) return this.selectedIndex = J, this._changeDetectorRef.markForCheck(), void (this.tabPanel && (this.tabPanel._activeTabId = F[J].id)); this.selectedIndex = -1, this._inkBar.hide() } _getRole() { return this.tabPanel ? "tablist" : this._elementRef.nativeElement.getAttribute("role") } } return pe.\u0275fac = function (F) { return new (F || pe)(y.Y36(y.SBq), y.Y36(ke.Is, 8), y.Y36(y.R0b), y.Y36(y.sBO), y.Y36(ge.rL), y.Y36(ue.t4), y.Y36(y.QbO, 8)) }, pe.\u0275dir = y.lG2({ type: pe, inputs: { backgroundColor: "backgroundColor", disableRipple: "disableRipple", color: "color", tabPanel: "tabPanel" }, features: [y.qOj] }), pe })(); const He = (0, v.sb)((0, v.Kr)((0, v.Id)(class { }))), z = Fn((() => { class pe extends He { get active() { return this._isActive } set active(F) { const J = (0, le.Ig)(F); J !== this._isActive && (this._isActive = J, this._tabNavBar.updateActiveLink()) } get rippleDisabled() { return this.disabled || this.disableRipple || this._tabNavBar.disableRipple || !!this.rippleConfig.disabled } constructor(F, J, Te, lt, gt, Ht) { super(), this._tabNavBar = F, this.elementRef = J, this._focusMonitor = gt, this._isActive = !1, this.id = "mat-tab-link-" + st++, this.rippleConfig = Te || {}, this.tabIndex = parseInt(lt) || 0, "NoopAnimations" === Ht && (this.rippleConfig.animation = { enterDuration: 0, exitDuration: 0 }) } focus() { this.elementRef.nativeElement.focus() } ngAfterViewInit() { this._focusMonitor.monitor(this.elementRef) } ngOnDestroy() { this._focusMonitor.stopMonitoring(this.elementRef) } _handleFocus() { this._tabNavBar.focusIndex = this._tabNavBar._items.toArray().indexOf(this) } _handleKeydown(F) { !this.disabled || F.keyCode !== ee.L_ && F.keyCode !== ee.K5 ? this._tabNavBar.tabPanel && F.keyCode === ee.L_ && this.elementRef.nativeElement.click() : F.preventDefault() } _getAriaControls() { return this._tabNavBar.tabPanel ? this._tabNavBar.tabPanel?.id : this.elementRef.nativeElement.getAttribute("aria-controls") } _getAriaSelected() { return this._tabNavBar.tabPanel ? this.active ? "true" : "false" : this.elementRef.nativeElement.getAttribute("aria-selected") } _getAriaCurrent() { return this.active && !this._tabNavBar.tabPanel ? "page" : null } _getRole() { return this._tabNavBar.tabPanel ? "tab" : this.elementRef.nativeElement.getAttribute("role") } _getTabIndex() { return this._tabNavBar.tabPanel ? this._isActive && !this.disabled ? 0 : -1 : this.tabIndex } } return pe.\u0275fac = function (F) { return new (F || pe)(y.Y36(Lt), y.Y36(y.SBq), y.Y36(v.Y2, 8), y.$8M("tabindex"), y.Y36(Se.tE), y.Y36(y.QbO, 8)) }, pe.\u0275dir = y.lG2({ type: pe, inputs: { active: "active", id: "id" }, features: [y.qOj] }), pe })()); let L = (() => { class pe extends Lt { get fitInkBarToContent() { return this._fitInkBarToContent.value } set fitInkBarToContent(F) { this._fitInkBarToContent.next((0, le.Ig)(F)), this._changeDetectorRef.markForCheck() } get stretchTabs() { return this._stretchTabs } set stretchTabs(F) { this._stretchTabs = (0, le.Ig)(F) } get animationDuration() { return this._animationDuration } set animationDuration(F) { this._animationDuration = /^\d+$/.test(F + "") ? F + "ms" : F } constructor(F, J, Te, lt, gt, Ht, un, yt) { super(F, J, Te, lt, gt, Ht, un), this._fitInkBarToContent = new We.X(!1), this._stretchTabs = !0, this.disablePagination = !(!yt || null == yt.disablePagination) && yt.disablePagination, this.fitInkBarToContent = !(!yt || null == yt.fitInkBarToContent) && yt.fitInkBarToContent, this.stretchTabs = !yt || null == yt.stretchTabs || yt.stretchTabs } ngAfterContentInit() { this._inkBar = new $n(this._items), super.ngAfterContentInit() } ngAfterViewInit() { super.ngAfterViewInit() } } return pe.\u0275fac = function (F) { return new (F || pe)(y.Y36(y.SBq), y.Y36(ke.Is, 8), y.Y36(y.R0b), y.Y36(y.sBO), y.Y36(ge.rL), y.Y36(ue.t4), y.Y36(y.QbO, 8), y.Y36(Et, 8)) }, pe.\u0275cmp = y.Xpm({ type: pe, selectors: [["", "mat-tab-nav-bar", ""]], contentQueries: function (F, J, Te) { if (1 & F && y.Suo(Te, H, 5), 2 & F) { let lt; y.iGM(lt = y.CRH()) && (J._items = lt) } }, viewQuery: function (F, J) { if (1 & F && (y.Gf(Mn, 7), y.Gf(On, 7), y.Gf(Wn, 7), y.Gf(Hn, 5), y.Gf(at, 5)), 2 & F) { let Te; y.iGM(Te = y.CRH()) && (J._tabListContainer = Te.first), y.iGM(Te = y.CRH()) && (J._tabList = Te.first), y.iGM(Te = y.CRH()) && (J._tabListInner = Te.first), y.iGM(Te = y.CRH()) && (J._nextPaginator = Te.first), y.iGM(Te = y.CRH()) && (J._previousPaginator = Te.first) } }, hostAttrs: [1, "mat-mdc-tab-nav-bar", "mat-mdc-tab-header"], hostVars: 17, hostBindings: function (F, J) { 2 & F && (y.uIk("role", J._getRole()), y.Udp("--mat-tab-animation-duration", J.animationDuration), y.ekj("mat-mdc-tab-header-pagination-controls-enabled", J._showPaginationControls)("mat-mdc-tab-header-rtl", "rtl" == J._getLayoutDirection())("mat-mdc-tab-nav-bar-stretch-tabs", J.stretchTabs)("mat-primary", "warn" !== J.color && "accent" !== J.color)("mat-accent", "accent" === J.color)("mat-warn", "warn" === J.color)("_mat-animation-noopable", "NoopAnimations" === J._animationMode)) }, inputs: { color: "color", fitInkBarToContent: "fitInkBarToContent", stretchTabs: ["mat-stretch-tabs", "stretchTabs"], animationDuration: "animationDuration" }, exportAs: ["matTabNavBar", "matTabNav"], features: [y.qOj], attrs: tn, ngContentSelectors: Dn, decls: 13, vars: 8, consts: [["aria-hidden", "true", "type", "button", "mat-ripple", "", "tabindex", "-1", 1, "mat-mdc-tab-header-pagination", "mat-mdc-tab-header-pagination-before", 3, "matRippleDisabled", "disabled", "click", "mousedown", "touchend"], ["previousPaginator", ""], [1, "mat-mdc-tab-header-pagination-chevron"], [1, "mat-mdc-tab-link-container", 3, "keydown"], ["tabListContainer", ""], [1, "mat-mdc-tab-list", 3, "cdkObserveContent"], ["tabList", ""], [1, "mat-mdc-tab-links"], ["tabListInner", ""], ["aria-hidden", "true", "type", "button", "mat-ripple", "", "tabindex", "-1", 1, "mat-mdc-tab-header-pagination", "mat-mdc-tab-header-pagination-after", 3, "matRippleDisabled", "disabled", "mousedown", "click", "touchend"], ["nextPaginator", ""]], template: function (F, J) { 1 & F && (y.F$t(), y.TgZ(0, "button", 0, 1), y.NdJ("click", function () { return J._handlePaginatorClick("before") })("mousedown", function (lt) { return J._handlePaginatorPress("before", lt) })("touchend", function () { return J._stopInterval() }), y._UZ(2, "div", 2), y.qZA(), y.TgZ(3, "div", 3, 4), y.NdJ("keydown", function (lt) { return J._handleKeydown(lt) }), y.TgZ(5, "div", 5, 6), y.NdJ("cdkObserveContent", function () { return J._onContentChanges() }), y.TgZ(7, "div", 7, 8), y.Hsn(9), y.qZA()()(), y.TgZ(10, "button", 9, 10), y.NdJ("mousedown", function (lt) { return J._handlePaginatorPress("after", lt) })("click", function () { return J._handlePaginatorClick("after") })("touchend", function () { return J._stopInterval() }), y._UZ(12, "div", 2), y.qZA()), 2 & F && (y.ekj("mat-mdc-tab-header-pagination-disabled", J._disableScrollBefore), y.Q6J("matRippleDisabled", J._disableScrollBefore || J.disableRipple)("disabled", J._disableScrollBefore || null), y.xp6(10), y.ekj("mat-mdc-tab-header-pagination-disabled", J._disableScrollAfter), y.Q6J("matRippleDisabled", J._disableScrollAfter || J.disableRipple)("disabled", J._disableScrollAfter || null)) }, dependencies: [v.wG, he.wD], styles: [".mdc-tab{min-width:90px;padding-right:24px;padding-left:24px;display:flex;flex:1 0 auto;justify-content:center;box-sizing:border-box;margin:0;padding-top:0;padding-bottom:0;border:none;outline:none;text-align:center;white-space:nowrap;cursor:pointer;-webkit-appearance:none;z-index:1}.mdc-tab::-moz-focus-inner{padding:0;border:0}.mdc-tab[hidden]{display:none}.mdc-tab--min-width{flex:0 1 auto}.mdc-tab__content{display:flex;align-items:center;justify-content:center;height:inherit;pointer-events:none}.mdc-tab__text-label{transition:150ms color linear;display:inline-block;line-height:1;z-index:2}.mdc-tab__icon{transition:150ms color linear;z-index:2}.mdc-tab--stacked .mdc-tab__content{flex-direction:column;align-items:center;justify-content:center}.mdc-tab--stacked .mdc-tab__text-label{padding-top:6px;padding-bottom:4px}.mdc-tab--active .mdc-tab__text-label,.mdc-tab--active .mdc-tab__icon{transition-delay:100ms}.mdc-tab:not(.mdc-tab--stacked) .mdc-tab__icon+.mdc-tab__text-label{padding-left:8px;padding-right:0}[dir=rtl] .mdc-tab:not(.mdc-tab--stacked) .mdc-tab__icon+.mdc-tab__text-label,.mdc-tab:not(.mdc-tab--stacked) .mdc-tab__icon+.mdc-tab__text-label[dir=rtl]{padding-left:0;padding-right:8px}.mdc-tab-indicator{display:flex;position:absolute;top:0;left:0;justify-content:center;width:100%;height:100%;pointer-events:none;z-index:1}.mdc-tab-indicator__content{transform-origin:left;opacity:0}.mdc-tab-indicator__content--underline{align-self:flex-end;box-sizing:border-box;width:100%;border-top-style:solid}.mdc-tab-indicator__content--icon{align-self:center;margin:0 auto}.mdc-tab-indicator--active .mdc-tab-indicator__content{opacity:1}.mdc-tab-indicator .mdc-tab-indicator__content{transition:250ms transform cubic-bezier(0.4, 0, 0.2, 1)}.mdc-tab-indicator--no-transition .mdc-tab-indicator__content{transition:none}.mdc-tab-indicator--fade .mdc-tab-indicator__content{transition:150ms opacity linear}.mdc-tab-indicator--active.mdc-tab-indicator--fade .mdc-tab-indicator__content{transition-delay:100ms}.mat-mdc-tab-ripple{position:absolute;top:0;left:0;bottom:0;right:0;pointer-events:none}.mat-mdc-tab-header{display:flex;overflow:hidden;position:relative;flex-shrink:0;--mdc-tab-indicator-active-indicator-height:2px;--mdc-tab-indicator-active-indicator-shape:0;--mdc-secondary-navigation-tab-container-height:48px}.mdc-tab-indicator .mdc-tab-indicator__content{transition-duration:var(--mat-tab-animation-duration, 250ms)}.mat-mdc-tab-header-pagination{-webkit-user-select:none;user-select:none;position:relative;display:none;justify-content:center;align-items:center;min-width:32px;cursor:pointer;z-index:2;-webkit-tap-highlight-color:rgba(0,0,0,0);touch-action:none;box-sizing:content-box;background:none;border:none;outline:0;padding:0}.mat-mdc-tab-header-pagination::-moz-focus-inner{border:0}.mat-mdc-tab-header-pagination .mat-ripple-element{opacity:.12;background-color:var(--mat-tab-header-inactive-ripple-color)}.mat-mdc-tab-header-pagination-controls-enabled .mat-mdc-tab-header-pagination{display:flex}.mat-mdc-tab-header-pagination-before,.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-after{padding-left:4px}.mat-mdc-tab-header-pagination-before .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-after .mat-mdc-tab-header-pagination-chevron{transform:rotate(-135deg)}.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-before,.mat-mdc-tab-header-pagination-after{padding-right:4px}.mat-mdc-tab-header-rtl .mat-mdc-tab-header-pagination-before .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-header-pagination-after .mat-mdc-tab-header-pagination-chevron{transform:rotate(45deg)}.mat-mdc-tab-header-pagination-chevron{border-style:solid;border-width:2px 2px 0 0;height:8px;width:8px;border-color:var(--mat-tab-header-pagination-icon-color)}.mat-mdc-tab-header-pagination-disabled{box-shadow:none;cursor:default;pointer-events:none}.mat-mdc-tab-header-pagination-disabled .mat-mdc-tab-header-pagination-chevron{opacity:.4}.mat-mdc-tab-list{flex-grow:1;position:relative;transition:transform 500ms cubic-bezier(0.35, 0, 0.25, 1)}._mat-animation-noopable .mat-mdc-tab-list{transition:none}._mat-animation-noopable span.mdc-tab-indicator__content,._mat-animation-noopable span.mdc-tab__text-label{transition:none}.mat-mdc-tab-links{display:flex;flex:1 0 auto}[mat-align-tabs=center]>.mat-mdc-tab-link-container .mat-mdc-tab-links{justify-content:center}[mat-align-tabs=end]>.mat-mdc-tab-link-container .mat-mdc-tab-links{justify-content:flex-end}.mat-mdc-tab-link-container{display:flex;flex-grow:1;overflow:hidden;z-index:1}.mat-mdc-tab-nav-bar.mat-tabs-with-background>.mat-mdc-tab-link-container,.mat-mdc-tab-nav-bar.mat-tabs-with-background>.mat-mdc-tab-header-pagination{background-color:var(--mat-tab-header-with-background-background-color)}.mat-mdc-tab-nav-bar.mat-tabs-with-background.mat-primary>.mat-mdc-tab-link-container .mat-mdc-tab-link .mdc-tab__text-label{color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-nav-bar.mat-tabs-with-background.mat-primary>.mat-mdc-tab-link-container .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-nav-bar.mat-tabs-with-background:not(.mat-primary)>.mat-mdc-tab-link-container .mat-mdc-tab-link:not(.mdc-tab--active) .mdc-tab__text-label{color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-nav-bar.mat-tabs-with-background:not(.mat-primary)>.mat-mdc-tab-link-container .mat-mdc-tab-link:not(.mdc-tab--active) .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-nav-bar.mat-tabs-with-background>.mat-mdc-tab-link-container .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-nav-bar.mat-tabs-with-background>.mat-mdc-tab-link-container .mat-mdc-focus-indicator::before,.mat-mdc-tab-nav-bar.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-nav-bar.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-mdc-focus-indicator::before{border-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-nav-bar.mat-tabs-with-background>.mat-mdc-tab-link-container .mat-ripple-element,.mat-mdc-tab-nav-bar.mat-tabs-with-background>.mat-mdc-tab-link-container .mdc-tab__ripple::before,.mat-mdc-tab-nav-bar.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-ripple-element,.mat-mdc-tab-nav-bar.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mdc-tab__ripple::before{background-color:var(--mat-tab-header-with-background-foreground-color)}.mat-mdc-tab-nav-bar.mat-tabs-with-background>.mat-mdc-tab-link-container .mat-mdc-tab-header-pagination-chevron,.mat-mdc-tab-nav-bar.mat-tabs-with-background>.mat-mdc-tab-header-pagination .mat-mdc-tab-header-pagination-chevron{color:var(--mat-tab-header-with-background-foreground-color)}"], encapsulation: 2 }), pe })(), H = (() => { class pe extends z { constructor(F, J, Te, lt, gt, Ht) { super(F, J, Te, lt, gt, Ht), this._destroyed = new re.x, F._fitInkBarToContent.pipe((0, Pe.R)(this._destroyed)).subscribe(un => { this.fitInkBarToContent = un }) } ngOnDestroy() { this._destroyed.next(), this._destroyed.complete(), super.ngOnDestroy() } } return pe.\u0275fac = function (F) { return new (F || pe)(y.Y36(L), y.Y36(y.SBq), y.Y36(v.Y2, 8), y.$8M("tabindex"), y.Y36(Se.tE), y.Y36(y.QbO, 8)) }, pe.\u0275cmp = y.Xpm({ type: pe, selectors: [["", "mat-tab-link", ""], ["", "matTabLink", ""]], hostAttrs: [1, "mdc-tab", "mat-mdc-tab-link", "mat-mdc-focus-indicator"], hostVars: 11, hostBindings: function (F, J) { 1 & F && y.NdJ("focus", function () { return J._handleFocus() })("keydown", function (lt) { return J._handleKeydown(lt) }), 2 & F && (y.uIk("aria-controls", J._getAriaControls())("aria-current", J._getAriaCurrent())("aria-disabled", J.disabled)("aria-selected", J._getAriaSelected())("id", J.id)("tabIndex", J._getTabIndex())("role", J._getRole()), y.ekj("mat-mdc-tab-disabled", J.disabled)("mdc-tab--active", J.active)) }, inputs: { disabled: "disabled", disableRipple: "disableRipple", tabIndex: "tabIndex", active: "active", id: "id" }, exportAs: ["matTabLink"], features: [y.qOj], attrs: St, ngContentSelectors: Dn, decls: 5, vars: 2, consts: [[1, "mdc-tab__ripple"], ["mat-ripple", "", 1, "mat-mdc-tab-ripple", 3, "matRippleTrigger", "matRippleDisabled"], [1, "mdc-tab__content"], [1, "mdc-tab__text-label"]], template: function (F, J) { 1 & F && (y.F$t(), y._UZ(0, "span", 0)(1, "div", 1), y.TgZ(2, "span", 2)(3, "span", 3), y.Hsn(4), y.qZA()()), 2 & F && (y.xp6(1), y.Q6J("matRippleTrigger", J.elementRef.nativeElement)("matRippleDisabled", J.rippleDisabled)) }, dependencies: [v.wG], styles: ['.mat-mdc-tab-link{-webkit-tap-highlight-color:rgba(0,0,0,0);-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;text-decoration:none;background:none;font-family:var(--mat-tab-header-label-text-font);font-size:var(--mat-tab-header-label-text-size);letter-spacing:var(--mat-tab-header-label-text-letter-spacing);line-height:var(--mat-tab-header-label-text-line-height);font-weight:var(--mat-tab-header-label-text-weight)}.mat-mdc-tab-link .mdc-tab-indicator__content--underline{border-color:var(--mdc-tab-indicator-active-indicator-color)}.mat-mdc-tab-link .mdc-tab-indicator__content--underline{border-top-width:var(--mdc-tab-indicator-active-indicator-height)}.mat-mdc-tab-link .mdc-tab-indicator__content--underline{border-radius:var(--mdc-tab-indicator-active-indicator-shape)}.mat-mdc-tab-link:not(.mdc-tab--stacked){height:var(--mdc-secondary-navigation-tab-container-height)}.mat-mdc-tab-link:not(:disabled).mdc-tab--active .mdc-tab__icon{fill:currentColor}.mat-mdc-tab-link:not(:disabled):hover.mdc-tab--active .mdc-tab__icon{fill:currentColor}.mat-mdc-tab-link:not(:disabled):focus.mdc-tab--active .mdc-tab__icon{fill:currentColor}.mat-mdc-tab-link:not(:disabled):active.mdc-tab--active .mdc-tab__icon{fill:currentColor}.mat-mdc-tab-link:disabled.mdc-tab--active .mdc-tab__icon{fill:currentColor}.mat-mdc-tab-link:not(:disabled):not(.mdc-tab--active) .mdc-tab__icon{fill:currentColor}.mat-mdc-tab-link:not(:disabled):hover:not(.mdc-tab--active) .mdc-tab__icon{fill:currentColor}.mat-mdc-tab-link:not(:disabled):focus:not(.mdc-tab--active) .mdc-tab__icon{fill:currentColor}.mat-mdc-tab-link:not(:disabled):active:not(.mdc-tab--active) .mdc-tab__icon{fill:currentColor}.mat-mdc-tab-link:disabled:not(.mdc-tab--active) .mdc-tab__icon{fill:currentColor}.mat-mdc-tab-link.mdc-tab{flex-grow:0}.mat-mdc-tab-link:hover .mdc-tab__text-label{color:var(--mat-tab-header-inactive-hover-label-text-color)}.mat-mdc-tab-link:focus .mdc-tab__text-label{color:var(--mat-tab-header-inactive-focus-label-text-color)}.mat-mdc-tab-link.mdc-tab--active .mdc-tab__text-label{color:var(--mat-tab-header-active-label-text-color)}.mat-mdc-tab-link.mdc-tab--active .mdc-tab__ripple::before,.mat-mdc-tab-link.mdc-tab--active .mat-ripple-element{background-color:var(--mat-tab-header-active-ripple-color)}.mat-mdc-tab-link.mdc-tab--active:hover .mdc-tab__text-label{color:var(--mat-tab-header-active-hover-label-text-color)}.mat-mdc-tab-link.mdc-tab--active:hover .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-active-hover-indicator-color)}.mat-mdc-tab-link.mdc-tab--active:focus .mdc-tab__text-label{color:var(--mat-tab-header-active-focus-label-text-color)}.mat-mdc-tab-link.mdc-tab--active:focus .mdc-tab-indicator__content--underline{border-color:var(--mat-tab-header-active-focus-indicator-color)}.mat-mdc-tab-link.mat-mdc-tab-disabled{opacity:.4;pointer-events:none}.mat-mdc-tab-link.mat-mdc-tab-disabled .mdc-tab__content{pointer-events:none}.mat-mdc-tab-link.mat-mdc-tab-disabled .mdc-tab__ripple::before,.mat-mdc-tab-link.mat-mdc-tab-disabled .mat-ripple-element{background-color:var(--mat-tab-header-disabled-ripple-color)}.mat-mdc-tab-link .mdc-tab__ripple::before{content:"";display:block;position:absolute;top:0;left:0;right:0;bottom:0;opacity:0;pointer-events:none;background-color:var(--mat-tab-header-inactive-ripple-color)}.mat-mdc-tab-link .mdc-tab__text-label{color:var(--mat-tab-header-inactive-label-text-color);display:inline-flex;align-items:center}.mat-mdc-tab-link .mdc-tab__content{position:relative;pointer-events:auto}.mat-mdc-tab-link:hover .mdc-tab__ripple::before{opacity:.04}.mat-mdc-tab-link.cdk-program-focused .mdc-tab__ripple::before,.mat-mdc-tab-link.cdk-keyboard-focused .mdc-tab__ripple::before{opacity:.12}.mat-mdc-tab-link .mat-ripple-element{opacity:.12;background-color:var(--mat-tab-header-inactive-ripple-color)}.mat-mdc-tab-header.mat-mdc-tab-nav-bar-stretch-tabs .mat-mdc-tab-link{flex-grow:1}.mat-mdc-tab-link::before{margin:5px}@media(max-width: 599px){.mat-mdc-tab-link{min-width:72px}}'], encapsulation: 2, changeDetection: 0 }), pe })(), Ne = (() => { class pe { constructor() { this.id = "mat-tab-nav-panel-" + st++ } } return pe.\u0275fac = function (F) { return new (F || pe) }, pe.\u0275cmp = y.Xpm({ type: pe, selectors: [["mat-tab-nav-panel"]], hostAttrs: ["role", "tabpanel", 1, "mat-mdc-tab-nav-panel"], hostVars: 2, hostBindings: function (F, J) { 2 & F && y.uIk("aria-labelledby", J._activeTabId)("id", J.id) }, inputs: { id: "id" }, exportAs: ["matTabNavPanel"], ngContentSelectors: Dn, decls: 1, vars: 0, template: function (F, J) { 1 & F && (y.F$t(), y.Hsn(0)) }, encapsulation: 2, changeDetection: 0 }), pe })(), pt = (() => { class pe { } return pe.\u0275fac = function (F) { return new (F || pe) }, pe.\u0275mod = y.oAB({ type: pe }), pe.\u0275inj = y.cJS({ imports: [a.ez, v.BQ, Y.eL, v.si, he.Q8, Se.rt, v.BQ] }), pe })() }, 1274: (nn, Qe, C) => { C.d(Qe, { Ye: () => Ie, g0: () => _e }); var a = C(5879), y = C(3680), v = C(2831), Y = C(6814); const he = ["*", [["mat-toolbar-row"]]], Se = ["*", "mat-toolbar-row"], ke = (0, y.pj)(class { constructor(xe) { this._elementRef = xe } }); let re = (() => { class xe { } return xe.\u0275fac = function (Oe) { return new (Oe || xe) }, xe.\u0275dir = a.lG2({ type: xe, selectors: [["mat-toolbar-row"]], hostAttrs: [1, "mat-toolbar-row"], exportAs: ["matToolbarRow"] }), xe })(), Ie = (() => { class xe extends ke { constructor(Oe, We, Pe) { super(Oe), this._platform = We, this._document = Pe } ngAfterViewInit() { this._platform.isBrowser && (this._checkToolbarMixedModes(), this._toolbarRows.changes.subscribe(() => this._checkToolbarMixedModes())) } _checkToolbarMixedModes() { } } return xe.\u0275fac = function (Oe) { return new (Oe || xe)(a.Y36(a.SBq), a.Y36(v.t4), a.Y36(Y.K0)) }, xe.\u0275cmp = a.Xpm({ type: xe, selectors: [["mat-toolbar"]], contentQueries: function (Oe, We, Pe) { if (1 & Oe && a.Suo(Pe, re, 5), 2 & Oe) { let Ve; a.iGM(Ve = a.CRH()) && (We._toolbarRows = Ve) } }, hostAttrs: [1, "mat-toolbar"], hostVars: 4, hostBindings: function (Oe, We) { 2 & Oe && a.ekj("mat-toolbar-multiple-rows", We._toolbarRows.length > 0)("mat-toolbar-single-row", 0 === We._toolbarRows.length) }, inputs: { color: "color" }, exportAs: ["matToolbar"], features: [a.qOj], ngContentSelectors: Se, decls: 2, vars: 0, template: function (Oe, We) { 1 & Oe && (a.F$t(he), a.Hsn(0), a.Hsn(1, 1)) }, styles: [".cdk-high-contrast-active .mat-toolbar{outline:solid 1px}.mat-toolbar .mat-mdc-button-base.mat-unthemed{--mdc-text-button-label-text-color: inherit;--mdc-outlined-button-label-text-color: inherit}.mat-toolbar-row,.mat-toolbar-single-row{display:flex;box-sizing:border-box;padding:0 16px;width:100%;flex-direction:row;align-items:center;white-space:nowrap}.mat-toolbar-multiple-rows{display:flex;box-sizing:border-box;flex-direction:column;width:100%}"], encapsulation: 2, changeDetection: 0 }), xe })(), _e = (() => { class xe { } return xe.\u0275fac = function (Oe) { return new (Oe || xe) }, xe.\u0275mod = a.oAB({ type: xe }), xe.\u0275inj = a.cJS({ imports: [y.BQ, y.BQ] }), xe })() }, 6593: (nn, Qe, C) => { C.d(Qe, { Dx: () => gn, H7: () => Ln, b2: () => Pt, q6: () => Ae, se: () => ee }); var a = C(5879), y = C(6814); class v extends y.w_ { constructor() { super(...arguments), this.supportsDOMEvents = !0 } } class Y extends v { static makeCurrent() { (0, y.HT)(new Y) } onAndCancel(z, L, H) { return z.addEventListener(L, H), () => { z.removeEventListener(L, H) } } dispatchEvent(z, L) { z.dispatchEvent(L) } remove(z) { z.parentNode && z.parentNode.removeChild(z) } createElement(z, L) { return (L = L || this.getDefaultDocument()).createElement(z) } createHtmlDocument() { return document.implementation.createHTMLDocument("fakeTitle") } getDefaultDocument() { return document } isElementNode(z) { return z.nodeType === Node.ELEMENT_NODE } isShadowRoot(z) { return z instanceof DocumentFragment } getGlobalEventTarget(z, L) { return "window" === L ? window : "document" === L ? z : "body" === L ? z.body : null } getBaseHref(z) { const L = function Se() { return he = he || document.querySelector("base"), he ? he.getAttribute("href") : null }(); return null == L ? null : function re(ae) { ke = ke || document.createElement("a"), ke.setAttribute("href", ae); const z = ke.pathname; return "/" === z.charAt(0) ? z : `/${z}` }(L) } resetBaseElement() { he = null } getUserAgent() { return window.navigator.userAgent } getCookie(z) { return (0, y.Mx)(document.cookie, z) } } let ke, he = null, Q = (() => { class ae { build() { return new XMLHttpRequest } } return ae.\u0275fac = function (L) { return new (L || ae) }, ae.\u0275prov = a.Yz7({ token: ae, factory: ae.\u0275fac }), ae })(); const _e = new a.OlP("EventManagerPlugins"); let xe = (() => { class ae { constructor(L, H) { this._zone = H, this._eventNameToPlugin = new Map, L.forEach(Ne => { Ne.manager = this }), this._plugins = L.slice().reverse() } addEventListener(L, H, Ne) { return this._findPluginFor(H).addEventListener(L, H, Ne) } getZone() { return this._zone } _findPluginFor(L) { let H = this._eventNameToPlugin.get(L); if (H) return H; if (H = this._plugins.find(pt => pt.supports(L)), !H) throw new a.vHH(5101, !1); return this._eventNameToPlugin.set(L, H), H } } return ae.\u0275fac = function (L) { return new (L || ae)(a.LFG(_e), a.LFG(a.R0b)) }, ae.\u0275prov = a.Yz7({ token: ae, factory: ae.\u0275fac }), ae })(); class ze { constructor(z) { this._doc = z } } const Oe = "ng-app-id"; let We = (() => { class ae { constructor(L, H, Ne, pt = {}) { this.doc = L, this.appId = H, this.nonce = Ne, this.platformId = pt, this.styleRef = new Map, this.hostNodes = new Set, this.styleNodesInDOM = this.collectServerRenderedStyles(), this.platformIsServer = (0, y.PM)(pt), this.resetHostNodes() } addStyles(L) { for (const H of L) 1 === this.changeUsageCount(H, 1) && this.onStyleAdded(H) } removeStyles(L) { for (const H of L) this.changeUsageCount(H, -1) <= 0 && this.onStyleRemoved(H) } ngOnDestroy() { const L = this.styleNodesInDOM; L && (L.forEach(H => H.remove()), L.clear()); for (const H of this.getAllStyles()) this.onStyleRemoved(H); this.resetHostNodes() } addHost(L) { this.hostNodes.add(L); for (const H of this.getAllStyles()) this.addStyleToHost(L, H) } removeHost(L) { this.hostNodes.delete(L) } getAllStyles() { return this.styleRef.keys() } onStyleAdded(L) { for (const H of this.hostNodes) this.addStyleToHost(H, L) } onStyleRemoved(L) { const H = this.styleRef; H.get(L)?.elements?.forEach(Ne => Ne.remove()), H.delete(L) } collectServerRenderedStyles() { const L = this.doc.head?.querySelectorAll(`style[${Oe}="${this.appId}"]`); if (L?.length) { const H = new Map; return L.forEach(Ne => { null != Ne.textContent && H.set(Ne.textContent, Ne) }), H } return null } changeUsageCount(L, H) { const Ne = this.styleRef; if (Ne.has(L)) { const pt = Ne.get(L); return pt.usage += H, pt.usage } return Ne.set(L, { usage: H, elements: [] }), H } getStyleElement(L, H) { const Ne = this.styleNodesInDOM, pt = Ne?.get(H); if (pt?.parentNode === L) return Ne.delete(H), pt.removeAttribute(Oe), pt; { const pe = this.doc.createElement("style"); return this.nonce && pe.setAttribute("nonce", this.nonce), pe.textContent = H, this.platformIsServer && pe.setAttribute(Oe, this.appId), pe } } addStyleToHost(L, H) { const Ne = this.getStyleElement(L, H); L.appendChild(Ne); const pt = this.styleRef, pe = pt.get(H)?.elements; pe ? pe.push(Ne) : pt.set(H, { elements: [Ne], usage: 1 }) } resetHostNodes() { const L = this.hostNodes; L.clear(), L.add(this.doc.head) } } return ae.\u0275fac = function (L) { return new (L || ae)(a.LFG(y.K0), a.LFG(a.AFp), a.LFG(a.Ojb, 8), a.LFG(a.Lbi)) }, ae.\u0275prov = a.Yz7({ token: ae, factory: ae.\u0275fac }), ae })(); const Pe = { svg: "http://www.w3.org/2000/svg", xhtml: "http://www.w3.org/1999/xhtml", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/", math: "http://www.w3.org/1998/MathML/" }, Ve = /%COMP%/g, Le = new a.OlP("RemoveStylesOnCompDestroy", { providedIn: "root", factory: () => !1 }); function ue(ae, z) { return z.map(L => L.replace(Ve, ae)) } let ee = (() => { class ae { constructor(L, H, Ne, pt, pe, fe, F, J = null) { this.eventManager = L, this.sharedStylesHost = H, this.appId = Ne, this.removeStylesOnCompDestroy = pt, this.doc = pe, this.platformId = fe, this.ngZone = F, this.nonce = J, this.rendererByCompId = new Map, this.platformIsServer = (0, y.PM)(fe), this.defaultRenderer = new $e(L, pe, F, this.platformIsServer) } createRenderer(L, H) { if (!L || !H) return this.defaultRenderer; this.platformIsServer && H.encapsulation === a.ifc.ShadowDom && (H = { ...H, encapsulation: a.ifc.Emulated }); const Ne = this.getOrCreateRenderer(L, H); return Ne instanceof On ? Ne.applyToHost(L) : Ne instanceof Mn && Ne.applyStyles(), Ne } getOrCreateRenderer(L, H) { const Ne = this.rendererByCompId; let pt = Ne.get(H.id); if (!pt) { const pe = this.doc, fe = this.ngZone, F = this.eventManager, J = this.sharedStylesHost, Te = this.removeStylesOnCompDestroy, lt = this.platformIsServer; switch (H.encapsulation) { case a.ifc.Emulated: pt = new On(F, J, H, this.appId, Te, pe, fe, lt); break; case a.ifc.ShadowDom: return new Dn(F, J, L, H, pe, fe, this.nonce, lt); default: pt = new Mn(F, J, H, Te, pe, fe, lt) }pt.onDestroy = () => Ne.delete(H.id), Ne.set(H.id, pt) } return pt } ngOnDestroy() { this.rendererByCompId.clear() } } return ae.\u0275fac = function (L) { return new (L || ae)(a.LFG(xe), a.LFG(We), a.LFG(a.AFp), a.LFG(Le), a.LFG(y.K0), a.LFG(a.Lbi), a.LFG(a.R0b), a.LFG(a.Ojb)) }, ae.\u0275prov = a.Yz7({ token: ae, factory: ae.\u0275fac }), ae })(); class $e { constructor(z, L, H, Ne) { this.eventManager = z, this.doc = L, this.ngZone = H, this.platformIsServer = Ne, this.data = Object.create(null), this.destroyNode = null } destroy() { } createElement(z, L) { return L ? this.doc.createElementNS(Pe[L] || L, z) : this.doc.createElement(z) } createComment(z) { return this.doc.createComment(z) } createText(z) { return this.doc.createTextNode(z) } appendChild(z, L) { (bn(z) ? z.content : z).appendChild(L) } insertBefore(z, L, H) { z && (bn(z) ? z.content : z).insertBefore(L, H) } removeChild(z, L) { z && z.removeChild(L) } selectRootElement(z, L) { let H = "string" == typeof z ? this.doc.querySelector(z) : z; if (!H) throw new a.vHH(-5104, !1); return L || (H.textContent = ""), H } parentNode(z) { return z.parentNode } nextSibling(z) { return z.nextSibling } setAttribute(z, L, H, Ne) { if (Ne) { L = Ne + ":" + L; const pt = Pe[Ne]; pt ? z.setAttributeNS(pt, L, H) : z.setAttribute(L, H) } else z.setAttribute(L, H) } removeAttribute(z, L, H) { if (H) { const Ne = Pe[H]; Ne ? z.removeAttributeNS(Ne, L) : z.removeAttribute(`${H}:${L}`) } else z.removeAttribute(L) } addClass(z, L) { z.classList.add(L) } removeClass(z, L) { z.classList.remove(L) } setStyle(z, L, H, Ne) { Ne & (a.JOm.DashCase | a.JOm.Important) ? z.style.setProperty(L, H, Ne & a.JOm.Important ? "important" : "") : z.style[L] = H } removeStyle(z, L, H) { H & a.JOm.DashCase ? z.style.removeProperty(L) : z.style[L] = "" } setProperty(z, L, H) { z[L] = H } setValue(z, L) { z.nodeValue = L } listen(z, L, H) { if ("string" == typeof z && !(z = (0, y.q)().getGlobalEventTarget(this.doc, z))) throw new Error(`Unsupported event target ${z} for event ${L}`); return this.eventManager.addEventListener(z, L, this.decoratePreventDefault(H)) } decoratePreventDefault(z) { return L => { if ("__ngUnwrap__" === L) return z; !1 === (this.platformIsServer ? this.ngZone.runGuarded(() => z(L)) : z(L)) && L.preventDefault() } } } function bn(ae) { return "TEMPLATE" === ae.tagName && void 0 !== ae.content } class Dn extends $e { constructor(z, L, H, Ne, pt, pe, fe, F) { super(z, pt, pe, F), this.sharedStylesHost = L, this.hostEl = H, this.shadowRoot = H.attachShadow({ mode: "open" }), this.sharedStylesHost.addHost(this.shadowRoot); const J = ue(Ne.id, Ne.styles); for (const Te of J) { const lt = document.createElement("style"); fe && lt.setAttribute("nonce", fe), lt.textContent = Te, this.shadowRoot.appendChild(lt) } } nodeOrShadowRoot(z) { return z === this.hostEl ? this.shadowRoot : z } appendChild(z, L) { return super.appendChild(this.nodeOrShadowRoot(z), L) } insertBefore(z, L, H) { return super.insertBefore(this.nodeOrShadowRoot(z), L, H) } removeChild(z, L) { return super.removeChild(this.nodeOrShadowRoot(z), L) } parentNode(z) { return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(z))) } destroy() { this.sharedStylesHost.removeHost(this.shadowRoot) } } class Mn extends $e { constructor(z, L, H, Ne, pt, pe, fe, F) { super(z, pt, pe, fe), this.sharedStylesHost = L, this.removeStylesOnCompDestroy = Ne, this.rendererUsageCount = 0, this.styles = F ? ue(F, H.styles) : H.styles } applyStyles() { this.sharedStylesHost.addStyles(this.styles), this.rendererUsageCount++ } destroy() { this.removeStylesOnCompDestroy && (this.sharedStylesHost.removeStyles(this.styles), this.rendererUsageCount--, 0 === this.rendererUsageCount && this.onDestroy?.()) } } class On extends Mn { constructor(z, L, H, Ne, pt, pe, fe, F) { const J = Ne + "-" + H.id; super(z, L, H, pt, pe, fe, F, J), this.contentAttr = function le(ae) { return "_ngcontent-%COMP%".replace(Ve, ae) }(J), this.hostAttr = function ge(ae) { return "_nghost-%COMP%".replace(Ve, ae) }(J) } applyToHost(z) { this.applyStyles(), this.setAttribute(z, this.hostAttr, "") } createElement(z, L) { const H = super.createElement(z, L); return super.setAttribute(H, this.contentAttr, ""), H } } let Wn = (() => { class ae extends ze { constructor(L) { super(L) } supports(L) { return !0 } addEventListener(L, H, Ne) { return L.addEventListener(H, Ne, !1), () => this.removeEventListener(L, H, Ne) } removeEventListener(L, H, Ne) { return L.removeEventListener(H, Ne) } } return ae.\u0275fac = function (L) { return new (L || ae)(a.LFG(y.K0)) }, ae.\u0275prov = a.Yz7({ token: ae, factory: ae.\u0275fac }), ae })(); const Hn = ["alt", "control", "meta", "shift"], at = { "\b": "Backspace", "\t": "Tab", "\x7f": "Delete", "\x1b": "Escape", Del: "Delete", Esc: "Escape", Left: "ArrowLeft", Right: "ArrowRight", Up: "ArrowUp", Down: "ArrowDown", Menu: "ContextMenu", Scroll: "ScrollLock", Win: "OS" }, vt = { alt: ae => ae.altKey, control: ae => ae.ctrlKey, meta: ae => ae.metaKey, shift: ae => ae.shiftKey }; let xt = (() => { class ae extends ze { constructor(L) { super(L) } supports(L) { return null != ae.parseEventName(L) } addEventListener(L, H, Ne) { const pt = ae.parseEventName(H), pe = ae.eventCallback(pt.fullKey, Ne, this.manager.getZone()); return this.manager.getZone().runOutsideAngular(() => (0, y.q)().onAndCancel(L, pt.domEventName, pe)) } static parseEventName(L) { const H = L.toLowerCase().split("."), Ne = H.shift(); if (0 === H.length || "keydown" !== Ne && "keyup" !== Ne) return null; const pt = ae._normalizeKey(H.pop()); let pe = "", fe = H.indexOf("code"); if (fe > -1 && (H.splice(fe, 1), pe = "code."), Hn.forEach(J => { const Te = H.indexOf(J); Te > -1 && (H.splice(Te, 1), pe += J + ".") }), pe += pt, 0 != H.length || 0 === pt.length) return null; const F = {}; return F.domEventName = Ne, F.fullKey = pe, F } static matchEventFullKeyCode(L, H) { let Ne = at[L.key] || L.key, pt = ""; return H.indexOf("code.") > -1 && (Ne = L.code, pt = "code."), !(null == Ne || !Ne) && (Ne = Ne.toLowerCase(), " " === Ne ? Ne = "space" : "." === Ne && (Ne = "dot"), Hn.forEach(pe => { pe !== Ne && (0, vt[pe])(L) && (pt += pe + ".") }), pt += Ne, pt === H) } static eventCallback(L, H, Ne) { return pt => { ae.matchEventFullKeyCode(pt, L) && Ne.runGuarded(() => H(pt)) } } static _normalizeKey(L) { return "esc" === L ? "escape" : L } } return ae.\u0275fac = function (L) { return new (L || ae)(a.LFG(y.K0)) }, ae.\u0275prov = a.Yz7({ token: ae, factory: ae.\u0275fac }), ae })(); const Ae = (0, a.eFA)(a._c5, "browser", [{ provide: a.Lbi, useValue: y.bD }, { provide: a.g9A, useValue: function Jt() { Y.makeCurrent() }, multi: !0 }, { provide: y.K0, useFactory: function St() { return (0, a.RDi)(document), document }, deps: [] }]), nt = new a.OlP(""), qt = [{ provide: a.rWj, useClass: class Ie { addToWindow(z) { a.dqk.getAngularTestability = (H, Ne = !0) => { const pt = z.findTestabilityInTree(H, Ne); if (null == pt) throw new a.vHH(5103, !1); return pt }, a.dqk.getAllAngularTestabilities = () => z.getAllTestabilities(), a.dqk.getAllAngularRootElements = () => z.getAllRootElements(), a.dqk.frameworkStabilizers || (a.dqk.frameworkStabilizers = []), a.dqk.frameworkStabilizers.push(H => { const Ne = a.dqk.getAllAngularTestabilities(); let pt = Ne.length, pe = !1; const fe = function (F) { pe = pe || F, pt--, 0 == pt && H(pe) }; Ne.forEach(F => { F.whenStable(fe) }) }) } findTestabilityInTree(z, L, H) { return null == L ? null : z.getTestability(L) ?? (H ? (0, y.q)().isShadowRoot(L) ? this.findTestabilityInTree(z, L.host, !0) : this.findTestabilityInTree(z, L.parentElement, !0) : null) } }, deps: [] }, { provide: a.lri, useClass: a.dDg, deps: [a.R0b, a.eoX, a.rWj] }, { provide: a.dDg, useClass: a.dDg, deps: [a.R0b, a.eoX, a.rWj] }], jt = [{ provide: a.zSh, useValue: "root" }, { provide: a.qLn, useFactory: function tn() { return new a.qLn }, deps: [] }, { provide: _e, useClass: Wn, multi: !0, deps: [y.K0, a.R0b, a.Lbi] }, { provide: _e, useClass: xt, multi: !0, deps: [y.K0] }, ee, We, xe, { provide: a.FYo, useExisting: ee }, { provide: y.JF, useClass: Q, deps: [] }, []]; let Pt = (() => { class ae { constructor(L) { } static withServerTransition(L) { return { ngModule: ae, providers: [{ provide: a.AFp, useValue: L.appId }] } } } return ae.\u0275fac = function (L) { return new (L || ae)(a.LFG(nt, 12)) }, ae.\u0275mod = a.oAB({ type: ae }), ae.\u0275inj = a.cJS({ providers: [...jt, ...qt], imports: [y.ez, a.hGG] }), ae })(), gn = (() => { class ae { constructor(L) { this._doc = L } getTitle() { return this._doc.title } setTitle(L) { this._doc.title = L || "" } } return ae.\u0275fac = function (L) { return new (L || ae)(a.LFG(y.K0)) }, ae.\u0275prov = a.Yz7({ token: ae, factory: function (L) { let H = null; return H = L ? new L : function Zt() { return new gn((0, a.LFG)(y.K0)) }(), H }, providedIn: "root" }), ae })(); typeof window < "u" && window; let Ln = (() => { class ae { } return ae.\u0275fac = function (L) { return new (L || ae) }, ae.\u0275prov = a.Yz7({ token: ae, factory: function (L) { let H = null; return H = L ? new (L || ae) : a.LFG(Et), H }, providedIn: "root" }), ae })(), Et = (() => { class ae extends Ln { constructor(L) { super(), this._doc = L } sanitize(L, H) { if (null == H) return null; switch (L) { case a.q3G.NONE: return H; case a.q3G.HTML: return (0, a.qzn)(H, "HTML") ? (0, a.z3N)(H) : (0, a.EiD)(this._doc, String(H)).toString(); case a.q3G.STYLE: return (0, a.qzn)(H, "Style") ? (0, a.z3N)(H) : H; case a.q3G.SCRIPT: if ((0, a.qzn)(H, "Script")) return (0, a.z3N)(H); throw new a.vHH(5200, !1); case a.q3G.URL: return (0, a.qzn)(H, "URL") ? (0, a.z3N)(H) : (0, a.mCW)(String(H)); case a.q3G.RESOURCE_URL: if ((0, a.qzn)(H, "ResourceURL")) return (0, a.z3N)(H); throw new a.vHH(5201, !1); default: throw new a.vHH(5202, !1) } } bypassSecurityTrustHtml(L) { return (0, a.JVY)(L) } bypassSecurityTrustStyle(L) { return (0, a.L6k)(L) } bypassSecurityTrustScript(L) { return (0, a.eBb)(L) } bypassSecurityTrustUrl(L) { return (0, a.LAX)(L) } bypassSecurityTrustResourceUrl(L) { return (0, a.pB0)(L) } } return ae.\u0275fac = function (L) { return new (L || ae)(a.LFG(y.K0)) }, ae.\u0275prov = a.Yz7({ token: ae, factory: function (L) { let H = null; return H = L ? new L : function In(ae) { return new Et(ae.get(y.K0)) }(a.LFG(a.zs3)), H }, providedIn: "root" }), ae })() }, 4190: (nn, Qe, C) => { C.d(Qe, { gz: () => mo, F0: () => lr, rH: () => pn, Od: () => er, Bz: () => Vs, lC: () => di }); var a = C(5879), y = C(2664), v = C(2459), Y = C(2096), he = C(5619), Se = C(2572), ke = C(6973), re = C(5211), Ie = C(4911), Q = C(8407), _e = C(8504), xe = C(6232), ze = C(3168), Oe = C(8645), We = C(6814), Pe = C(7398), Ve = C(4664), tt = C(8180), Ye = C(7921), ut = C(2181), ie = C(1631), Le = C(1374), le = C(6328), ge = C(9397), ue = C(6306), ee = C(6699), $e = C(3572), rt = C(9360), Kt = C(8251); function bn(S) { return S <= 0 ? () => xe.E : (0, rt.e)((I, m) => { let u = []; I.subscribe((0, Kt.x)(m, h => { u.push(h), S < u.length && u.shift() }, () => { for (const h of u) m.next(h); m.complete() }, void 0, () => { u = null })) }) } var Dn = C(3026), Mn = C(2737), Wn = C(975), Hn = C(4716), at = C(6196), vt = C(7537), xt = C(6593); const it = "primary", Ft = Symbol("RouteTitle"); class Wt { constructor(I) { this.params = I || {} } has(I) { return Object.prototype.hasOwnProperty.call(this.params, I) } get(I) { if (this.has(I)) { const m = this.params[I]; return Array.isArray(m) ? m[0] : m } return null } getAll(I) { if (this.has(I)) { const m = this.params[I]; return Array.isArray(m) ? m : [m] } return [] } get keys() { return Object.keys(this.params) } } function rn(S) { return new Wt(S) } function Jt(S, I, m) { const u = m.path.split("/"); if (u.length > S.length || "full" === m.pathMatch && (I.hasChildren() || u.length < S.length)) return null; const h = {}; for (let x = 0; x < u.length; x++) { const M = u[x], $ = S[x]; if (M.startsWith(":")) h[M.substring(1)] = $; else if (M !== $.path) return null } return { consumed: S.slice(0, u.length), posParams: h } } function St(S, I) { const m = S ? Object.keys(S) : void 0, u = I ? Object.keys(I) : void 0; if (!m || !u || m.length != u.length) return !1; let h; for (let x = 0; x < m.length; x++)if (h = m[x], !ht(S[h], I[h])) return !1; return !0 } function ht(S, I) { if (Array.isArray(S) && Array.isArray(I)) { if (S.length !== I.length) return !1; const m = [...S].sort(), u = [...I].sort(); return m.every((h, x) => u[x] === h) } return S === I } function Ae(S) { return S.length > 0 ? S[S.length - 1] : null } function nt(S) { return (0, y.b)(S) ? S : (0, a.QGY)(S) ? (0, v.D)(Promise.resolve(S)) : (0, Y.of)(S) } const qt = { exact: function Nt(S, I, m) { if (!Xe(S.segments, I.segments) || !$n(S.segments, I.segments, m) || S.numberOfChildren !== I.numberOfChildren) return !1; for (const u in I.children) if (!S.children[u] || !Nt(S.children[u], I.children[u], m)) return !1; return !0 }, subset: Zt }, jt = { exact: function qe(S, I) { return St(S, I) }, subset: function on(S, I) { return Object.keys(I).length <= Object.keys(S).length && Object.keys(I).every(m => ht(S[m], I[m])) }, ignored: () => !0 }; function Pt(S, I, m) { return qt[m.paths](S.root, I.root, m.matrixParams) && jt[m.queryParams](S.queryParams, I.queryParams) && !("exact" === m.fragment && S.fragment !== I.fragment) } function Zt(S, I, m) { return gn(S, I, I.segments, m) } function gn(S, I, m, u) { if (S.segments.length > m.length) { const h = S.segments.slice(0, m.length); return !(!Xe(h, m) || I.hasChildren() || !$n(h, m, u)) } if (S.segments.length === m.length) { if (!Xe(S.segments, m) || !$n(S.segments, m, u)) return !1; for (const h in I.children) if (!S.children[h] || !Zt(S.children[h], I.children[h], u)) return !1; return !0 } { const h = m.slice(0, S.segments.length), x = m.slice(S.segments.length); return !!(Xe(S.segments, h) && $n(S.segments, h, u) && S.children[it]) && gn(S.children[it], I, x, u) } } function $n(S, I, m) { return I.every((u, h) => jt[m](S[h].parameters, u.parameters)) } class Fn { constructor(I = new Ke([], {}), m = {}, u = null) { this.root = I, this.queryParams = m, this.fragment = u } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = rn(this.queryParams)), this._queryParamMap } toString() { return Z.serialize(this) } } class Ke { constructor(I, m) { this.segments = I, this.children = m, this.parent = null, Object.values(m).forEach(u => u.parent = this) } hasChildren() { return this.numberOfChildren > 0 } get numberOfChildren() { return Object.keys(this.children).length } toString() { return Fe(this) } } class se { constructor(I, m) { this.path = I, this.parameters = m } get parameterMap() { return this._parameterMap || (this._parameterMap = rn(this.parameters)), this._parameterMap } toString() { return Et(this) } } function Xe(S, I) { return S.length === I.length && S.every((m, u) => m.path === I[u].path) } let ve = (() => { class S { } return S.\u0275fac = function (m) { return new (m || S) }, S.\u0275prov = a.Yz7({ token: S, factory: function () { return new Ue }, providedIn: "root" }), S })(); class Ue { parse(I) { const m = new L(I); return new Fn(m.parseRootSegment(), m.parseQueryParams(), m.parseFragment()) } serialize(I) { const m = `/${ct(I.root, !0)}`, u = function G(S) { const I = Object.keys(S).map(m => { const u = S[m]; return Array.isArray(u) ? u.map(h => `${Qt(m)}=${Qt(h)}`).join("&") : `${Qt(m)}=${Qt(u)}` }).filter(m => !!m); return I.length ? `?${I.join("&")}` : "" }(I.queryParams); return `${m}${u}${"string" == typeof I.fragment ? `#${function fn(S) { return encodeURI(S) }(I.fragment)}` : ""}` } } const Z = new Ue; function Fe(S) { return S.segments.map(I => Et(I)).join("/") } function ct(S, I) { if (!S.hasChildren()) return Fe(S); if (I) { const m = S.children[it] ? ct(S.children[it], !1) : "", u = []; return Object.entries(S.children).forEach(([h, x]) => { h !== it && u.push(`${h}:${ct(x, !1)}`) }), u.length > 0 ? `${m}(${u.join("//")})` : m } { const m = function Ot(S, I) { let m = []; return Object.entries(S.children).forEach(([u, h]) => { u === it && (m = m.concat(I(h, u))) }), Object.entries(S.children).forEach(([u, h]) => { u !== it && (m = m.concat(I(h, u))) }), m }(S, (u, h) => h === it ? [ct(S.children[it], !1)] : [`${h}:${ct(u, !1)}`]); return 1 === Object.keys(S.children).length && null != S.children[it] ? `${Fe(S)}/${m[0]}` : `${Fe(S)}/(${m.join("//")})` } } function Mt(S) { return encodeURIComponent(S).replace(/%40/g, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",") } function Qt(S) { return Mt(S).replace(/%3B/gi, ";") } function En(S) { return Mt(S).replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/%26/gi, "&") } function Ln(S) { return decodeURIComponent(S) } function In(S) { return Ln(S.replace(/\+/g, "%20")) } function Et(S) { return `${En(S.path)}${function _t(S) { return Object.keys(S).map(I => `;${En(I)}=${En(S[I])}`).join("") }(S.parameters)}` } const W = /^[^\/()?;#]+/; function me(S) { const I = S.match(W); return I ? I[0] : "" } const de = /^[^\/()?;=#]+/, Lt = /^[^=?&#]+/, ae = /^[^&#]+/; class L { constructor(I) { this.url = I, this.remaining = I } parseRootSegment() { return this.consumeOptional("/"), "" === this.remaining || this.peekStartsWith("?") || this.peekStartsWith("#") ? new Ke([], {}) : new Ke([], this.parseChildren()) } parseQueryParams() { const I = {}; if (this.consumeOptional("?")) do { this.parseQueryParam(I) } while (this.consumeOptional("&")); return I } parseFragment() { return this.consumeOptional("#") ? decodeURIComponent(this.remaining) : null } parseChildren() { if ("" === this.remaining) return {}; this.consumeOptional("/"); const I = []; for (this.peekStartsWith("(") || I.push(this.parseSegment()); this.peekStartsWith("/") && !this.peekStartsWith("//") && !this.peekStartsWith("/(");)this.capture("/"), I.push(this.parseSegment()); let m = {}; this.peekStartsWith("/(") && (this.capture("/"), m = this.parseParens(!0)); let u = {}; return this.peekStartsWith("(") && (u = this.parseParens(!1)), (I.length > 0 || Object.keys(m).length > 0) && (u[it] = new Ke(I, m)), u } parseSegment() { const I = me(this.remaining); if ("" === I && this.peekStartsWith(";")) throw new a.vHH(4009, !1); return this.capture(I), new se(Ln(I), this.parseMatrixParams()) } parseMatrixParams() { const I = {}; for (; this.consumeOptional(";");)this.parseParam(I); return I } parseParam(I) { const m = function st(S) { const I = S.match(de); return I ? I[0] : "" }(this.remaining); if (!m) return; this.capture(m); let u = ""; if (this.consumeOptional("=")) { const h = me(this.remaining); h && (u = h, this.capture(u)) } I[Ln(m)] = Ln(u) } parseQueryParam(I) { const m = function He(S) { const I = S.match(Lt); return I ? I[0] : "" }(this.remaining); if (!m) return; this.capture(m); let u = ""; if (this.consumeOptional("=")) { const M = function z(S) { const I = S.match(ae); return I ? I[0] : "" }(this.remaining); M && (u = M, this.capture(u)) } const h = In(m), x = In(u); if (I.hasOwnProperty(h)) { let M = I[h]; Array.isArray(M) || (M = [M], I[h] = M), M.push(x) } else I[h] = x } parseParens(I) { const m = {}; for (this.capture("("); !this.consumeOptional(")") && this.remaining.length > 0;) { const u = me(this.remaining), h = this.remaining[u.length]; if ("/" !== h && ")" !== h && ";" !== h) throw new a.vHH(4010, !1); let x; u.indexOf(":") > -1 ? (x = u.slice(0, u.indexOf(":")), this.capture(x), this.capture(":")) : I && (x = it); const M = this.parseChildren(); m[x] = 1 === Object.keys(M).length ? M[it] : new Ke([], M), this.consumeOptional("//") } return m } peekStartsWith(I) { return this.remaining.startsWith(I) } consumeOptional(I) { return !!this.peekStartsWith(I) && (this.remaining = this.remaining.substring(I.length), !0) } capture(I) { if (!this.consumeOptional(I)) throw new a.vHH(4011, !1) } } function H(S) { return S.segments.length > 0 ? new Ke([], { [it]: S }) : S } function Ne(S) { const I = {}; for (const u of Object.keys(S.children)) { const x = Ne(S.children[u]); if (u === it && 0 === x.segments.length && x.hasChildren()) for (const [M, $] of Object.entries(x.children)) I[M] = $; else (x.segments.length > 0 || x.hasChildren()) && (I[u] = x) } return function pt(S) { if (1 === S.numberOfChildren && S.children[it]) { const I = S.children[it]; return new Ke(S.segments.concat(I.segments), I.children) } return S }(new Ke(S.segments, I)) } function pe(S) { return S instanceof Fn } function F(S) { let I; const h = H(function m(x) { const M = {}; for (const Ee of x.children) { const je = m(Ee); M[Ee.outlet] = je } const $ = new Ke(x.url, M); return x === S && (I = $), $ }(S.root)); return I ?? h } function J(S, I, m, u) { let h = S; for (; h.parent;)h = h.parent; if (0 === I.length) return gt(h, h, h, m, u); const x = function yt(S) { if ("string" == typeof S[0] && 1 === S.length && "/" === S[0]) return new un(!0, 0, S); let I = 0, m = !1; const u = S.reduce((h, x, M) => { if ("object" == typeof x && null != x) { if (x.outlets) { const $ = {}; return Object.entries(x.outlets).forEach(([Ee, je]) => { $[Ee] = "string" == typeof je ? je.split("/") : je }), [...h, { outlets: $ }] } if (x.segmentPath) return [...h, x.segmentPath] } return "string" != typeof x ? [...h, x] : 0 === M ? (x.split("/").forEach(($, Ee) => { 0 == Ee && "." === $ || (0 == Ee && "" === $ ? m = !0 : ".." === $ ? I++ : "" != $ && h.push($)) }), h) : [...h, x] }, []); return new un(m, I, u) }(I); if (x.toRoot()) return gt(h, h, new Ke([], {}), m, u); const M = function dn(S, I, m) { if (S.isAbsolute) return new It(I, !0, 0); if (!m) return new It(I, !1, NaN); if (null === m.parent) return new It(m, !0, 0); const u = Te(S.commands[0]) ? 0 : 1; return function Pn(S, I, m) { let u = S, h = I, x = m; for (; x > h;) { if (x -= h, u = u.parent, !u) throw new a.vHH(4005, !1); h = u.segments.length } return new It(u, !1, h - x) }(m, m.segments.length - 1 + u, S.numberOfDoubleDots) }(x, h, S), $ = M.processChildren ? si(M.segmentGroup, M.index, x.commands) : ni(M.segmentGroup, M.index, x.commands); return gt(h, M.segmentGroup, $, m, u) } function Te(S) { return "object" == typeof S && null != S && !S.outlets && !S.segmentPath } function lt(S) { return "object" == typeof S && null != S && S.outlets } function gt(S, I, m, u, h) { let M, x = {}; u && Object.entries(u).forEach(([Ee, je]) => { x[Ee] = Array.isArray(je) ? je.map(ft => `${ft}`) : `${je}` }), M = S === I ? m : Ht(S, I, m); const $ = H(Ne(M)); return new Fn($, x, h) } function Ht(S, I, m) { const u = {}; return Object.entries(S.children).forEach(([h, x]) => { u[h] = x === I ? m : Ht(x, I, m) }), new Ke(S.segments, u) } class un { constructor(I, m, u) { if (this.isAbsolute = I, this.numberOfDoubleDots = m, this.commands = u, I && u.length > 0 && Te(u[0])) throw new a.vHH(4003, !1); const h = u.find(lt); if (h && h !== Ae(u)) throw new a.vHH(4004, !1) } toRoot() { return this.isAbsolute && 1 === this.commands.length && "/" == this.commands[0] } } class It { constructor(I, m, u) { this.segmentGroup = I, this.processChildren = m, this.index = u } } function ni(S, I, m) { if (S || (S = new Ke([], {})), 0 === S.segments.length && S.hasChildren()) return si(S, I, m); const u = function Ai(S, I, m) { let u = 0, h = I; const x = { match: !1, pathIndex: 0, commandIndex: 0 }; for (; h < S.segments.length;) { if (u >= m.length) return x; const M = S.segments[h], $ = m[u]; if (lt($)) break; const Ee = `${$}`, je = u < m.length - 1 ? m[u + 1] : null; if (h > 0 && void 0 === Ee) break; if (Ee && je && "object" == typeof je && void 0 === je.outlets) { if (!Io(Ee, je, M)) return x; u += 2 } else { if (!Io(Ee, {}, M)) return x; u++ } h++ } return { match: !0, pathIndex: h, commandIndex: u } }(S, I, m), h = m.slice(u.commandIndex); if (u.match && u.pathIndex < S.segments.length) { const x = new Ke(S.segments.slice(0, u.pathIndex), {}); return x.children[it] = new Ke(S.segments.slice(u.pathIndex), S.children), si(x, 0, h) } return u.match && 0 === h.length ? new Ke(S.segments, {}) : u.match && !S.hasChildren() ? Li(S, I, m) : u.match ? si(S, 0, h) : Li(S, I, m) } function si(S, I, m) { if (0 === m.length) return new Ke(S.segments, {}); { const u = function qn(S) { return lt(S[0]) ? S[0].outlets : { [it]: S } }(m), h = {}; if (!u[it] && S.children[it] && 1 === S.numberOfChildren && 0 === S.children[it].segments.length) { const x = si(S.children[it], I, m); return new Ke(S.segments, x.children) } return Object.entries(u).forEach(([x, M]) => { "string" == typeof M && (M = [M]), null !== M && (h[x] = ni(S.children[x], I, M)) }), Object.entries(S.children).forEach(([x, M]) => { void 0 === u[x] && (h[x] = M) }), new Ke(S.segments, h) } } function Li(S, I, m) { const u = S.segments.slice(0, I); let h = 0; for (; h < m.length;) { const x = m[h]; if (lt(x)) { const Ee = ho(x.outlets); return new Ke(u, Ee) } if (0 === h && Te(m[0])) { u.push(new se(S.segments[I].path, $r(m[0]))), h++; continue } const M = lt(x) ? x.outlets[it] : `${x}`, $ = h < m.length - 1 ? m[h + 1] : null; M && $ && Te($) ? (u.push(new se(M, $r($))), h += 2) : (u.push(new se(M, {})), h++) } return new Ke(u, {}) } function ho(S) { const I = {}; return Object.entries(S).forEach(([m, u]) => { "string" == typeof u && (u = [u]), null !== u && (I[m] = Li(new Ke([], {}), 0, u)) }), I } function $r(S) { const I = {}; return Object.entries(S).forEach(([m, u]) => I[m] = `${u}`), I } function Io(S, I, m) { return S == m.path && St(I, m.parameters) } const zi = "imperative"; class Ti { constructor(I, m) { this.id = I, this.url = m } } class Pr extends Ti { constructor(I, m, u = "imperative", h = null) { super(I, m), this.type = 0, this.navigationTrigger = u, this.restoredState = h } toString() { return `NavigationStart(id: ${this.id}, url: '${this.url}')` } } class Ir extends Ti { constructor(I, m, u) { super(I, m), this.urlAfterRedirects = u, this.type = 1 } toString() { return `NavigationEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}')` } } class bo extends Ti { constructor(I, m, u, h) { super(I, m), this.reason = u, this.code = h, this.type = 2 } toString() { return `NavigationCancel(id: ${this.id}, url: '${this.url}')` } } class Nr extends Ti { constructor(I, m, u, h) { super(I, m), this.reason = u, this.code = h, this.type = 16 } } class Vi extends Ti { constructor(I, m, u, h) { super(I, m), this.error = u, this.target = h, this.type = 3 } toString() { return `NavigationError(id: ${this.id}, url: '${this.url}', error: ${this.error})` } } class cs extends Ti { constructor(I, m, u, h) { super(I, m), this.urlAfterRedirects = u, this.state = h, this.type = 4 } toString() { return `RoutesRecognized(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class fo extends Ti { constructor(I, m, u, h) { super(I, m), this.urlAfterRedirects = u, this.state = h, this.type = 7 } toString() { return `GuardsCheckStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class Jo extends Ti { constructor(I, m, u, h, x) { super(I, m), this.urlAfterRedirects = u, this.state = h, this.shouldActivate = x, this.type = 8 } toString() { return `GuardsCheckEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state}, shouldActivate: ${this.shouldActivate})` } } class sr extends Ti { constructor(I, m, u, h) { super(I, m), this.urlAfterRedirects = u, this.state = h, this.type = 5 } toString() { return `ResolveStart(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class wt extends Ti { constructor(I, m, u, h) { super(I, m), this.urlAfterRedirects = u, this.state = h, this.type = 6 } toString() { return `ResolveEnd(id: ${this.id}, url: '${this.url}', urlAfterRedirects: '${this.urlAfterRedirects}', state: ${this.state})` } } class bt { constructor(I) { this.route = I, this.type = 9 } toString() { return `RouteConfigLoadStart(path: ${this.route.path})` } } class Rt { constructor(I) { this.route = I, this.type = 10 } toString() { return `RouteConfigLoadEnd(path: ${this.route.path})` } } class sn { constructor(I) { this.snapshot = I, this.type = 11 } toString() { return `ChildActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class wn { constructor(I) { this.snapshot = I, this.type = 12 } toString() { return `ChildActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class dt { constructor(I) { this.snapshot = I, this.type = 13 } toString() { return `ActivationStart(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class Be { constructor(I) { this.snapshot = I, this.type = 14 } toString() { return `ActivationEnd(path: '${this.snapshot.routeConfig && this.snapshot.routeConfig.path || ""}')` } } class ye { constructor(I, m, u) { this.routerEvent = I, this.position = m, this.anchor = u, this.type = 15 } toString() { return `Scroll(anchor: '${this.anchor}', position: '${this.position ? `${this.position[0]}, ${this.position[1]}` : null}')` } } class Vt { constructor() { this.outlet = null, this.route = null, this.injector = null, this.children = new At, this.attachRef = null } } let At = (() => { class S { constructor() { this.contexts = new Map } onChildOutletCreated(m, u) { const h = this.getOrCreateContext(m); h.outlet = u, this.contexts.set(m, h) } onChildOutletDestroyed(m) { const u = this.getContext(m); u && (u.outlet = null, u.attachRef = null) } onOutletDeactivated() { const m = this.contexts; return this.contexts = new Map, m } onOutletReAttached(m) { this.contexts = m } getOrCreateContext(m) { let u = this.getContext(m); return u || (u = new Vt, this.contexts.set(m, u)), u } getContext(m) { return this.contexts.get(m) || null } } return S.\u0275fac = function (m) { return new (m || S) }, S.\u0275prov = a.Yz7({ token: S, factory: S.\u0275fac, providedIn: "root" }), S })(); class cn { constructor(I) { this._root = I } get root() { return this._root.value } parent(I) { const m = this.pathFromRoot(I); return m.length > 1 ? m[m.length - 2] : null } children(I) { const m = Tn(I, this._root); return m ? m.children.map(u => u.value) : [] } firstChild(I) { const m = Tn(I, this._root); return m && m.children.length > 0 ? m.children[0].value : null } siblings(I) { const m = ii(I, this._root); return m.length < 2 ? [] : m[m.length - 2].children.map(h => h.value).filter(h => h !== I) } pathFromRoot(I) { return ii(I, this._root).map(m => m.value) } } function Tn(S, I) { if (S === I.value) return I; for (const m of I.children) { const u = Tn(S, m); if (u) return u } return null } function ii(S, I) { if (S === I.value) return [I]; for (const m of I.children) { const u = ii(S, m); if (u.length) return u.unshift(I), u } return [] } class wi { constructor(I, m) { this.value = I, this.children = m } toString() { return `TreeNode(${this.value})` } } function Xi(S) { const I = {}; return S && S.children.forEach(m => I[m.value.outlet] = m), I } class Dr extends cn { constructor(I, m) { super(I), this.snapshot = m, tr(this, I) } toString() { return this.snapshot.toString() } } function xr(S, I) { const m = function Ko(S, I) { const M = new ci([], {}, {}, "", {}, it, I, null, {}); return new ki("", new wi(M, [])) }(0, I), u = new he.X([new se("", {})]), h = new he.X({}), x = new he.X({}), M = new he.X({}), $ = new he.X(""), Ee = new mo(u, h, M, $, x, it, I, m.root); return Ee.snapshot = m.root, new Dr(new wi(Ee, []), m) } class mo { constructor(I, m, u, h, x, M, $, Ee) { this.urlSubject = I, this.paramsSubject = m, this.queryParamsSubject = u, this.fragmentSubject = h, this.dataSubject = x, this.outlet = M, this.component = $, this._futureSnapshot = Ee, this.title = this.dataSubject?.pipe((0, Pe.U)(je => je[Ft])) ?? (0, Y.of)(void 0), this.url = I, this.params = m, this.queryParams = u, this.fragment = h, this.data = x } get routeConfig() { return this._futureSnapshot.routeConfig } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = this.params.pipe((0, Pe.U)(I => rn(I)))), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = this.queryParams.pipe((0, Pe.U)(I => rn(I)))), this._queryParamMap } toString() { return this.snapshot ? this.snapshot.toString() : `Future(${this._futureSnapshot})` } } function _i(S, I = "emptyOnly") { const m = S.pathFromRoot; let u = 0; if ("always" !== I) for (u = m.length - 1; u >= 1;) { const h = m[u], x = m[u - 1]; if (h.routeConfig && "" === h.routeConfig.path) u--; else { if (x.component) break; u-- } } return function Sn(S) { return S.reduce((I, m) => ({ params: { ...I.params, ...m.params }, data: { ...I.data, ...m.data }, resolve: { ...m.data, ...I.resolve, ...m.routeConfig?.data, ...m._resolvedData } }), { params: {}, data: {}, resolve: {} }) }(m.slice(u)) } class ci { get title() { return this.data?.[Ft] } constructor(I, m, u, h, x, M, $, Ee, je) { this.url = I, this.params = m, this.queryParams = u, this.fragment = h, this.data = x, this.outlet = M, this.component = $, this.routeConfig = Ee, this._resolve = je } get root() { return this._routerState.root } get parent() { return this._routerState.parent(this) } get firstChild() { return this._routerState.firstChild(this) } get children() { return this._routerState.children(this) } get pathFromRoot() { return this._routerState.pathFromRoot(this) } get paramMap() { return this._paramMap || (this._paramMap = rn(this.params)), this._paramMap } get queryParamMap() { return this._queryParamMap || (this._queryParamMap = rn(this.queryParams)), this._queryParamMap } toString() { return `Route(url:'${this.url.map(u => u.toString()).join("/")}', path:'${this.routeConfig ? this.routeConfig.path : ""}')` } } class ki extends cn { constructor(I, m) { super(m), this.url = I, tr(this, m) } toString() { return Lr(this._root) } } function tr(S, I) { I.value._routerState = S, I.children.forEach(m => tr(S, m)) } function Lr(S) { const I = S.children.length > 0 ? ` { ${S.children.map(Lr).join(", ")} } ` : ""; return `${S.value}${I}` } function nr(S) { if (S.snapshot) { const I = S.snapshot, m = S._futureSnapshot; S.snapshot = m, St(I.queryParams, m.queryParams) || S.queryParamsSubject.next(m.queryParams), I.fragment !== m.fragment && S.fragmentSubject.next(m.fragment), St(I.params, m.params) || S.paramsSubject.next(m.params), function tn(S, I) { if (S.length !== I.length) return !1; for (let m = 0; m < S.length; ++m)if (!St(S[m], I[m])) return !1; return !0 }(I.url, m.url) || S.urlSubject.next(m.url), St(I.data, m.data) || S.dataSubject.next(m.data) } else S.snapshot = S._futureSnapshot, S.dataSubject.next(S._futureSnapshot.data) } function io(S, I) { const m = St(S.params, I.params) && function Me(S, I) { return Xe(S, I) && S.every((m, u) => St(m.parameters, I[u].parameters)) }(S.url, I.url); return m && !(!S.parent != !I.parent) && (!S.parent || io(S.parent, I.parent)) } let di = (() => { class S { constructor() { this.activated = null, this._activatedRoute = null, this.name = it, this.activateEvents = new a.vpe, this.deactivateEvents = new a.vpe, this.attachEvents = new a.vpe, this.detachEvents = new a.vpe, this.parentContexts = (0, a.f3M)(At), this.location = (0, a.f3M)(a.s_b), this.changeDetector = (0, a.f3M)(a.sBO), this.environmentInjector = (0, a.f3M)(a.lqb), this.inputBinder = (0, a.f3M)(ro, { optional: !0 }), this.supportsBindingToComponentInputs = !0 } get activatedComponentRef() { return this.activated } ngOnChanges(m) { if (m.name) { const { firstChange: u, previousValue: h } = m.name; if (u) return; this.isTrackedInParentContexts(h) && (this.deactivate(), this.parentContexts.onChildOutletDestroyed(h)), this.initializeOutletWithName() } } ngOnDestroy() { this.isTrackedInParentContexts(this.name) && this.parentContexts.onChildOutletDestroyed(this.name), this.inputBinder?.unsubscribeFromRouteData(this) } isTrackedInParentContexts(m) { return this.parentContexts.getContext(m)?.outlet === this } ngOnInit() { this.initializeOutletWithName() } initializeOutletWithName() { if (this.parentContexts.onChildOutletCreated(this.name, this), this.activated) return; const m = this.parentContexts.getContext(this.name); m?.route && (m.attachRef ? this.attach(m.attachRef, m.route) : this.activateWith(m.route, m.injector)) } get isActivated() { return !!this.activated } get component() { if (!this.activated) throw new a.vHH(4012, !1); return this.activated.instance } get activatedRoute() { if (!this.activated) throw new a.vHH(4012, !1); return this._activatedRoute } get activatedRouteData() { return this._activatedRoute ? this._activatedRoute.snapshot.data : {} } detach() { if (!this.activated) throw new a.vHH(4012, !1); this.location.detach(); const m = this.activated; return this.activated = null, this._activatedRoute = null, this.detachEvents.emit(m.instance), m } attach(m, u) { this.activated = m, this._activatedRoute = u, this.location.insert(m.hostView), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.attachEvents.emit(m.instance) } deactivate() { if (this.activated) { const m = this.component; this.activated.destroy(), this.activated = null, this._activatedRoute = null, this.deactivateEvents.emit(m) } } activateWith(m, u) { if (this.isActivated) throw new a.vHH(4013, !1); this._activatedRoute = m; const h = this.location, M = m.snapshot.component, $ = this.parentContexts.getOrCreateContext(this.name).children, Ee = new qr(m, $, h.injector); this.activated = h.createComponent(M, { index: h.length, injector: Ee, environmentInjector: u ?? this.environmentInjector }), this.changeDetector.markForCheck(), this.inputBinder?.bindActivatedRouteToOutletComponent(this), this.activateEvents.emit(this.activated.instance) } } return S.\u0275fac = function (m) { return new (m || S) }, S.\u0275dir = a.lG2({ type: S, selectors: [["router-outlet"]], inputs: { name: "name" }, outputs: { activateEvents: "activate", deactivateEvents: "deactivate", attachEvents: "attach", detachEvents: "detach" }, exportAs: ["outlet"], standalone: !0, features: [a.TTD] }), S })(); class qr { constructor(I, m, u) { this.route = I, this.childContexts = m, this.parent = u } get(I, m) { return I === mo ? this.route : I === At ? this.childContexts : this.parent.get(I, m) } } const ro = new a.OlP(""); let Xn = (() => { class S { constructor() { this.outletDataSubscriptions = new Map } bindActivatedRouteToOutletComponent(m) { this.unsubscribeFromRouteData(m), this.subscribeToRouteData(m) } unsubscribeFromRouteData(m) { this.outletDataSubscriptions.get(m)?.unsubscribe(), this.outletDataSubscriptions.delete(m) } subscribeToRouteData(m) { const { activatedRoute: u } = m, h = (0, Se.a)([u.queryParams, u.params, u.data]).pipe((0, Ve.w)(([x, M, $], Ee) => ($ = { ...x, ...M, ...$ }, 0 === Ee ? (0, Y.of)($) : Promise.resolve($)))).subscribe(x => { if (!m.isActivated || !m.activatedComponentRef || m.activatedRoute !== u || null === u.component) return void this.unsubscribeFromRouteData(m); const M = (0, a.qFp)(u.component); if (M) for (const { templateName: $ } of M.inputs) m.activatedComponentRef.setInput($, x[$]); else this.unsubscribeFromRouteData(m) }); this.outletDataSubscriptions.set(m, h) } } return S.\u0275fac = function (m) { return new (m || S) }, S.\u0275prov = a.Yz7({ token: S, factory: S.\u0275fac }), S })(); function Ao(S, I, m) { if (m && S.shouldReuseRoute(I.value, m.value.snapshot)) { const u = m.value; u._futureSnapshot = I.value; const h = function ko(S, I, m) { return I.children.map(u => { for (const h of m.children) if (S.shouldReuseRoute(u.value, h.value.snapshot)) return Ao(S, u, h); return Ao(S, u) }) }(S, I, m); return new wi(u, h) } { if (S.shouldAttach(I.value)) { const x = S.retrieve(I.value); if (null !== x) { const M = x.route; return M.value._futureSnapshot = I.value, M.children = I.children.map($ => Ao(S, $)), M } } const u = function cr(S) { return new mo(new he.X(S.url), new he.X(S.params), new he.X(S.queryParams), new he.X(S.fragment), new he.X(S.data), S.outlet, S.component, S) }(I.value), h = I.children.map(x => Ao(S, x)); return new wi(u, h) } } const Zo = "ngNavigationCancelingError"; function ds(S, I) { const { redirectTo: m, navigationBehaviorOptions: u } = pe(I) ? { redirectTo: I, navigationBehaviorOptions: void 0 } : I, h = oo(!1, 0, I); return h.url = m, h.navigationBehaviorOptions = u, h } function oo(S, I, m) { const u = new Error("NavigationCancelingError: " + (S || "")); return u[Zo] = !0, u.cancellationCode = I, m && (u.url = m), u } function Qr(S) { return es(S) && pe(S.url) } function es(S) { return S && S[Zo] } let Tr = (() => { class S { } return S.\u0275fac = function (m) { return new (m || S) }, S.\u0275cmp = a.Xpm({ type: S, selectors: [["ng-component"]], standalone: !0, features: [a.jDz], decls: 1, vars: 0, template: function (m, u) { 1 & m && a._UZ(0, "router-outlet") }, dependencies: [di], encapsulation: 2 }), S })(); function Qo(S) { const I = S.children && S.children.map(Qo), m = I ? { ...S, children: I } : { ...S }; return !m.component && !m.loadComponent && (I || m.loadChildren) && m.outlet && m.outlet !== it && (m.component = Tr), m } function br(S) { return S.outlet || it } function po(S) { if (!S) return null; if (S.routeConfig?._injector) return S.routeConfig._injector; for (let I = S.parent; I; I = I.parent) { const m = I.routeConfig; if (m?._loadedInjector) return m._loadedInjector; if (m?._injector) return m._injector } return null } class us { constructor(I, m, u, h, x) { this.routeReuseStrategy = I, this.futureState = m, this.currState = u, this.forwardEvent = h, this.inputBindingEnabled = x } activate(I) { const m = this.futureState._root, u = this.currState ? this.currState._root : null; this.deactivateChildRoutes(m, u, I), nr(this.futureState.root), this.activateChildRoutes(m, u, I) } deactivateChildRoutes(I, m, u) { const h = Xi(m); I.children.forEach(x => { const M = x.value.outlet; this.deactivateRoutes(x, h[M], u), delete h[M] }), Object.values(h).forEach(x => { this.deactivateRouteAndItsChildren(x, u) }) } deactivateRoutes(I, m, u) { const h = I.value, x = m ? m.value : null; if (h === x) if (h.component) { const M = u.getContext(h.outlet); M && this.deactivateChildRoutes(I, m, M.children) } else this.deactivateChildRoutes(I, m, u); else x && this.deactivateRouteAndItsChildren(m, u) } deactivateRouteAndItsChildren(I, m) { I.value.component && this.routeReuseStrategy.shouldDetach(I.value.snapshot) ? this.detachAndStoreRouteSubtree(I, m) : this.deactivateRouteAndOutlet(I, m) } detachAndStoreRouteSubtree(I, m) { const u = m.getContext(I.value.outlet), h = u && I.value.component ? u.children : m, x = Xi(I); for (const M of Object.keys(x)) this.deactivateRouteAndItsChildren(x[M], h); if (u && u.outlet) { const M = u.outlet.detach(), $ = u.children.onOutletDeactivated(); this.routeReuseStrategy.store(I.value.snapshot, { componentRef: M, route: I, contexts: $ }) } } deactivateRouteAndOutlet(I, m) { const u = m.getContext(I.value.outlet), h = u && I.value.component ? u.children : m, x = Xi(I); for (const M of Object.keys(x)) this.deactivateRouteAndItsChildren(x[M], h); u && (u.outlet && (u.outlet.deactivate(), u.children.onOutletDeactivated()), u.attachRef = null, u.route = null) } activateChildRoutes(I, m, u) { const h = Xi(m); I.children.forEach(x => { this.activateRoutes(x, h[x.value.outlet], u), this.forwardEvent(new Be(x.value.snapshot)) }), I.children.length && this.forwardEvent(new wn(I.value.snapshot)) } activateRoutes(I, m, u) { const h = I.value, x = m ? m.value : null; if (nr(h), h === x) if (h.component) { const M = u.getOrCreateContext(h.outlet); this.activateChildRoutes(I, m, M.children) } else this.activateChildRoutes(I, m, u); else if (h.component) { const M = u.getOrCreateContext(h.outlet); if (this.routeReuseStrategy.shouldAttach(h.snapshot)) { const $ = this.routeReuseStrategy.retrieve(h.snapshot); this.routeReuseStrategy.store(h.snapshot, null), M.children.onOutletReAttached($.contexts), M.attachRef = $.componentRef, M.route = $.route.value, M.outlet && M.outlet.attach($.componentRef, $.route.value), nr($.route.value), this.activateChildRoutes(I, null, M.children) } else { const $ = po(h.snapshot); M.attachRef = null, M.route = h, M.injector = $, M.outlet && M.outlet.activateWith(h, M.injector), this.activateChildRoutes(I, null, M.children) } } else this.activateChildRoutes(I, null, u) } } class dr { constructor(I) { this.path = I, this.route = this.path[this.path.length - 1] } } class Wr { constructor(I, m) { this.component = I, this.route = m } } function Ni(S, I, m) { const u = S._root; return Xr(u, I ? I._root : null, m, [u.value]) } function ao(S, I) { const m = Symbol(), u = I.get(S, m); return u === m ? "function" != typeof S || (0, a.Z0I)(S) ? I.get(S) : S : u } function Xr(S, I, m, u, h = { canDeactivateChecks: [], canActivateChecks: [] }) { const x = Xi(I); return S.children.forEach(M => { (function bs(S, I, m, u, h = { canDeactivateChecks: [], canActivateChecks: [] }) { const x = S.value, M = I ? I.value : null, $ = m ? m.getContext(S.value.outlet) : null; if (M && x.routeConfig === M.routeConfig) { const Ee = function ta(S, I, m) { if ("function" == typeof m) return m(S, I); switch (m) { case "pathParamsChange": return !Xe(S.url, I.url); case "pathParamsOrQueryParamsChange": return !Xe(S.url, I.url) || !St(S.queryParams, I.queryParams); case "always": return !0; case "paramsOrQueryParamsChange": return !io(S, I) || !St(S.queryParams, I.queryParams); default: return !io(S, I) } }(M, x, x.routeConfig.runGuardsAndResolvers); Ee ? h.canActivateChecks.push(new dr(u)) : (x.data = M.data, x._resolvedData = M._resolvedData), Xr(S, I, x.component ? $ ? $.children : null : m, u, h), Ee && $ && $.outlet && $.outlet.isActivated && h.canDeactivateChecks.push(new Wr($.outlet.component, M)) } else M && Ci(I, $, h), h.canActivateChecks.push(new dr(u)), Xr(S, null, x.component ? $ ? $.children : null : m, u, h) })(M, x[M.value.outlet], m, u.concat([M.value]), h), delete x[M.value.outlet] }), Object.entries(x).forEach(([M, $]) => Ci($, m.getContext(M), h)), h } function Ci(S, I, m) { const u = Xi(S), h = S.value; Object.entries(u).forEach(([x, M]) => { Ci(M, h.component ? I ? I.children.getContext(x) : null : I, m) }), m.canDeactivateChecks.push(new Wr(h.component && I && I.outlet && I.outlet.isActivated ? I.outlet.component : null, h)) } function ys(S) { return "function" == typeof S } function jo(S) { return S instanceof ke.K || "EmptyError" === S?.name } const K = Symbol("INITIAL_VALUE"); function V() { return (0, Ve.w)(S => (0, Se.a)(S.map(I => I.pipe((0, tt.q)(1), (0, Ye.O)(K)))).pipe((0, Pe.U)(I => { for (const m of I) if (!0 !== m) { if (m === K) return K; if (!1 === m || m instanceof Fn) return m } return !0 }), (0, ut.h)(I => I !== K), (0, tt.q)(1))) } function gi(S) { return (0, Q.z)((0, ge.b)(I => { if (pe(I)) throw ds(0, I) }), (0, Pe.U)(I => !0 === I)) } class Zi { constructor(I) { this.segmentGroup = I || null } } class ji { constructor(I) { this.urlTree = I } } function Bi(S) { return (0, _e._)(new Zi(S)) } function ir(S) { return (0, _e._)(new ji(S)) } class Yi { constructor(I, m) { this.urlSerializer = I, this.urlTree = m } noMatchError(I) { return new a.vHH(4002, !1) } lineralizeSegments(I, m) { let u = [], h = m.root; for (; ;) { if (u = u.concat(h.segments), 0 === h.numberOfChildren) return (0, Y.of)(u); if (h.numberOfChildren > 1 || !h.children[it]) return (0, _e._)(new a.vHH(4e3, !1)); h = h.children[it] } } applyRedirectCommands(I, m, u) { return this.applyRedirectCreateUrlTree(m, this.urlSerializer.parse(m), I, u) } applyRedirectCreateUrlTree(I, m, u, h) { const x = this.createSegmentGroup(I, m.root, u, h); return new Fn(x, this.createQueryParams(m.queryParams, this.urlTree.queryParams), m.fragment) } createQueryParams(I, m) { const u = {}; return Object.entries(I).forEach(([h, x]) => { if ("string" == typeof x && x.startsWith(":")) { const $ = x.substring(1); u[h] = m[$] } else u[h] = x }), u } createSegmentGroup(I, m, u, h) { const x = this.createSegments(I, m.segments, u, h); let M = {}; return Object.entries(m.children).forEach(([$, Ee]) => { M[$] = this.createSegmentGroup(I, Ee, u, h) }), new Ke(x, M) } createSegments(I, m, u, h) { return m.map(x => x.path.startsWith(":") ? this.findPosParam(I, x, h) : this.findOrReturn(x, u)) } findPosParam(I, m, u) { const h = u[m.path.substring(1)]; if (!h) throw new a.vHH(4001, !1); return h } findOrReturn(I, m) { let u = 0; for (const h of m) { if (h.path === I.path) return m.splice(u), h; u++ } return I } } const Kr = { matched: !1, consumedSegments: [], remainingSegments: [], parameters: {}, positionalParamSegments: {} }; function Mr(S, I, m, u, h) { const x = Sr(S, I, m); return x.matched ? (u = function Br(S, I) { return S.providers && !S._injector && (S._injector = (0, a.MMx)(S.providers, I, `Route: ${S.path}`)), S._injector ?? I }(I, u), function Ii(S, I, m, u) { const h = I.canMatch; if (!h || 0 === h.length) return (0, Y.of)(!0); const x = h.map(M => { const $ = ao(M, S); return nt(function ws(S) { return S && ys(S.canMatch) }($) ? $.canMatch(I, m) : S.runInContext(() => $(I, m))) }); return (0, Y.of)(x).pipe(V(), gi()) }(u, I, m).pipe((0, Pe.U)(M => !0 === M ? x : { ...Kr }))) : (0, Y.of)(x) } function Sr(S, I, m) { if ("" === I.path) return "full" === I.pathMatch && (S.hasChildren() || m.length > 0) ? { ...Kr } : { matched: !0, consumedSegments: [], remainingSegments: m, parameters: {}, positionalParamSegments: {} }; const h = (I.matcher || Jt)(m, S, I); if (!h) return { ...Kr }; const x = {}; Object.entries(h.posParams ?? {}).forEach(([$, Ee]) => { x[$] = Ee.path }); const M = h.consumed.length > 0 ? { ...x, ...h.consumed[h.consumed.length - 1].parameters } : x; return { matched: !0, consumedSegments: h.consumed, remainingSegments: m.slice(h.consumed.length), parameters: M, positionalParamSegments: h.posParams ?? {} } } function Do(S, I, m, u) { return m.length > 0 && function rs(S, I, m) { return m.some(u => os(S, I, u) && br(u) !== it) }(S, m, u) ? { segmentGroup: new Ke(I, hs(u, new Ke(m, S.children))), slicedSegments: [] } : 0 === m.length && function Jr(S, I, m) { return m.some(u => os(S, I, u)) }(S, m, u) ? { segmentGroup: new Ke(S.segments, $o(S, 0, m, u, S.children)), slicedSegments: m } : { segmentGroup: new Ke(S.segments, S.children), slicedSegments: m } } function $o(S, I, m, u, h) { const x = {}; for (const M of u) if (os(S, m, M) && !h[br(M)]) { const $ = new Ke([], {}); x[br(M)] = $ } return { ...h, ...x } } function hs(S, I) { const m = {}; m[it] = I; for (const u of S) if ("" === u.path && br(u) !== it) { const h = new Ke([], {}); m[br(u)] = h } return m } function os(S, I, m) { return (!(S.hasChildren() || I.length > 0) || "full" !== m.pathMatch) && "" === m.path } class fs { constructor(I, m, u, h, x, M, $) { this.injector = I, this.configLoader = m, this.rootComponentType = u, this.config = h, this.urlTree = x, this.paramsInheritanceStrategy = M, this.urlSerializer = $, this.allowRedirects = !0, this.applyRedirects = new Yi(this.urlSerializer, this.urlTree) } noMatchError(I) { return new a.vHH(4002, !1) } recognize() { const I = Do(this.urlTree.root, [], [], this.config).segmentGroup; return this.processSegmentGroup(this.injector, this.config, I, it).pipe((0, ue.K)(m => { if (m instanceof ji) return this.allowRedirects = !1, this.urlTree = m.urlTree, this.match(m.urlTree); throw m instanceof Zi ? this.noMatchError(m) : m }), (0, Pe.U)(m => { const u = new ci([], Object.freeze({}), Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, {}, it, this.rootComponentType, null, {}), h = new wi(u, m), x = new ki("", h), M = function fe(S, I, m = null, u = null) { return J(F(S), I, m, u) }(u, [], this.urlTree.queryParams, this.urlTree.fragment); return M.queryParams = this.urlTree.queryParams, x.url = this.urlSerializer.serialize(M), this.inheritParamsAndData(x._root), { state: x, tree: M } })) } match(I) { return this.processSegmentGroup(this.injector, this.config, I.root, it).pipe((0, ue.K)(u => { throw u instanceof Zi ? this.noMatchError(u) : u })) } inheritParamsAndData(I) { const m = I.value, u = _i(m, this.paramsInheritanceStrategy); m.params = Object.freeze(u.params), m.data = Object.freeze(u.data), I.children.forEach(h => this.inheritParamsAndData(h)) } processSegmentGroup(I, m, u, h) { return 0 === u.segments.length && u.hasChildren() ? this.processChildren(I, m, u) : this.processSegment(I, m, u, u.segments, h, !0) } processChildren(I, m, u) { const h = []; for (const x of Object.keys(u.children)) "primary" === x ? h.unshift(x) : h.push(x); return (0, v.D)(h).pipe((0, le.b)(x => { const M = u.children[x], $ = function Ki(S, I) { const m = S.filter(u => br(u) === I); return m.push(...S.filter(u => br(u) !== I)), m }(m, x); return this.processSegmentGroup(I, $, M, x) }), (0, ee.R)((x, M) => (x.push(...M), x)), (0, $e.d)(null), function On(S, I) { const m = arguments.length >= 2; return u => u.pipe(S ? (0, ut.h)((h, x) => S(h, x, u)) : Mn.y, bn(1), m ? (0, $e.d)(I) : (0, Dn.T)(() => new ke.K)) }(), (0, ie.z)(x => { if (null === x) return Bi(u); const M = ma(x); return function Za(S) { S.sort((I, m) => I.value.outlet === it ? -1 : m.value.outlet === it ? 1 : I.value.outlet.localeCompare(m.value.outlet)) }(M), (0, Y.of)(M) })) } processSegment(I, m, u, h, x, M) { return (0, v.D)(m).pipe((0, le.b)($ => this.processSegmentAgainstRoute($._injector ?? I, m, $, u, h, x, M).pipe((0, ue.K)(Ee => { if (Ee instanceof Zi) return (0, Y.of)(null); throw Ee }))), (0, Le.P)($ => !!$), (0, ue.K)($ => { if (jo($)) return function ks(S, I, m) { return 0 === I.length && !S.children[m] }(u, h, x) ? (0, Y.of)([]) : Bi(u); throw $ })) } processSegmentAgainstRoute(I, m, u, h, x, M, $) { return function Ka(S, I, m, u) { return !!(br(S) === u || u !== it && os(I, m, S)) && ("**" === S.path || Sr(I, S, m).matched) }(u, h, x, M) ? void 0 === u.redirectTo ? this.matchSegmentAgainstRoute(I, h, u, x, M, $) : $ && this.allowRedirects ? this.expandSegmentAgainstRouteUsingRedirect(I, h, m, u, x, M) : Bi(h) : Bi(h) } expandSegmentAgainstRouteUsingRedirect(I, m, u, h, x, M) { return "**" === h.path ? this.expandWildCardWithParamsAgainstRouteUsingRedirect(I, u, h, M) : this.expandRegularSegmentAgainstRouteUsingRedirect(I, m, u, h, x, M) } expandWildCardWithParamsAgainstRouteUsingRedirect(I, m, u, h) { const x = this.applyRedirects.applyRedirectCommands([], u.redirectTo, {}); return u.redirectTo.startsWith("/") ? ir(x) : this.applyRedirects.lineralizeSegments(u, x).pipe((0, ie.z)(M => { const $ = new Ke(M, {}); return this.processSegment(I, m, $, M, h, !1) })) } expandRegularSegmentAgainstRouteUsingRedirect(I, m, u, h, x, M) { const { matched: $, consumedSegments: Ee, remainingSegments: je, positionalParamSegments: ft } = Sr(m, h, x); if (!$) return Bi(m); const zt = this.applyRedirects.applyRedirectCommands(Ee, h.redirectTo, ft); return h.redirectTo.startsWith("/") ? ir(zt) : this.applyRedirects.lineralizeSegments(h, zt).pipe((0, ie.z)(xn => this.processSegment(I, u, m, xn.concat(je), M, !1))) } matchSegmentAgainstRoute(I, m, u, h, x, M) { let $; if ("**" === u.path) { const Ee = h.length > 0 ? Ae(h).parameters : {}, je = new ci(h, Ee, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, To(u), br(u), u.component ?? u._loadedComponent ?? null, u, pa(u)); $ = (0, Y.of)({ snapshot: je, consumedSegments: [], remainingSegments: [] }), m.children = {} } else $ = Mr(m, u, h, I).pipe((0, Pe.U)(({ matched: Ee, consumedSegments: je, remainingSegments: ft, parameters: zt }) => Ee ? { snapshot: new ci(je, zt, Object.freeze({ ...this.urlTree.queryParams }), this.urlTree.fragment, To(u), br(u), u.component ?? u._loadedComponent ?? null, u, pa(u)), consumedSegments: je, remainingSegments: ft } : null)); return $.pipe((0, Ve.w)(Ee => null === Ee ? Bi(m) : this.getChildConfig(I = u._injector ?? I, u, h).pipe((0, Ve.w)(({ routes: je }) => { const ft = u._loadedInjector ?? I, { snapshot: zt, consumedSegments: xn, remainingSegments: An } = Ee, { segmentGroup: ri, slicedSegments: hi } = Do(m, xn, An, je); if (0 === hi.length && ri.hasChildren()) return this.processChildren(ft, je, ri).pipe((0, Pe.U)(ei => null === ei ? null : [new wi(zt, ei)])); if (0 === je.length && 0 === hi.length) return (0, Y.of)([new wi(zt, [])]); const fi = br(u) === x; return this.processSegment(ft, je, ri, hi, fi ? it : x, !0).pipe((0, Pe.U)(ei => [new wi(zt, ei)])) })))) } getChildConfig(I, m, u) { return m.children ? (0, Y.of)({ routes: m.children, injector: I }) : m.loadChildren ? void 0 !== m._loadedRoutes ? (0, Y.of)({ routes: m._loadedRoutes, injector: m._loadedInjector }) : function jn(S, I, m, u) { const h = I.canLoad; if (void 0 === h || 0 === h.length) return (0, Y.of)(!0); const x = h.map(M => { const $ = ao(M, S); return nt(function Ws(S) { return S && ys(S.canLoad) }($) ? $.canLoad(I, m) : S.runInContext(() => $(I, m))) }); return (0, Y.of)(x).pipe(V(), gi()) }(I, m, u).pipe((0, ie.z)(h => h ? this.configLoader.loadChildren(I, m).pipe((0, ge.b)(x => { m._loadedRoutes = x.routes, m._loadedInjector = x.injector })) : function gr(S) { return (0, _e._)(oo(!1, 3)) }())) : (0, Y.of)({ routes: [], injector: I }) } } function _r(S) { const I = S.value.routeConfig; return I && "" === I.path } function ma(S) { const I = [], m = new Set; for (const u of S) { if (!_r(u)) { I.push(u); continue } const h = I.find(x => u.value.routeConfig === x.value.routeConfig); void 0 !== h ? (h.children.push(...u.children), m.add(h)) : I.push(u) } for (const u of m) { const h = ma(u.children); I.push(new wi(u.value, h)) } return I.filter(u => !m.has(u)) } function To(S) { return S.data || {} } function pa(S) { return S.resolve || {} } function lo(S) { return "string" == typeof S.title || null === S.title } function Rs(S) { return (0, Ve.w)(I => { const m = S(I); return m ? (0, v.D)(m).pipe((0, Pe.U)(() => I)) : (0, Y.of)(I) }) } const go = new a.OlP("ROUTES"); let Os = (() => { class S { constructor() { this.componentLoaders = new WeakMap, this.childrenLoaders = new WeakMap, this.compiler = (0, a.f3M)(a.Sil) } loadComponent(m) { if (this.componentLoaders.get(m)) return this.componentLoaders.get(m); if (m._loadedComponent) return (0, Y.of)(m._loadedComponent); this.onLoadStartListener && this.onLoadStartListener(m); const u = nt(m.loadComponent()).pipe((0, Pe.U)(yr), (0, ge.b)(x => { this.onLoadEndListener && this.onLoadEndListener(m), m._loadedComponent = x }), (0, Hn.x)(() => { this.componentLoaders.delete(m) })), h = new ze.c(u, () => new Oe.x).pipe((0, at.x)()); return this.componentLoaders.set(m, h), h } loadChildren(m, u) { if (this.childrenLoaders.get(u)) return this.childrenLoaders.get(u); if (u._loadedRoutes) return (0, Y.of)({ routes: u._loadedRoutes, injector: u._loadedInjector }); this.onLoadStartListener && this.onLoadStartListener(u); const x = this.loadModuleFactoryOrRoutes(u.loadChildren).pipe((0, Pe.U)($ => { this.onLoadEndListener && this.onLoadEndListener(u); let Ee, je; return Array.isArray($) ? je = $ : (Ee = $.create(m).injector, je = Ee.get(go, [], a.XFs.Self | a.XFs.Optional).flat()), { routes: je.map(Qo), injector: Ee } }), (0, Hn.x)(() => { this.childrenLoaders.delete(u) })), M = new ze.c(x, () => new Oe.x).pipe((0, at.x)()); return this.childrenLoaders.set(u, M), M } loadModuleFactoryOrRoutes(m) { return nt(m()).pipe((0, Pe.U)(yr), (0, ie.z)(u => u instanceof a.YKP || Array.isArray(u) ? (0, Y.of)(u) : (0, v.D)(this.compiler.compileModuleAsync(u)))) } } return S.\u0275fac = function (m) { return new (m || S) }, S.\u0275prov = a.Yz7({ token: S, factory: S.\u0275fac, providedIn: "root" }), S })(); function yr(S) { return function xs(S) { return S && "object" == typeof S && "default" in S }(S) ? S.default : S } let Oo = (() => { class S { get hasRequestedNavigation() { return 0 !== this.navigationId } constructor() { this.currentNavigation = null, this.lastSuccessfulNavigation = null, this.events = new Oe.x, this.configLoader = (0, a.f3M)(Os), this.environmentInjector = (0, a.f3M)(a.lqb), this.urlSerializer = (0, a.f3M)(ve), this.rootContexts = (0, a.f3M)(At), this.inputBindingEnabled = null !== (0, a.f3M)(ro, { optional: !0 }), this.navigationId = 0, this.afterPreactivation = () => (0, Y.of)(void 0), this.rootComponentType = null, this.configLoader.onLoadEndListener = h => this.events.next(new Rt(h)), this.configLoader.onLoadStartListener = h => this.events.next(new bt(h)) } complete() { this.transitions?.complete() } handleNavigationRequest(m) { const u = ++this.navigationId; this.transitions?.next({ ...this.transitions.value, ...m, id: u }) } setupNavigations(m) { return this.transitions = new he.X({ id: 0, currentUrlTree: m.currentUrlTree, currentRawUrl: m.currentUrlTree, extractedUrl: m.urlHandlingStrategy.extract(m.currentUrlTree), urlAfterRedirects: m.urlHandlingStrategy.extract(m.currentUrlTree), rawUrl: m.currentUrlTree, extras: {}, resolve: null, reject: null, promise: Promise.resolve(!0), source: zi, restoredState: null, currentSnapshot: m.routerState.snapshot, targetSnapshot: null, currentRouterState: m.routerState, targetRouterState: null, guards: { canActivateChecks: [], canDeactivateChecks: [] }, guardsResult: null }), this.transitions.pipe((0, ut.h)(u => 0 !== u.id), (0, Pe.U)(u => ({ ...u, extractedUrl: m.urlHandlingStrategy.extract(u.rawUrl) })), (0, Ve.w)(u => { let h = !1, x = !1; return (0, Y.of)(u).pipe((0, ge.b)(M => { this.currentNavigation = { id: M.id, initialUrl: M.rawUrl, extractedUrl: M.extractedUrl, trigger: M.source, extras: M.extras, previousNavigation: this.lastSuccessfulNavigation ? { ...this.lastSuccessfulNavigation, previousNavigation: null } : null } }), (0, Ve.w)(M => { const $ = m.browserUrlTree.toString(), Ee = !m.navigated || M.extractedUrl.toString() !== $ || $ !== m.currentUrlTree.toString(); if (!Ee && "reload" !== (M.extras.onSameUrlNavigation ?? m.onSameUrlNavigation)) { const ft = ""; return this.events.next(new Nr(M.id, m.serializeUrl(u.rawUrl), ft, 0)), m.rawUrlTree = M.rawUrl, M.resolve(null), xe.E } if (m.urlHandlingStrategy.shouldProcessUrl(M.rawUrl)) return P(M.source) && (m.browserUrlTree = M.extractedUrl), (0, Y.of)(M).pipe((0, Ve.w)(ft => { const zt = this.transitions?.getValue(); return this.events.next(new Pr(ft.id, this.urlSerializer.serialize(ft.extractedUrl), ft.source, ft.restoredState)), zt !== this.transitions?.getValue() ? xe.E : Promise.resolve(ft) }), function ia(S, I, m, u, h, x) { return (0, ie.z)(M => function sl(S, I, m, u, h, x, M = "emptyOnly") { return new fs(S, I, m, u, h, M, x).recognize() }(S, I, m, u, M.extractedUrl, h, x).pipe((0, Pe.U)(({ state: $, tree: Ee }) => ({ ...M, targetSnapshot: $, urlAfterRedirects: Ee })))) }(this.environmentInjector, this.configLoader, this.rootComponentType, m.config, this.urlSerializer, m.paramsInheritanceStrategy), (0, ge.b)(ft => { if (u.targetSnapshot = ft.targetSnapshot, u.urlAfterRedirects = ft.urlAfterRedirects, this.currentNavigation = { ...this.currentNavigation, finalUrl: ft.urlAfterRedirects }, "eager" === m.urlUpdateStrategy) { if (!ft.extras.skipLocationChange) { const xn = m.urlHandlingStrategy.merge(ft.urlAfterRedirects, ft.rawUrl); m.setBrowserUrl(xn, ft) } m.browserUrlTree = ft.urlAfterRedirects } const zt = new cs(ft.id, this.urlSerializer.serialize(ft.extractedUrl), this.urlSerializer.serialize(ft.urlAfterRedirects), ft.targetSnapshot); this.events.next(zt) })); if (Ee && m.urlHandlingStrategy.shouldProcessUrl(m.rawUrlTree)) { const { id: ft, extractedUrl: zt, source: xn, restoredState: An, extras: ri } = M, hi = new Pr(ft, this.urlSerializer.serialize(zt), xn, An); this.events.next(hi); const fi = xr(0, this.rootComponentType).snapshot; return u = { ...M, targetSnapshot: fi, urlAfterRedirects: zt, extras: { ...ri, skipLocationChange: !1, replaceUrl: !1 } }, (0, Y.of)(u) } { const ft = ""; return this.events.next(new Nr(M.id, m.serializeUrl(u.extractedUrl), ft, 1)), m.rawUrlTree = M.rawUrl, M.resolve(null), xe.E } }), (0, ge.b)(M => { const $ = new fo(M.id, this.urlSerializer.serialize(M.extractedUrl), this.urlSerializer.serialize(M.urlAfterRedirects), M.targetSnapshot); this.events.next($) }), (0, Pe.U)(M => u = { ...M, guards: Ni(M.targetSnapshot, M.currentSnapshot, this.rootContexts) }), function w(S, I) { return (0, ie.z)(m => { const { targetSnapshot: u, currentSnapshot: h, guards: { canActivateChecks: x, canDeactivateChecks: M } } = m; return 0 === M.length && 0 === x.length ? (0, Y.of)({ ...m, guardsResult: !0 }) : function D(S, I, m, u) { return (0, v.D)(S).pipe((0, ie.z)(h => function Gn(S, I, m, u, h) { const x = I && I.routeConfig ? I.routeConfig.canDeactivate : null; if (!x || 0 === x.length) return (0, Y.of)(!0); const M = x.map($ => { const Ee = po(I) ?? h, je = ao($, Ee); return nt(function fa(S) { return S && ys(S.canDeactivate) }(je) ? je.canDeactivate(S, I, m, u) : Ee.runInContext(() => je(S, I, m, u))).pipe((0, Le.P)()) }); return (0, Y.of)(M).pipe(V()) }(h.component, h.route, m, I, u)), (0, Le.P)(h => !0 !== h, !0)) }(M, u, h, S).pipe((0, ie.z)($ => $ && function Da(S) { return "boolean" == typeof S }($) ? function ne(S, I, m, u) { return (0, v.D)(I).pipe((0, le.b)(h => (0, re.z)(function mt(S, I) { return null !== S && I && I(new sn(S)), (0, Y.of)(!0) }(h.route.parent, u), function Re(S, I) { return null !== S && I && I(new dt(S)), (0, Y.of)(!0) }(h.route, u), function mn(S, I, m) { const u = I[I.length - 1], x = I.slice(0, I.length - 1).reverse().map(M => function As(S) { const I = S.routeConfig ? S.routeConfig.canActivateChild : null; return I && 0 !== I.length ? { node: S, guards: I } : null }(M)).filter(M => null !== M).map(M => (0, Ie.P)(() => { const $ = M.guards.map(Ee => { const je = po(M.node) ?? m, ft = ao(Ee, je); return nt(function ha(S) { return S && ys(S.canActivateChild) }(ft) ? ft.canActivateChild(u, S) : je.runInContext(() => ft(u, S))).pipe((0, Le.P)()) }); return (0, Y.of)($).pipe(V()) })); return (0, Y.of)(x).pipe(V()) }(S, h.path, m), function kt(S, I, m) { const u = I.routeConfig ? I.routeConfig.canActivate : null; if (!u || 0 === u.length) return (0, Y.of)(!0); const h = u.map(x => (0, Ie.P)(() => { const M = po(I) ?? m, $ = ao(x, M); return nt(function na(S) { return S && ys(S.canActivate) }($) ? $.canActivate(I, S) : M.runInContext(() => $(I, S))).pipe((0, Le.P)()) })); return (0, Y.of)(h).pipe(V()) }(S, h.route, m))), (0, Le.P)(h => !0 !== h, !0)) }(u, x, S, I) : (0, Y.of)($)), (0, Pe.U)($ => ({ ...m, guardsResult: $ }))) }) }(this.environmentInjector, M => this.events.next(M)), (0, ge.b)(M => { if (u.guardsResult = M.guardsResult, pe(M.guardsResult)) throw ds(0, M.guardsResult); const $ = new Jo(M.id, this.urlSerializer.serialize(M.extractedUrl), this.urlSerializer.serialize(M.urlAfterRedirects), M.targetSnapshot, !!M.guardsResult); this.events.next($) }), (0, ut.h)(M => !!M.guardsResult || (m.restoreHistory(M), this.cancelNavigationTransition(M, "", 3), !1)), Rs(M => { if (M.guards.canActivateChecks.length) return (0, Y.of)(M).pipe((0, ge.b)($ => { const Ee = new sr($.id, this.urlSerializer.serialize($.extractedUrl), this.urlSerializer.serialize($.urlAfterRedirects), $.targetSnapshot); this.events.next(Ee) }), (0, Ve.w)($ => { let Ee = !1; return (0, Y.of)($).pipe(function Bs(S, I) { return (0, ie.z)(m => { const { targetSnapshot: u, guards: { canActivateChecks: h } } = m; if (!h.length) return (0, Y.of)(m); let x = 0; return (0, v.D)(h).pipe((0, le.b)(M => function Ta(S, I, m, u) { const h = S.routeConfig, x = S._resolve; return void 0 !== h?.title && !lo(h) && (x[Ft] = h.title), function Ma(S, I, m, u) { const h = function ms(S) { return [...Object.keys(S), ...Object.getOwnPropertySymbols(S)] }(S); if (0 === h.length) return (0, Y.of)({}); const x = {}; return (0, v.D)(h).pipe((0, ie.z)(M => function ts(S, I, m, u) { const h = po(I) ?? u, x = ao(S, h); return nt(x.resolve ? x.resolve(I, m) : h.runInContext(() => x(I, m))) }(S[M], I, m, u).pipe((0, Le.P)(), (0, ge.b)($ => { x[M] = $ }))), bn(1), (0, Wn.h)(x), (0, ue.K)(M => jo(M) ? xe.E : (0, _e._)(M))) }(x, S, I, u).pipe((0, Pe.U)(M => (S._resolvedData = M, S.data = _i(S, m).resolve, h && lo(h) && (S.data[Ft] = h.title), null))) }(M.route, u, S, I)), (0, ge.b)(() => x++), bn(1), (0, ie.z)(M => x === h.length ? (0, Y.of)(m) : xe.E)) }) }(m.paramsInheritanceStrategy, this.environmentInjector), (0, ge.b)({ next: () => Ee = !0, complete: () => { Ee || (m.restoreHistory($), this.cancelNavigationTransition($, "", 2)) } })) }), (0, ge.b)($ => { const Ee = new wt($.id, this.urlSerializer.serialize($.extractedUrl), this.urlSerializer.serialize($.urlAfterRedirects), $.targetSnapshot); this.events.next(Ee) })) }), Rs(M => { const $ = Ee => { const je = []; Ee.routeConfig?.loadComponent && !Ee.routeConfig._loadedComponent && je.push(this.configLoader.loadComponent(Ee.routeConfig).pipe((0, ge.b)(ft => { Ee.component = ft }), (0, Pe.U)(() => { }))); for (const ft of Ee.children) je.push(...$(ft)); return je }; return (0, Se.a)($(M.targetSnapshot.root)).pipe((0, $e.d)(), (0, tt.q)(1)) }), Rs(() => this.afterPreactivation()), (0, Pe.U)(M => { const $ = function vs(S, I, m) { const u = Ao(S, I._root, m ? m._root : void 0); return new Dr(u, I) }(m.routeReuseStrategy, M.targetSnapshot, M.currentRouterState); return u = { ...M, targetRouterState: $ } }), (0, ge.b)(M => { m.currentUrlTree = M.urlAfterRedirects, m.rawUrlTree = m.urlHandlingStrategy.merge(M.urlAfterRedirects, M.rawUrl), m.routerState = M.targetRouterState, "deferred" === m.urlUpdateStrategy && (M.extras.skipLocationChange || m.setBrowserUrl(m.rawUrlTree, M), m.browserUrlTree = M.urlAfterRedirects) }), ((S, I, m, u) => (0, Pe.U)(h => (new us(I, h.targetRouterState, h.currentRouterState, m, u).activate(S), h)))(this.rootContexts, m.routeReuseStrategy, M => this.events.next(M), this.inputBindingEnabled), (0, tt.q)(1), (0, ge.b)({ next: M => { h = !0, this.lastSuccessfulNavigation = this.currentNavigation, m.navigated = !0, this.events.next(new Ir(M.id, this.urlSerializer.serialize(M.extractedUrl), this.urlSerializer.serialize(m.currentUrlTree))), m.titleStrategy?.updateTitle(M.targetRouterState.snapshot), M.resolve(!0) }, complete: () => { h = !0 } }), (0, Hn.x)(() => { h || x || this.cancelNavigationTransition(u, "", 1), this.currentNavigation?.id === u.id && (this.currentNavigation = null) }), (0, ue.K)(M => { if (x = !0, es(M)) { Qr(M) || (m.navigated = !0, m.restoreHistory(u, !0)); const $ = new bo(u.id, this.urlSerializer.serialize(u.extractedUrl), M.message, M.cancellationCode); if (this.events.next($), Qr(M)) { const Ee = m.urlHandlingStrategy.merge(M.url, m.rawUrlTree), je = { skipLocationChange: u.extras.skipLocationChange, replaceUrl: "eager" === m.urlUpdateStrategy || P(u.source) }; m.scheduleNavigation(Ee, zi, null, je, { resolve: u.resolve, reject: u.reject, promise: u.promise }) } else u.resolve(!1) } else { m.restoreHistory(u, !0); const $ = new Vi(u.id, this.urlSerializer.serialize(u.extractedUrl), M, u.targetSnapshot ?? void 0); this.events.next($); try { u.resolve(m.errorHandler(M)) } catch (Ee) { u.reject(Ee) } } return xe.E })) })) } cancelNavigationTransition(m, u, h) { const x = new bo(m.id, this.urlSerializer.serialize(m.extractedUrl), u, h); this.events.next(x), m.resolve(!1) } } return S.\u0275fac = function (m) { return new (m || S) }, S.\u0275prov = a.Yz7({ token: S, factory: S.\u0275fac, providedIn: "root" }), S })(); function P(S) { return S !== zi } let X = (() => { class S { buildTitle(m) { let u, h = m.root; for (; void 0 !== h;)u = this.getResolvedTitleForRoute(h) ?? u, h = h.children.find(x => x.outlet === it); return u } getResolvedTitleForRoute(m) { return m.data[Ft] } } return S.\u0275fac = function (m) { return new (m || S) }, S.\u0275prov = a.Yz7({ token: S, factory: function () { return (0, a.f3M)(B) }, providedIn: "root" }), S })(), B = (() => { class S extends X { constructor(m) { super(), this.title = m } updateTitle(m) { const u = this.buildTitle(m); void 0 !== u && this.title.setTitle(u) } } return S.\u0275fac = function (m) { return new (m || S)(a.LFG(xt.Dx)) }, S.\u0275prov = a.Yz7({ token: S, factory: S.\u0275fac, providedIn: "root" }), S })(), be = (() => { class S { } return S.\u0275fac = function (m) { return new (m || S) }, S.\u0275prov = a.Yz7({ token: S, factory: function () { return (0, a.f3M)($t) }, providedIn: "root" }), S })(); class Je { shouldDetach(I) { return !1 } store(I, m) { } shouldAttach(I) { return !1 } retrieve(I) { return null } shouldReuseRoute(I, m) { return I.routeConfig === m.routeConfig } } let $t = (() => { class S extends Je { } return S.\u0275fac = function () { let I; return function (u) { return (I || (I = a.n5z(S)))(u || S) } }(), S.\u0275prov = a.Yz7({ token: S, factory: S.\u0275fac, providedIn: "root" }), S })(); const en = new a.OlP("", { providedIn: "root", factory: () => ({}) }); let Zn = (() => { class S { } return S.\u0275fac = function (m) { return new (m || S) }, S.\u0275prov = a.Yz7({ token: S, factory: function () { return (0, a.f3M)(Ji) }, providedIn: "root" }), S })(), Ji = (() => { class S { shouldProcessUrl(m) { return !0 } extract(m) { return m } merge(m, u) { return m } } return S.\u0275fac = function (m) { return new (m || S) }, S.\u0275prov = a.Yz7({ token: S, factory: S.\u0275fac, providedIn: "root" }), S })(); var xi = (() => ((xi = xi || {})[xi.COMPLETE = 0] = "COMPLETE", xi[xi.FAILED = 1] = "FAILED", xi[xi.REDIRECTING = 2] = "REDIRECTING", xi))(); function Hi(S, I) { S.events.pipe((0, ut.h)(m => m instanceof Ir || m instanceof bo || m instanceof Vi || m instanceof Nr), (0, Pe.U)(m => m instanceof Ir || m instanceof Nr ? xi.COMPLETE : m instanceof bo && (0 === m.code || 1 === m.code) ? xi.REDIRECTING : xi.FAILED), (0, ut.h)(m => m !== xi.REDIRECTING), (0, tt.q)(1)).subscribe(() => { I() }) } function Fi(S) { throw S } function Di(S, I, m) { return I.parse("/") } const qi = { paths: "exact", fragment: "ignored", matrixParams: "ignored", queryParams: "exact" }, rr = { paths: "subset", fragment: "ignored", matrixParams: "ignored", queryParams: "subset" }; let lr = (() => { class S { get navigationId() { return this.navigationTransitions.navigationId } get browserPageId() { if ("computed" === this.canceledNavigationResolution) return this.location.getState()?.\u0275routerPageId } get events() { return this.navigationTransitions.events } constructor() { this.disposed = !1, this.currentPageId = 0, this.console = (0, a.f3M)(a.c2e), this.isNgZoneEnabled = !1, this.options = (0, a.f3M)(en, { optional: !0 }) || {}, this.pendingTasks = (0, a.f3M)(a.HDt), this.errorHandler = this.options.errorHandler || Fi, this.malformedUriErrorHandler = this.options.malformedUriErrorHandler || Di, this.navigated = !1, this.lastSuccessfulId = -1, this.urlHandlingStrategy = (0, a.f3M)(Zn), this.routeReuseStrategy = (0, a.f3M)(be), this.titleStrategy = (0, a.f3M)(X), this.onSameUrlNavigation = this.options.onSameUrlNavigation || "ignore", this.paramsInheritanceStrategy = this.options.paramsInheritanceStrategy || "emptyOnly", this.urlUpdateStrategy = this.options.urlUpdateStrategy || "deferred", this.canceledNavigationResolution = this.options.canceledNavigationResolution || "replace", this.config = (0, a.f3M)(go, { optional: !0 })?.flat() ?? [], this.navigationTransitions = (0, a.f3M)(Oo), this.urlSerializer = (0, a.f3M)(ve), this.location = (0, a.f3M)(We.Ye), this.componentInputBindingEnabled = !!(0, a.f3M)(ro, { optional: !0 }), this.isNgZoneEnabled = (0, a.f3M)(a.R0b) instanceof a.R0b && a.R0b.isInAngularZone(), this.resetConfig(this.config), this.currentUrlTree = new Fn, this.rawUrlTree = this.currentUrlTree, this.browserUrlTree = this.currentUrlTree, this.routerState = xr(0, null), this.navigationTransitions.setupNavigations(this).subscribe(m => { this.lastSuccessfulId = m.id, this.currentPageId = this.browserPageId ?? 0 }, m => { this.console.warn(`Unhandled Navigation Error: ${m}`) }) } resetRootComponentType(m) { this.routerState.root.component = m, this.navigationTransitions.rootComponentType = m } initialNavigation() { if (this.setUpLocationChangeListener(), !this.navigationTransitions.hasRequestedNavigation) { const m = this.location.getState(); this.navigateToSyncWithBrowser(this.location.path(!0), zi, m) } } setUpLocationChangeListener() { this.locationSubscription || (this.locationSubscription = this.location.subscribe(m => { const u = "popstate" === m.type ? "popstate" : "hashchange"; "popstate" === u && setTimeout(() => { this.navigateToSyncWithBrowser(m.url, u, m.state) }, 0) })) } navigateToSyncWithBrowser(m, u, h) { const x = { replaceUrl: !0 }, M = h?.navigationId ? h : null; if (h) { const Ee = { ...h }; delete Ee.navigationId, delete Ee.\u0275routerPageId, 0 !== Object.keys(Ee).length && (x.state = Ee) } const $ = this.parseUrl(m); this.scheduleNavigation($, u, M, x) } get url() { return this.serializeUrl(this.currentUrlTree) } getCurrentNavigation() { return this.navigationTransitions.currentNavigation } get lastSuccessfulNavigation() { return this.navigationTransitions.lastSuccessfulNavigation } resetConfig(m) { this.config = m.map(Qo), this.navigated = !1, this.lastSuccessfulId = -1 } ngOnDestroy() { this.dispose() } dispose() { this.navigationTransitions.complete(), this.locationSubscription && (this.locationSubscription.unsubscribe(), this.locationSubscription = void 0), this.disposed = !0 } createUrlTree(m, u = {}) { const { relativeTo: h, queryParams: x, fragment: M, queryParamsHandling: $, preserveFragment: Ee } = u, je = Ee ? this.currentUrlTree.fragment : M; let zt, ft = null; switch ($) { case "merge": ft = { ...this.currentUrlTree.queryParams, ...x }; break; case "preserve": ft = this.currentUrlTree.queryParams; break; default: ft = x || null }null !== ft && (ft = this.removeEmptyProps(ft)); try { zt = F(h ? h.snapshot : this.routerState.snapshot.root) } catch { ("string" != typeof m[0] || !m[0].startsWith("/")) && (m = []), zt = this.currentUrlTree.root } return J(zt, m, ft, je ?? null) } navigateByUrl(m, u = { skipLocationChange: !1 }) { const h = pe(m) ? m : this.parseUrl(m), x = this.urlHandlingStrategy.merge(h, this.rawUrlTree); return this.scheduleNavigation(x, zi, null, u) } navigate(m, u = { skipLocationChange: !1 }) { return function ui(S) { for (let I = 0; I < S.length; I++)if (null == S[I]) throw new a.vHH(4008, !1) }(m), this.navigateByUrl(this.createUrlTree(m, u), u) } serializeUrl(m) { return this.urlSerializer.serialize(m) } parseUrl(m) { let u; try { u = this.urlSerializer.parse(m) } catch (h) { u = this.malformedUriErrorHandler(h, this.urlSerializer, m) } return u } isActive(m, u) { let h; if (h = !0 === u ? { ...qi } : !1 === u ? { ...rr } : u, pe(m)) return Pt(this.currentUrlTree, m, h); const x = this.parseUrl(m); return Pt(this.currentUrlTree, x, h) } removeEmptyProps(m) { return Object.keys(m).reduce((u, h) => { const x = m[h]; return null != x && (u[h] = x), u }, {}) } scheduleNavigation(m, u, h, x, M) { if (this.disposed) return Promise.resolve(!1); let $, Ee, je; M ? ($ = M.resolve, Ee = M.reject, je = M.promise) : je = new Promise((zt, xn) => { $ = zt, Ee = xn }); const ft = this.pendingTasks.add(); return Hi(this, () => { queueMicrotask(() => this.pendingTasks.remove(ft)) }), this.navigationTransitions.handleNavigationRequest({ source: u, restoredState: h, currentUrlTree: this.currentUrlTree, currentRawUrl: this.currentUrlTree, rawUrl: m, extras: x, resolve: $, reject: Ee, promise: je, currentSnapshot: this.routerState.snapshot, currentRouterState: this.routerState }), je.catch(zt => Promise.reject(zt)) } setBrowserUrl(m, u) { const h = this.urlSerializer.serialize(m); if (this.location.isCurrentPathEqualTo(h) || u.extras.replaceUrl) { const M = { ...u.extras.state, ...this.generateNgRouterState(u.id, this.browserPageId) }; this.location.replaceState(h, "", M) } else { const x = { ...u.extras.state, ...this.generateNgRouterState(u.id, (this.browserPageId ?? 0) + 1) }; this.location.go(h, "", x) } } restoreHistory(m, u = !1) { if ("computed" === this.canceledNavigationResolution) { const x = this.currentPageId - (this.browserPageId ?? this.currentPageId); 0 !== x ? this.location.historyGo(x) : this.currentUrlTree === this.getCurrentNavigation()?.finalUrl && 0 === x && (this.resetState(m), this.browserUrlTree = m.currentUrlTree, this.resetUrlToCurrentUrlTree()) } else "replace" === this.canceledNavigationResolution && (u && this.resetState(m), this.resetUrlToCurrentUrlTree()) } resetState(m) { this.routerState = m.currentRouterState, this.currentUrlTree = m.currentUrlTree, this.rawUrlTree = this.urlHandlingStrategy.merge(this.currentUrlTree, m.rawUrl) } resetUrlToCurrentUrlTree() { this.location.replaceState(this.urlSerializer.serialize(this.rawUrlTree), "", this.generateNgRouterState(this.lastSuccessfulId, this.currentPageId)) } generateNgRouterState(m, u) { return "computed" === this.canceledNavigationResolution ? { navigationId: m, \u0275routerPageId: u } : { navigationId: m } } } return S.\u0275fac = function (m) { return new (m || S) }, S.\u0275prov = a.Yz7({ token: S, factory: S.\u0275fac, providedIn: "root" }), S })(), pn = (() => { class S { constructor(m, u, h, x, M, $) { this.router = m, this.route = u, this.tabIndexAttribute = h, this.renderer = x, this.el = M, this.locationStrategy = $, this.href = null, this.commands = null, this.onChanges = new Oe.x, this.preserveFragment = !1, this.skipLocationChange = !1, this.replaceUrl = !1; const Ee = M.nativeElement.tagName?.toLowerCase(); this.isAnchorElement = "a" === Ee || "area" === Ee, this.isAnchorElement ? this.subscription = m.events.subscribe(je => { je instanceof Ir && this.updateHref() }) : this.setTabIndexIfNotOnNativeEl("0") } setTabIndexIfNotOnNativeEl(m) { null != this.tabIndexAttribute || this.isAnchorElement || this.applyAttributeValue("tabindex", m) } ngOnChanges(m) { this.isAnchorElement && this.updateHref(), this.onChanges.next(this) } set routerLink(m) { null != m ? (this.commands = Array.isArray(m) ? m : [m], this.setTabIndexIfNotOnNativeEl("0")) : (this.commands = null, this.setTabIndexIfNotOnNativeEl(null)) } onClick(m, u, h, x, M) { return !!(null === this.urlTree || this.isAnchorElement && (0 !== m || u || h || x || M || "string" == typeof this.target && "_self" != this.target)) || (this.router.navigateByUrl(this.urlTree, { skipLocationChange: this.skipLocationChange, replaceUrl: this.replaceUrl, state: this.state }), !this.isAnchorElement) } ngOnDestroy() { this.subscription?.unsubscribe() } updateHref() { this.href = null !== this.urlTree && this.locationStrategy ? this.locationStrategy?.prepareExternalUrl(this.router.serializeUrl(this.urlTree)) : null; const m = null === this.href ? null : (0, a.P3R)(this.href, this.el.nativeElement.tagName.toLowerCase(), "href"); this.applyAttributeValue("href", m) } applyAttributeValue(m, u) { const h = this.renderer, x = this.el.nativeElement; null !== u ? h.setAttribute(x, m, u) : h.removeAttribute(x, m) } get urlTree() { return null === this.commands ? null : this.router.createUrlTree(this.commands, { relativeTo: void 0 !== this.relativeTo ? this.relativeTo : this.route, queryParams: this.queryParams, fragment: this.fragment, queryParamsHandling: this.queryParamsHandling, preserveFragment: this.preserveFragment }) } } return S.\u0275fac = function (m) { return new (m || S)(a.Y36(lr), a.Y36(mo), a.$8M("tabindex"), a.Y36(a.Qsj), a.Y36(a.SBq), a.Y36(We.S$)) }, S.\u0275dir = a.lG2({ type: S, selectors: [["", "routerLink", ""]], hostVars: 1, hostBindings: function (m, u) { 1 & m && a.NdJ("click", function (x) { return u.onClick(x.button, x.ctrlKey, x.shiftKey, x.altKey, x.metaKey) }), 2 & m && a.uIk("target", u.target) }, inputs: { target: "target", queryParams: "queryParams", fragment: "fragment", queryParamsHandling: "queryParamsHandling", state: "state", relativeTo: "relativeTo", preserveFragment: ["preserveFragment", "preserveFragment", a.VuI], skipLocationChange: ["skipLocationChange", "skipLocationChange", a.VuI], replaceUrl: ["replaceUrl", "replaceUrl", a.VuI], routerLink: "routerLink" }, standalone: !0, features: [a.Xq5, a.TTD] }), S })(), er = (() => { class S { get isActive() { return this._isActive } constructor(m, u, h, x, M) { this.router = m, this.element = u, this.renderer = h, this.cdr = x, this.link = M, this.classes = [], this._isActive = !1, this.routerLinkActiveOptions = { exact: !1 }, this.isActiveChange = new a.vpe, this.routerEventsSubscription = m.events.subscribe($ => { $ instanceof Ir && this.update() }) } ngAfterContentInit() { (0, Y.of)(this.links.changes, (0, Y.of)(null)).pipe((0, vt.J)()).subscribe(m => { this.update(), this.subscribeToEachLinkOnChanges() }) } subscribeToEachLinkOnChanges() { this.linkInputChangesSubscription?.unsubscribe(); const m = [...this.links.toArray(), this.link].filter(u => !!u).map(u => u.onChanges); this.linkInputChangesSubscription = (0, v.D)(m).pipe((0, vt.J)()).subscribe(u => { this._isActive !== this.isLinkActive(this.router)(u) && this.update() }) } set routerLinkActive(m) { const u = Array.isArray(m) ? m : m.split(" "); this.classes = u.filter(h => !!h) } ngOnChanges(m) { this.update() } ngOnDestroy() { this.routerEventsSubscription.unsubscribe(), this.linkInputChangesSubscription?.unsubscribe() } update() { !this.links || !this.router.navigated || queueMicrotask(() => { const m = this.hasActiveLinks(); this._isActive !== m && (this._isActive = m, this.cdr.markForCheck(), this.classes.forEach(u => { m ? this.renderer.addClass(this.element.nativeElement, u) : this.renderer.removeClass(this.element.nativeElement, u) }), m && void 0 !== this.ariaCurrentWhenActive ? this.renderer.setAttribute(this.element.nativeElement, "aria-current", this.ariaCurrentWhenActive.toString()) : this.renderer.removeAttribute(this.element.nativeElement, "aria-current"), this.isActiveChange.emit(m)) }) } isLinkActive(m) { const u = function wo(S) { return !!S.paths }(this.routerLinkActiveOptions) ? this.routerLinkActiveOptions : this.routerLinkActiveOptions.exact || !1; return h => !!h.urlTree && m.isActive(h.urlTree, u) } hasActiveLinks() { const m = this.isLinkActive(this.router); return this.link && m(this.link) || this.links.some(m) } } return S.\u0275fac = function (m) { return new (m || S)(a.Y36(lr), a.Y36(a.SBq), a.Y36(a.Qsj), a.Y36(a.sBO), a.Y36(pn, 8)) }, S.\u0275dir = a.lG2({ type: S, selectors: [["", "routerLinkActive", ""]], contentQueries: function (m, u, h) { if (1 & m && a.Suo(h, pn, 5), 2 & m) { let x; a.iGM(x = a.CRH()) && (u.links = x) } }, inputs: { routerLinkActiveOptions: "routerLinkActiveOptions", ariaCurrentWhenActive: "ariaCurrentWhenActive", routerLinkActive: "routerLinkActive" }, outputs: { isActiveChange: "isActiveChange" }, exportAs: ["routerLinkActive"], standalone: !0, features: [a.TTD] }), S })(); class Ur { } let co = (() => { class S { constructor(m, u, h, x, M) { this.router = m, this.injector = h, this.preloadingStrategy = x, this.loader = M } setUpPreloading() { this.subscription = this.router.events.pipe((0, ut.h)(m => m instanceof Ir), (0, le.b)(() => this.preload())).subscribe(() => { }) } preload() { return this.processRoutes(this.injector, this.router.config) } ngOnDestroy() { this.subscription && this.subscription.unsubscribe() } processRoutes(m, u) { const h = []; for (const x of u) { x.providers && !x._injector && (x._injector = (0, a.MMx)(x.providers, m, `Route: ${x.path}`)); const M = x._injector ?? m, $ = x._loadedInjector ?? M; (x.loadChildren && !x._loadedRoutes && void 0 === x.canLoad || x.loadComponent && !x._loadedComponent) && h.push(this.preloadConfig(M, x)), (x.children || x._loadedRoutes) && h.push(this.processRoutes($, x.children ?? x._loadedRoutes)) } return (0, v.D)(h).pipe((0, vt.J)()) } preloadConfig(m, u) { return this.preloadingStrategy.preload(u, () => { let h; h = u.loadChildren && void 0 === u.canLoad ? this.loader.loadChildren(m, u) : (0, Y.of)(null); const x = h.pipe((0, ie.z)(M => null === M ? (0, Y.of)(void 0) : (u._loadedRoutes = M.routes, u._loadedInjector = M.injector, this.processRoutes(M.injector ?? m, M.routes)))); if (u.loadComponent && !u._loadedComponent) { const M = this.loader.loadComponent(u); return (0, v.D)([x, M]).pipe((0, vt.J)()) } return x }) } } return S.\u0275fac = function (m) { return new (m || S)(a.LFG(lr), a.LFG(a.Sil), a.LFG(a.lqb), a.LFG(Ur), a.LFG(Os)) }, S.\u0275prov = a.Yz7({ token: S, factory: S.\u0275fac, providedIn: "root" }), S })(); const Un = new a.OlP(""); let Yt = (() => { class S { constructor(m, u, h, x, M = {}) { this.urlSerializer = m, this.transitions = u, this.viewportScroller = h, this.zone = x, this.options = M, this.lastId = 0, this.lastSource = "imperative", this.restoredId = 0, this.store = {}, M.scrollPositionRestoration = M.scrollPositionRestoration || "disabled", M.anchorScrolling = M.anchorScrolling || "disabled" } init() { "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.setHistoryScrollRestoration("manual"), this.routerEventsSubscription = this.createScrollEvents(), this.scrollEventsSubscription = this.consumeScrollEvents() } createScrollEvents() { return this.transitions.events.subscribe(m => { m instanceof Pr ? (this.store[this.lastId] = this.viewportScroller.getScrollPosition(), this.lastSource = m.navigationTrigger, this.restoredId = m.restoredState ? m.restoredState.navigationId : 0) : m instanceof Ir ? (this.lastId = m.id, this.scheduleScrollEvent(m, this.urlSerializer.parse(m.urlAfterRedirects).fragment)) : m instanceof Nr && 0 === m.code && (this.lastSource = void 0, this.restoredId = 0, this.scheduleScrollEvent(m, this.urlSerializer.parse(m.url).fragment)) }) } consumeScrollEvents() { return this.transitions.events.subscribe(m => { m instanceof ye && (m.position ? "top" === this.options.scrollPositionRestoration ? this.viewportScroller.scrollToPosition([0, 0]) : "enabled" === this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition(m.position) : m.anchor && "enabled" === this.options.anchorScrolling ? this.viewportScroller.scrollToAnchor(m.anchor) : "disabled" !== this.options.scrollPositionRestoration && this.viewportScroller.scrollToPosition([0, 0])) }) } scheduleScrollEvent(m, u) { this.zone.runOutsideAngular(() => { setTimeout(() => { this.zone.run(() => { this.transitions.events.next(new ye(m, "popstate" === this.lastSource ? this.store[this.restoredId] : null, u)) }) }, 0) }) } ngOnDestroy() { this.routerEventsSubscription?.unsubscribe(), this.scrollEventsSubscription?.unsubscribe() } } return S.\u0275fac = function (m) { a.$Z() }, S.\u0275prov = a.Yz7({ token: S, factory: S.\u0275fac }), S })(); function Us(S, I) { return { \u0275kind: S, \u0275providers: I } } function xo() { const S = (0, a.f3M)(a.zs3); return I => { const m = S.get(a.z2F); if (I !== m.components[0]) return; const u = S.get(lr), h = S.get(qa); 1 === S.get(ga) && u.initialNavigation(), S.get(Ei, null, a.XFs.Optional)?.setUpPreloading(), S.get(Un, null, a.XFs.Optional)?.init(), u.resetRootComponentType(m.componentTypes[0]), h.closed || (h.next(), h.complete(), h.unsubscribe()) } } const qa = new a.OlP("", { factory: () => new Oe.x }), ga = new a.OlP("", { providedIn: "root", factory: () => 1 }), Ei = new a.OlP(""); function _a(S) { return Us(0, [{ provide: Ei, useExisting: co }, { provide: Ur, useExisting: S }]) } const Es = new a.OlP("ROUTER_FORROOT_GUARD"), Hr = [We.Ye, { provide: ve, useClass: Ue }, lr, At, { provide: mo, useFactory: function eo(S) { return S.routerState.root }, deps: [lr] }, Os, []]; function Bn() { return new a.PXZ("Router", lr) } let Vs = (() => { class S { constructor(m) { } static forRoot(m, u) { return { ngModule: S, providers: [Hr, [], { provide: go, multi: !0, useValue: m }, { provide: Es, useFactory: Ba, deps: [[lr, new a.FiY, new a.tp0]] }, { provide: en, useValue: u || {} }, u?.useHash ? { provide: We.S$, useClass: We.Do } : { provide: We.S$, useClass: We.b0 }, { provide: Un, useFactory: () => { const S = (0, a.f3M)(We.EM), I = (0, a.f3M)(a.R0b), m = (0, a.f3M)(en), u = (0, a.f3M)(Oo), h = (0, a.f3M)(ve); return m.scrollOffset && S.setOffset(m.scrollOffset), new Yt(h, u, S, I, m) } }, u?.preloadingStrategy ? _a(u.preloadingStrategy).\u0275providers : [], { provide: a.PXZ, multi: !0, useFactory: Bn }, u?.initialNavigation ? Aa(u) : [], u?.bindToComponentInputs ? Us(8, [Xn, { provide: ro, useExisting: Xn }]).\u0275providers : [], [{ provide: ka, useFactory: xo }, { provide: a.tb, multi: !0, useExisting: ka }]] } } static forChild(m) { return { ngModule: S, providers: [{ provide: go, multi: !0, useValue: m }] } } } return S.\u0275fac = function (m) { return new (m || S)(a.LFG(Es, 8)) }, S.\u0275mod = a.oAB({ type: S }), S.\u0275inj = a.cJS({}), S })(); function Ba(S) { return "guarded" } function Aa(S) { return ["disabled" === S.initialNavigation ? Us(3, [{ provide: a.ip1, multi: !0, useFactory: () => { const I = (0, a.f3M)(lr); return () => { I.setUpLocationChangeListener() } } }, { provide: ga, useValue: 2 }]).\u0275providers : [], "enabledBlocking" === S.initialNavigation ? Us(2, [{ provide: ga, useValue: 0 }, { provide: a.ip1, multi: !0, deps: [a.zs3], useFactory: I => { const m = I.get(We.V_, Promise.resolve()); return () => m.then(() => new Promise(u => { const h = I.get(lr), x = I.get(qa); Hi(h, () => { u(!0) }), I.get(Oo).afterPreactivation = () => (u(!0), x.closed ? (0, Y.of)(void 0) : x), h.initialNavigation() })) } }]).\u0275providers : []] } const ka = new a.OlP("") }, 3106: (nn, Qe, C) => { C.d(Qe, { Z: () => We }); var a = C(9058), y = C(4537), v = C(6122), Y = C(7879); class he { constructor(Ve, tt) { this._delegate = Ve, this.firebase = tt, (0, v._addComponent)(Ve, new y.wA("app-compat", () => this, "PUBLIC")), this.container = Ve.container } get automaticDataCollectionEnabled() { return this._delegate.automaticDataCollectionEnabled } set automaticDataCollectionEnabled(Ve) { this._delegate.automaticDataCollectionEnabled = Ve } get name() { return this._delegate.name } get options() { return this._delegate.options } delete() { return new Promise(Ve => { this._delegate.checkDestroyed(), Ve() }).then(() => (this.firebase.INTERNAL.removeApp(this.name), (0, v.deleteApp)(this._delegate))) } _getService(Ve, tt = v._DEFAULT_ENTRY_NAME) { var Ye; this._delegate.checkDestroyed(); const ut = this._delegate.container.getProvider(Ve); return !ut.isInitialized() && "EXPLICIT" === (null === (Ye = ut.getComponent()) || void 0 === Ye ? void 0 : Ye.instantiationMode) && ut.initialize(), ut.getImmediate({ identifier: tt }) } _removeServiceInstance(Ve, tt = v._DEFAULT_ENTRY_NAME) { this._delegate.container.getProvider(Ve).clearInstance(tt) } _addComponent(Ve) { (0, v._addComponent)(this._delegate, Ve) } _addOrOverwriteComponent(Ve) { (0, v._addOrOverwriteComponent)(this._delegate, Ve) } toJSON() { return { name: this.name, automaticDataCollectionEnabled: this.automaticDataCollectionEnabled, options: this.options } } } const ke = new a.LL("app-compat", "Firebase", { "no-app": "No Firebase App '{$appName}' has been created - call Firebase App.initializeApp()", "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance." }), Q = function Ie() { const Pe = function re(Pe) { const Ve = {}, tt = { __esModule: !0, initializeApp: function ie(ue, ee = {}) { const $e = v.initializeApp(ue, ee); if ((0, a.r3)(Ve, $e.name)) return Ve[$e.name]; const rt = new Pe($e, tt); return Ve[$e.name] = rt, rt }, app: ut, registerVersion: v.registerVersion, setLogLevel: v.setLogLevel, onLog: v.onLog, apps: null, SDK_VERSION: v.SDK_VERSION, INTERNAL: { registerComponent: function le(ue) { const ee = ue.name, $e = ee.replace("-compat", ""); if (v._registerComponent(ue) && "PUBLIC" === ue.type) { const rt = (Kt = ut()) => { if ("function" != typeof Kt[$e]) throw ke.create("invalid-app-argument", { appName: ee }); return Kt[$e]() }; void 0 !== ue.serviceProps && (0, a.ZB)(rt, ue.serviceProps), tt[$e] = rt, Pe.prototype[$e] = function (...Kt) { return this._getService.bind(this, ee).apply(this, ue.multipleInstances ? Kt : []) } } return "PUBLIC" === ue.type ? tt[$e] : null }, removeApp: function Ye(ue) { delete Ve[ue] }, useAsService: function ge(ue, ee) { return "serverAuth" === ee ? null : ee }, modularAPIs: v } }; function ut(ue) { if (!(0, a.r3)(Ve, ue = ue || v._DEFAULT_ENTRY_NAME)) throw ke.create("no-app", { appName: ue }); return Ve[ue] } return tt.default = tt, Object.defineProperty(tt, "apps", { get: function Le() { return Object.keys(Ve).map(ue => Ve[ue]) } }), ut.App = Pe, tt }(he); return Pe.INTERNAL = Object.assign(Object.assign({}, Pe.INTERNAL), { createFirebaseNamespace: Ie, extendNamespace: function Ve(tt) { (0, a.ZB)(Pe, tt) }, createSubscribe: a.ne, ErrorFactory: a.LL, deepExtend: a.ZB }), Pe }(), _e = new Y.Yd("@firebase/app-compat"); if ((0, a.jU)() && void 0 !== self.firebase) { _e.warn("\n    Warning: Firebase is already defined in the global scope. Please make sure\n    Firebase library is only loaded once.\n  "); const Pe = self.firebase.SDK_VERSION; Pe && Pe.indexOf("LITE") >= 0 && _e.warn("\n    Warning: You are trying to load Firebase while using Firebase Performance standalone script.\n    You should load Firebase Performance with this instance of Firebase to avoid loading duplicate code.\n    ") } const We = Q; !function Oe(Pe) { (0, v.registerVersion)("@firebase/app-compat", "0.2.13", Pe) }() }, 6122: (nn, Qe, C) => { C.r(Qe), C.d(Qe, { FirebaseError: () => Y.ZR, SDK_VERSION: () => En, _DEFAULT_ENTRY_NAME: () => Ke, _addComponent: () => Ot, _addOrOverwriteComponent: () => ve, _apps: () => Me, _clearComponents: () => ct, _components: () => Xe, _getProvider: () => Z, _registerComponent: () => Ue, _removeServiceInstance: () => Fe, deleteApp: () => _t, getApp: () => In, getApps: () => Et, initializeApp: () => Ln, onLog: () => me, registerVersion: () => W, setLogLevel: () => de }); var a = C(5861), y = C(4537), v = C(7879), Y = C(9058); const he = (yt, It) => It.some(dn => yt instanceof dn); let Se, ke; const Q = new WeakMap, _e = new WeakMap, xe = new WeakMap, ze = new WeakMap, Oe = new WeakMap; let Ve = { get(yt, It, dn) { if (yt instanceof IDBTransaction) { if ("done" === It) return _e.get(yt); if ("objectStoreNames" === It) return yt.objectStoreNames || xe.get(yt); if ("store" === It) return dn.objectStoreNames[1] ? void 0 : dn.objectStore(dn.objectStoreNames[0]) } return ie(yt[It]) }, set: (yt, It, dn) => (yt[It] = dn, !0), has: (yt, It) => yt instanceof IDBTransaction && ("done" === It || "store" === It) || It in yt }; function ut(yt) { return "function" == typeof yt ? function Ye(yt) { return yt !== IDBDatabase.prototype.transaction || "objectStoreNames" in IDBTransaction.prototype ? function Ie() { return ke || (ke = [IDBCursor.prototype.advance, IDBCursor.prototype.continue, IDBCursor.prototype.continuePrimaryKey]) }().includes(yt) ? function (...It) { return yt.apply(Le(this), It), ie(Q.get(this)) } : function (...It) { return ie(yt.apply(Le(this), It)) } : function (It, ...dn) { const Pn = yt.call(Le(this), It, ...dn); return xe.set(Pn, It.sort ? It.sort() : [It]), ie(Pn) } }(yt) : (yt instanceof IDBTransaction && function Pe(yt) { if (_e.has(yt)) return; const It = new Promise((dn, Pn) => { const qn = () => { yt.removeEventListener("complete", ni), yt.removeEventListener("error", si), yt.removeEventListener("abort", si) }, ni = () => { dn(), qn() }, si = () => { Pn(yt.error || new DOMException("AbortError", "AbortError")), qn() }; yt.addEventListener("complete", ni), yt.addEventListener("error", si), yt.addEventListener("abort", si) }); _e.set(yt, It) }(yt), he(yt, function re() { return Se || (Se = [IDBDatabase, IDBObjectStore, IDBIndex, IDBCursor, IDBTransaction]) }()) ? new Proxy(yt, Ve) : yt) } function ie(yt) { if (yt instanceof IDBRequest) return function We(yt) { const It = new Promise((dn, Pn) => { const qn = () => { yt.removeEventListener("success", ni), yt.removeEventListener("error", si) }, ni = () => { dn(ie(yt.result)), qn() }, si = () => { Pn(yt.error), qn() }; yt.addEventListener("success", ni), yt.addEventListener("error", si) }); return It.then(dn => { dn instanceof IDBCursor && Q.set(dn, yt) }).catch(() => { }), Oe.set(It, yt), It }(yt); if (ze.has(yt)) return ze.get(yt); const It = ut(yt); return It !== yt && (ze.set(yt, It), Oe.set(It, yt)), It } const Le = yt => Oe.get(yt), ue = ["get", "getKey", "getAll", "getAllKeys", "count"], ee = ["put", "add", "delete", "clear"], $e = new Map; function rt(yt, It) { if (!(yt instanceof IDBDatabase) || It in yt || "string" != typeof It) return; if ($e.get(It)) return $e.get(It); const dn = It.replace(/FromIndex$/, ""), Pn = It !== dn, qn = ee.includes(dn); if (!(dn in (Pn ? IDBIndex : IDBObjectStore).prototype) || !qn && !ue.includes(dn)) return; const ni = function () { var si = (0, a.Z)(function* (Ai, ...Li) { const ho = this.transaction(Ai, qn ? "readwrite" : "readonly"); let $r = ho.store; return Pn && ($r = $r.index(Li.shift())), (yield Promise.all([$r[dn](...Li), qn && ho.done]))[0] }); return function (Li) { return si.apply(this, arguments) } }(); return $e.set(It, ni), ni } !function tt(yt) { Ve = yt(Ve) }(yt => ({ ...yt, get: (It, dn, Pn) => rt(It, dn) || yt.get(It, dn, Pn), has: (It, dn) => !!rt(It, dn) || yt.has(It, dn) })); class Kt { constructor(It) { this.container = It } getPlatformInfoString() { return this.container.getProviders().map(dn => { if (function bn(yt) { const It = yt.getComponent(); return "VERSION" === It?.type }(dn)) { const Pn = dn.getImmediate(); return `${Pn.library}/${Pn.version}` } return null }).filter(dn => dn).join(" ") } } const Dn = "@firebase/app", On = new v.Yd("@firebase/app"), Ke = "[DEFAULT]", se = { [Dn]: "fire-core", "@firebase/app-compat": "fire-core-compat", "@firebase/analytics": "fire-analytics", "@firebase/analytics-compat": "fire-analytics-compat", "@firebase/app-check": "fire-app-check", "@firebase/app-check-compat": "fire-app-check-compat", "@firebase/auth": "fire-auth", "@firebase/auth-compat": "fire-auth-compat", "@firebase/database": "fire-rtdb", "@firebase/database-compat": "fire-rtdb-compat", "@firebase/functions": "fire-fn", "@firebase/functions-compat": "fire-fn-compat", "@firebase/installations": "fire-iid", "@firebase/installations-compat": "fire-iid-compat", "@firebase/messaging": "fire-fcm", "@firebase/messaging-compat": "fire-fcm-compat", "@firebase/performance": "fire-perf", "@firebase/performance-compat": "fire-perf-compat", "@firebase/remote-config": "fire-rc", "@firebase/remote-config-compat": "fire-rc-compat", "@firebase/storage": "fire-gcs", "@firebase/storage-compat": "fire-gcs-compat", "@firebase/firestore": "fire-fst", "@firebase/firestore-compat": "fire-fst-compat", "fire-js": "fire-js", firebase: "fire-js-all" }, Me = new Map, Xe = new Map; function Ot(yt, It) { try { yt.container.addComponent(It) } catch (dn) { On.debug(`Component ${It.name} failed to register with FirebaseApp ${yt.name}`, dn) } } function ve(yt, It) { yt.container.addOrOverwriteComponent(It) } function Ue(yt) { const It = yt.name; if (Xe.has(It)) return On.debug(`There were multiple attempts to register component ${It}.`), !1; Xe.set(It, yt); for (const dn of Me.values()) Ot(dn, yt); return !0 } function Z(yt, It) { const dn = yt.container.getProvider("heartbeat").getImmediate({ optional: !0 }); return dn && dn.triggerHeartbeat(), yt.container.getProvider(It) } function Fe(yt, It, dn = Ke) { Z(yt, It).clearInstance(dn) } function ct() { Xe.clear() } const Qt = new Y.LL("app", "Firebase", { "no-app": "No Firebase App '{$appName}' has been created - call initializeApp() first", "bad-app-name": "Illegal App name: '{$appName}", "duplicate-app": "Firebase App named '{$appName}' already exists with different options or config", "app-deleted": "Firebase App named '{$appName}' already deleted", "no-options": "Need to provide options, when not being deployed to hosting via source.", "invalid-app-argument": "firebase.{$appName}() takes either no argument or a Firebase App instance.", "invalid-log-argument": "First argument to `onLog` must be null or a function.", "idb-open": "Error thrown when opening IndexedDB. Original error: {$originalErrorMessage}.", "idb-get": "Error thrown when reading from IndexedDB. Original error: {$originalErrorMessage}.", "idb-set": "Error thrown when writing to IndexedDB. Original error: {$originalErrorMessage}.", "idb-delete": "Error thrown when deleting from IndexedDB. Original error: {$originalErrorMessage}." }); class fn { constructor(It, dn, Pn) { this._isDeleted = !1, this._options = Object.assign({}, It), this._config = Object.assign({}, dn), this._name = dn.name, this._automaticDataCollectionEnabled = dn.automaticDataCollectionEnabled, this._container = Pn, this.container.addComponent(new y.wA("app", () => this, "PUBLIC")) } get automaticDataCollectionEnabled() { return this.checkDestroyed(), this._automaticDataCollectionEnabled } set automaticDataCollectionEnabled(It) { this.checkDestroyed(), this._automaticDataCollectionEnabled = It } get name() { return this.checkDestroyed(), this._name } get options() { return this.checkDestroyed(), this._options } get config() { return this.checkDestroyed(), this._config } get container() { return this._container } get isDeleted() { return this._isDeleted } set isDeleted(It) { this._isDeleted = It } checkDestroyed() { if (this.isDeleted) throw Qt.create("app-deleted", { appName: this._name }) } } const En = "9.23.0"; function Ln(yt, It = {}) { let dn = yt; "object" != typeof It && (It = { name: It }); const Pn = Object.assign({ name: Ke, automaticDataCollectionEnabled: !1 }, It), qn = Pn.name; if ("string" != typeof qn || !qn) throw Qt.create("bad-app-name", { appName: String(qn) }); if (dn || (dn = (0, Y.aH)()), !dn) throw Qt.create("no-options"); const ni = Me.get(qn); if (ni) { if ((0, Y.vZ)(dn, ni.options) && (0, Y.vZ)(Pn, ni.config)) return ni; throw Qt.create("duplicate-app", { appName: qn }) } const si = new y.H0(qn); for (const Li of Xe.values()) si.addComponent(Li); const Ai = new fn(dn, Pn, si); return Me.set(qn, Ai), Ai } function In(yt = Ke) { const It = Me.get(yt); if (!It && yt === Ke && (0, Y.aH)()) return Ln(); if (!It) throw Qt.create("no-app", { appName: yt }); return It } function Et() { return Array.from(Me.values()) } function _t(yt) { return G.apply(this, arguments) } function G() { return (G = (0, a.Z)(function* (yt) { const It = yt.name; Me.has(It) && (Me.delete(It), yield Promise.all(yt.container.getProviders().map(dn => dn.delete())), yt.isDeleted = !0) })).apply(this, arguments) } function W(yt, It, dn) { var Pn; let qn = null !== (Pn = se[yt]) && void 0 !== Pn ? Pn : yt; dn && (qn += `-${dn}`); const ni = qn.match(/\s|\//), si = It.match(/\s|\//); if (ni || si) { const Ai = [`Unable to register library "${qn}" with version "${It}":`]; return ni && Ai.push(`library name "${qn}" contains illegal characters (whitespace or "/")`), ni && si && Ai.push("and"), si && Ai.push(`version name "${It}" contains illegal characters (whitespace or "/")`), void On.warn(Ai.join(" ")) } Ue(new y.wA(`${qn}-version`, () => ({ library: qn, version: It }), "VERSION")) } function me(yt, It) { if (null !== yt && "function" != typeof yt) throw Qt.create("invalid-log-argument"); (0, v.Am)(yt, It) } function de(yt) { (0, v.Ub)(yt) } const st = "firebase-heartbeat-database", Lt = 1, He = "firebase-heartbeat-store"; let ae = null; function z() { return ae || (ae = function le(yt, It, { blocked: dn, upgrade: Pn, blocking: qn, terminated: ni } = {}) { const si = indexedDB.open(yt, It), Ai = ie(si); return Pn && si.addEventListener("upgradeneeded", Li => { Pn(ie(si.result), Li.oldVersion, Li.newVersion, ie(si.transaction), Li) }), dn && si.addEventListener("blocked", Li => dn(Li.oldVersion, Li.newVersion, Li)), Ai.then(Li => { ni && Li.addEventListener("close", () => ni()), qn && Li.addEventListener("versionchange", ho => qn(ho.oldVersion, ho.newVersion, ho)) }).catch(() => { }), Ai }(st, Lt, { upgrade: (yt, It) => { 0 === It && yt.createObjectStore(He) } }).catch(yt => { throw Qt.create("idb-open", { originalErrorMessage: yt.message }) })), ae } function H() { return (H = (0, a.Z)(function* (yt) { try { return yield (yield z()).transaction(He).objectStore(He).get(pe(yt)) } catch (It) { if (It instanceof Y.ZR) On.warn(It.message); else { const dn = Qt.create("idb-get", { originalErrorMessage: It?.message }); On.warn(dn.message) } } })).apply(this, arguments) } function Ne(yt, It) { return pt.apply(this, arguments) } function pt() { return (pt = (0, a.Z)(function* (yt, It) { try { const Pn = (yield z()).transaction(He, "readwrite"); yield Pn.objectStore(He).put(It, pe(yt)), yield Pn.done } catch (dn) { if (dn instanceof Y.ZR) On.warn(dn.message); else { const Pn = Qt.create("idb-set", { originalErrorMessage: dn?.message }); On.warn(Pn.message) } } })).apply(this, arguments) } function pe(yt) { return `${yt.name}!${yt.options.appId}` } class J { constructor(It) { this.container = It, this._heartbeatsCache = null; const dn = this.container.getProvider("app").getImmediate(); this._storage = new gt(dn), this._heartbeatsCachePromise = this._storage.read().then(Pn => (this._heartbeatsCache = Pn, Pn)) } triggerHeartbeat() { var It = this; return (0, a.Z)(function* () { const Pn = It.container.getProvider("platform-logger").getImmediate().getPlatformInfoString(), qn = Te(); if (null === It._heartbeatsCache && (It._heartbeatsCache = yield It._heartbeatsCachePromise), It._heartbeatsCache.lastSentHeartbeatDate !== qn && !It._heartbeatsCache.heartbeats.some(ni => ni.date === qn)) return It._heartbeatsCache.heartbeats.push({ date: qn, agent: Pn }), It._heartbeatsCache.heartbeats = It._heartbeatsCache.heartbeats.filter(ni => { const si = new Date(ni.date).valueOf(); return Date.now() - si <= 2592e6 }), It._storage.overwrite(It._heartbeatsCache) })() } getHeartbeatsHeader() { var It = this; return (0, a.Z)(function* () { if (null === It._heartbeatsCache && (yield It._heartbeatsCachePromise), null === It._heartbeatsCache || 0 === It._heartbeatsCache.heartbeats.length) return ""; const dn = Te(), { heartbeatsToSend: Pn, unsentEntries: qn } = function lt(yt, It = 1024) { const dn = []; let Pn = yt.slice(); for (const qn of yt) { const ni = dn.find(si => si.agent === qn.agent); if (ni) { if (ni.dates.push(qn.date), Ht(dn) > It) { ni.dates.pop(); break } } else if (dn.push({ agent: qn.agent, dates: [qn.date] }), Ht(dn) > It) { dn.pop(); break } Pn = Pn.slice(1) } return { heartbeatsToSend: dn, unsentEntries: Pn } }(It._heartbeatsCache.heartbeats), ni = (0, Y.L)(JSON.stringify({ version: 2, heartbeats: Pn })); return It._heartbeatsCache.lastSentHeartbeatDate = dn, qn.length > 0 ? (It._heartbeatsCache.heartbeats = qn, yield It._storage.overwrite(It._heartbeatsCache)) : (It._heartbeatsCache.heartbeats = [], It._storage.overwrite(It._heartbeatsCache)), ni })() } } function Te() { return (new Date).toISOString().substring(0, 10) } class gt { constructor(It) { this.app = It, this._canUseIndexedDBPromise = this.runIndexedDBEnvironmentCheck() } runIndexedDBEnvironmentCheck() { return (0, a.Z)(function* () { return !!(0, Y.hl)() && (0, Y.eu)().then(() => !0).catch(() => !1) })() } read() { var It = this; return (0, a.Z)(function* () { return (yield It._canUseIndexedDBPromise) && (yield function L(yt) { return H.apply(this, arguments) }(It.app)) || { heartbeats: [] } })() } overwrite(It) { var dn = this; return (0, a.Z)(function* () { var Pn; if (yield dn._canUseIndexedDBPromise) { const ni = yield dn.read(); return Ne(dn.app, { lastSentHeartbeatDate: null !== (Pn = It.lastSentHeartbeatDate) && void 0 !== Pn ? Pn : ni.lastSentHeartbeatDate, heartbeats: It.heartbeats }) } })() } add(It) { var dn = this; return (0, a.Z)(function* () { var Pn; if (yield dn._canUseIndexedDBPromise) { const ni = yield dn.read(); return Ne(dn.app, { lastSentHeartbeatDate: null !== (Pn = It.lastSentHeartbeatDate) && void 0 !== Pn ? Pn : ni.lastSentHeartbeatDate, heartbeats: [...ni.heartbeats, ...It.heartbeats] }) } })() } } function Ht(yt) { return (0, Y.L)(JSON.stringify({ version: 2, heartbeats: yt })).length } !function un(yt) { Ue(new y.wA("platform-logger", It => new Kt(It), "PRIVATE")), Ue(new y.wA("heartbeat", It => new J(It), "PRIVATE")), W(Dn, "0.9.13", yt), W(Dn, "0.9.13", "esm2017"), W("fire-js", "") }("") }, 4537: (nn, Qe, C) => { C.d(Qe, { H0: () => re, wA: () => v }); var a = C(5861), y = C(9058); class v { constructor(Q, _e, xe) { this.name = Q, this.instanceFactory = _e, this.type = xe, this.multipleInstances = !1, this.serviceProps = {}, this.instantiationMode = "LAZY", this.onInstanceCreated = null } setInstantiationMode(Q) { return this.instantiationMode = Q, this } setMultipleInstances(Q) { return this.multipleInstances = Q, this } setServiceProps(Q) { return this.serviceProps = Q, this } setInstanceCreatedCallback(Q) { return this.onInstanceCreated = Q, this } } const Y = "[DEFAULT]"; class he { constructor(Q, _e) { this.name = Q, this.container = _e, this.component = null, this.instances = new Map, this.instancesDeferred = new Map, this.instancesOptions = new Map, this.onInitCallbacks = new Map } get(Q) { const _e = this.normalizeInstanceIdentifier(Q); if (!this.instancesDeferred.has(_e)) { const xe = new y.BH; if (this.instancesDeferred.set(_e, xe), this.isInitialized(_e) || this.shouldAutoInitialize()) try { const ze = this.getOrInitializeService({ instanceIdentifier: _e }); ze && xe.resolve(ze) } catch { } } return this.instancesDeferred.get(_e).promise } getImmediate(Q) { var _e; const xe = this.normalizeInstanceIdentifier(Q?.identifier), ze = null !== (_e = Q?.optional) && void 0 !== _e && _e; if (!this.isInitialized(xe) && !this.shouldAutoInitialize()) { if (ze) return null; throw Error(`Service ${this.name} is not available`) } try { return this.getOrInitializeService({ instanceIdentifier: xe }) } catch (Oe) { if (ze) return null; throw Oe } } getComponent() { return this.component } setComponent(Q) { if (Q.name !== this.name) throw Error(`Mismatching Component ${Q.name} for Provider ${this.name}.`); if (this.component) throw Error(`Component for ${this.name} has already been provided`); if (this.component = Q, this.shouldAutoInitialize()) { if (function ke(Ie) { return "EAGER" === Ie.instantiationMode }(Q)) try { this.getOrInitializeService({ instanceIdentifier: Y }) } catch { } for (const [_e, xe] of this.instancesDeferred.entries()) { const ze = this.normalizeInstanceIdentifier(_e); try { const Oe = this.getOrInitializeService({ instanceIdentifier: ze }); xe.resolve(Oe) } catch { } } } } clearInstance(Q = Y) { this.instancesDeferred.delete(Q), this.instancesOptions.delete(Q), this.instances.delete(Q) } delete() { var Q = this; return (0, a.Z)(function* () { const _e = Array.from(Q.instances.values()); yield Promise.all([..._e.filter(xe => "INTERNAL" in xe).map(xe => xe.INTERNAL.delete()), ..._e.filter(xe => "_delete" in xe).map(xe => xe._delete())]) })() } isComponentSet() { return null != this.component } isInitialized(Q = Y) { return this.instances.has(Q) } getOptions(Q = Y) { return this.instancesOptions.get(Q) || {} } initialize(Q = {}) { const { options: _e = {} } = Q, xe = this.normalizeInstanceIdentifier(Q.instanceIdentifier); if (this.isInitialized(xe)) throw Error(`${this.name}(${xe}) has already been initialized`); if (!this.isComponentSet()) throw Error(`Component ${this.name} has not been registered yet`); const ze = this.getOrInitializeService({ instanceIdentifier: xe, options: _e }); for (const [Oe, We] of this.instancesDeferred.entries()) xe === this.normalizeInstanceIdentifier(Oe) && We.resolve(ze); return ze } onInit(Q, _e) { var xe; const ze = this.normalizeInstanceIdentifier(_e), Oe = null !== (xe = this.onInitCallbacks.get(ze)) && void 0 !== xe ? xe : new Set; Oe.add(Q), this.onInitCallbacks.set(ze, Oe); const We = this.instances.get(ze); return We && Q(We, ze), () => { Oe.delete(Q) } } invokeOnInitCallbacks(Q, _e) { const xe = this.onInitCallbacks.get(_e); if (xe) for (const ze of xe) try { ze(Q, _e) } catch { } } getOrInitializeService({ instanceIdentifier: Q, options: _e = {} }) { let xe = this.instances.get(Q); if (!xe && this.component && (xe = this.component.instanceFactory(this.container, { instanceIdentifier: (Ie = Q, Ie === Y ? void 0 : Ie), options: _e }), this.instances.set(Q, xe), this.instancesOptions.set(Q, _e), this.invokeOnInitCallbacks(xe, Q), this.component.onInstanceCreated)) try { this.component.onInstanceCreated(this.container, Q, xe) } catch { } var Ie; return xe || null } normalizeInstanceIdentifier(Q = Y) { return this.component ? this.component.multipleInstances ? Q : Y : Q } shouldAutoInitialize() { return !!this.component && "EXPLICIT" !== this.component.instantiationMode } } class re { constructor(Q) { this.name = Q, this.providers = new Map } addComponent(Q) { const _e = this.getProvider(Q.name); if (_e.isComponentSet()) throw new Error(`Component ${Q.name} has already been registered with ${this.name}`); _e.setComponent(Q) } addOrOverwriteComponent(Q) { this.getProvider(Q.name).isComponentSet() && this.providers.delete(Q.name), this.addComponent(Q) } getProvider(Q) { if (this.providers.has(Q)) return this.providers.get(Q); const _e = new he(Q, this); return this.providers.set(Q, _e), _e } getProviders() { return Array.from(this.providers.values()) } } }, 7879: (nn, Qe, C) => { C.d(Qe, { Am: () => Ie, Ub: () => re, Yd: () => ke, in: () => y }); const a = []; var y = (() => ((y = y || {})[y.DEBUG = 0] = "DEBUG", y[y.VERBOSE = 1] = "VERBOSE", y[y.INFO = 2] = "INFO", y[y.WARN = 3] = "WARN", y[y.ERROR = 4] = "ERROR", y[y.SILENT = 5] = "SILENT", y))(); const v = { debug: y.DEBUG, verbose: y.VERBOSE, info: y.INFO, warn: y.WARN, error: y.ERROR, silent: y.SILENT }, Y = y.INFO, he = { [y.DEBUG]: "log", [y.VERBOSE]: "log", [y.INFO]: "info", [y.WARN]: "warn", [y.ERROR]: "error" }, Se = (Q, _e, ...xe) => { if (_e < Q.logLevel) return; const ze = (new Date).toISOString(), Oe = he[_e]; if (!Oe) throw new Error(`Attempted to log a message with an invalid logType (value: ${_e})`); console[Oe](`[${ze}]  ${Q.name}:`, ...xe) }; class ke { constructor(_e) { this.name = _e, this._logLevel = Y, this._logHandler = Se, this._userLogHandler = null, a.push(this) } get logLevel() { return this._logLevel } set logLevel(_e) { if (!(_e in y)) throw new TypeError(`Invalid value "${_e}" assigned to \`logLevel\``); this._logLevel = _e } setLogLevel(_e) { this._logLevel = "string" == typeof _e ? v[_e] : _e } get logHandler() { return this._logHandler } set logHandler(_e) { if ("function" != typeof _e) throw new TypeError("Value assigned to `logHandler` must be a function"); this._logHandler = _e } get userLogHandler() { return this._userLogHandler } set userLogHandler(_e) { this._userLogHandler = _e } debug(..._e) { this._userLogHandler && this._userLogHandler(this, y.DEBUG, ..._e), this._logHandler(this, y.DEBUG, ..._e) } log(..._e) { this._userLogHandler && this._userLogHandler(this, y.VERBOSE, ..._e), this._logHandler(this, y.VERBOSE, ..._e) } info(..._e) { this._userLogHandler && this._userLogHandler(this, y.INFO, ..._e), this._logHandler(this, y.INFO, ..._e) } warn(..._e) { this._userLogHandler && this._userLogHandler(this, y.WARN, ..._e), this._logHandler(this, y.WARN, ..._e) } error(..._e) { this._userLogHandler && this._userLogHandler(this, y.ERROR, ..._e), this._logHandler(this, y.ERROR, ..._e) } } function re(Q) { a.forEach(_e => { _e.setLogLevel(Q) }) } function Ie(Q, _e) { for (const xe of a) { let ze = null; _e && _e.level && (ze = v[_e.level]), xe.userLogHandler = null === Q ? null : (Oe, We, ...Pe) => { const Ve = Pe.map(tt => { if (null == tt) return null; if ("string" == typeof tt) return tt; if ("number" == typeof tt || "boolean" == typeof tt) return tt.toString(); if (tt instanceof Error) return tt.message; try { return JSON.stringify(tt) } catch { return null } }).filter(tt => tt).join(" "); We >= (ze ?? Oe.logLevel) && Q({ level: y[We].toLowerCase(), message: Ve, args: Pe, type: Oe.name }) } } } }, 3182: (nn, Qe, C) => { C.d(Qe, { C6: () => a.getApps, KN: () => a.registerVersion, Mq: () => a.getApp, ZF: () => a.initializeApp }); var a = C(6122); (0, a.registerVersion)("firebase", "9.23.0", "app") }, 752: (nn, Qe, C) => { C.d(Qe, { hJ: () => a.V, Xb: () => a.a8, v0: () => a.o }); var a = C(6878); C(9058), C(6122), C(7879), C(4537) }, 7142: (nn, Qe, C) => { C.d(Qe, { Z: () => a.Z }); var a = C(3106); a.Z.registerVersion("firebase", "9.23.0", "app-compat") }, 6365: (nn, Qe, C) => { C.r(Qe); var a = C(5861), y = C(3106), v = C(6878), Y = C(9058), ke = (C(6122), C(7879), C(4537)); function re() { return window } function _e() { return _e = (0, a.Z)(function* (z, L, H) { var Ne; const { BuildInfo: pt } = re(); (0, v.as)(L.sessionId, "AuthEvent did not contain a session ID"); const pe = yield function tt(z) { return Ye.apply(this, arguments) }(L.sessionId), fe = {}; return (0, v.at)() ? fe.ibi = pt.packageName : (0, v.au)() ? fe.apn = pt.packageName : (0, v.av)(z, "operation-not-supported-in-this-environment"), pt.displayName && (fe.appDisplayName = pt.displayName), fe.sessionId = pe, (0, v.aw)(z, H, L.type, void 0, null !== (Ne = L.eventId) && void 0 !== Ne ? Ne : void 0, fe) }), _e.apply(this, arguments) } function ze() { return (ze = (0, a.Z)(function* (z) { const { BuildInfo: L } = re(), H = {}; (0, v.at)() ? H.iosBundleId = L.packageName : (0, v.au)() ? H.androidPackageName = L.packageName : (0, v.av)(z, "operation-not-supported-in-this-environment"), yield (0, v.ax)(z, H) })).apply(this, arguments) } function Pe() { return (Pe = (0, a.Z)(function* (z, L, H) { const { cordova: Ne } = re(); let pt = () => { }; try { yield new Promise((pe, fe) => { let F = null; function J() { var gt; pe(); const Ht = null === (gt = Ne.plugins.browsertab) || void 0 === gt ? void 0 : gt.close; "function" == typeof Ht && Ht(), "function" == typeof H?.close && H.close() } function Te() { F || (F = window.setTimeout(() => { fe((0, v.az)(z, "redirect-cancelled-by-user")) }, 2e3)) } function lt() { "visible" === document?.visibilityState && Te() } L.addPassiveListener(J), document.addEventListener("resume", Te, !1), (0, v.au)() && document.addEventListener("visibilitychange", lt, !1), pt = () => { L.removePassiveListener(J), document.removeEventListener("resume", Te, !1), document.removeEventListener("visibilitychange", lt, !1), F && window.clearTimeout(F) } }) } finally { pt() } })).apply(this, arguments) } function Ye() { return (Ye = (0, a.Z)(function* (z) { const L = function ut(z) { if ((0, v.as)(/[0-9a-zA-Z]+/.test(z), "Can only convert alpha-numeric strings"), typeof TextEncoder < "u") return (new TextEncoder).encode(z); const L = new ArrayBuffer(z.length), H = new Uint8Array(L); for (let Ne = 0; Ne < z.length; Ne++)H[Ne] = z.charCodeAt(Ne); return H }(z), H = yield crypto.subtle.digest("SHA-256", L); return Array.from(new Uint8Array(H)).map(pt => pt.toString(16).padStart(2, "0")).join("") })).apply(this, arguments) } class Le extends v.aB { constructor() { super(...arguments), this.passiveListeners = new Set, this.initPromise = new Promise(L => { this.resolveInialized = L }) } addPassiveListener(L) { this.passiveListeners.add(L) } removePassiveListener(L) { this.passiveListeners.delete(L) } resetRedirect() { this.queuedRedirectEvent = null, this.hasHandledPotentialRedirect = !1 } onEvent(L) { return this.resolveInialized(), this.passiveListeners.forEach(H => H(L)), super.onEvent(L) } initialized() { var L = this; return (0, a.Z)(function* () { yield L.initPromise })() } } function ue(z) { return ee.apply(this, arguments) } function ee() { return (ee = (0, a.Z)(function* (z) { const L = yield Kt()._get(bn(z)); return L && (yield Kt()._remove(bn(z))), L })).apply(this, arguments) } function rt() { const z = []; for (let H = 0; H < 20; H++) { const Ne = Math.floor(62 * Math.random()); z.push("1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ".charAt(Ne)) } return z.join("") } function Kt() { return (0, v.aC)(v.b) } function bn(z) { return (0, v.aD)("authEvent", z.config.apiKey, z.name) } function On(z) { if (!z?.includes("?")) return {}; const [L, ...H] = z.split("?"); return (0, Y.zd)(H.join("?")) } const at = class Hn { constructor() { this._redirectPersistence = v.a, this._shouldInitProactively = !0, this.eventManagers = new Map, this.originValidationPromises = {}, this._completeRedirectFn = v.aE, this._overrideRedirectResult = v.aF } _initialize(L) { var H = this; return (0, a.Z)(function* () { const Ne = L._key(); let pt = H.eventManagers.get(Ne); return pt || (pt = new Le(L), H.eventManagers.set(Ne, pt), H.attachCallbackListeners(L, pt)), pt })() } _openPopup(L) { (0, v.av)(L, "operation-not-supported-in-this-environment") } _openRedirect(L, H, Ne, pt) { var pe = this; return (0, a.Z)(function* () { !function Ve(z) { var L, H, Ne, pt, pe, fe, F, J, Te, lt; const gt = re(); (0, v.aA)("function" == typeof (null === (L = gt?.universalLinks) || void 0 === L ? void 0 : L.subscribe), z, "invalid-cordova-configuration", { missingPlugin: "cordova-universal-links-plugin-fix" }), (0, v.aA)(typeof (null === (H = gt?.BuildInfo) || void 0 === H ? void 0 : H.packageName) < "u", z, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-buildInfo" }), (0, v.aA)("function" == typeof (null === (pe = null === (pt = null === (Ne = gt?.cordova) || void 0 === Ne ? void 0 : Ne.plugins) || void 0 === pt ? void 0 : pt.browsertab) || void 0 === pe ? void 0 : pe.openUrl), z, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-browsertab" }), (0, v.aA)("function" == typeof (null === (J = null === (F = null === (fe = gt?.cordova) || void 0 === fe ? void 0 : fe.plugins) || void 0 === F ? void 0 : F.browsertab) || void 0 === J ? void 0 : J.isAvailable), z, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-browsertab" }), (0, v.aA)("function" == typeof (null === (lt = null === (Te = gt?.cordova) || void 0 === Te ? void 0 : Te.InAppBrowser) || void 0 === lt ? void 0 : lt.open), z, "invalid-cordova-configuration", { missingPlugin: "cordova-plugin-inappbrowser" }) }(L); const fe = yield pe._initialize(L); yield fe.initialized(), fe.resetRedirect(), (0, v.aG)(), yield pe._originValidation(L); const F = function le(z, L, H = null) { return { type: L, eventId: H, urlResponse: null, sessionId: rt(), postBody: null, tenantId: z.tenantId, error: (0, v.az)(z, "no-auth-event") } }(L, Ne, pt); yield function ge(z, L) { return Kt()._set(bn(z), L) }(L, F); const J = yield function Q(z, L, H) { return _e.apply(this, arguments) }(L, F, H), Te = yield function Oe(z) { const { cordova: L } = re(); return new Promise(H => { L.plugins.browsertab.isAvailable(Ne => { let pt = null; Ne ? L.plugins.browsertab.openUrl(z) : pt = L.InAppBrowser.open(z, (0, v.ay)() ? "_blank" : "_system", "location=yes"), H(pt) }) }) }(J); return function We(z, L, H) { return Pe.apply(this, arguments) }(L, fe, Te) })() } _isIframeWebStorageSupported(L, H) { throw new Error("Method not implemented.") } _originValidation(L) { const H = L._key(); return this.originValidationPromises[H] || (this.originValidationPromises[H] = function xe(z) { return ze.apply(this, arguments) }(L)), this.originValidationPromises[H] } attachCallbackListeners(L, H) { const { universalLinks: Ne, handleOpenURL: pt, BuildInfo: pe } = re(), fe = setTimeout((0, a.Z)(function* () { yield ue(L), H.onEvent(vt()) }), 500), F = function () { var lt = (0, a.Z)(function* (gt) { clearTimeout(fe); const Ht = yield ue(L); let un = null; Ht && gt?.url && (un = function $e(z, L) { var H, Ne; const pt = function Mn(z) { const L = On(z), H = L.link ? decodeURIComponent(L.link) : void 0, Ne = On(H).link, pt = L.deep_link_id ? decodeURIComponent(L.deep_link_id) : void 0; return On(pt).link || pt || Ne || H || z }(L); if (pt.includes("/__/auth/callback")) { const pe = On(pt), fe = pe.firebaseError ? function Dn(z) { try { return JSON.parse(z) } catch { return null } }(decodeURIComponent(pe.firebaseError)) : null, F = null === (Ne = null === (H = fe?.code) || void 0 === H ? void 0 : H.split("auth/")) || void 0 === Ne ? void 0 : Ne[1], J = F ? (0, v.az)(F) : null; return J ? { type: z.type, eventId: z.eventId, tenantId: z.tenantId, error: J, urlResponse: null, sessionId: null, postBody: null } : { type: z.type, eventId: z.eventId, tenantId: z.tenantId, sessionId: z.sessionId, urlResponse: pt, postBody: null } } return null }(Ht, gt.url)), H.onEvent(un || vt()) }); return function (Ht) { return lt.apply(this, arguments) } }(); typeof Ne < "u" && "function" == typeof Ne.subscribe && Ne.subscribe(null, F); const J = pt, Te = `${pe.packageName.toLowerCase()}://`; re().handleOpenURL = function () { var lt = (0, a.Z)(function* (gt) { if (gt.toLowerCase().startsWith(Te) && F({ url: gt }), "function" == typeof J) try { J(gt) } catch (Ht) { console.error(Ht) } }); return function (gt) { return lt.apply(this, arguments) } }() } }; function vt() { return { type: "unknown", eventId: null, sessionId: null, urlResponse: null, postBody: null, tenantId: null, error: (0, v.az)("no-auth-event") } } function rn() { var z; return (null === (z = self?.location) || void 0 === z ? void 0 : z.protocol) || null } function tn(z = (0, Y.z$)()) { return !("file:" !== rn() && "ionic:" !== rn() && "capacitor:" !== rn() || !z.toLowerCase().match(/iphone|ipad|ipod|android/)) } function qt() { try { const z = self.localStorage, L = v.aL(); if (z) return z.setItem(L, "1"), z.removeItem(L), !function nt(z = (0, Y.z$)()) { return function ht() { return (0, Y.w1)() && 11 === document?.documentMode }() || function Ae(z = (0, Y.z$)()) { return /Edge\/\d+/.test(z) }(z) }() || (0, Y.hl)() } catch { return jt() && (0, Y.hl)() } return !1 } function jt() { return typeof global < "u" && "WorkerGlobalScope" in global && "importScripts" in global } function Pt() { return (function Jt() { return "http:" === rn() || "https:" === rn() }() || (0, Y.ru)() || tn()) && !function St() { return (0, Y.b$)() || (0, Y.UG)() }() && qt() && !jt() } function qe() { return tn() && typeof document < "u" } function on() { return (on = (0, a.Z)(function* () { return !!qe() && new Promise(z => { const L = setTimeout(() => { z(!1) }, 1e3); document.addEventListener("deviceready", () => { clearTimeout(L), z(!0) }) }) })).apply(this, arguments) } const gn = { LOCAL: "local", NONE: "none", SESSION: "session" }, $n = v.aA, Fn = "persistence"; function se(z) { return Me.apply(this, arguments) } function Me() { return (Me = (0, a.Z)(function* (z) { yield z._initializationPromise; const L = Ot(), H = v.aD(Fn, z.config.apiKey, z.name); L && L.setItem(H, z._getPersistence()) })).apply(this, arguments) } function Ot() { var z; try { return (null === (z = function Zt() { return typeof window < "u" ? window : null }()) || void 0 === z ? void 0 : z.sessionStorage) || null } catch { return null } } const ve = v.aA; class Ue { constructor() { this.browserResolver = v.aC(v.k), this.cordovaResolver = v.aC(at), this.underlyingResolver = null, this._redirectPersistence = v.a, this._completeRedirectFn = v.aE, this._overrideRedirectResult = v.aF } _initialize(L) { var H = this; return (0, a.Z)(function* () { return yield H.selectUnderlyingResolver(), H.assertedUnderlyingResolver._initialize(L) })() } _openPopup(L, H, Ne, pt) { var pe = this; return (0, a.Z)(function* () { return yield pe.selectUnderlyingResolver(), pe.assertedUnderlyingResolver._openPopup(L, H, Ne, pt) })() } _openRedirect(L, H, Ne, pt) { var pe = this; return (0, a.Z)(function* () { return yield pe.selectUnderlyingResolver(), pe.assertedUnderlyingResolver._openRedirect(L, H, Ne, pt) })() } _isIframeWebStorageSupported(L, H) { this.assertedUnderlyingResolver._isIframeWebStorageSupported(L, H) } _originValidation(L) { return this.assertedUnderlyingResolver._originValidation(L) } get _shouldInitProactively() { return qe() || this.browserResolver._shouldInitProactively } get assertedUnderlyingResolver() { return ve(this.underlyingResolver, "internal-error"), this.underlyingResolver } selectUnderlyingResolver() { var L = this; return (0, a.Z)(function* () { if (L.underlyingResolver) return; const H = yield function Nt() { return on.apply(this, arguments) }(); L.underlyingResolver = H ? L.cordovaResolver : L.browserResolver })() } } function Z(z) { return z.unwrap() } function ct(z) { return Qt(z) } function Qt(z) { const { _tokenResponse: L } = z instanceof Y.ZR ? z.customData : z; if (!L) return null; if (!(z instanceof Y.ZR) && "temporaryProof" in L && "phoneNumber" in L) return v.P.credentialFromResult(z); const H = L.providerId; if (!H || H === v.p.PASSWORD) return null; let Ne; switch (H) { case v.p.GOOGLE: Ne = v.V; break; case v.p.FACEBOOK: Ne = v.U; break; case v.p.GITHUB: Ne = v.W; break; case v.p.TWITTER: Ne = v.Z; break; default: const { oauthIdToken: pt, oauthAccessToken: pe, oauthTokenSecret: fe, pendingToken: F, nonce: J } = L; return pe || fe || pt || F ? F ? H.startsWith("saml.") ? v.aO._create(H, F) : v.L._fromParams({ providerId: H, signInMethod: H, pendingToken: F, idToken: pt, accessToken: pe }) : new v.X(H).credential({ idToken: pt, accessToken: pe, rawNonce: J }) : null }return z instanceof Y.ZR ? Ne.credentialFromError(z) : Ne.credentialFromResult(z) } function fn(z, L) { return L.catch(H => { throw H instanceof Y.ZR && function Mt(z, L) { var H; const Ne = null === (H = L.customData) || void 0 === H ? void 0 : H._tokenResponse; if ("auth/multi-factor-auth-required" === L?.code) L.resolver = new In(z, v.aq(z, L)); else if (Ne) { const pt = Qt(L), pe = L; pt && (pe.credential = pt, pe.tenantId = Ne.tenantId || void 0, pe.email = Ne.email || void 0, pe.phoneNumber = Ne.phoneNumber || void 0) } }(z, H), H }).then(H => { const pt = H.user; return { operationType: H.operationType, credential: ct(H), additionalUserInfo: v.ao(H), user: Et.getOrCreate(pt) } }) } function En(z, L) { return Ln.apply(this, arguments) } function Ln() { return (Ln = (0, a.Z)(function* (z, L) { const H = yield L; return { verificationId: H.verificationId, confirm: Ne => fn(z, H.confirm(Ne)) } })).apply(this, arguments) } class In { constructor(L, H) { this.resolver = H, this.auth = function Fe(z) { return z.wrapped() }(L) } get session() { return this.resolver.session } get hints() { return this.resolver.hints } resolveSignIn(L) { return fn(Z(this.auth), this.resolver.resolveSignIn(L)) } } class Et { constructor(L) { this._delegate = L, this.multiFactor = v.ar(L) } static getOrCreate(L) { return Et.USER_MAP.has(L) || Et.USER_MAP.set(L, new Et(L)), Et.USER_MAP.get(L) } delete() { return this._delegate.delete() } reload() { return this._delegate.reload() } toJSON() { return this._delegate.toJSON() } getIdTokenResult(L) { return this._delegate.getIdTokenResult(L) } getIdToken(L) { return this._delegate.getIdToken(L) } linkAndRetrieveDataWithCredential(L) { return this.linkWithCredential(L) } linkWithCredential(L) { var H = this; return (0, a.Z)(function* () { return fn(H.auth, v.a0(H._delegate, L)) })() } linkWithPhoneNumber(L, H) { var Ne = this; return (0, a.Z)(function* () { return En(Ne.auth, v.l(Ne._delegate, L, H)) })() } linkWithPopup(L) { var H = this; return (0, a.Z)(function* () { return fn(H.auth, v.d(H._delegate, L, Ue)) })() } linkWithRedirect(L) { var H = this; return (0, a.Z)(function* () { return yield se(v.aH(H.auth)), v.g(H._delegate, L, Ue) })() } reauthenticateAndRetrieveDataWithCredential(L) { return this.reauthenticateWithCredential(L) } reauthenticateWithCredential(L) { var H = this; return (0, a.Z)(function* () { return fn(H.auth, v.a1(H._delegate, L)) })() } reauthenticateWithPhoneNumber(L, H) { return En(this.auth, v.r(this._delegate, L, H)) } reauthenticateWithPopup(L) { return fn(this.auth, v.e(this._delegate, L, Ue)) } reauthenticateWithRedirect(L) { var H = this; return (0, a.Z)(function* () { return yield se(v.aH(H.auth)), v.h(H._delegate, L, Ue) })() } sendEmailVerification(L) { return v.ae(this._delegate, L) } unlink(L) { var H = this; return (0, a.Z)(function* () { return yield v.an(H._delegate, L), H })() } updateEmail(L) { return v.aj(this._delegate, L) } updatePassword(L) { return v.ak(this._delegate, L) } updatePhoneNumber(L) { return v.u(this._delegate, L) } updateProfile(L) { return v.ai(this._delegate, L) } verifyBeforeUpdateEmail(L, H) { return v.af(this._delegate, L, H) } get emailVerified() { return this._delegate.emailVerified } get isAnonymous() { return this._delegate.isAnonymous } get metadata() { return this._delegate.metadata } get phoneNumber() { return this._delegate.phoneNumber } get providerData() { return this._delegate.providerData } get refreshToken() { return this._delegate.refreshToken } get tenantId() { return this._delegate.tenantId } get displayName() { return this._delegate.displayName } get email() { return this._delegate.email } get photoURL() { return this._delegate.photoURL } get providerId() { return this._delegate.providerId } get uid() { return this._delegate.uid } get auth() { return this._delegate.auth } } Et.USER_MAP = new WeakMap; const _t = v.aA; let G = (() => { class z { constructor(H, Ne) { if (this.app = H, Ne.isInitialized()) return this._delegate = Ne.getImmediate(), void this.linkUnderlyingAuth(); const { apiKey: pt } = H.options; _t(pt, "invalid-api-key", { appName: H.name }), _t(pt, "invalid-api-key", { appName: H.name }); const pe = typeof window < "u" ? Ue : void 0; this._delegate = Ne.initialize({ options: { persistence: me(pt, H.name), popupRedirectResolver: pe } }), this._delegate._updateErrorMap(v.D), this.linkUnderlyingAuth() } get emulatorConfig() { return this._delegate.emulatorConfig } get currentUser() { return this._delegate.currentUser ? Et.getOrCreate(this._delegate.currentUser) : null } get languageCode() { return this._delegate.languageCode } set languageCode(H) { this._delegate.languageCode = H } get settings() { return this._delegate.settings } get tenantId() { return this._delegate.tenantId } set tenantId(H) { this._delegate.tenantId = H } useDeviceLanguage() { this._delegate.useDeviceLanguage() } signOut() { return this._delegate.signOut() } useEmulator(H, Ne) { v.I(this._delegate, H, Ne) } applyActionCode(H) { return v.a5(this._delegate, H) } checkActionCode(H) { return v.a6(this._delegate, H) } confirmPasswordReset(H, Ne) { return v.a4(this._delegate, H, Ne) } createUserWithEmailAndPassword(H, Ne) { var pt = this; return (0, a.Z)(function* () { return fn(pt._delegate, v.a8(pt._delegate, H, Ne)) })() } fetchProvidersForEmail(H) { return this.fetchSignInMethodsForEmail(H) } fetchSignInMethodsForEmail(H) { return v.ad(this._delegate, H) } isSignInWithEmailLink(H) { return v.ab(this._delegate, H) } getRedirectResult() { var H = this; return (0, a.Z)(function* () { _t(Pt(), H._delegate, "operation-not-supported-in-this-environment"); const Ne = yield v.j(H._delegate, Ue); return Ne ? fn(H._delegate, Promise.resolve(Ne)) : { credential: null, user: null } })() } addFrameworkForLogging(H) { !function xt(z, L) { (0, v.aH)(z)._logFramework(L) }(this._delegate, H) } onAuthStateChanged(H, Ne, pt) { const { next: pe, error: fe, complete: F } = W(H, Ne, pt); return this._delegate.onAuthStateChanged(pe, fe, F) } onIdTokenChanged(H, Ne, pt) { const { next: pe, error: fe, complete: F } = W(H, Ne, pt); return this._delegate.onIdTokenChanged(pe, fe, F) } sendSignInLinkToEmail(H, Ne) { return v.aa(this._delegate, H, Ne) } sendPasswordResetEmail(H, Ne) { return v.a3(this._delegate, H, Ne || void 0) } setPersistence(H) { var Ne = this; return (0, a.Z)(function* () { let pt; switch (function Ke(z, L) { $n(Object.values(gn).includes(L), z, "invalid-persistence-type"), (0, Y.b$)() ? $n(L !== gn.SESSION, z, "unsupported-persistence-type") : (0, Y.UG)() ? $n(L === gn.NONE, z, "unsupported-persistence-type") : jt() ? $n(L === gn.NONE || L === gn.LOCAL && (0, Y.hl)(), z, "unsupported-persistence-type") : $n(L === gn.NONE || qt(), z, "unsupported-persistence-type") }(Ne._delegate, H), H) { case gn.SESSION: pt = v.a; break; case gn.LOCAL: pt = (yield v.aC(v.i)._isAvailable()) ? v.i : v.b; break; case gn.NONE: pt = v.N; break; default: return v.av("argument-error", { appName: Ne._delegate.name }) }return Ne._delegate.setPersistence(pt) })() } signInAndRetrieveDataWithCredential(H) { return this.signInWithCredential(H) } signInAnonymously() { return fn(this._delegate, v._(this._delegate)) } signInWithCredential(H) { return fn(this._delegate, v.$(this._delegate, H)) } signInWithCustomToken(H) { return fn(this._delegate, v.a2(this._delegate, H)) } signInWithEmailAndPassword(H, Ne) { return fn(this._delegate, v.a9(this._delegate, H, Ne)) } signInWithEmailLink(H, Ne) { return fn(this._delegate, v.ac(this._delegate, H, Ne)) } signInWithPhoneNumber(H, Ne) { return En(this._delegate, v.s(this._delegate, H, Ne)) } signInWithPopup(H) { var Ne = this; return (0, a.Z)(function* () { return _t(Pt(), Ne._delegate, "operation-not-supported-in-this-environment"), fn(Ne._delegate, v.c(Ne._delegate, H, Ue)) })() } signInWithRedirect(H) { var Ne = this; return (0, a.Z)(function* () { return _t(Pt(), Ne._delegate, "operation-not-supported-in-this-environment"), yield se(Ne._delegate), v.f(Ne._delegate, H, Ue) })() } updateCurrentUser(H) { return this._delegate.updateCurrentUser(H) } verifyPasswordResetCode(H) { return v.a7(this._delegate, H) } unwrap() { return this._delegate } _delete() { return this._delegate._delete() } linkUnderlyingAuth() { this._delegate.wrapped = () => this } } return z.Persistence = gn, z })(); function W(z, L, H) { let Ne = z; "function" != typeof z && ({ next: Ne, error: L, complete: H } = z); const pt = Ne; return { next: fe => pt(fe && Et.getOrCreate(fe)), error: L, complete: H } } function me(z, L) { const H = function Xe(z, L) { const H = Ot(); if (!H) return []; const Ne = v.aD(Fn, z, L); switch (H.getItem(Ne)) { case gn.NONE: return [v.N]; case gn.LOCAL: return [v.i, v.a]; case gn.SESSION: return [v.a]; default: return [] } }(z, L); if (typeof self < "u" && !H.includes(v.i) && H.push(v.i), typeof window < "u") for (const Ne of [v.b, v.a]) H.includes(Ne) || H.push(Ne); return H.includes(v.N) || H.push(v.N), H } class de { constructor() { this.providerId = "phone", this._delegate = new v.P(Z(y.Z.auth())) } static credential(L, H) { return v.P.credential(L, H) } verifyPhoneNumber(L, H) { return this._delegate.verifyPhoneNumber(L, H) } unwrap() { return this._delegate } } de.PHONE_SIGN_IN_METHOD = v.P.PHONE_SIGN_IN_METHOD, de.PROVIDER_ID = v.P.PROVIDER_ID; const st = v.aA; class Lt { constructor(L, H, Ne = y.Z.app()) { var pt; st(null === (pt = Ne.options) || void 0 === pt ? void 0 : pt.apiKey, "invalid-api-key", { appName: Ne.name }), this._delegate = new v.R(L, H, Ne.auth()), this.type = this._delegate.type } clear() { this._delegate.clear() } render() { return this._delegate.render() } verify() { return this._delegate.verify() } } !function ae(z) { z.INTERNAL.registerComponent(new ke.wA("auth-compat", L => { const H = L.getProvider("app-compat").getImmediate(), Ne = L.getProvider("auth"); return new G(H, Ne) }, "PUBLIC").setServiceProps({ ActionCodeInfo: { Operation: { EMAIL_SIGNIN: v.A.EMAIL_SIGNIN, PASSWORD_RESET: v.A.PASSWORD_RESET, RECOVER_EMAIL: v.A.RECOVER_EMAIL, REVERT_SECOND_FACTOR_ADDITION: v.A.REVERT_SECOND_FACTOR_ADDITION, VERIFY_AND_CHANGE_EMAIL: v.A.VERIFY_AND_CHANGE_EMAIL, VERIFY_EMAIL: v.A.VERIFY_EMAIL } }, EmailAuthProvider: v.Q, FacebookAuthProvider: v.U, GithubAuthProvider: v.W, GoogleAuthProvider: v.V, OAuthProvider: v.X, SAMLAuthProvider: v.Y, PhoneAuthProvider: de, PhoneMultiFactorGenerator: v.m, RecaptchaVerifier: Lt, TwitterAuthProvider: v.Z, Auth: G, AuthCredential: v.J, Error: Y.ZR }).setInstantiationMode("LAZY").setMultipleInstances(!1)), z.registerVersion("@firebase/auth-compat", "0.4.2") }(y.Z) }, 5861: (nn, Qe, C) => { function a(v, Y, he, Se, ke, re, Ie) { try { var Q = v[re](Ie), _e = Q.value } catch (xe) { return void he(xe) } Q.done ? Y(_e) : Promise.resolve(_e).then(Se, ke) } function y(v) { return function () { var Y = this, he = arguments; return new Promise(function (Se, ke) { var re = v.apply(Y, he); function Ie(_e) { a(re, Se, ke, Ie, Q, "next", _e) } function Q(_e) { a(re, Se, ke, Ie, Q, "throw", _e) } Ie(void 0) }) } } C.d(Qe, { Z: () => y }) }, 7582: (nn, Qe, C) => { function Y(at, vt) { var xt = {}; for (var it in at) Object.prototype.hasOwnProperty.call(at, it) && vt.indexOf(it) < 0 && (xt[it] = at[it]); if (null != at && "function" == typeof Object.getOwnPropertySymbols) { var Ft = 0; for (it = Object.getOwnPropertySymbols(at); Ft < it.length; Ft++)vt.indexOf(it[Ft]) < 0 && Object.prototype.propertyIsEnumerable.call(at, it[Ft]) && (xt[it[Ft]] = at[it[Ft]]) } return xt } function xe(at, vt, xt, it) { return new (xt || (xt = Promise))(function (Wt, rn) { function Jt(ht) { try { St(it.next(ht)) } catch (Ae) { rn(Ae) } } function tn(ht) { try { St(it.throw(ht)) } catch (Ae) { rn(Ae) } } function St(ht) { ht.done ? Wt(ht.value) : function Ft(Wt) { return Wt instanceof xt ? Wt : new xt(function (rn) { rn(Wt) }) }(ht.value).then(Jt, tn) } St((it = it.apply(at, vt || [])).next()) }) } function ie(at) { return this instanceof ie ? (this.v = at, this) : new ie(at) } function Le(at, vt, xt) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var Ft, it = xt.apply(at, vt || []), Wt = []; return Ft = {}, rn("next"), rn("throw"), rn("return"), Ft[Symbol.asyncIterator] = function () { return this }, Ft; function rn(nt) { it[nt] && (Ft[nt] = function (qt) { return new Promise(function (jt, Pt) { Wt.push([nt, qt, jt, Pt]) > 1 || Jt(nt, qt) }) }) } function Jt(nt, qt) { try { !function tn(nt) { nt.value instanceof ie ? Promise.resolve(nt.value.v).then(St, ht) : Ae(Wt[0][2], nt) }(it[nt](qt)) } catch (jt) { Ae(Wt[0][3], jt) } } function St(nt) { Jt("next", nt) } function ht(nt) { Jt("throw", nt) } function Ae(nt, qt) { nt(qt), Wt.shift(), Wt.length && Jt(Wt[0][0], Wt[0][1]) } } function ge(at) { if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined."); var xt, vt = at[Symbol.asyncIterator]; return vt ? vt.call(at) : (at = function Pe(at) { var vt = "function" == typeof Symbol && Symbol.iterator, xt = vt && at[vt], it = 0; if (xt) return xt.call(at); if (at && "number" == typeof at.length) return { next: function () { return at && it >= at.length && (at = void 0), { value: at && at[it++], done: !at } } }; throw new TypeError(vt ? "Object is not iterable." : "Symbol.iterator is not defined.") }(at), xt = {}, it("next"), it("throw"), it("return"), xt[Symbol.asyncIterator] = function () { return this }, xt); function it(Wt) { xt[Wt] = at[Wt] && function (rn) { return new Promise(function (Jt, tn) { !function Ft(Wt, rn, Jt, tn) { Promise.resolve(tn).then(function (St) { Wt({ value: St, done: Jt }) }, rn) }(Jt, tn, (rn = at[Wt](rn)).done, rn.value) }) } } } C.d(Qe, { FC: () => Le, KL: () => ge, _T: () => Y, mG: () => xe, qq: () => ie }), "function" == typeof SuppressedError && SuppressedError } }, nn => { nn(nn.s = 1326) }]);